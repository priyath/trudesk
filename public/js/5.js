(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[5],{

/***/ "./src/public/js/modules/ajaximgupload.js":
/*!************************************************!*\
  !*** ./src/public/js/modules/ajaximgupload.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\"), __webpack_require__(/*! underscore */ \"./src/public/js/vendor/underscore/underscore.js\"), __webpack_require__(/*! modules/helpers */ \"./src/public/js/modules/helpers.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($, _, helpers) {\n  var aiu = {}\n\n  aiu.init = function () {\n    $(document).ready(function () {\n      $('#profileImageInput').on('change', function () {\n        var val = $(this).val()\n        if (val === '') return true\n\n        var form = $('#aUploadImageForm')\n        var formData = new FormData($(form)[0])\n        var timestamp = new Date().getTime()\n\n        $.ajax({\n          url: '/accounts/uploadImage',\n          type: 'POST',\n          data: formData,\n          // async: false,\n          cache: false,\n          contentType: false,\n          processData: false,\n          success: function (data) {\n            form.find('img').attr('src', data + '?' + timestamp)\n          },\n          error: function (err) {\n            console.log('[trudesk:ajaximgupload:onChange] Error - ', err)\n            helpers.UI.showSnackbar({\n              text: 'An error occurred. Please check console. 2',\n              actionTextColor: '#B92929'\n            })\n          }\n        })\n\n        $(this).val('')\n      })\n    })\n  }\n\n  return aiu\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n\n//# sourceURL=webpack:///./src/public/js/modules/ajaximgupload.js?");

/***/ }),

/***/ "./src/public/js/modules/attachmentUpload.js":
/*!***************************************************!*\
  !*** ./src/public/js/modules/attachmentUpload.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\"), __webpack_require__(/*! underscore */ \"./src/public/js/vendor/underscore/underscore.js\"), __webpack_require__(/*! modules/helpers */ \"./src/public/js/modules/helpers.js\"), __webpack_require__(/*! modules/socket */ \"./src/public/js/modules/socket.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (\n  $,\n  _,\n  helpers,\n  socket\n) {\n  var attachmentUploader = {}\n\n  attachmentUploader.init = function () {\n    $(document).ready(function () {\n      $('.attachmentInput1').each(function () {\n        $(this).on('change', function () {\n          var self = $(this)\n          var val = self.val()\n          if (val === '') return true\n\n          var form = $('#attachmentForm')\n          if (_.isUndefined(form) || _.isNull(form)) return false\n\n          var formData = new FormData($(form)[0])\n\n          $.ajax({\n            url: '/tickets/uploadattachment',\n            type: 'POST',\n            data: formData,\n            // async: false,\n            cache: false,\n            contentType: false,\n            processData: false,\n            success: function (data) {\n              // helpers.showFlash('Attachment Successfully Uploaded.');\n              helpers.UI.showSnackbar('Attachment Successfully Uploaded', false)\n\n              // Refresh Attachments - Socket.IO\n              if (_.isUndefined(data.ticket)) return false\n\n              socket.ui.refreshTicketAttachments(data.ticket._id)\n            },\n            error: function (err) {\n              console.log('[trudesk:attachmentUpload:onChange] Error - ' + err)\n              // helpers.showFlash(err.responseText, true);\n              helpers.UI.showSnackbar(err.responseText, true)\n            }\n          })\n\n          self.val('')\n        })\n      })\n    })\n  }\n\n  return attachmentUploader\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n\n//# sourceURL=webpack:///./src/public/js/modules/attachmentUpload.js?");

/***/ }),

/***/ "./src/public/js/pages/accountsImport.js":
/*!***********************************************!*\
  !*** ./src/public/js/pages/accountsImport.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n  __webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\"),\n  __webpack_require__(/*! underscore */ \"./src/public/js/vendor/underscore/underscore.js\"),\n  __webpack_require__(/*! modules/helpers */ \"./src/public/js/modules/helpers.js\"),\n  __webpack_require__(/*! velocity */ \"./src/public/js/vendor/velocity/velocity.min.js\"),\n  __webpack_require__(/*! uikit */ \"./src/public/js/vendor/uikit/js/uikit_combined.min.js\"),\n  __webpack_require__(/*! modules/socket */ \"./src/public/js/modules/socket.js\"),\n\n  __webpack_require__(/*! jquery_steps */ \"./src/public/js/plugins/jquery.steps.js\"),\n  __webpack_require__(/*! jquery_actual */ \"./src/public/js/plugins/jquery.actual.js\"),\n  __webpack_require__(/*! history */ \"./src/public/js/vendor/history/jquery.history.js\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($, _, helpers, velocity, UIkit, socket) {\n  var accountsImportPage = {}\n  var state = {}\n  accountsImportPage.init = function (callback) {\n    $(document).ready(function () {\n      var testPage = $('#page-content').find('.accountsImport')\n      if (testPage.length < 1) {\n        if (typeof callback === 'function') {\n          return callback()\n        }\n\n        return false\n      }\n\n      helpers.resizeAll()\n\n      accountsImportPage.wizardCSV()\n      accountsImportPage.csvUpload()\n\n      accountsImportPage.wizardJson()\n      accountsImportPage.jsonUpload()\n\n      accountsImportPage.wizardLdap()\n\n      state.csvUploaded = false\n      state.csvData = null\n\n      if (typeof callback === 'function') {\n        return callback()\n      }\n    })\n  }\n\n  accountsImportPage.wizardCSV = function () {\n    var $wizardCsv = $('#wizard_csv')\n\n    if ($wizardCsv.length) {\n      $wizardCsv.steps({\n        headerTag: 'h3',\n        bodyTag: 'section',\n        transitionEffect: 'slideLeft',\n        trigger: 'change',\n        cssClass: 'wizard wizard-green',\n        onInit: function (event, currentIndex) {\n          contentHeight($wizardCsv, currentIndex)\n\n          $wizardCsv\n            .find('.button_next')\n            .addClass('disabled')\n            .attr('aria-disabled', true)\n            .find('a')\n            .attr('disabled', true)\n\n          setTimeout(function () {\n            $(window).resize()\n          }, 100)\n        },\n        onStepChanging: function (event, currentIndex, newIndex) {\n          if (currentIndex === 0 && newIndex === 1) {\n            // Review Uploaded Data\n            if (!state.csvUploaded) {\n              return false\n            }\n          }\n\n          return true\n        },\n        onStepChanged: function (event, currentIndex) {\n          if (currentIndex === 2) {\n            // Last step Disable all until done.\n            $wizardCsv.find('.steps ul li').each(function () {\n              $(this).addClass('disabled')\n            })\n            $wizardCsv.find('.actions ul li').addClass('disabled')\n            $wizardCsv\n              .find('.button_previous')\n              .addClass('disabled')\n              .attr('aria-disabled', true)\n\n            var csvStatusBox = $('#csv-import-status-box')\n            var csvStatusUL = csvStatusBox.find('ul')\n            csvStatusUL.append('<li>Starting import...</li>')\n            disableUIElements()\n\n            // send data\n            setTimeout(function () {\n              socket.accountsImporter.sendAccountData('csv', state.addedUsers, state.updatedUsers)\n            }, 1000)\n          }\n\n          // Disable all future steps when moving backwards\n          $('.steps .current')\n            .nextAll()\n            .removeClass('done')\n            .addClass('disabled')\n\n          contentHeight($wizardCsv, currentIndex)\n        },\n        onFinished: function () {\n          location.href = '/accounts'\n        }\n      })\n    }\n  }\n\n  accountsImportPage.csvUpload = function () {\n    var progressbar = $('#progressbar')\n\n    var bar = progressbar.find('.uk-progress-bar')\n\n    var settings = {\n      action: '/accounts/import/csv/upload',\n      allow: '*.csv',\n      loadstart: function () {\n        bar.css('width', '0%').text('0%')\n        progressbar.removeClass('uk-hidden')\n      },\n      progress: function (percent) {\n        percent = Math.ceil(percent)\n        bar.css('width', percent + '%').text(percent + '%')\n      },\n      notallowed: function () {\n        helpers.UI.showSnackbar('Invalid File Type. Please upload a CSV file.', true)\n      },\n      error: function (err) {\n        console.error(err)\n        helpers.UI.showSnackbar('An unknown error occurred. Check Console', true)\n      },\n      allcomplete: function (response) {\n        response = JSON.parse(response)\n        if (!response.success) {\n          console.log(response)\n          helpers.UI.showSnackbar('An Error occurred. Check Console', true)\n          return false\n        }\n\n        state.csvUploaded = true\n        state.csvData = response.contents\n        state.addedUsers = response.addedUsers\n        state.updatedUsers = response.updatedUsers\n\n        $('#csv-review-list').val(csvReviewRender(response.addedUsers, response.updatedUsers))\n\n        console.log(state.csvData)\n\n        bar.css('width', '100%').text('100%')\n\n        setTimeout(function () {\n          progressbar.addClass('uk-hidden')\n\n          $('#wizard_csv').steps('setStep', 1)\n        }, 1000)\n\n        // helpers.UI.showSnackbar('Upload Complete', false);\n      }\n    }\n\n    UIkit.uploadSelect($('#upload-select'), settings)\n    UIkit.uploadDrop($('#upload-drop'), settings)\n  }\n\n  accountsImportPage.wizardJson = function () {\n    var $wizardJson = $('#wizard_json')\n\n    if ($wizardJson.length) {\n      $wizardJson.steps({\n        headerTag: 'h3',\n        bodyTag: 'section',\n        transitionEffect: 'slideLeft',\n        trigger: 'change',\n        cssClass: 'wizard wizard-blue-gray',\n        onInit: function (event, currentIndex) {\n          contentHeight($wizardJson, currentIndex)\n\n          $wizardJson\n            .find('.button_next')\n            .addClass('disabled')\n            .attr('aria-disabled', true)\n            .find('a')\n            .attr('disabled', true)\n\n          setTimeout(function () {\n            $(window).resize()\n          }, 100)\n        },\n        onStepChanging: function (event, currentIndex, newIndex) {\n          if (currentIndex === 0 && newIndex === 1) {\n            // Review Uploaded Data\n            if (!state.jsonUploaded) {\n              return false\n            }\n          }\n\n          return true\n        },\n        onStepChanged: function (event, currentIndex) {\n          if (currentIndex === 2) {\n            // Last step Disable all until done.\n            $wizardJson.find('.steps ul li').each(function () {\n              $(this).addClass('disabled')\n            })\n            $wizardJson.find('.actions ul li').addClass('disabled')\n            $wizardJson\n              .find('.button_previous')\n              .addClass('disabled')\n              .attr('aria-disabled', true)\n\n            var csvStatusBox = $('#json-import-status-box')\n            var csvStatusUL = csvStatusBox.find('ul')\n            csvStatusUL.append('<li>Starting import...</li>')\n            disableUIElements()\n\n            // send data\n            setTimeout(function () {\n              socket.accountsImporter.sendAccountData('json', state.addedUsers, state.updatedUsers)\n            }, 1000)\n          }\n\n          // Disable all future steps when moving backwards\n          $('.steps .current')\n            .nextAll()\n            .removeClass('done')\n            .addClass('disabled')\n\n          contentHeight($wizardJson, currentIndex)\n        },\n        onFinished: function () {\n          location.href = '/accounts'\n        }\n      })\n    }\n  }\n\n  accountsImportPage.jsonUpload = function () {\n    var progressbar = $('#json-progressbar')\n\n    var bar = progressbar.find('.uk-progress-bar')\n\n    var settings = {\n      action: '/accounts/import/json/upload',\n      allow: '*.json',\n      loadstart: function () {\n        bar.css('width', '0%').text('0%')\n        progressbar.removeClass('uk-hidden')\n      },\n      progress: function (percent) {\n        percent = Math.ceil(percent)\n        bar.css('width', percent + '%').text(percent + '%')\n      },\n      notallowed: function () {\n        helpers.UI.showSnackbar('Invalid File Type. Please upload a JSON file.', true)\n      },\n      error: function (err) {\n        console.error(err)\n        helpers.UI.showSnackbar('An unknown error occurred. Check Console', true)\n      },\n      allcomplete: function (response) {\n        response = JSON.parse(response)\n        if (!response.success) {\n          console.log(response)\n          helpers.UI.showSnackbar('An Error occurred. Check Console', true)\n          return false\n        }\n\n        state.jsonUploaded = true\n        state.jsonData = response.contents\n        state.addedUsers = response.addedUsers\n        state.updatedUsers = response.updatedUsers\n\n        $('#json-review-list').val(csvReviewRender(response.addedUsers, response.updatedUsers))\n\n        bar.css('width', '100%').text('100%')\n\n        setTimeout(function () {\n          progressbar.addClass('uk-hidden')\n\n          $('#wizard_json').steps('setStep', 1)\n        }, 1000)\n      }\n    }\n\n    UIkit.uploadSelect($('#json-upload-select'), settings)\n    UIkit.uploadDrop($('#json-upload-drop'), settings)\n  }\n\n  accountsImportPage.wizardLdap = function () {\n    var $wizardLdap = $('#wizard_ldap')\n    var $connectionForm = $('#wizard_ldap_connection_form')\n\n    var ldapSuccess = false\n\n    var addedUsers = []\n\n    var updatedUsers = []\n\n    if ($wizardLdap.length) {\n      $wizardLdap.steps({\n        headerTag: 'h3',\n        bodyTag: 'section',\n        transitionEffect: 'slideLeft',\n        trigger: 'change',\n        cssClass: 'wizard',\n        onInit: function (event, currentIndex) {\n          contentHeight($wizardLdap, currentIndex)\n\n          // $wizardLdap.find('.button_next').addClass('disabled').attr('aria-disabled', true).find('a').attr('disabled', true);\n          $wizardLdap.find('.button_next > a').html(\"Connect  <i class='material-icons'>&#xE315;</i>\")\n\n          setTimeout(function () {\n            $(window).resize()\n          }, 100)\n        },\n        onStepChanging: function (event, currentIndex, newIndex) {\n          if (currentIndex === 0 && newIndex === 1) {\n            var verifyStatus = $('#wizard_ldap_verify_text')\n            var data = $connectionForm.serializeObject()\n\n            $wizardLdap.find('#wizard_ldap_verify_spinner').removeClass('uk-hidden')\n            $wizardLdap.find('#wizard_ldap_verify_icon').addClass('uk-hidden')\n            $wizardLdap.find('.button_next > a').html(\"Next  <i class='material-icons'>&#xE315;</i>\")\n            setTimeout(function () {\n              $.ajax({\n                url: '/accounts/import/ldap/bind',\n                method: 'POST',\n                headers: {\n                  'Content-Type': 'application/json'\n                },\n                contentType: 'application/json',\n                dataType: 'json',\n                data: JSON.stringify(data),\n                beforeSend: function () {\n                  // $wizardLdap.siblings('.card-spinner').removeClass('uk-hidden');\n                },\n                error: function (err) {\n                  console.error(err)\n                  verifyStatus.text(\n                    'An error occured while trying to bind to the ldap server. Please check connection settings.'\n                  )\n                  $wizardLdap.find('#wizard_ldap_verify_spinner').addClass('uk-hidden')\n                  $wizardLdap\n                    .find('#wizard_ldap_verify_icon')\n                    .removeClass('md-color-green uk-hidden')\n                    .addClass('md-color-red')\n                    .find('> i')\n                    .html('&#xE000;')\n                  // $wizardLdap.steps('setStep', 0);\n                },\n                success: function (response) {\n                  if (response.success) {\n                    ldapSuccess = true\n                    verifyStatus.text('Successfully connected to ldap server. Please click next to review accounts.')\n                    $wizardLdap.find('#wizard_ldap_verify_spinner').addClass('uk-hidden')\n                    $wizardLdap\n                      .find('#wizard_ldap_verify_icon')\n                      .removeClass('md-color-red uk-hidden')\n                      .addClass('md-color-green')\n                      .find('> i')\n                      .html('&#xE86C;')\n                    addedUsers = response.addedUsers\n                    updatedUsers = response.updatedUsers\n\n                    $('#ldap-review-list').val(ldapReviewRender(response.addedUsers, response.updatedUsers))\n                  } else {\n                    verifyStatus.text(\n                      'An error occured while trying to bind to the ldap server. Please check connection settings.'\n                    )\n                    $wizardLdap.find('#wizard_ldap_verify_spinner').addClass('uk-hidden')\n                    $wizardLdap\n                      .find('#wizard_ldap_verify_icon')\n                      .removeClass('md-color-green uk-hidden')\n                      .addClass('md-color-red')\n                      .find('> i')\n                      .html('&#xE000;')\n                  }\n                },\n                complete: function () {\n                  setTimeout(function () {\n                    $wizardLdap.siblings('.card-spinner').addClass('uk-hidden')\n                  }, 800)\n                }\n              })\n            }, 500)\n          }\n\n          if (newIndex === 0) {\n            ldapSuccess = false\n          }\n\n          if (currentIndex === 1 && newIndex === 0) {\n            // Verify to Connection\n            $wizardLdap.find('.button_next > a').html(\"Connect  <i class='material-icons'>&#xE315;</i>\")\n          }\n\n          if (currentIndex === 1 && newIndex === 2) {\n            // Verify to Review\n            if (!ldapSuccess) return false\n          }\n\n          // if (newIndex === 3) {\n          //\n          //     // $wizardLdap.find('.button_previous').addClass('disabled').attr('aria-disabled', true);\n          //     // $wizardLdap.find('.button_finish').addClass('disabled').attr('aria-disabled', true);\n          // }\n\n          return true\n        },\n        onStepChanged: function (event, currentIndex) {\n          if (currentIndex === 3) {\n            // Last step Disable all until done.\n            $wizardLdap.find('.steps ul li').each(function () {\n              $(this).addClass('disabled')\n            })\n            $wizardLdap.find('.actions ul li').addClass('disabled')\n            $wizardLdap\n              .find('.button_previous')\n              .addClass('disabled')\n              .attr('aria-disabled', true)\n\n            var ldapStatusBox = $('#ldap-import-status-box')\n            var ldapStatusUL = ldapStatusBox.find('ul')\n            ldapStatusUL.append('<li>Starting import...</li>')\n            disableUIElements()\n\n            // send data\n            setTimeout(function () {\n              socket.accountsImporter.sendAccountData('ldap', addedUsers, updatedUsers)\n            }, 1000)\n          }\n\n          // Disable all future steps when moving backwards\n          $('.steps .current')\n            .nextAll()\n            .removeClass('done')\n            .addClass('disabled')\n\n          contentHeight($wizardLdap, currentIndex)\n        },\n        onFinished: function () {\n          location.href = '/accounts'\n        }\n      })\n    }\n  }\n\n  function disableUIElements () {\n    // $(window).on('beforeunload', function() {\n    //     return 'Are you sure? We are still importing users.';\n    // });\n\n    $('.sidebar').css({ width: 0 })\n    $('.side-nav-bottom-panel').css({ width: 0 })\n    $('#page-content').css('margin-left', 0)\n    $('.top-menu').css({ display: 'none' })\n    $('.js-wizard-select-wrapper').css({ display: 'none' })\n    $('.js-wizard-cancel').each(function () {\n      $(this).css({ display: 'none' })\n    })\n  }\n\n  function ldapReviewRender (addedUsers, updatedUsers) {\n    var addedUsersTemplate = []\n    var updatedUsersTemplate = []\n\n    if (addedUsers === null) addedUsers = []\n    if (updatedUsers === null) updatedUsers = []\n\n    for (var i = 0; i < addedUsers.length; i++) {\n      addedUsersTemplate.push(\n        addedUsers[i].sAMAccountName +\n          ' | action=add username=' +\n          addedUsers[i].sAMAccountName +\n          ' name=' +\n          addedUsers[i].displayName +\n          ' email=' +\n          addedUsers[i].mail +\n          ' title=' +\n          addedUsers[i].title\n      )\n    }\n\n    for (var k = 0; k < updatedUsers.length; k++) {\n      updatedUsersTemplate.push(\n        updatedUsers[k].username +\n          ' | action=update username=' +\n          updatedUsers[k].username +\n          ' name=' +\n          updatedUsers[k].fullname +\n          ' email=' +\n          updatedUsers[k].email +\n          ' title=' +\n          updatedUsers[k].title\n      )\n    }\n\n    var sep = []\n\n    if (addedUsersTemplate.length > 0) {\n      sep.push('----------------')\n    }\n\n    return _.union(addedUsersTemplate, sep, updatedUsersTemplate).join('\\r')\n  }\n\n  function csvReviewRender (addedUsers, updatedUsers) {\n    var addedUsersTemplate = []\n    var updatedUsersTemplate = []\n\n    if (addedUsers === null) addedUsers = []\n    if (updatedUsers === null) updatedUsers = []\n\n    for (var i = 0; i < addedUsers.length; i++) {\n      addedUsersTemplate.push(\n        addedUsers[i].username +\n          ' | action=add username=' +\n          addedUsers[i].username +\n          ' name=' +\n          addedUsers[i].fullname +\n          ' email=' +\n          addedUsers[i].email +\n          ' title=' +\n          addedUsers[i].title\n      )\n    }\n\n    for (var k = 0; k < updatedUsers.length; k++) {\n      updatedUsersTemplate.push(\n        updatedUsers[k].username +\n          ' | action=update username=' +\n          updatedUsers[k].username +\n          ' name=' +\n          updatedUsers[k].fullname +\n          ' email=' +\n          updatedUsers[k].email +\n          ' title=' +\n          updatedUsers[k].title\n      )\n    }\n\n    var sep = []\n\n    if (addedUsersTemplate.length > 0) {\n      sep.push('----------------')\n    }\n\n    return _.union(addedUsersTemplate, sep, updatedUsersTemplate).join('\\r')\n  }\n\n  function contentHeight (thisWizard, step) {\n    var thisHeight = $(thisWizard)\n      .find('.step-' + step)\n      .actual('outerHeight')\n    $(thisWizard)\n      .children('.content')\n      .velocity({ height: thisHeight }, { duration: 140, easing: [0.215, 0.61, 0.355, 1] })\n  }\n\n  return accountsImportPage\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n\n//# sourceURL=webpack:///./src/public/js/pages/accountsImport.js?");

/***/ }),

/***/ "./src/public/js/pages/createNotice.js":
/*!*********************************************!*\
  !*** ./src/public/js/pages/createNotice.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\"), __webpack_require__(/*! chosen */ \"./src/public/js/vendor/chosen/chosen.jquery.min.js\"), __webpack_require__(/*! history */ \"./src/public/js/vendor/history/jquery.history.js\"), __webpack_require__(/*! colorpicker */ \"./src/public/js/vendor/simplecolorpicker/jquery.simplecolorpicker.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($) {\n  var createNotice = {}\n\n  createNotice.init = function (callback) {\n    $(document).ready(function () {\n      $('select[name=\"nColor\"]').simplecolorpicker({ theme: 'fontawesome' })\n      $('select[name=\"nFontColor\"]').simplecolorpicker({ theme: 'fontawesome' })\n\n      if (typeof callback === 'function') {\n        return callback()\n      }\n    })\n  }\n\n  return createNotice\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n\n//# sourceURL=webpack:///./src/public/js/pages/createNotice.js?");

/***/ }),

/***/ "./src/public/js/pages/dashboard.js":
/*!******************************************!*\
  !*** ./src/public/js/pages/dashboard.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:46 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n  __webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\"),\n  __webpack_require__(/*! underscore */ \"./src/public/js/vendor/underscore/underscore.js\"),\n  __webpack_require__(/*! modules/helpers */ \"./src/public/js/modules/helpers.js\"),\n  __webpack_require__(/*! countup */ \"./src/public/js/vendor/countup/countUp.min.js\"),\n  __webpack_require__(/*! c3 */ \"./src/public/js/vendor/c3/c3.js\"),\n  __webpack_require__(/*! d3 */ \"./src/public/js/vendor/d3/d3.min.js\"),\n  __webpack_require__(/*! moment */ \"./src/public/js/vendor/moment/moment.js\"),\n  __webpack_require__(/*! d3pie */ \"./src/public/js/vendor/d3pie/d3pie.min.js\"),\n  __webpack_require__(/*! metricsgraphics */ \"./src/public/js/vendor/metricsgraphics/metricsgraphics.min.js\"),\n  __webpack_require__(/*! peity */ \"./src/public/js/vendor/peity/jquery.peity.min.js\"),\n  __webpack_require__(/*! history */ \"./src/public/js/vendor/history/jquery.history.js\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($, _, helpers, CountUp, c3, d3, moment) {\n  var dashboardPage = {}\n\n  dashboardPage.init = function (callback) {\n    $(document).ready(function () {\n      var testPage = $('#page-content').find('.dashboard')\n      if (testPage.length < 1) {\n        if (typeof callback === 'function') {\n          return callback()\n        }\n\n        return true\n      }\n\n      helpers.resizeAll()\n\n      dashboardPage.shortDateFormat = window.trudeskSettingsService.getSettings().shortDateFormat.value\n\n      var parms = {\n        full_width: true,\n        height: 250,\n        target: '#breakdownGraph',\n        x_accessor: 'date',\n        y_accessor: 'value',\n        y_extended_ticks: true,\n        show_tooltips: false,\n        area: [1],\n        aggregate_rollover: true,\n        transition_on_update: false\n        // colors: ['#2196f3']\n      }\n\n      var showOverdue =\n        $('#__showOverdueTickets')\n          .text()\n          .toLowerCase() === 'true'\n      if (true) {\n        var overdueCard = $('#overdue_tickets')\n        var $overdueTableBody = overdueCard.find('table.uk-table > tbody')\n        $overdueTableBody.empty() // Clear\n        $.ajax({\n          url: '/api/v1/tickets/overdue',\n          method: 'GET',\n          success: function (_data) {\n            var overdueSpinner = overdueCard.find('.card-spinner')\n            var html = ''\n            _.each(_data.tickets, function (ticket) {\n              html += '<tr class=\"uk-table-middle\">'\n              html +=\n                '<td class=\"uk-width-1-10 uk-text-nowrap\"><a href=\"/tickets/' +\n                ticket.uid +\n                '\">T#' +\n                ticket.uid +\n                '</a></td>'\n              html +=\n                '<td class=\"uk-width-1-10 uk-text-nowrap\"><span class=\"uk-badge ticket-status-open uk-width-1-1\">In Progress</span></td>'\n              html +=\n                  '<td class=\"uk-width-1-10 uk-text-nowrap\"><span class=\"uk-badge ticket-status-open uk-width-1-1\">In Progress</span></td>'\n              html += '<td class=\"uk-width-6-10\">' + ticket.subject + '</td>'\n              if (ticket.updated) {\n                html +=\n                  '<td class=\"uk-width-2-10 uk-text-right uk-text-muted uk-text-small\">' +\n                  moment\n                    .utc(ticket.updated)\n                    .tz(helpers.getTimezone())\n                    .format(dashboardPage.shortDateFormat) +\n                  '</td>'\n              } else {\n                html +=\n                  '<td class=\"uk-width-2-10 uk-text-right uk-text-muted uk-text-small\">' +\n                  moment\n                    .utc(ticket.date)\n                    .tz(helpers.getTimezone())\n                    .format(dashboardPage.shortDateFormat) +\n                  '</td>'\n              }\n              html += '</tr>'\n            })\n\n            $overdueTableBody.append(html)\n            $overdueTableBody.ajaxify()\n            overdueSpinner.animate({ opacity: 0 }, 600, function () {\n              $(this).hide()\n            })\n          },\n          error: function (err) {\n            console.log('[trudesk:dashboard:loadOverdue] Error - ' + err.responseText)\n            helpers.UI.showSnackbar(err.responseText, true)\n          }\n        })\n      }\n\n      getData(30)\n\n      $('#select_timespan').on('change', function () {\n        var self = $(this)\n        getData(self.val())\n      })\n\n      function getData (timespan) {\n        $.ajax({\n          url: '/api/v1/tickets/stats/' + timespan,\n          method: 'GET',\n          success: function (_data) {\n            var lastUpdated = $('#lastUpdated').find('span')\n\n            var formatString = helpers.getLongDateFormat() + ' ' + helpers.getTimeFormat()\n            var formated = moment.utc(_data.lastUpdated, 'MM/DD/YYYY hh:mm:ssa').format(formatString)\n\n            lastUpdated.text(formated)\n\n            if (!_data.data) {\n              console.log('[trudesk:dashboard:getData] Error - Invalid Graph Data')\n              helpers.UI.showSnackbar('Error - Invalid Graph Data', true)\n            } else if (_data.data.length < 1) {\n              // No data in graph. Show No Data avaliable\n              var $breakdownGraph = $('#breakdownGraph')\n              $breakdownGraph.empty()\n              $breakdownGraph.append('<div class=\"no-data-available-text\">No Data Available</div>')\n            } else {\n              $('#breakdownGraph').empty()\n              parms.data = MG.convert.date(_data.data, 'date')\n              MG.data_graphic(parms)\n            }\n\n            var tCount = _data.ticketCount\n\n            var ticketCount = $('#ticketCount')\n            var oldTicketCount = ticketCount.text() === '--' ? 0 : ticketCount.text()\n            var totalTicketText = 'Total Tickets (last ' + timespan + 'd)'\n            // if (timespan == 0)\n            //     totalTicketText = 'Total Tickets (lifetime)';\n            ticketCount\n              .parents('.tru-card-content')\n              .find('span.uk-text-small')\n              .text(totalTicketText)\n            var theAnimation = new CountUp('ticketCount', parseInt(oldTicketCount), tCount, 0, 1.5)\n            theAnimation.start()\n\n            var closedCount = Number(_data.closedCount)\n            var closedPercent = Math.round((closedCount / tCount) * 100)\n\n            var textComplete = $('#text_complete')\n            var oldTextComplete = textComplete.text() === '--' ? 0 : textComplete.text()\n            var completeAnimation = new CountUp('text_complete', parseInt(oldTextComplete), closedPercent, 0, 1.5)\n            completeAnimation.start()\n\n            var pieComplete = $('#pie_complete')\n            pieComplete.text(closedPercent + '/100')\n            pieComplete.peity('donut', {\n              height: 24,\n              width: 24,\n              fill: ['#29b955', '#ccc']\n            })\n\n            var $responseTimeText = $('#responseTime_text')\n            // var responseTime_graph = $('#responseTime_graph');\n            var oldResponseTime = $responseTimeText.text() === '--' ? 0 : $responseTimeText.text()\n            var responseTime = _data.ticketAvg\n            var responseTimeAnimation = new CountUp(\n              'responseTime_text',\n              parseInt(oldResponseTime),\n              responseTime,\n              0,\n              1.5\n            )\n            responseTimeAnimation.start()\n\n            // QuickStats\n            var mostRequester = $('#mostRequester')\n            if (_data.mostRequester) {\n              mostRequester.text(_data.mostRequester.name + ' (' + _data.mostRequester.value + ')')\n            }\n            var mostCommenter = $('#mostCommenter')\n            if (_data.mostCommenter) {\n              mostCommenter.text(_data.mostCommenter.name + ' (' + _data.mostCommenter.value + ')')\n            } else {\n              mostCommenter.text('--')\n            }\n\n            var mostAssignee = $('#mostAssignee')\n            if (_data.mostAssignee) {\n              mostAssignee.text(_data.mostAssignee.name + ' (' + _data.mostAssignee.value + ')')\n            } else {\n              mostAssignee.text('--')\n            }\n\n            var mostActiveTicket = $('#mostActiveTicket')\n            if (_data.mostActiveTicket) {\n              mostActiveTicket\n                .attr('href', '/tickets/' + _data.mostActiveTicket.uid)\n                .text('T#' + _data.mostActiveTicket.uid)\n            }\n          },\n          error: function (err) {\n            console.log('[trudesk:dashboard:getData] Error - ' + err.responseText)\n            helpers.UI.showSnackbar(err.responseText, true)\n          }\n        })\n\n        $('#topTenTags')\n          .parents('.panel')\n          .find('.card-spinner')\n          .css({ display: 'block', opacity: 1 })\n        $.ajax({\n          url: '/api/v1/tickets/count/tags/' + timespan,\n          method: 'GET',\n          success: function (data) {\n            var arr = _.map(data.tags, function (v, key) {\n              // TODO: this impl should be changed\n              const tagName = key.split(',')[0];\n              const tagId = key.split(',')[1];\n              return [tagId, v, tagName]\n            })\n\n            arr = _.first(arr, 10)\n            var colors = [\n              '#e74c3c',\n              '#3498db',\n              '#9b59b6',\n              '#34495e',\n              '#1abc9c',\n              '#2ecc71',\n              '#03A9F4',\n              '#00BCD4',\n              '#009688',\n              '#4CAF50',\n              '#FF5722',\n              '#CDDC39',\n              '#FFC107',\n              '#00E5FF',\n              '#E040FB',\n              '#607D8B'\n            ]\n\n            const nameMap = arr.reduce(function(map, el) {\n              map[el[0]] = el[2];\n              return map;\n            }, {});\n\n\n            var c = _.object(\n              _.map(arr, function (v) {\n                return v[0]\n              }),\n              _.shuffle(colors)\n            )\n\n            c3.generate({\n              bindto: d3.select('#topTenTags'),\n              size: {\n                height: 200\n              },\n              data: {\n                columns: arr,\n                type: 'donut',\n                onclick: function (data, i) {\n                  window.location.href = `/tickets/filter/?f=1&tag=${data.id}`\n                  ;\n                },\n                colors: c,\n                empty: { label: { text: 'No Data Available' } },\n                labels: true,\n                names: nameMap\n              },\n              donut: {\n                label: {\n                  format: function () {\n                    return ''\n                  }\n                }\n              }\n            })\n\n            $('#topTenTags')\n              .parents('.panel')\n              .find('.card-spinner')\n              .animate({ opacity: 0 }, 600, function () {\n                $(this).hide()\n              })\n          }\n        })\n\n        $('#pieChart')\n          .parent()\n          .find('.card-spinner')\n          .css({ display: 'block', opacity: 1 })\n        $.ajax({\n          url: '/api/v1/tickets/count/topgroups/' + timespan + '/5',\n          method: 'GET',\n          success: function (data) {\n            var arr = _.map(data.items, function (v) {\n              return [v.id, v.count, v.name]\n            })\n\n            var colors = [\n              '#e74c3c',\n              '#3498db',\n              '#9b59b6',\n              '#34495e',\n              '#1abc9c',\n              '#2ecc71',\n              '#03A9F4',\n              '#00BCD4',\n              '#009688',\n              '#4CAF50',\n              '#FF5722',\n              '#CDDC39',\n              '#FFC107',\n              '#00E5FF',\n              '#E040FB',\n              '#607D8B'\n            ]\n\n            colors = _.shuffle(colors)\n\n            var c = _.object(\n              _.map(arr, function (v) {\n                return v[0]\n              }),\n              colors\n            )\n\n            const nameMap = arr.reduce(function(map, el) {\n              map[el[0]] = el[2];\n              return map;\n            }, {});\n\n            c3.generate({\n              bindto: d3.select('#pieChart'),\n              size: {\n                height: 200\n              },\n              data: {\n                columns: arr,\n                type: 'pie',\n                onclick: function (data, i) {\n                  window.location.href = `/tickets/filter/?f=1&gp=${data.id}`\n                  ;\n                },\n                colors: c,\n                empty: { label: { text: 'No Data Available' } },\n                labels: true,\n                names: nameMap\n              },\n              donut: {\n                label: {\n                  format: function () {\n                    return ''\n                  }\n                }\n              },\n            })\n\n            $('#pieChart')\n              .parent()\n              .find('.card-spinner')\n              .animate({ opacity: 0 }, 600, function () {\n                $(this).hide()\n              })\n          }\n        })\n      }\n\n      if (typeof callback === 'function') {\n        return callback()\n      }\n    })\n  }\n\n  return dashboardPage\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n\n//# sourceURL=webpack:///./src/public/js/pages/dashboard.js?");

/***/ }),

/***/ "./src/public/js/pages/groups.js":
/*!***************************************!*\
  !*** ./src/public/js/pages/groups.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n  __webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\"),\n  __webpack_require__(/*! modules/helpers */ \"./src/public/js/modules/helpers.js\"),\n  __webpack_require__(/*! uikit */ \"./src/public/js/vendor/uikit/js/uikit_combined.min.js\"),\n  __webpack_require__(/*! datatables */ \"./src/public/js/vendor/datatables/jquery.dataTables.js\"),\n  __webpack_require__(/*! dt_responsive */ \"./src/public/js/vendor/datatables/dataTables.responsive.js\"),\n  __webpack_require__(/*! dt_grouping */ \"./src/public/js/vendor/datatables/dataTables.grouping.js\"),\n  // 'dt_foundation',\n  __webpack_require__(/*! dt_scroller */ \"./src/public/js/vendor/datatables/dataTables.scroller.js\"),\n  __webpack_require__(/*! history */ \"./src/public/js/vendor/history/jquery.history.js\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($, helpers, UIkit) {\n  var groupsPage = {}\n\n  groupsPage.init = function (callback) {\n    $(document).ready(function () {\n      // get all filters\n      var filterArray = []\n      $('#group_list')\n        .children()\n        .each(function () {\n          var thisfilter = $(this).attr('data-uk-filter')\n          if ($.inArray(thisfilter, filterArray) === -1) {\n            filterArray.push(thisfilter)\n          }\n        })\n\n      var filterArrayLength = filterArray.length\n\n      var grid = UIkit.grid($('#group_list'), {\n        controls: '',\n        gutter: 20\n      })\n\n      // find user\n      $('#group_list_search')\n        .keyup(function () {\n          var sValue = $(this)\n            .val()\n            .toLowerCase()\n\n          if (sValue.length > 2) {\n            var filteredItems = ''\n            for (var $i = 0; $i < filterArrayLength; $i++) {\n              if (filterArray[$i].toLowerCase().indexOf(sValue) !== -1) {\n                filteredItems += (filteredItems.length > 1 ? ',' : '') + filterArray[$i]\n              }\n            }\n\n            if (filteredItems) {\n              // filter grid items\n              grid.filter(filteredItems)\n            } else {\n              // show all\n              grid.filter('all')\n            }\n          } else {\n            // reset filter\n            grid.filter()\n          }\n        })\n        .on('blur', function () {\n          // clear search input\n          // $(this).val('');\n        })\n\n      //            var table = $('#groupsTable');\n      //            table.dataTable({\n      //                searching: true,\n      //                bLengthChange: false,\n      //                bPaginate: false,\n      //                iDisplayLength: 99999,\n      //                bInfo: false,\n      //                scrollY: '100%',\n      //                order: [[1, 'asc']],\n      //                columnDefs: [\n      //                    {\"width\": \"50px\", \"targets\": 0}\n      //                ]\n      //            });\n      /// /                .rowGrouping({\n      /// /                iGroupingColumnIndex: 5,\n      /// /                sGroupingColumnSortDirection: \"asc\",\n      /// /                iGroupingOrderByColumnIndex: 1,\n      /// /                bHideGroupingColumn: false,\n      /// /                bHideGroupingOrderByColumn: false\n      /// /            });\n      //\n      //            helpers.resizeDataTables('.groupsList');\n\n      if (typeof callback === 'function') {\n        return callback()\n      }\n    })\n  }\n\n  return groupsPage\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n\n//# sourceURL=webpack:///./src/public/js/pages/groups.js?");

/***/ }),

/***/ "./src/public/js/pages/logs.js":
/*!*************************************!*\
  !*** ./src/public/js/pages/logs.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\"), __webpack_require__(/*! modules/socket */ \"./src/public/js/modules/socket.js\"), __webpack_require__(/*! history */ \"./src/public/js/vendor/history/jquery.history.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($, socket) {\n  var logsPage = {}\n\n  logsPage.init = function (callback) {\n    $(document).ready(function () {\n      socket.ui.fetchServerLogs()\n      var $sLogs = $('#serverlogs')\n      if ($sLogs.length > 0) {\n        $sLogs.scrollTop(99999999999999 * 999999999999999)\n      }\n\n      if (typeof callback === 'function') {\n        return callback()\n      }\n    })\n  }\n\n  return logsPage\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n\n//# sourceURL=webpack:///./src/public/js/pages/logs.js?");

/***/ }),

/***/ "./src/public/js/pages/messages.js":
/*!*****************************************!*\
  !*** ./src/public/js/pages/messages.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n  __webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\"),\n  __webpack_require__(/*! underscore */ \"./src/public/js/vendor/underscore/underscore.js\"),\n  __webpack_require__(/*! angular */ \"./src/public/js/vendor/angular/angular.min.js\"),\n  __webpack_require__(/*! uikit */ \"./src/public/js/vendor/uikit/js/uikit_combined.min.js\"),\n  __webpack_require__(/*! moment */ \"./src/public/js/vendor/moment/moment.js\"),\n  __webpack_require__(/*! modules/helpers */ \"./src/public/js/modules/helpers.js\"),\n  __webpack_require__(/*! modules/socket */ \"./src/public/js/modules/socket.js\"),\n  __webpack_require__(/*! history */ \"./src/public/js/vendor/history/jquery.history.js\"),\n  __webpack_require__(/*! isinview */ \"./src/public/js/plugins/jquery.isinview.js\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($, _, angular, UIKit, moment, helpers) {\n  var messagesPage = {}\n\n  messagesPage.init = function (callback) {\n    $(document).ready(function () {\n      var $messageScroller = $('#message-content.scrollable')\n\n      var $messagesWrapper = $('#messages')\n\n      var $scrollspy = $('#conversation-scrollspy')\n\n      var $spinner = $scrollspy.find('i')\n\n      var $searchBox = $('.search-box').find('input')\n\n      var $nextPage = 2\n\n      var $enabled = true\n\n      var $loading = false\n\n      // $inview             = null,\n\n      var $recentMessages = {}\n\n      var $convoId = $('#message-content[data-conversation-id]').attr('data-conversation-id')\n\n      var $loggedInAccountId = window.trudeskSessionService.getUser()._id\n\n      // Setup Context Menu\n      helpers.setupContextMenu('#convo-list > ul > li', function (action, target) {\n        var $li = $(target)\n        if (!$li.is('li')) {\n          $li = $(target).parents('li')\n        }\n        var convoId = $li.attr('data-conversation-id')\n        if (action.toLowerCase() === 'delete') {\n          UIKit.modal.confirm(\n            'Are you sure you want to delete this conversation?',\n            function () {\n              // Confirm\n              deleteConversation(convoId)\n            },\n            function () {\n              // Cancel\n            },\n            {\n              labels: {\n                Ok: 'YES'\n              },\n              confirmButtonClass: 'md-btn-danger'\n            }\n          )\n        }\n      })\n\n      $searchBox.off('keyup')\n      $searchBox.on('keyup', onSearchKeyUp)\n\n      $(window).off('$trudesk:ready.messages')\n      $(window).on('$trudesk:ready.messages', function () {\n        helpers.scrollToBottom($messageScroller)\n\n        // set active\n        if ($convoId !== undefined) {\n          var item = $('ul > li[data-conversation-id=\"' + $convoId + '\"]')\n          item.addClass('active')\n        }\n\n        // Remove All Chat Boxes\n        if (\n          $('#__page')\n            .text()\n            .toLowerCase() === 'messages'\n        ) {\n          $('.chat-box-position').each(function () {\n            var self = $(this)\n            self.remove()\n          })\n\n          $('.message-textbox')\n            .find('input')\n            .focus()\n\n          $messageScroller.scroll(function () {\n            if ($scrollspy.isInView($messageScroller)) {\n              var run = _.throttle(loadMoreMessages, 100)\n              run()\n            }\n          })\n        }\n      })\n\n      function deleteConversation (convoId) {\n        $.ajax({\n          url: '/api/v1/messages/conversation/' + convoId,\n          method: 'DELETE',\n          success: function (response) {\n            if (response.success) {\n              // Check if on conversation\n              var $convo = $('#message-content[data-conversation-id=\"' + response.conversation._id + '\"]')\n              if ($convo.length > 0) {\n                History.pushState(null, null, '/messages', false)\n              } else {\n                var $convoLI = $('#convo-list').find('li[data-conversation-id=\"' + response.conversation._id + '\"]')\n                if ($convoLI.length > 0) {\n                  $convoLI.remove()\n                }\n              }\n\n              $.event.trigger('$trudesk:chat:conversation:deleted', {\n                conversation: response.conversation\n              })\n\n              helpers.UI.showSnackbar('Conversation Deleted.', false)\n            }\n          },\n          error: function (error) {\n            console.log(error)\n          }\n        })\n      }\n\n      function onSearchKeyUp () {\n        var searchTerm = $searchBox.val().toLowerCase()\n        $('.all-user-list li').each(function () {\n          if ($(this).filter('[data-search-term *= ' + searchTerm + ']').length > 0 || searchTerm.length < 1) {\n            $(this).show()\n          } else {\n            $(this).hide()\n          }\n        })\n      }\n\n      function loadMoreMessages () {\n        if (!$enabled || $loading) return false\n        if (_.isUndefined($convoId)) return false\n        $loading = true\n        $spinner.removeClass('uk-hidden')\n\n        // Load Messages\n        $.ajax({\n          url: '/api/v1/messages/conversation/' + $convoId + '?page=' + $nextPage\n        })\n          .done(function (data) {\n            $spinner.addClass('uk-hidden')\n            var messages = data.messages\n            if (_.size(messages) < 1) {\n              $enabled = false\n              $loading = false\n              return false\n            }\n\n            var html = ''\n\n            _.each(messages, function (m) {\n              var h = buildMessageHTML(m)\n              if (h.length > 0) html += h\n            })\n\n            var stage = $('<div></div>')\n              .appendTo('body')\n              .addClass('stage')\n              .css({\n                opacity: 0,\n                visibility: 'hidden',\n                position: 'absolute',\n                top: '-9999em',\n                left: '-9999em'\n              })\n              .append(html)\n            var height = $(stage).outerHeight()\n            $(stage).remove()\n\n            $messagesWrapper.prepend(html)\n\n            UIKit.$html.trigger('changed.uk.dom')\n            $messageScroller.scrollTop(height, true)\n\n            $nextPage = $nextPage + 1\n            $loading = false\n          })\n          .error(function (err) {\n            console.log(err)\n          })\n      }\n\n      function buildMessageHTML (message) {\n        var html = ''\n        var loggedInAccountId = window.trudeskSessionService.getUser()._id\n        if (loggedInAccountId === undefined) return false\n        var left = true\n        if (message.owner._id.toString() === loggedInAccountId.toString()) {\n          left = false\n        }\n\n        var image = message.owner.image === undefined ? 'defaultProfile.jpg' : message.owner.image\n\n        if (left) {\n          html += '<div class=\"message message-left\">'\n          html +=\n            '<img class=\"profileImage\" src=\"/uploads/users/' +\n            image +\n            '\" data-userId=\"' +\n            message.owner._id +\n            '\" data-uk-tooltip=\"{pos:\\'left\\', animation: false}\" title=\"' +\n            message.owner.fullname +\n            ' - ' +\n            moment(message.createdAt)\n              .tz(helpers.getTimezone())\n              .format(helpers.getShortDateFormat() + ' ' + helpers.getTimeFormat()) +\n            '\"/>'\n          html += '<div class=\"message-body\">'\n          html += '<p>' + message.body + '</p>'\n          html += '</div>'\n          html += '</div>'\n        } else {\n          html += '<div class=\"message message-right\">'\n          html +=\n            '<div class=\"message-body\" data-uk-tooltip=\"{pos:\\'right\\', animation: false}\" title=\"' +\n            moment(message.createdAt)\n              .tz(helpers.getTimezone())\n              .format(helpers.getShortDateFormat() + ' ' + helpers.getTimeFormat()) +\n            '\">'\n          html += '<p>' + message.body + '</p>'\n          html += '</div>'\n          html += '</div>'\n        }\n\n        return html\n      }\n\n      // Remove all Events in the .conversation namespace for this page.\n      $(window).off('.conversation')\n\n      // On user Typing\n      $(window).on('$trudesk:chat:typing.conversation', function (event, data) {\n        var convoListItem = $('#convo-list').find('li[data-conversation-id=\"' + data.cid + '\"]')\n        if (convoListItem.length > 0) {\n          $recentMessages[data.cid] = convoListItem.find('.message-subject').text()\n          convoListItem.find('.message-subject').text(data.fromUser.fullname + ' is typing...')\n        }\n      })\n\n      $(window).on('$trudesk:chat:stoptyping.conversation', function (event, data) {\n        var convoListItem = $('#convo-list').find('li[data-conversation-id=\"' + data.cid + '\"]')\n        if (convoListItem.length > 0) {\n          convoListItem.find('.message-subject').text($recentMessages[data.cid])\n        }\n      })\n\n      // On Chat Message\n      $(window).on('$trudesk:chat:message.conversation', function (event, data) {\n        var message = {\n          _id: data.messageId,\n          conversation: data.conversation,\n          body: data.message,\n          owner: data.fromUser\n        }\n\n        var html = buildMessageHTML(message)\n        var messageWrapper = $('#message-content[data-conversation-id=\"' + message.conversation + '\"]')\n        if (messageWrapper.length > 0) {\n          messageWrapper.find('#messages').append(html)\n        }\n\n        var convoListItem = $('li[data-conversation-id=\"' + data.conversation + '\"]')\n        if (convoListItem.length > 0) {\n          convoListItem.attr('data-updatedAt', new Date())\n          var ul = convoListItem.parent('ul')\n          var li = ul.children('li')\n          li.detach().sort(function (a, b) {\n            return new Date($(a).attr('data-updatedAt')) < new Date($(b).attr('data-updatedAt'))\n          })\n\n          ul.append(li)\n\n          var fromName = message.owner.fullname\n          if (message.owner._id.toString() === $loggedInAccountId) {\n            fromName = 'You'\n          }\n\n          convoListItem.find('.message-subject').text(fromName + ': ' + message.body)\n          $recentMessages[message.conversation] = fromName + ': ' + message.body\n          var timezone = helpers.getTimezone()\n          convoListItem.find('.message-date').text(\n            moment\n              .utc()\n              .tz(timezone)\n              .calendar()\n          )\n        } else {\n          var convoUL = $('#convo-list > ul.message-items')\n          if (convoUL.length > 0) {\n            var partner = message.owner\n            if (message.owner._id.toString() === $loggedInAccountId.toString()) {\n              partner = data.toUser\n            }\n            var newLI = buildConversationListItem({\n              _id: message.conversation,\n              partner: partner,\n              updatedAt: new Date(),\n              recentMessage: message.owner.fullname + ': ' + message.body\n            })\n\n            var $injector = angular.injector(['ng', 'trudesk'])\n            $injector.invoke([\n              '$compile',\n              '$rootScope',\n              function ($compile, $rootScope) {\n                var $scope = convoUL.prepend(newLI).scope()\n                $compile(convoUL)($scope || $rootScope)\n                $rootScope.$digest()\n              }\n            ])\n          }\n        }\n\n        UIKit.$html.trigger('changed.uk.dom')\n        helpers.scrollToBottom($messageScroller)\n      })\n\n      function buildConversationListItem (data) {\n        var html = ''\n\n        html +=\n          '<li ng-click=\"loadConversation(\\'' +\n          data._id +\n          '\\');\" data-conversation-id=\"' +\n          data._id +\n          '\" data-updatedAt=\"' +\n          data.updatedAt +\n          '\">'\n        html += '<div class=\"profile-pic\">'\n        var imageUrl = 'defaultProfile.jpg'\n        if (data.partner.image) {\n          imageUrl = data.partner.image\n        }\n        html +=\n          '<img src=\"/uploads/users/' +\n          imageUrl +\n          '\" class=\"uk-border-circle profileImage\" data-userid=\"' +\n          data.partner._id +\n          '\" />'\n        html += '<span class=\"user-online uk-border-circle\" data-user-status-id=\"' + data.partner._id + '\"></span>'\n        html += '</div>'\n        html += '<div class=\"convo-info\">'\n        html += '<span class=\"message-from\">' + data.partner.fullname + '</span>'\n        html += '<span class=\"message-date\">' + moment(data.updatedAt).calendar() + '</span>'\n        html += '<span class=\"message-subject\">' + data.recentMessage + '</span>'\n        html += '</div>'\n        html += '</li>'\n\n        return html\n      }\n\n      if (typeof callback === 'function') {\n        return callback()\n      }\n    })\n  }\n\n  return messagesPage\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n\n//# sourceURL=webpack:///./src/public/js/pages/messages.js?");

/***/ }),

/***/ "./src/public/js/pages/notices.js":
/*!****************************************!*\
  !*** ./src/public/js/pages/notices.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n  __webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\"),\n  __webpack_require__(/*! modules/helpers */ \"./src/public/js/modules/helpers.js\"),\n  __webpack_require__(/*! colorpicker */ \"./src/public/js/vendor/simplecolorpicker/jquery.simplecolorpicker.js\"),\n  __webpack_require__(/*! datatables */ \"./src/public/js/vendor/datatables/jquery.dataTables.js\"),\n  __webpack_require__(/*! dt_responsive */ \"./src/public/js/vendor/datatables/dataTables.responsive.js\"),\n  __webpack_require__(/*! dt_grouping */ \"./src/public/js/vendor/datatables/dataTables.grouping.js\"),\n  // 'dt_foundation',\n  __webpack_require__(/*! dt_scroller */ \"./src/public/js/vendor/datatables/dataTables.scroller.js\"),\n  __webpack_require__(/*! history */ \"./src/public/js/vendor/history/jquery.history.js\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($, helpers) {\n  var noticesPage = {}\n\n  noticesPage.init = function (callback) {\n    $(document).ready(function () {\n      var table = $('#noticesTable')\n      table.dataTable({\n        searching: false,\n        bLengthChange: false,\n        bPaginate: false,\n        bInfo: false,\n        bSort: false,\n        scrollY: '100%',\n        order: [[3, 'desc']],\n        columnDefs: [\n          { width: '50px', targets: 0 },\n          { width: '20%', targets: 1 },\n          { width: '50%', targets: 2 },\n          { width: '20%', targets: 3 },\n          { width: '50px', targets: 4 }\n        ],\n        oLanguage: {\n          sEmptyTable: 'No notices to display.'\n        }\n      })\n      //                .rowGrouping({\n      //                iGroupingColumnIndex: 5,\n      //                sGroupingColumnSortDirection: \"asc\",\n      //                iGroupingOrderByColumnIndex: 1,\n      //                bHideGroupingColumn: false,\n      //                bHideGroupingOrderByColumn: false\n      //            });\n\n      helpers.resizeDataTables('.noticesList')\n\n      if (typeof callback === 'function') {\n        return callback()\n      }\n    })\n  }\n\n  return noticesPage\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n\n//# sourceURL=webpack:///./src/public/js/pages/notices.js?");

/***/ }),

/***/ "./src/public/js/pages/plugins.js":
/*!****************************************!*\
  !*** ./src/public/js/pages/plugins.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\"), __webpack_require__(/*! modules/helpers */ \"./src/public/js/modules/helpers.js\"), __webpack_require__(/*! tether */ \"./src/public/js/vendor/tether/tether.min.js\"), __webpack_require__(/*! history */ \"./src/public/js/vendor/history/jquery.history.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($, helpers, Tether) {\n  var pluginsPage = {}\n\n  pluginsPage.init = function (callback) {\n    $(document).ready(function () {\n      var $searchPluginList = $('#search_plugin_list')\n      $searchPluginList.off('keyup')\n      $searchPluginList.on('keyup', function () {\n        var value = this.value.toLowerCase()\n        $('table#plugin_list_table')\n          .find('tbody')\n          .find('tr')\n          .each(function () {\n            var id = $(this)\n              .find('td')\n              .text()\n              .toLowerCase()\n            $(this).toggle(id.indexOf(value) !== -1)\n          })\n      })\n\n      if ($('.plugin-tether').length > 0) {\n        // eslint-disable-next-line\n        new Tether({\n          element: '.plugin-tether',\n          target: '.tether-plugins',\n          attachment: 'top left',\n          targetAttachment: 'top right',\n          offset: '0 -20px'\n        })\n      }\n\n      if (typeof callback === 'function') {\n        return callback()\n      }\n    })\n  }\n\n  return pluginsPage\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n\n//# sourceURL=webpack:///./src/public/js/pages/plugins.js?");

/***/ }),

/***/ "./src/public/js/pages/profile.js":
/*!****************************************!*\
  !*** ./src/public/js/pages/profile.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\"), __webpack_require__(/*! qrcode */ \"./src/public/js/vendor/qrcode/jquery.qrcode.min.js\"), __webpack_require__(/*! history */ \"./src/public/js/vendor/history/jquery.history.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($) {\n  var profile = {}\n\n  profile.init = function (callback) {\n    $(document).ready(function () {\n      generateQRCode()\n\n      if (typeof callback === 'function') {\n        return callback()\n      }\n    })\n  }\n\n  function generateQRCode () {\n    var $totp = $('#totp-qrcode')\n    var hasKey = $totp.attr('data-hasKey')\n    var key = $totp.attr('data-totpkey')\n    if (hasKey === 'true') {\n      $totp.qrcode({ width: 242, height: 242, text: key })\n    } else {\n      $('input#tOTPKey').addClass('hide')\n      $('.totp-settings-wrap .panel-body2').addClass('hide')\n    }\n  }\n\n  return profile\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n\n//# sourceURL=webpack:///./src/public/js/pages/profile.js?");

/***/ }),

/***/ "./src/public/js/pages/reports.js":
/*!****************************************!*\
  !*** ./src/public/js/pages/reports.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n  __webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\"),\n  __webpack_require__(/*! underscore */ \"./src/public/js/vendor/underscore/underscore.js\"),\n  __webpack_require__(/*! modules/helpers */ \"./src/public/js/modules/helpers.js\"),\n  __webpack_require__(/*! countup */ \"./src/public/js/vendor/countup/countUp.min.js\"),\n  __webpack_require__(/*! c3 */ \"./src/public/js/vendor/c3/c3.js\"),\n  __webpack_require__(/*! d3pie */ \"./src/public/js/vendor/d3pie/d3pie.min.js\"),\n  __webpack_require__(/*! metricsgraphics */ \"./src/public/js/vendor/metricsgraphics/metricsgraphics.min.js\"),\n  __webpack_require__(/*! peity */ \"./src/public/js/vendor/peity/jquery.peity.min.js\"),\n  __webpack_require__(/*! history */ \"./src/public/js/vendor/history/jquery.history.js\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($, _, helpers, CountUp, c3) {\n  var reportsPage = {}\n\n  function getData (timespan) {\n    var parms = {\n      full_width: true,\n      height: 250,\n      target: '#test',\n      x_accessor: 'date',\n      y_accessor: 'value',\n      y_extended_ticks: true,\n      show_tooltips: false,\n      aggregate_rollover: true,\n      transition_on_update: false,\n      colors: ['#2196f3', 'red']\n    }\n\n    $.ajax({\n      url: '/api/v1/tickets/stats/' + timespan,\n      method: 'GET',\n      success: function (_data) {\n        var lastUpdated = $('#lastUpdated').find('span')\n        lastUpdated.text(_data.lastUpdated)\n\n        if (!_data.data) {\n          console.log('[trudesk:dashboard:getData] Error - Invalid Graph Data')\n          helpers.UI.showSnackbar('Error - Invalid Graph Data', true)\n        } else {\n          parms.data = MG.convert.date(_data.data, 'date')\n          MG.data_graphic(parms)\n        }\n\n        // var tCount = _(_data.data).reduce(function(m, x) { return m + x.value; }, 0);\n        var tCount = _data.ticketCount\n\n        var ticketCount = $('#ticketCount')\n        var oldTicketCount = ticketCount.text() === '--' ? 0 : ticketCount.text()\n        var totalTicketText = 'Total Tickets (last ' + timespan + 'd)'\n        if (timespan === 0) {\n          totalTicketText = 'Total Tickets (lifetime)'\n        }\n        ticketCount\n          .parents('.tru-card-content')\n          .find('span.uk-text-small')\n          .text(totalTicketText)\n        var theAnimation = new CountUp('ticketCount', parseInt(oldTicketCount), tCount, 0, 1.5)\n        theAnimation.start()\n\n        var closedCount = Number(_data.closedCount)\n        var closedPercent = Math.round((closedCount / tCount) * 100)\n\n        var textComplete = $('#text_complete')\n        var oldTextComplete = textComplete.text() === '--' ? 0 : textComplete.text()\n        var completeAnimation = new CountUp('text_complete', parseInt(oldTextComplete), closedPercent, 0, 1.5)\n        completeAnimation.start()\n\n        var pieComplete = $('#pie_complete')\n        pieComplete.text(closedPercent + '/100')\n        pieComplete.peity('donut', {\n          height: 24,\n          width: 24,\n          fill: ['#29b955', '#ccc']\n        })\n\n        var responseTimeText = $('#responseTime_text')\n        // var responseTime_graph = $('#responseTime_graph');\n        var oldResponseTime = responseTimeText.text() === '--' ? 0 : responseTimeText.text()\n        var responseTime = _data.ticketAvg\n        var responeTimeAnimation = new CountUp('responseTime_text', parseInt(oldResponseTime), responseTime, 0, 1.5)\n        responeTimeAnimation.start()\n      }\n    }).error(function (err) {\n      // console.log(err);\n      console.log('[trudesk:dashboard:getData] Error - ' + err.responseText)\n      helpers.UI.showSnackbar(err.responseText, true)\n    })\n\n    $.ajax({\n      url: '/api/v1/tickets/count/tags/' + timespan,\n      method: 'GET',\n      success: function (data) {\n        var arr = _.map(data.tags, function (v, key) {\n          return [key, v]\n        })\n\n        arr = _.first(arr, 10)\n\n        var colors = [\n          '#e74c3c',\n          '#3498db',\n          '#9b59b6',\n          '#34495e',\n          '#1abc9c',\n          '#2ecc71',\n          '#03A9F4',\n          '#00BCD4',\n          '#009688',\n          '#4CAF50',\n          '#FF5722',\n          '#CDDC39',\n          '#FFC107',\n          '#00E5FF',\n          '#E040FB',\n          '#607D8B'\n        ]\n\n        var c = _.object(\n          _.map(arr, function (v) {\n            return v[0]\n          }),\n          _.shuffle(colors)\n        )\n\n        c3.generate({\n          bindto: d3.select('#topTenTags'),\n          size: {\n            height: 200\n          },\n          data: {\n            columns: arr,\n            type: 'donut',\n            colors: c,\n            empty: { label: { text: 'No Data Available' } }\n          },\n          donut: {\n            label: {\n              format: function () {\n                return ''\n              }\n            }\n          }\n        })\n      }\n    })\n\n    $.ajax({\n      url: '/api/v1/tickets/count/topgroups/' + timespan + '/5',\n      method: 'GET',\n      success: function (data) {\n        var arr = _.map(data.items, function (v) {\n          return [v.name, v.count]\n        })\n\n        var colors = [\n          '#e74c3c',\n          '#3498db',\n          '#9b59b6',\n          '#34495e',\n          '#1abc9c',\n          '#2ecc71',\n          '#03A9F4',\n          '#00BCD4',\n          '#009688',\n          '#4CAF50',\n          '#FF5722',\n          '#CDDC39',\n          '#FFC107',\n          '#00E5FF',\n          '#E040FB',\n          '#607D8B'\n        ]\n\n        colors = _.shuffle(colors)\n\n        var c = _.object(\n          _.map(arr, function (v) {\n            return v[0]\n          }),\n          colors\n        )\n\n        c3.generate({\n          bindto: d3.select('#pieChart'),\n          size: {\n            height: 200\n          },\n          data: {\n            columns: arr,\n            type: 'pie',\n            colors: c,\n            empty: { label: { text: 'No Data Available' } }\n          },\n          donut: {\n            label: {\n              format: function () {\n                return ''\n              }\n            }\n          }\n        })\n      }\n    })\n  }\n\n  reportsPage.init = function (callback) {\n    $(document).ready(function () {\n      var testPage = $('#page-content').find('.reportsOverview')\n      if (testPage.length < 1) {\n        if (typeof callback === 'function') {\n          return callback()\n        }\n      } else {\n        helpers.resizeAll()\n\n        getData(30)\n\n        $('#select_timespan').on('change', function () {\n          var self = $(this)\n          getData(self.val())\n        })\n\n        if (typeof callback === 'function') {\n          return callback()\n        }\n      }\n    })\n  }\n\n  return reportsPage\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n\n//# sourceURL=webpack:///./src/public/js/pages/reports.js?");

/***/ }),

/***/ "./src/public/js/pages/reportsBreakdown.js":
/*!*************************************************!*\
  !*** ./src/public/js/pages/reportsBreakdown.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n *       .                             .o8                     oooo\n *    .o8                             \"888                     `888\n *  .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n *    888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n *    888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n *    888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n *    \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n *  ========================================================================\n *  Author:     Chris Brame\n *  Updated:    1/20/19 4:43 PM\n *  Copyright (c) 2014-2019. All rights reserved.\n */\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n  __webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\"),\n  __webpack_require__(/*! underscore */ \"./src/public/js/vendor/underscore/underscore.js\"),\n  __webpack_require__(/*! modules/helpers */ \"./src/public/js/modules/helpers.js\"),\n  __webpack_require__(/*! countup */ \"./src/public/js/vendor/countup/countUp.min.js\"),\n  __webpack_require__(/*! c3 */ \"./src/public/js/vendor/c3/c3.js\"),\n  __webpack_require__(/*! d3pie */ \"./src/public/js/vendor/d3pie/d3pie.min.js\"),\n  __webpack_require__(/*! moment */ \"./src/public/js/vendor/moment/moment.js\"),\n  __webpack_require__(/*! metricsgraphics */ \"./src/public/js/vendor/metricsgraphics/metricsgraphics.min.js\"),\n  __webpack_require__(/*! peity */ \"./src/public/js/vendor/peity/jquery.peity.min.js\"),\n  __webpack_require__(/*! history */ \"./src/public/js/vendor/history/jquery.history.js\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($, _, helpers, CountUp, c3, d3pie, moment) {\n  var reportsBreakdownPage = {}\n\n  reportsBreakdownPage.init = function (callback) {\n    $(document).ready(function () {\n      var testPage = $('#page-content').find('.reportsBreakdownGroup')\n      if (testPage.length < 1) {\n        testPage = $('#page-content').find('.reportsBreakdownUser')\n        if (testPage.length < 1) {\n          if (typeof callback === 'function') {\n            return callback()\n          }\n\n          return true\n        }\n      }\n\n      helpers.resizeAll()\n\n      var parms = {\n        full_width: true,\n        height: 250,\n        target: '#test',\n        x_accessor: 'date',\n        y_accessor: 'value',\n        y_extended_ticks: true,\n        show_tooltips: false,\n        aggregate_rollover: true,\n        transition_on_update: false,\n        colors: ['green', 'red']\n      }\n\n      $('#select_group').on('change', function () {\n        var self = $(this)\n        getData('/api/v1/tickets/stats/group/' + self.val())\n      })\n\n      $('#select_user').on('change', function () {\n        var self = $(this)\n\n        getData('/api/v1/tickets/stats/user/' + self.val())\n      })\n\n      function getData (url) {\n        $.ajax({\n          url: url,\n          method: 'GET',\n          success: function (_data) {\n            if (_data.data.graphData) {\n              parms.data = MG.convert.date(_data.data.graphData, 'date')\n              MG.data_graphic(parms)\n            }\n\n            var tCount = _data.data.ticketCount\n            var ticketCount = $('#ticketCount')\n            var oldTicketCount = ticketCount.text() === '--' ? 0 : ticketCount.text()\n            var totalTicketText = 'Total Tickets (lifetime)'\n            ticketCount\n              .parents('.tru-card-content')\n              .find('span.uk-text-small')\n              .text(totalTicketText)\n            var theAnimation = new CountUp('ticketCount', parseInt(oldTicketCount), tCount, 0, 1.5)\n            theAnimation.start()\n\n            var closedCount = Number(_data.data.closedCount)\n            var closedPercent = Math.round((closedCount / tCount) * 100)\n\n            var textComplete = $('#text_complete')\n            var oldTextComplete = textComplete.text() === '--' ? 0 : textComplete.text()\n            var completeAnimation = new CountUp('text_complete', parseInt(oldTextComplete), closedPercent, 0, 1.5)\n            completeAnimation.start()\n\n            var pieComplete = $('#pie_complete')\n            pieComplete.text(closedPercent + '/100')\n            pieComplete.peity('donut', {\n              height: 24,\n              width: 24,\n              fill: ['#29b955', '#ccc']\n            })\n\n            var responseTimeText = $('#responseTime_text')\n            // var responseTime_graph = $('#responseTime_graph');\n            var oldResponseTime = responseTimeText.text() === '--' ? 0 : responseTimeText.text()\n            var responseTime = _data.data.avgResponse\n            var responseTimeAnimation = new CountUp(\n              'responseTime_text',\n              parseInt(oldResponseTime),\n              responseTime,\n              0,\n              1.5\n            )\n            responseTimeAnimation.start()\n\n            var recentTicketsBody = $('tbody.recent-tickets')\n            recentTicketsBody.html('')\n            var html = ''\n            var sortedTickets = _.sortBy(_data.data.recentTickets, 'uid').reverse()\n            _.each(sortedTickets, function (ticket) {\n              var status = ''\n              switch (ticket.status) {\n                case 0:\n                  status = 'new'\n                  break\n                case 1:\n                  status = 'open'\n                  break\n                case 2:\n                  status = 'pending'\n                  break\n                case 3:\n                  status = 'closed'\n                  break\n              }\n              html += '<tr class=\"uk-table-middle\">'\n              html +=\n                '<td class=\"uk-width-1-10 uk-text-nowrap\"><a href=\"/tickets/' +\n                ticket.uid +\n                '\">T#' +\n                ticket.uid +\n                '</a></td>'\n              html +=\n                '<td class=\"uk-width-1-10 uk-text-nowrap\"><span class=\"uk-badge ticket-status-' +\n                status +\n                ' uk-width-1-1\">' +\n                status +\n                '</span></td>'\n              html += '<td class=\"uk-width-6-10\">'\n              html += ticket.subject\n              html += '</td>'\n              html += '<td class=\"uk-width-2-10 uk-text-right uk-text-muted uk-text-small\">'\n              html += moment\n                .utc(ticket.updated)\n                .tz(helpers.getTimezone())\n                .format(helpers.getShortDateFormat())\n              html += '</td>'\n              html += '</tr>'\n            })\n\n            recentTicketsBody.append(html)\n\n            var arr = _.map(_data.data.tags, function (v, key) {\n              return [key, v]\n            })\n\n            var colors = [\n              '#e53935',\n              '#d81b60',\n              '#8e24aa',\n              '#1e88e5',\n              '#00897b',\n              '#43a047',\n              '#00acc1',\n              '#e65100',\n              '#6d4c41',\n              '#455a64'\n            ]\n\n            var c = _.object(\n              _.map(arr, function (v) {\n                return v[0]\n              }),\n              colors\n            )\n\n            c3.generate({\n              bindto: d3.select('#topTags'),\n              size: {\n                height: 200\n              },\n              data: {\n                columns: arr,\n                type: 'donut',\n                colors: c\n              },\n              donut: {\n                label: {\n                  format: function () {\n                    return ''\n                  }\n                }\n              }\n            })\n\n            helpers.UI.matchHeight()\n          }\n        }).error(function (err) {\n          // console.log(err);\n          console.log('[trudesk:reportsBreakdownGroup:getData] Error - ' + err.responseText)\n          helpers.UI.showSnackbar(JSON.parse(err.responseText).error, true)\n        })\n      }\n\n      if (typeof callback === 'function') {\n        return callback()\n      }\n    })\n  }\n\n  return reportsBreakdownPage\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n\n//# sourceURL=webpack:///./src/public/js/pages/reportsBreakdown.js?");

/***/ }),

/***/ "./src/public/js/plugins/jquery.actual.js":
/*!************************************************!*\
  !*** ./src/public/js/plugins/jquery.actual.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Copyright 2012, Ben Lin (http://dreamerslab.com/)\n * Licensed under the MIT License (LICENSE.txt).\n *\n * Version: 1.0.19\n *\n * Requires: jQuery >= 1.2.3\n */\n;(function (factory) {\n  if (true) {\n    // AMD. Register module depending on jQuery using requirejs define.\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(function ($) {\n  $.fn.addBack = $.fn.addBack || $.fn.andSelf\n\n  $.fn.extend({\n    actual: function (method, options) {\n      // check if the jQuery method exist\n      if (!this[method]) {\n        throw '$.actual => The jQuery method \"' + method + '\" you called does not exist'\n      }\n\n      var defaults = {\n        absolute: false,\n        clone: false,\n        includeMargin: false,\n        display: 'block'\n      }\n\n      var configs = $.extend(defaults, options)\n\n      var $target = this.eq(0)\n      var fix, restore\n\n      if (configs.clone === true) {\n        fix = function () {\n          var style = 'position: absolute !important; top: -1000 !important; '\n\n          // this is useful with css3pie\n          $target = $target\n            .clone()\n            .attr('style', style)\n            .appendTo('body')\n        }\n\n        restore = function () {\n          // remove DOM element after getting the width\n          $target.remove()\n        }\n      } else {\n        var tmp = []\n        var style = ''\n        var $hidden\n\n        fix = function () {\n          // get all hidden parents\n          $hidden = $target\n            .parents()\n            .addBack()\n            .filter(':hidden')\n          style += 'visibility: hidden !important; display: ' + configs.display + ' !important; '\n\n          if (configs.absolute === true) style += 'position: absolute !important; '\n\n          // save the origin style props\n          // set the hidden el css to be got the actual value later\n          $hidden.each(function () {\n            // Save original style. If no style was set, attr() returns undefined\n            var $this = $(this)\n            var thisStyle = $this.attr('style')\n\n            tmp.push(thisStyle)\n            // Retain as much of the original style as possible, if there is one\n            $this.attr('style', thisStyle ? thisStyle + ';' + style : style)\n          })\n        }\n\n        restore = function () {\n          // restore origin style values\n          $hidden.each(function (i) {\n            var $this = $(this)\n            var _tmp = tmp[i]\n\n            if (_tmp === undefined) {\n              $this.removeAttr('style')\n            } else {\n              $this.attr('style', _tmp)\n            }\n          })\n        }\n      }\n\n      fix()\n      // get the actual value with user specific methed\n      // it can be 'width', 'height', 'outerWidth', 'innerWidth'... etc\n      // configs.includeMargin only works for 'outerWidth' and 'outerHeight'\n      var actual = /(outer)/.test(method) ? $target[method](configs.includeMargin) : $target[method]()\n\n      restore()\n      // IMPORTANT, this plugin only return the value of the first element\n      return actual\n    }\n  })\n})\n\n\n//# sourceURL=webpack:///./src/public/js/plugins/jquery.actual.js?");

/***/ }),

/***/ "./src/public/js/plugins/jquery.documentsize.js":
/*!******************************************************!*\
  !*** ./src/public/js/plugins/jquery.documentsize.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function($) {// jQuery.documentSize, v1.2.3\n// Copyright (c) 2015-2016 Michael Heim, Zeilenwechsel.de\n// Distributed under MIT license\n// http://github.com/hashchange/jquery.documentsize\n\n;(function (root, factory) {\n  'use strict'\n\n  if (true) {\n    module.exports = factory(__webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\"))\n  } else {}\n})(this, function (jQuery) {\n  'use strict'\n  ;(function ($) {\n    'use strict'\n\n    // IIFE generating the functions $.documentWidth, $.documentHeight, $.windowWidth, $.windowHeight, and\n    // $.scrollbarWidth.\n    //\n    // These functions need to run feature detections which requires insertion of an iframe ($.documentWidth/Height) and\n    // a div ($.scrollbarWidth). The body element in the main document must be available when that happens (ie, the\n    // opening body tag must have been parsed).\n    //\n    // For that reason, the detection does not run instantly - after all, the code might be loaded and run while parsing\n    // the head. Instead, detection happens on DOM-ready, or when any of the functions is invoked for the first time.\n    // Given the purpose of the functions, they won't be called until after the opening body tag has been parsed.\n\n    var _scrollbarWidth,\n      _supportsWindowInnerWidth,\n      _supportsSubpixelAccuracy,\n      elementNameForDocSizeQuery,\n      ieVersion,\n      useGetComputedStyle = !!window.getComputedStyle\n\n    /**\n     * @param   {Document} [_document=document]\n     * @returns {number}\n     */\n    $.documentWidth = function (_document) {\n      var width\n\n      _document || (_document = document)\n\n      try {\n        if (elementNameForDocSizeQuery === undefined) testDocumentScroll()\n        width = _document[elementNameForDocSizeQuery].scrollWidth\n      } catch (e) {\n        // Fallback for unsupported, broken browsers which can't run the behaviour test successfully\n        width = guessDocumentSize('Width', _document)\n      }\n\n      return width\n    }\n\n    /**\n     * @param   {Document} [_document=document]\n     * @returns {number}\n     */\n    $.documentHeight = function (_document) {\n      var height\n\n      _document || (_document = document)\n\n      try {\n        if (elementNameForDocSizeQuery === undefined) testDocumentScroll()\n        height = _document[elementNameForDocSizeQuery].scrollHeight\n      } catch (e) {\n        // Fallback for unsupported, broken browsers which can't run the behaviour test successfully\n        height = guessDocumentSize('Height', _document)\n      }\n\n      return height\n    }\n\n    /**\n     * @param   {string|Object|Window} [options=\"visual\"]  (a) viewport option: strings \"visual\", \"layout\" (case-\n     *                                                         insensitive), or a hash with a `viewport` property\n     *                                                     (b) the window argument\n     * @param   {string|Object|Window} [_window=window]    same as first argument; positions for window and viewport\n     *                                                     argument are interchangeable\n     * @returns {number}\n     */\n    $.windowWidth = function (options, _window) {\n      var config = getWindowQueryConfig(arguments)\n      return getWindowSize('Width', config)\n    }\n\n    /**\n     * @param   {string|Object|Window} [options=\"visual\"]  (a) viewport option: strings \"visual\", \"layout\" (case-\n     *                                                         insensitive), or a hash with a `viewport` property\n     *                                                     (b) the window argument\n     * @param   {string|Object|Window} [_window=window]    same as first argument; positions for window and viewport\n     *                                                     argument are interchangeable\n     * @returns {number}\n     */\n    $.windowHeight = function (options, _window) {\n      var config = getWindowQueryConfig(arguments)\n      return getWindowSize('Height', config)\n    }\n\n    /**\n     * @param   {Window} [_window=window]\n     * @returns {number}\n     */\n    $.pinchZoomFactor = function (_window) {\n      // Calculate the zoom factor based on the width, not the height. getPinchZoomFactor() does just that.\n      //\n      // It would be more accurate to use the longest side for the calculation, keeping the effect of rounding errors\n      // low (unless the browser supports sub-pixel accuracy anyway).\n      //\n      // Unfortunately, iOS does not allow that approach. Switching from normal to minimal UI is not reflected in the\n      // clientHeight, so the zoom factor would seem to change when the UI disappears (even though in reality, it\n      // doesn't). We have to use the width, irrespective of orientation.\n\n      return getPinchZoomFactor(_window)\n    }\n\n    /**\n     * @returns {number}\n     */\n    $.scrollbarWidth = browserScrollbarWidth\n\n    /**\n     * Returns the window width or height. Does the actual work of $.windowWidth() and $.windowHeight().\n     *\n     * Handles minimal UI in iOS properly. Returns the size of either the visual viewport (default) or the layout\n     * viewport.\n     *\n     * Precision:\n     *\n     * - The maximum rounding error for the visual viewport is +/- 1px.\n     * - Layout viewport width is precise.\n     * - Layout viewport height would potentially be prone to larger rounding errors (though in practice they rarely\n     *   seem to exceed +/- 2px). Additional logic is employed to detect and correct these errors. As a result, the\n     *   layout viewport height is precise as well.\n     *\n     * @param   {string}            dimension  must be \"Width\" or \"Height\" (upper case!)\n     * @param   {WindowQueryConfig} config\n     * @returns {number}\n     */\n    function getWindowSize (dimension, config) {\n      var ddeClientHeight,\n        visualSize,\n        zoomFactor,\n        snapToKnownHeight,\n        lBound,\n        uBound,\n        _window = config.window,\n        scrollbarsConsumeSpace = browserScrollbarWidth() !== 0,\n        getLayoutViewportWidth = config.useLayoutViewport && dimension === 'Width',\n        useClientSize = scrollbarsConsumeSpace || !supportsWindowInnerWidth() || getLayoutViewportWidth,\n        size = useClientSize\n          ? _window.document.documentElement['client' + dimension]\n          : getWindowInnerSize(dimension, _window)\n\n      if (config.useLayoutViewport && !useClientSize) {\n        // Looking for the layout viewport height on mobile. Calculate it from window.innerHeight and the zoom\n        // factor, so as to capture the real height when the browser is in minimal UI on iOS.\n        //\n        // NB The layout viewport has a size in full CSS pixels (unaffected by zooming, hence no sub pixels).\n\n        visualSize = size\n        zoomFactor = getPinchZoomFactor(_window, { asRange: true })\n\n        size = Math.round(visualSize * zoomFactor.calculated)\n\n        // Fix rounding errors, caused by the visual height ignoring sub-pixel fractions. If we know we are near a\n        // known layout viewport height, use that.\n        if (!supportsSubpixelAccuracy()) {\n          ddeClientHeight = _window.document.documentElement.clientHeight\n\n          // In Android, the height we get from ddE.clientHeight and the one calculated from window.innerHeight\n          // should be the same, except for rounding errors in the calculation. So basically, we could just set\n          // any calculated value to the clientHeight, no matter how large the difference is. (That is, if we even\n          // end up here - in some versions of Chrome on Android, for instance, we have sub-pixel accuracy.)\n          //\n          // Not so in iOS. In minimal UI, the real layout viewport may be larger than the one reported by\n          // clientHeight, by about 60px. So we need to impose reasonable limits on what is considered to be near\n          // the clientHeight.\n          //\n          // - If the calculated value is within 3px of the clientHeight, we consider it to be a clear case of a\n          //   rounding error.\n          // - Alternatively, the clientHeight must be between the theoretical maximum and minimum values of the\n          //   computation, assuming maximum rounding errors at every stage.\n          // - If we use that range, its upper bound is capped at 30px above the clientHeight - keeping a safe\n          //   distance from current minimal UI heights, or possible future ones.\n\n          lBound = (visualSize - 1) * zoomFactor.min\n          uBound = (visualSize + 1) * zoomFactor.max\n\n          snapToKnownHeight =\n            (size <= ddeClientHeight + 3 && size >= ddeClientHeight - 3) ||\n            (lBound <= ddeClientHeight && uBound >= ddeClientHeight && uBound < ddeClientHeight + 30)\n\n          if (snapToKnownHeight) size = ddeClientHeight\n        }\n      }\n\n      return size\n    }\n\n    /**\n     * Calculates the zoom factor for pinch zooming on mobile. A factor > 1 means that the page is zoomed in (content\n     * enlarged).\n     *\n     * The zoom factor returned here measures the size of the visual viewport with respect to the size of the layout\n     * viewport. Note that browsers usually calculate their zoom level with respect to the ideal viewport, not the\n     * layout viewport (see Peter-Paul Koch, The Mobile Web Handbook, Chapter 3: Viewports, Section \"Minimum and Maximum\n     * Zoom\").\n     *\n     * Ignores page zoom on the desktop (returning a zoom factor of 1). For the distinction between pinch and page zoom,\n     * again see Chapter 3 in PPK's book.\n     *\n     * @param   {Window}  [_window=window]\n     * @param   {Object}  [options]\n     * @param   {boolean} [options.asRange=false]\n     * @returns {number|ZoomAccuracyRange}\n     */\n    function getPinchZoomFactor (_window, options) {\n      var ddeClientWidth,\n        windowInnerWidth,\n        asRange = options && options.asRange,\n        factors = {\n          calculated: 1,\n          min: 1,\n          max: 1\n        },\n        skip = browserScrollbarWidth() !== 0 || !supportsWindowInnerWidth()\n\n      if (!skip) {\n        _window || (_window = window)\n        ddeClientWidth = _window.document.documentElement.clientWidth\n        windowInnerWidth = getWindowInnerWidth(_window)\n\n        // Calculate the zoom factor, assuming window.innerWidth is precise (no rounding errors).\n        factors.calculated = ddeClientWidth / windowInnerWidth\n\n        // If requested, determine the minimum and maximum value of the zoom factor in the presence of rounding errors.\n        if (asRange) {\n          if (supportsSubpixelAccuracy()) {\n            // No need to take rounding errors into account\n            factors.min = factors.max = factors.calculated\n          } else {\n            factors.min = ddeClientWidth / (windowInnerWidth + 1)\n            factors.max = ddeClientWidth / (windowInnerWidth - 1)\n          }\n        }\n      }\n\n      return asRange ? factors : factors.calculated\n    }\n\n    /**\n     * Handles the argument juggling for $.windowWidth() and $.windowHeight(). Extracts the window and viewport settings\n     * from the arguments, applying the defaults (use global window, use visual viewport) where necessary.\n     *\n     * Examines the first two arguments. The window and the viewport setting can appear in either position,\n     * interchangeably. The viewport setting can be passed in as a string, or as part of an options hash,\n     * `{ viewport: ... }`.\n     *\n     * Recognized viewport names are \"visual\" and \"layout\" (case-insensitive).\n     *\n     * @param   {Array|Arguments} args\n     * @returns {WindowQueryConfig}\n     */\n    function getWindowQueryConfig (args) {\n      var isWindowArg0,\n        isOptionArg0,\n        isOptionArg1,\n        // Defaults\n        _window = window,\n        _useVisualViewport = true\n\n      if (args && args.length) {\n        // Coerce to a real array\n        args = Array.prototype.slice.call(args)\n\n        // Examine the first argument. Cast strings to an options hash with a `viewport` property.\n        isWindowArg0 = isWindow(args[0])\n        if (!isWindowArg0) args[0] = castStringToViewportOption(args[0])\n        isOptionArg0 = !isWindowArg0 && args[0]\n\n        // Examine the second argument. Again, cast strings to an options hash with a `viewport` property.\n        if (!isOptionArg0) args[1] = castStringToViewportOption(args[1])\n        isOptionArg1 = !isOptionArg0 && args[1]\n\n        // Extract window and viewport option, if available.\n        if (isWindowArg0) {\n          _window = args[0]\n          if (isOptionArg1 && args[1].viewport) _useVisualViewport = isVisualViewport(args[1].viewport)\n        } else if (isOptionArg0) {\n          if (args[0].viewport) _useVisualViewport = isVisualViewport(args[0].viewport)\n          if (isWindow(args[1])) _window = args[1]\n        } else if (!args[0] && args[1]) {\n          // First argument was falsy, e.g. undefined, null. Ignore it. But process the second, non-falsy argument.\n          if (isOptionArg1 && args[1].viewport) {\n            _useVisualViewport = isVisualViewport(args[1].viewport)\n          } else if (isWindow(args[1])) {\n            _window = args[1]\n          }\n        }\n      }\n\n      return {\n        window: _window,\n        useVisualViewport: _useVisualViewport,\n        useLayoutViewport: !_useVisualViewport\n      }\n    }\n\n    /**\n     * Checks if the argument is the name of the visual viewport. The check is case-insensitive.\n     *\n     * Expects a string. Tolerates falsy values, returning false then (argument is not naming the visual viewport).\n     * Throws an error for everything else. Also throws an error if the viewport name is a string but not recognized\n     * (typo alert).\n     *\n     * Helper for getWindowQueryConfig().\n     *\n     * @param   {string} [name]  strings \"visual\", \"layout\" (case-insensitive)\n     * @returns {boolean}\n     */\n    function isVisualViewport (name) {\n      var viewport = isString(name) && name.toLowerCase()\n\n      if (name && !viewport) throw new Error('Invalid viewport option: ' + name)\n      if (viewport && viewport !== 'visual' && viewport !== 'layout') throw new Error('Invalid viewport name: ' + name)\n\n      return viewport === 'visual'\n    }\n\n    /**\n     * Examines a value and casts a string to a hash with a `viewport` property (the string being its value). If the\n     * value is not a string, or if the string is empty, it is returned as-is. Helper for getWindowQueryConfig().\n     *\n     * @param   {*} arg\n     * @returns {*}\n     */\n    function castStringToViewportOption (arg) {\n      return isString(arg) && arg !== '' ? { viewport: arg } : arg\n    }\n\n    /**\n     * Checks if the browser supports window.innerWidth and window.innerHeight.\n     *\n     * The check is run on demand, rather than up front while loading the component, because the window properties can\n     * behave strangely in the early stages of opening a window. The component might be loaded in the document head,\n     * which could potentially be early enough to run into these oddities. So we wait until the first call.\n     *\n     * IE 8 does not support window.innerWidth and .innerHeight. FF has a bug which as only been fixed in FF25 (released\n     * 29 Oct 2013). It manifests itself in a fictional return value of 10 for these properties. See\n     *\n     * - https://developer.mozilla.org/en-US/docs/Web/API/Window.innerWidth\n     * - https://developer.mozilla.org/en-US/docs/Web/API/Window.innerHeight\n     * - https://bugzilla.mozilla.org/show_bug.cgi?id=641188\n     *\n     * @returns {boolean}\n     */\n    function supportsWindowInnerWidth () {\n      if (_supportsWindowInnerWidth === undefined) _supportsWindowInnerWidth = getWindowInnerWidth() > 10\n      return _supportsWindowInnerWidth\n    }\n\n    /**\n     * Does the actual work of $.scrollbarWidth. Protected from external modification. See $.scrollbarWidth for details.\n     *\n     * Adapted from Ben Alman's scrollbarWidth plugin. See\n     * - http://benalman.com/projects/jquery-misc-plugins/#scrollbarwidth\n     * - http://jsbin.com/zeliy/1\n     *\n     * @returns {number}\n     */\n    function browserScrollbarWidth () {\n      var testEl\n\n      if (_scrollbarWidth === undefined) {\n        testEl = document.createElement('div')\n        testEl.style.cssText =\n          'width: 100px; height: 100px; overflow: scroll; position: absolute; top: -500px; left: -500px; margin: 0px; padding: 0px; border: none;'\n\n        document.body.appendChild(testEl)\n        _scrollbarWidth = testEl.offsetWidth - testEl.clientWidth\n        document.body.removeChild(testEl)\n      }\n\n      return _scrollbarWidth\n    }\n\n    /**\n     * Detects which element to use for a document size query (body or documentElement).\n     *\n     * Sandbox\n     * -------\n     *\n     * The detection is sandboxed in an iframe element created for the purpose. If the iframe window can't be\n     * accessed because of some obscure policy restriction or browser bug, the main window and document is used\n     * as a fallback.\n     *\n     * The test is designed to minimize the visual and rendering impact in the test window, in case the fallback\n     * should ever be used.\n     *\n     * Test method\n     * -----------\n     *\n     * We can't test directly which call to use (at least not with an even worse amount of intervention than is\n     * already the case, which matters if the iframe is not accessible). But we can work by exclusion.\n     *\n     * In Chrome (desktop and mobile), Safari (also iOS), and Opera, body.scrollWidth returns the true document\n     * width. In Firefox and IE, body.scrollWidth responds to the body content size instead. In those browsers,\n     * true document width is returned by document.documentElement.scrollWidth.\n     *\n     * So we test the behaviour of body.scrollWidth by manipulating the body size, while keeping the document size\n     * constant.\n     *\n     * - We prepare for the test by making sure the body does not display its overflow.\n     * - Then we inject a small test element into the body and give it a relative position far outside the viewport.\n     *\n     * The body size is expanded, but the document size remains unaffected because the body hides the overflowing\n     * test element (either outright, or by putting it in a hidden part of the scroll pane). Then we check if\n     * body.scrollWidth has responded to the change. From that, we infer the right element to use for a document\n     * width query.\n     *\n     * The function does not return anything. It sets the elementNameForDocSizeQuery in the closure instead.\n     */\n    function testDocumentScroll () {\n      var initialDocumentState,\n        _testEl,\n        initialScrollWidth,\n        responds,\n        iframe = createTestIframe(),\n        _document = (iframe && iframe.contentDocument) || document,\n        _body = _document.body,\n        inIframe = _document !== document\n\n      // Create a test element which will be used to to expand the body content way to the right.\n      _testEl = _document.createElement('div')\n      _testEl.style.cssText = 'width: 1px; height: 1px; position: relative; top: 0px; left: 32000px;'\n\n      // Make sure that the body (but not the window) hides its overflow. Only applies if the iframe is not\n      // accessible. The iframe document already contains the required styles.\n      if (!inIframe) initialDocumentState = prepareGlobalDocument()\n\n      // Inject the test element, then test if the body.scrollWidth property responds\n      initialScrollWidth = _body.scrollWidth\n      _body.appendChild(_testEl)\n      responds = initialScrollWidth !== _body.scrollWidth\n      _body.removeChild(_testEl)\n\n      // Restore the overflow settings for window and body\n      if (!inIframe) restoreGlobalDocument(initialDocumentState)\n\n      // If body.scrollWidth responded, it reacts to body content size, not document size. Default to\n      // ddE.scrollWidth. If it did not react, however, it is linked to the (unchanged) document size.\n      elementNameForDocSizeQuery = responds ? 'documentElement' : 'body'\n\n      if (iframe) document.body.removeChild(iframe)\n    }\n\n    /**\n     * Creates an iframe document with an HTML5 doctype and UTF-8 encoding and positions it off screen. Window size\n     * is 500px x 500px. Body and window (document element) are set to overflow: hidden.\n     *\n     * In case the content document of the iframe can't be accessed for some reason, the function returns undefined.\n     * This is unlikely to ever happen, though.\n     *\n     * @returns {HTMLIFrameElement|undefined}\n     */\n    function createTestIframe () {\n      var iframe = document.createElement('iframe'),\n        body = document.body\n\n      iframe.style.cssText =\n        'position: absolute; top: -600px; left: -600px; width: 500px; height: 500px; margin: 0px; padding: 0px; border: none; display: block;'\n      iframe.frameborder = '0'\n\n      body.appendChild(iframe)\n      iframe.src = 'about:blank'\n\n      if (!iframe.contentDocument) return\n\n      iframe.contentDocument.write(\n        '<!DOCTYPE html><html><head><meta charset=\"UTF-8\"><title></title><style type=\"text/css\">html, body { overflow: hidden; }</style></head><body></body></html>'\n      )\n\n      return iframe\n    }\n\n    /**\n     * Makes sure the body (but not the window) hides its overflow. Works with the global document, returns the initial\n     * state before manipulation (including properties indicating what has been modified).\n     *\n     * Used only if iframe creation or access has failed for some reason.\n     */\n    function prepareGlobalDocument () {\n      var ddEStyle,\n        bodyStyle,\n        ddE = document.documentElement,\n        body = document.body,\n        ddEComputedStyles = useGetComputedStyle ? window.getComputedStyle(ddE, null) : ddE.currentStyle,\n        bodyComputedStyles = useGetComputedStyle ? window.getComputedStyle(body, null) : body.currentStyle,\n        ddEOverflowX = (ddEComputedStyles.overflowX || ddEComputedStyles.overflow || 'visible').toLowerCase(),\n        bodyOverflowX = (bodyComputedStyles.overflowX || bodyComputedStyles.overflow || 'visible').toLowerCase(),\n        modifyBody = bodyOverflowX !== 'hidden',\n        modifyDocumentElement = ddEOverflowX === 'visible',\n        initialState = {\n          documentElement: {\n            modified: modifyDocumentElement\n          },\n          body: {\n            modified: modifyBody\n          }\n        }\n\n      if (modifyDocumentElement) {\n        ddEStyle = ddE.style\n        initialState.documentElement.styleOverflowX = ddEStyle.overflowX\n        ddEStyle.overflowX = 'auto'\n      }\n\n      if (modifyBody) {\n        bodyStyle = body.style\n        initialState.body.styleOverflowX = bodyStyle.overflowX\n        bodyStyle.overflowX = 'hidden'\n      }\n\n      return initialState\n    }\n\n    /**\n     * Restores the body and documentElement styles to their initial state, which is passed in as an argument. Works\n     * with the global document.\n     *\n     * Used only if iframe creation or access has failed for some reason.\n     *\n     * @param {Object} previousState  the initial state, as returned by prepareGlobalDocument()\n     */\n    function restoreGlobalDocument (previousState) {\n      if (previousState.documentElement.modified)\n        document.documentElement.style.overflowX = previousState.documentElement.styleOverflowX\n      if (previousState.body.modified) document.body.style.overflowX = previousState.body.styleOverflowX\n    }\n\n    /**\n     * Returns a best guess for the window width or height. Used as a fallback for unsupported browsers which are too\n     * broken to even run the feature test.\n     *\n     * The conventional jQuery method of guessing the document size is used here: every conceivable value is queried and\n     * the largest one is picked.\n     *\n     * @param {string}   dimension    accepted values are \"Width\" or \"Height\" (capitalized first letter!)\n     * @param {Document} [_document]\n     */\n    function guessDocumentSize (dimension, _document) {\n      var ddE = _document.documentElement\n\n      return Math.max(\n        ddE.body['scroll' + dimension],\n        _document['scroll' + dimension],\n        ddE.body['offset' + dimension],\n        _document['offset' + dimension],\n        _document['client' + dimension]\n      )\n    }\n\n    /**\n     * Returns window.innerWidth.\n     *\n     * Along the way, the return value is examined to see if the browser supports sub-pixel accuracy (floating-point\n     * values).\n     *\n     * @param   {Window} [_window=window]\n     * @returns {number}\n     */\n    function getWindowInnerWidth (_window) {\n      return getWindowInnerSize('Width', _window)\n    }\n\n    /**\n     * Returns window.innerHeight.\n     *\n     * Along the way, the return value is examined to see if the browser supports sub-pixel accuracy (floating-point\n     * values).\n     *\n     * @param   {Window} [_window=window]\n     * @returns {number}\n     */\n    function getWindowInnerHeight (_window) {\n      return getWindowInnerSize('Height', _window)\n    }\n\n    /**\n     * Returns window.innerWidth or window.innerHeight, depending on the dimension argument.\n     *\n     * Along the way, the return value is examined to see if the browser supports sub-pixel accuracy (floating-point\n     * values).\n     *\n     * @param   {string} dimension  must be \"Width\" or \"Height\" (upper case!)\n     * @param   {Window} [_window=window]\n     * @returns {number}\n     */\n    function getWindowInnerSize (dimension, _window) {\n      var size = (_window || window)['inner' + dimension]\n\n      // Check for fractions. Exclude undefined return values in browsers which don't support window.innerWidth/Height.\n      if (size) checkForFractions(size)\n      return size\n    }\n\n    /**\n     * Accepts an observed value of window.innerWidth or window.innerHeight and examines it for fractional values.\n     * Caches the finding if there is one. Helper for getWindowInnerWidth() and friends.\n     *\n     * See supportsSubpixelAccuracy() for more.\n     *\n     * @param {number} sizeMeasurement\n     */\n    function checkForFractions (sizeMeasurement) {\n      // When checking the cached value, we can't accept false as a definitive answer. We have to continue checking\n      // unless the cached value is `true`.\n      //\n      // See supportsSubpixelAccuracy().\n      if (!_supportsSubpixelAccuracy && isFloat(sizeMeasurement)) _supportsSubpixelAccuracy = true\n    }\n\n    /**\n     * Returns whether or not the browser supports sub-pixel accuracy (floating-point values) for window.innerWidth and\n     * window.innerHeight - as far as we know yet.\n     *\n     * The browser behaviour can't be tested directly, and must be figured out by continuous observation. We have to\n     * monitor the return values of window.innerWidth/Height for fractions. That is done with getWindowInnerWidth etc.\n     * As soon as we find a fraction, we know that the browser supports floating-point accuracy.\n     *\n     * However, we can never be sure of the opposite. If we haven't encountered a fraction yet, it could simply mean\n     * that we are at 100% zoom, and integers have indeed been the correct return value so far.\n     *\n     * So when the method here answers with true, it is definitive. When it returns false, that just means \"maybe not,\n     * but we don't know\". And the the return value might flip to true in a future query.\n     *\n     * @returns {boolean}\n     */\n    function supportsSubpixelAccuracy () {\n      return !!_supportsSubpixelAccuracy\n    }\n\n    function isWindow (value) {\n      // Identical to jQuery.isWindow()\n      return value != null && value.window == value // jshint ignore:line\n    }\n\n    function isString (value) {\n      // Done as in the Lodash compatibility build\n      return (\n        typeof value === 'string' ||\n        (value && typeof value === 'object' && Object.prototype.toString.call(value) === '[object String]') ||\n        false\n      )\n    }\n\n    /**\n     * Returns whether or not a value is of type number. Also rejects NaN as a number.\n     *\n     * NB This is not the same as $.isNumeric because $.isNumeric( \"3\" ) is true while isNumber( \"3\" ) is false.\n     *\n     * @param   {*} value\n     * @returns {boolean}\n     */\n    function isNumber (value) {\n      // Done as in the Lodash compatibility build, but rejecting NaN as a number.\n      var isNumeric =\n        typeof value === 'number' ||\n        (value && typeof value === 'object' && Object.prototype.toString.call(value) === '[object Number]') ||\n        false\n\n      // Reject NaN before returning\n      return isNumeric && value === +value\n    }\n\n    /**\n     * Returns whether or not a number is a float, ie has decimals.\n     *\n     * Requires the argument to be a number. If unsure, guard against false detections with\n     * `isNumber( value ) && isFloat ( value )`.\n     *\n     * For the technique, see http://stackoverflow.com/a/3885844/508355\n     *\n     * @param   {number} num\n     * @returns {boolean}\n     */\n    function isFloat (num) {\n      return num === +num && num !== (num | 0) // jshint ignore:line\n    }\n\n    /**\n     * Returns the IE version, or false if the browser is not IE.\n     *\n     * The result is determined by browser sniffing, rather than a test tailored to the use case. The function must only\n     * be called as a last resort, for scenarios where there is no alternative to browser sniffing.\n     *\n     * These scenarios include:\n     *\n     * - Preventing IE6 and IE7 from crashing\n     * - Preventing IE9 from blocking or delaying the load event\n     *\n     * The test follows the MSDN recommendation at https://msdn.microsoft.com/en-us/library/ms537509(v=vs.85).aspx#parsingua\n     * The result is cached.\n     *\n     * @returns {number|boolean}\n     */\n    function getIEVersion () {\n      var userAgent, userAgentTestRx\n\n      if (ieVersion === undefined) {\n        ieVersion = false\n        userAgent = navigator && navigator.userAgent\n\n        if (navigator && navigator.appName === 'Microsoft Internet Explorer' && userAgent) {\n          userAgentTestRx = new RegExp('MSIE ([0-9]{1,}[.0-9]{0,})') // jshint ignore:line\n          if (userAgentTestRx.exec(userAgent) != null) ieVersion = parseFloat(RegExp.$1)\n        }\n      }\n\n      return ieVersion\n    }\n\n    /**\n     * Checks if we are dealing with a truly ancient version of IE (< IE8).\n     *\n     * This is done by browser sniffing, rather than a test tailored to the use case. Use it only if there is no\n     * alternative.\n     *\n     * @returns {boolean}\n     */\n    function isAncientIE () {\n      var ieVersion = getIEVersion()\n      return ieVersion && ieVersion < 8\n    }\n\n    /**\n     * Checks if the browser is IE9.\n     *\n     * This is done by browser sniffing, rather than a test tailored to the use case. Use it only if there is no\n     * alternative.\n     *\n     * @returns {boolean}\n     */\n    function isIE9 () {\n      return getIEVersion() === 9\n    }\n\n    // Let's prime $.documentWidth(), $.documentHeight() and $.scrollbarWidth() immediately after the DOM is ready. It\n    // is best to do it up front because the test touches the DOM, so let's get it over with before people set up\n    // handlers for mutation events and such.\n    //\n    // This step has to be skipped for the following browsers:\n    //\n    // - ancient versions of IE (IE6, IE7).\n    //   IE6 and IE7 can't handle the feature tests on DOM ready - they crash right away. Later on, the tests are ok.\n    //\n    // - IE9.\n    //   If the feature tests were run on DOM ready, the window load event would become unreliable. The event might not\n    //   fire until the user moves the mouse over the document. This bug is rare and not triggered by jQuery.documentSize\n    //   alone; third-party code likely plays a role. The exact circumstances are not clear - see issue #3.\n    //\n    // For these browsers, we don't run the feature tests preemptively. Instead, we do it on demand, when the first\n    // document size query is made.\n    if (typeof $ === 'function' && !isAncientIE() && !isIE9()) {\n      // Try-catch acts as a safety net for unsupported, broken browsers\n      try {\n        $(function () {\n          if (elementNameForDocSizeQuery === undefined) testDocumentScroll()\n          browserScrollbarWidth()\n        })\n      } catch (e) {}\n    }\n\n    /**\n     * Custom types.\n     *\n     * For easier documentation and type inference.\n     */\n\n    /**\n     * @name ZoomAccuracyRange\n     * @type {Object}\n     *\n     * @property {number} calculated\n     * @property {number} min\n     * @property {number} max\n     */\n\n    /**\n     * @name WindowQueryConfig\n     * @type {Object}\n     *\n     * @property {Window}  window\n     * @property {boolean} useVisualViewport\n     * @property {boolean} useLayoutViewport\n     */\n  })(typeof jQuery !== 'undefined' ? jQuery : typeof Zepto !== 'undefined' ? Zepto : $)\n  return jQuery.documentSize\n})\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\")))\n\n//# sourceURL=webpack:///./src/public/js/plugins/jquery.documentsize.js?");

/***/ }),

/***/ "./src/public/js/plugins/jquery.isinview.js":
/*!**************************************************!*\
  !*** ./src/public/js/plugins/jquery.isinview.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function($) {// jQuery.isInView, v1.0.3\n// Copyright (c)2015 Michael Heim, Zeilenwechsel.de\n// Distributed under MIT license\n// http://github.com/hashchange/jquery.isinview\n\n;(function (root, factory) {\n  'use strict'\n\n  if (true) {\n    module.exports = factory(__webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\"), __webpack_require__(/*! jquery_docsize */ \"./src/public/js/plugins/jquery.documentsize.js\"))\n  } else {}\n})(this, function (jQuery) {\n  'use strict'\n  ;(function ($) {\n    'use strict'\n\n    var _useGetComputedStyle = !!window.getComputedStyle, // IE8, my dear, this is for you\n      _isIOS,\n      root = window,\n      $root = $(window)\n\n    /**\n     * API\n     */\n\n    /**\n     * @param   {string} [axis=\"both\"]  values \"horizontal\", \"vertical\", \"both\"\n     * @returns {boolean|Object|undefined}\n     */\n    $.fn.hasScrollbar = function (axis) {\n      return hasScrollbar(this, axis)\n    }\n\n    /**\n     * @param   {string} [axis=\"both\"]  values \"horizontal\", \"vertical\", \"both\"\n     * @returns {number|Object|undefined}\n     */\n    $.fn.scrollbarWidth = function (axis) {\n      return effectiveScrollbarWith(this, axis)\n    }\n\n    /**\n     * @returns {Window|undefined}\n     */\n    $.fn.ownerWindow = function () {\n      return ownerWindow(this)\n    }\n\n    /**\n     * @param {Window|Document|HTMLElement|jQuery|string} [container=window]\n     * @param {Object}                                    [opts]\n     * @param {boolean}                                   [opts.partially=false]\n     * @param {boolean}                                   [opts.excludeHidden=false]\n     * @param {string}                                    [opts.direction=\"both\"]\n     * @param {string}                                    [opts.box=\"border-box\"]     alternatively, \"content-box\"\n     * @param {number|string}                             [opts.tolerance=0]          number only (px), or with unit (\"px\" or \"%\" only)\n     *\n     * @returns {jQuery}\n     */\n    $.fn.inView = function (container, opts) {\n      return inView(this, container, opts)\n    }\n\n    /**\n     * @param {Object}        [opts]\n     * @param {boolean}       [opts.partially=false]\n     * @param {boolean}       [opts.excludeHidden=false]\n     * @param {string}        [opts.direction=\"both\"]\n     * @param {string}        [opts.box=\"border-box\"]     alternatively, \"content-box\"\n     * @param {number|string} [opts.tolerance=0]          number only (px), or with unit (\"px\" or \"%\" only)\n     *\n     * @returns {jQuery}\n     */\n    $.fn.inViewport = function (opts) {\n      return inView(this, ownerWindow(this), opts)\n    }\n\n    /**\n     * @param {Window|Document|HTMLElement|jQuery|string} [container=window]\n     * @param {Object}                                    [opts]\n     * @param {boolean}                                   [opts.partially=false]\n     * @param {boolean}                                   [opts.excludeHidden=false]\n     * @param {string}                                    [opts.direction=\"both\"]\n     * @param {string}                                    [opts.box=\"border-box\"]     alternatively, \"content-box\"\n     * @param {number|string}                             [opts.tolerance=0]          number only (px), or with unit (\"px\" or \"%\" only)\n     *\n     * @returns {boolean}\n     */\n    $.fn.isInView = function (container, opts) {\n      return isInView(this, container, opts)\n    }\n\n    /**\n     * @param {Object}        [opts]\n     * @param {boolean}       [opts.partially=false]\n     * @param {boolean}       [opts.excludeHidden=false]\n     * @param {string}        [opts.direction=\"both\"]\n     * @param {string}        [opts.box=\"border-box\"]     alternatively, \"content-box\"\n     * @param {number|string} [opts.tolerance=0]          number only (px), or with unit (\"px\" or \"%\" only)\n     *\n     * @returns {boolean}\n     */\n    $.fn.isInViewport = function (opts) {\n      return isInView(this, ownerWindow(this), opts)\n    }\n\n    $.expr.match.inviewport = /^(?:inVieport)$/i\n\n    $.expr.setFilters.inviewport = $.expr.createPseudo(function () {\n      return $.expr.createPseudo(function (elems, matches) {\n        var i,\n          config,\n          length = elems.length\n\n        if (length) {\n          config = _prepareConfig($(elems))\n          checkHierarchy(elems[0], config.container)\n\n          for (i = 0; i < length; i++) {\n            matches[i] = _isInView(elems[i], config) ? elems[i] : undefined\n          }\n        }\n      })\n    })\n\n    /**\n     * Internals\n     */\n\n    /**\n     * Does the actual work of $.fn.hasScrollbar. Protected from external modification. See $.fn.hasScrollbar for\n     * details.\n     *\n     * @param   {jQuery} $elem\n     * @param   {string} [axis=\"both\"]  values \"horizontal\", \"vertical\", \"both\"\n     * @returns {boolean|Object|undefined}\n     */\n    function hasScrollbar ($elem, axis) {\n      var $body,\n        elemProps,\n        bodyProps,\n        innerWidth,\n        innerHeight,\n        scrollWidth,\n        scrollHeight,\n        query = { target: {} },\n        result = {},\n        context = {},\n        elem = $elem[0]\n\n      $elem = $elem.eq(0)\n      axis || (axis = 'both')\n\n      query.getBoth = axis === 'both'\n      query.getHorizontal = axis === 'horizontal' || query.getBoth\n      query.getVertical = axis === 'vertical' || query.getBoth\n\n      if (axis !== 'horizontal' && axis !== 'vertical' && axis !== 'both')\n        throw new Error('Invalid parameter value: axis = ' + axis)\n      if (!$elem.length) return\n\n      // Transformations:\n      // - If called on a window, we need window, document, documentElement and body, and discard the element\n      // - If called on the document or document element, we treat it like a call on window (above)\n      // - If called on the body, we need document, documentElement and the body itself (again, we discard the element\n      //   to avoid ambiguity)\n      // - If called on an iframe element, we treat it like a window call, using the iframe content window\n      query.target.isWindow = $.isWindow(elem)\n      if (query.target.isWindow) {\n        context.document = elem.document\n      } else if (elem.nodeType === 9) {\n        context.document = elem\n        query.target.isWindow = true\n      } else if (elem === elem.ownerDocument.documentElement) {\n        context.document = elem.ownerDocument\n        query.target.isWindow = true\n      } else if (elem.nodeType === 1 && elem.tagName.toLowerCase() === 'iframe') {\n        context.document = elem.contentDocument || elem.contentWindow.document\n        query.target.isWindow = true\n      } else if (elem === elem.ownerDocument.body) {\n        context.document = elem.ownerDocument\n        query.target.isBody = true\n      }\n\n      if (query.target.isWindow || query.target.isBody) {\n        context.window = context.document.defaultView || context.document.parentWindow\n        context.$document = $(context.document)\n        context.documentElement = context.document.documentElement\n        context.body = context.document.body\n\n        elem = $elem = undefined // won't be needed; discard, to avoid ambiguity in the code below\n      }\n\n      if (query.target.isWindow) {\n        result = _windowHasScrollbar(query, context)\n      } else if (query.target.isBody) {\n        // Checking for body scroll bars.\n        //\n        // body.clientWidth returns the width of the body, minus the scroll bars. We can simply compare it to the\n        // full width, provided that the browser displays scroll bars which take up space.\n        //\n        // By implication, this check DOES NOT work for an effective body overflow of \"auto\" in browsers which\n        // display scroll bars of width 0. (Affects iOS, other mobile browsers, and Safari on OS X when used without\n        // an attached mouse.) There simply is no reliable, bullet-proof way to determine the width of the body\n        // content, ie the true body scroll width, in those browsers.\n        bodyProps = _getViewportOverflows(query, context).body\n\n        $body = $(context.body)\n        if (query.getHorizontal)\n          result.horizontal =\n            bodyProps.overflowScrollX || (bodyProps.overflowAutoX && context.body.clientHeight < $body.height())\n        if (query.getVertical)\n          result.vertical =\n            bodyProps.overflowScrollY || (bodyProps.overflowAutoY && context.body.clientWidth < $body.width())\n      } else {\n        // Scroll bars on an ordinary HTML element\n        //\n        // If we deal with an ordinary element, we always need the overflow settings for both axes because the axes\n        // interact (one scroll bar can cause another).\n        elemProps = getCss(elem, ['overflow', 'overflowX', 'overflowY'], { toLowerCase: true })\n        elemProps = getAppliedOverflows(elemProps, true)\n\n        scrollWidth = elem.scrollWidth\n        scrollHeight = elem.scrollHeight\n\n        result.horizontal =\n          scrollWidth > 0 &&\n          (elemProps.overflowScrollX || (elemProps.overflowAutoX && (innerWidth = $elem.innerWidth()) < scrollWidth))\n        result.vertical =\n          scrollHeight > 0 &&\n          (elemProps.overflowScrollY || (elemProps.overflowAutoY && (innerHeight = $elem.innerHeight()) < scrollHeight))\n\n        // Detect if the appearance of one scroll bar causes the other to appear, too.\n        result.vertical =\n          result.vertical ||\n          (result.horizontal &&\n            elemProps.overflowAutoY &&\n            (innerHeight !== undefined ? innerHeight : $elem.innerHeight()) - $.scrollbarWidth() < scrollHeight)\n        result.horizontal =\n          result.horizontal ||\n          (result.vertical &&\n            elemProps.overflowAutoX &&\n            (innerWidth !== undefined ? innerWidth : $elem.innerWidth()) - $.scrollbarWidth() < scrollWidth)\n      }\n\n      return query.getBoth ? result : query.getHorizontal ? result.horizontal : result.vertical\n    }\n\n    /**\n     * Does the actual work of $.fn.scrollbarWidth. Protected from external modification. See $.fn.scrollbarWidth for\n     * details.\n     *\n     * @param   {jQuery} $elem\n     * @param   {string} [axis=\"both\"]  values \"horizontal\", \"vertical\", \"both\"\n     * @returns {number|Object}\n     */\n    function effectiveScrollbarWith ($elem, axis) {\n      var queryHorizontal,\n        queryVertical,\n        queryBoth,\n        elemHasScrollbar,\n        horizontal,\n        vertical,\n        globalWidth = $.scrollbarWidth()\n\n      axis || (axis = 'both')\n\n      queryBoth = axis === 'both'\n      queryHorizontal = axis === 'horizontal' || queryBoth\n      queryVertical = axis === 'vertical' || queryBoth\n\n      if (axis !== 'horizontal' && axis !== 'vertical' && axis !== 'both')\n        throw new Error('Invalid parameter value: axis = ' + axis)\n      if (!$elem.length) return\n\n      // Bail out early, without an $elem.hasScrollbar() query, if scroll bars don't take up any space.\n      if (globalWidth === 0) return queryBoth ? { horizontal: 0, vertical: 0 } : 0\n\n      elemHasScrollbar = queryBoth\n        ? hasScrollbar($elem)\n        : queryHorizontal\n        ? { horizontal: hasScrollbar($elem, 'horizontal') }\n        : { vertical: hasScrollbar($elem, 'vertical') }\n\n      if (queryHorizontal) horizontal = elemHasScrollbar.horizontal ? globalWidth : 0\n      if (queryVertical) vertical = elemHasScrollbar.vertical ? globalWidth : 0\n\n      return queryBoth ? { horizontal: horizontal, vertical: vertical } : queryHorizontal ? horizontal : vertical\n    }\n\n    /**\n     * Does the actual work of $.fn.ownerWindow. Protected from external modification. See $.fn.ownerWindow for details.\n     *\n     * @param   {jQuery} $elem\n     * @returns {Window|undefined}\n     */\n    function ownerWindow ($elem) {\n      var elem = $elem[0],\n        ownerDocument = elem && (elem.nodeType === 9 ? elem : elem.ownerDocument)\n\n      return (\n        (ownerDocument && (ownerDocument.defaultView || ownerDocument.parentWindow)) ||\n        ($.isWindow(elem) && elem) ||\n        undefined\n      )\n    }\n\n    /**\n     * Does the actual work of $.fn.inView. Protected from external modification. See $.fn.inView for details.\n     *\n     * @param {jQuery}                                    $elems\n     * @param {Window|Document|HTMLElement|jQuery|string} [container=window]\n     * @param {Object}                                    [opts]\n     * @param {boolean}                                   [opts.partially=false]\n     * @param {boolean}                                   [opts.excludeHidden=false]\n     * @param {string}                                    [opts.direction=\"both\"]\n     * @param {string}                                    [opts.box=\"border-box\"]     alternatively, \"content-box\"\n     * @param {number|string}                             [opts.tolerance=0]          number only (px), or with unit (\"px\" or \"%\" only)\n     *\n     * @returns {jQuery}\n     */\n    function inView ($elems, container, opts) {\n      var config,\n        elemsInView = []\n\n      if (!$elems.length) return $()\n\n      config = _prepareConfig($elems, container, opts)\n\n      // Check if the elements are children of the container. For performance reasons, only the first element is\n      // examined.\n      checkHierarchy($elems[0], config.container)\n\n      $elems.each(function () {\n        if (_isInView(this, config)) elemsInView.push(this)\n      })\n\n      return $(elemsInView)\n    }\n\n    /**\n     * Does the actual work of $.fn.isInView. Protected from external modification. See $.fn.isInView for details.\n     *\n     * @param {jQuery}                                    $elem\n     * @param {Window|Document|HTMLElement|jQuery|string} [container=window]\n     * @param {Object}                                    [opts]\n     * @param {boolean}                                   [opts.partially=false]\n     * @param {boolean}                                   [opts.excludeHidden=false]\n     * @param {string}                                    [opts.direction=\"both\"]\n     * @param {string}                                    [opts.box=\"border-box\"]     alternatively, \"content-box\"\n     * @param {number|string}                             [opts.tolerance=0]          number only (px), or with unit (\"px\" or \"%\" only)\n     *\n     * @returns {boolean}\n     */\n    function isInView ($elem, container, opts) {\n      var config,\n        elem = $elem[0]\n\n      if (!$elem.length) return false\n\n      config = _prepareConfig($elem, container, opts)\n      checkHierarchy(elem, config.container)\n\n      return _isInView(elem, config)\n    }\n\n    /**\n     * Prepares the configuration for a single element query. Returns the config object which is to be consumed by\n     * _isInView().\n     *\n     * @param {jQuery}                                    $elem                       single element, or set of elements\n     * @param {Window|Document|HTMLElement|jQuery|string} [container=window]\n     * @param {Object}                                    [opts]\n     * @param {boolean}                                   [opts.partially=false]\n     * @param {boolean}                                   [opts.excludeHidden=false]\n     * @param {string}                                    [opts.direction=\"both\"]\n     * @param {string}                                    [opts.box=\"border-box\"]     alternatively, \"content-box\"\n     * @param {number|string}                             [opts.tolerance=0]          number only (px), or with unit (\"px\" or \"%\" only)\n     *\n     * @returns {Object}\n     */\n    function _prepareConfig ($elem, container, opts) {\n      var $container,\n        direction,\n        config = {}\n\n      opts || (opts = {})\n\n      container || (container = ownerWindow($elem))\n      config.$container = $container = wrapContainer(container)\n      config.container = container = $container[0]\n\n      checkOptions(opts)\n\n      direction = opts.direction || 'both'\n      config.useVertical = direction === 'both' || direction === 'vertical'\n      config.useHorizontal = direction === 'both' || direction === 'horizontal'\n\n      config.partially = opts.partially\n      config.excludeHidden = opts.excludeHidden\n      config.borderBox = opts.box !== 'content-box'\n      config.containerIsWindow = $.isWindow(container)\n\n      if (opts.tolerance !== undefined) {\n        config.toleranceType = isNumber(opts.tolerance) || opts.tolerance.slice(-3) === 'px' ? 'add' : 'multiply'\n        config.tolerance =\n          config.toleranceType === 'add' ? parseFloat(opts.tolerance) : parseFloat(opts.tolerance) / 100 + 1\n      } else {\n        config.tolerance = 0\n        config.toleranceType = 'add'\n      }\n\n      // Create an object to cache DOM queries with regard to the viewport, for faster repeated access.\n      config.cache = {}\n\n      return config\n    }\n\n    /**\n     * Returns if an element is in view, with regard to a given configuration.\n     *\n     * The configuration is built with _prepareConfig().\n     *\n     * @param {HTMLElement}        elem\n     * @param {Object}             config\n     * @param {HTMLElement|Window} config.container\n     * @param {jQuery}             config.$container\n     * @param {boolean}            config.containerIsWindow\n     * @param {Object}             config.cache\n     * @param {boolean}            config.useHorizontal\n     * @param {boolean}            config.useVertical\n     * @param {boolean}            config.partially\n     * @param {boolean}            config.excludeHidden\n     * @param {boolean}            config.borderBox\n     * @param {number}             config.tolerance\n     * @param {string}             config.toleranceType\n     *\n     * @returns {boolean}\n     */\n    function _isInView (elem, config) {\n      var containerWidth,\n        containerHeight,\n        hTolerance,\n        vTolerance,\n        rect,\n        container = config.container,\n        $container = config.$container,\n        cache = config.cache,\n        elemInView = true\n\n      if (elem === container) throw new Error('Invalid container: is the same as the element')\n\n      // When hidden elements are ignored, we check if an element consumes space in the document. And we bail out\n      // immediately if it doesn't.\n      //\n      // The test employed for this works in the vast majority of cases, but there is a limitation. We use offsetWidth\n      // and offsetHeight, which considers the content (incl. borders) but ignores margins. Zero-size content with a\n      // margin might actually consume space sometimes, but it won't be detected (see http://jsbin.com/tiwabo/3).\n      //\n      // That said, the definition of visibility and the actual test are the same as in jQuery :visible.\n      if (config.excludeHidden && !(elem.offsetWidth > 0 && elem.offsetHeight > 0)) return false\n\n      if (config.useHorizontal) containerWidth = getNetContainerWidth($container, config.containerIsWindow, cache)\n      if (config.useVertical) containerHeight = getNetContainerHeight($container, config.containerIsWindow, cache)\n\n      // Convert tolerance to a px value (if given as a percentage)\n      hTolerance =\n        cache.hTolerance !== undefined\n          ? cache.hTolerance\n          : (cache.hTolerance = config.toleranceType === 'add' ? config.tolerance : containerWidth * config.tolerance)\n      vTolerance =\n        cache.vTolerance !== undefined\n          ? cache.vTolerance\n          : (cache.vTolerance = config.toleranceType === 'add' ? config.tolerance : containerHeight * config.tolerance)\n\n      // We can safely use getBoundingClientRect without a fallback. Its core properties (top, left, bottom, right)\n      // are supported on the desktop for ages (IE5+). On mobile, too: supported from Blackberry 6+ (2010), iOS 4\n      // (2010, iPhone 3GS+), according to the jQuery source comment in $.fn.offset.\n      //\n      // In oldIE (up to IE8), the coordinates were 2px off in each dimension because the \"viewport\" began at (2,2) of\n      // the window. Can be feature-tested by creating an absolutely positioned div at (0,0) and reading the rect\n      // coordinates. Won't be fixed here because the quirk is too minor to justify the overhead, just for oldIE.\n      //\n      // (See http://stackoverflow.com/a/10231202/508355 and Zakas, Professional Javascript (2012), p. 406)\n\n      rect = config.borderBox ? elem.getBoundingClientRect() : getContentRect(elem)\n      if (!config.containerIsWindow) rect = getRelativeRect(rect, $container, cache)\n\n      if (config.partially) {\n        if (config.useVertical) elemInView = rect.top < containerHeight + vTolerance && rect.bottom > -vTolerance\n        if (config.useHorizontal)\n          elemInView = elemInView && rect.left < containerWidth + hTolerance && rect.right > -hTolerance\n      } else {\n        if (config.useVertical)\n          elemInView =\n            rect.top >= -vTolerance &&\n            rect.top < containerHeight + vTolerance &&\n            rect.bottom > -vTolerance &&\n            rect.bottom <= containerHeight + vTolerance\n        if (config.useHorizontal)\n          elemInView =\n            elemInView &&\n            rect.left >= -hTolerance &&\n            rect.left < containerWidth + hTolerance &&\n            rect.right > -hTolerance &&\n            rect.right <= containerWidth + hTolerance\n      }\n\n      return elemInView\n    }\n\n    /**\n     * Gets the TextRectangle coordinates relative to a container element.\n     *\n     * Do not call if the container is a window (redundant) or a document. Both calls would fail.\n     */\n    function getRelativeRect (rect, $container, cache) {\n      var containerPaddingRectRoot\n\n      if (cache && cache.containerPaddingRectRoot) {\n        containerPaddingRectRoot = cache.containerPaddingRectRoot\n      } else {\n        // gBCR coordinates enclose padding, and leave out margin. That is perfect for scrolling because\n        //\n        // - padding scrolls (ie,o it is part of the scrollable area, and gBCR puts it inside)\n        // - margin doesn't scroll (ie, it pushes the scrollable area to another position, and gBCR records that)\n        //\n        // Borders, however, don't scroll, so they are not part of the scrollable area, but gBCR puts them inside.\n        //\n        // (See http://jsbin.com/pivata/10 for an extensive test of gBCR behaviour.)\n\n        containerPaddingRectRoot = getPaddingRectRoot($container[0])\n\n        // Cache the calculations\n        if (cache) cache.containerPaddingRectRoot = containerPaddingRectRoot\n      }\n\n      return {\n        top: rect.top - containerPaddingRectRoot.top,\n        bottom: rect.bottom - containerPaddingRectRoot.top,\n        left: rect.left - containerPaddingRectRoot.left,\n        right: rect.right - containerPaddingRectRoot.left\n      }\n    }\n\n    /**\n     * Calculates the rect of the content-box. Similar to getBoundingClientRect, but excludes padding and borders - and\n     * is much slower.\n     *\n     * @param   {HTMLElement} elem\n     * @returns {ClientRect}\n     */\n    function getContentRect (elem) {\n      var rect = elem.getBoundingClientRect(),\n        props = getCss(\n          elem,\n          [\n            'borderTopWidth',\n            'borderRightWidth',\n            'borderBottomWidth',\n            'borderLeftWidth',\n            'paddingTop',\n            'paddingRight',\n            'paddingBottom',\n            'paddingLeft'\n          ],\n          { toFloat: true }\n        )\n\n      return {\n        top: rect.top + props.paddingTop + props.borderTopWidth,\n        right: rect.right - (props.paddingRight + props.borderRightWidth),\n        bottom: rect.bottom - (props.paddingBottom + props.borderBottomWidth),\n        left: rect.left + props.paddingLeft + props.borderLeftWidth\n      }\n    }\n\n    /**\n     * Returns the top, left coordinates of the rect of the padding box (offset box).\n     *\n     * The coordinates match those of getBoundingClientRect, but exclude the borders.\n     *\n     * Does not care about bottom, right coordinates, in order to speed up the process.\n     *\n     * @param   {HTMLElement} elem\n     * @returns {{ top: number, left: number }}\n     */\n    function getPaddingRectRoot (elem) {\n      var rect = elem.getBoundingClientRect(),\n        props = getCss(elem, ['borderTopWidth', 'borderLeftWidth'], { toFloat: true })\n\n      return {\n        top: rect.top + props.borderTopWidth,\n        left: rect.left + props.borderLeftWidth\n      }\n    }\n\n    /**\n     * Returns the scroll bar state of the window. Helper for hasScrollbar().\n     *\n     * @param {Object} query\n     * @param {Object} context\n     *\n     * @returns {{vertical: boolean, horizontal: boolean}}\n     */\n    function _windowHasScrollbar (query, context) {\n      var windowInnerHeight,\n        windowInnerWidth,\n        windowProps,\n        scrollbarWidth = $.scrollbarWidth(),\n        result = {},\n        doneX = !query.getHorizontal,\n        doneY = !query.getVertical\n\n      // We may be able to take a shortcut. The window.innerWidth and -Height report the dimensions of the viewport\n      // including scroll bars, and documentElement.clientWidth and -Height report them without scroll bars. That\n      // gives the presence of a scroll bar away, as long as\n      //\n      // - the scroll bars actually take up space (width > 0)\n      // - the browser supports window.innerWidth/Height (IE8, for instance, does not)\n      // - the browser doesn't report a buggy value. FF has a bug which as only been fixed in FF25 (released 29 Oct\n      //   2013). It manifests itself in a fictional return value of 10 for these properties. See\n      //   * https://developer.mozilla.org/en-US/docs/Web/API/Window.innerWidth\n      //   * https://developer.mozilla.org/en-US/docs/Web/API/Window.innerHeight\n      //   * https://bugzilla.mozilla.org/show_bug.cgi?id=641188\n\n      if (query.getHorizontal && scrollbarWidth > 0) {\n        windowInnerHeight = context.window.innerHeight\n        if (windowInnerHeight > 10) {\n          result.horizontal = windowInnerHeight > context.documentElement.clientHeight\n          doneX = true\n        }\n      }\n\n      if (query.getVertical && scrollbarWidth > 0) {\n        windowInnerWidth = context.window.innerWidth\n        if (windowInnerWidth > 10) {\n          result.vertical = windowInnerWidth > context.documentElement.clientWidth\n          doneY = true\n        }\n      }\n\n      if (!doneX || !doneY) {\n        // Shortcut didn't work. We have to evaluate overflow settings, window and document size.\n\n        windowProps = _getViewportOverflows(query, context).window\n\n        // Handle the trivial cases first: window set to overflow: scroll or to overflow: hidden.\n        if (!doneX && windowProps.overflowScrollX) result.horizontal = doneX = true\n        if (!doneY && windowProps.overflowScrollY) result.vertical = doneY = true\n\n        if (!doneX && windowProps.overflowHiddenX) {\n          result.horizontal = false\n          doneX = true\n        }\n\n        if (!doneY && windowProps.overflowHiddenY) {\n          result.vertical = false\n          doneY = true\n        }\n\n        // Handle the remaining overflow: auto case\n        //\n        // (There is no actual overflow: visible case for the viewport, see getAppliedViewportOverflows.)\n        if (!doneX) result.horizontal = context.documentElement.clientWidth < $.documentWidth(context.document)\n        if (!doneY) result.vertical = context.documentElement.clientHeight < $.documentHeight(context.document)\n      }\n\n      return result\n    }\n\n    /**\n     * Returns the applied overflow for the viewport (documentElement) and body in an aggregated `{ window: ...,\n     * body: ...}` hash. Helper for hasScrollbar().\n     *\n     * If we deal with window or body scroll bars, we always need the settings for both body and window (documentElement)\n     * because they are interdependent. See getAppliedViewportOverflows().\n     *\n     * @param {Object} query\n     * @param {Object} context\n     * @returns {{window: AppliedOverflow, body: AppliedOverflow}}\n     */\n    function _getViewportOverflows (query, context) {\n      var windowProps,\n        bodyProps,\n        overflowPropNames = ['overflow'],\n        bodyOverflowPropNames = ['overflow']\n\n      if (query.getHorizontal) {\n        overflowPropNames.push('overflowX')\n        bodyOverflowPropNames.push('overflowX')\n      }\n      if (query.getVertical) {\n        overflowPropNames.push('overflowY')\n        bodyOverflowPropNames.push('overflowY')\n      }\n\n      windowProps = getCss(context.documentElement, overflowPropNames, { toLowerCase: true })\n      bodyProps = getCss(context.body, bodyOverflowPropNames, { toLowerCase: true })\n\n      return getAppliedViewportOverflows(windowProps, bodyProps)\n    }\n\n    /**\n     * Determines the effective overflow setting of an element, separately for each axis, based on the `overflow`,\n     * `overflowX` and `overflowY` properties of the element which must be passed in as a hash.\n     *\n     * Returns a hash of the computed results for overflowX, overflowY. Also adds boolean status properties to the hash\n     * if the createBooleans flag is set. These are properties for mere convenience. They signal if a particular\n     * overflow type applies (e.g. overflowHiddenX = true/false).\n     *\n     * ATTN The method does not take the special relation of body and documentElement into account. That is handled by\n     * the more specific getAppliedViewportOverflows() function.\n     *\n     * The effective overflow setting is established as follows:\n     *\n     * - If a computed value for `overflow(X/Y)` exists, it gets applied to the axis.\n     * - If not, the computed value of the general `overflow` setting gets applied to the axis.\n     * - If there is no computed value at all, the overflow default gets applied to the axis. The default is\n     *   \"visible\" in seemingly every browser out there. Falling back to the default should never be necessary,\n     *   though, because there always is a computed value.\n     *\n     * @param {Object}        props            hash of element properties (computed values)\n     * @param {string}        props.overflow\n     * @param {string}        props.overflowX\n     * @param {string}        props.overflowY\n     * @param {boolean=false} createBooleans   if true, create the full set of boolean status properties, e.g.\n     *                                         overflowVisibleX (true/false), overflowHiddenY (true/false) etc\n     * @returns {AppliedOverflow}              hash of the computed results: overflowX, overflowY, optional boolean\n     *                                         status properties\n     */\n    function getAppliedOverflows (props, createBooleans) {\n      var status = {}\n\n      // Establish the applied overflow (e.g. overflowX: \"scroll\")\n      status.overflowX = props.overflowX || props.overflow || 'visible'\n      status.overflowY = props.overflowY || props.overflow || 'visible'\n\n      // Create the derived boolean status properties (e.g overflowScrollX: true)\n      if (createBooleans) {\n        $.each(['Visible', 'Auto', 'Scroll', 'Hidden'], function (index, type) {\n          var lcType = type.toLowerCase()\n          status['overflow' + type + 'X'] = status.overflowX === lcType\n          status['overflow' + type + 'Y'] = status.overflowY === lcType\n        })\n      }\n\n      return status\n    }\n\n    /**\n     * Determines the effective overflow setting of the viewport and body, separately for each axis, based on the\n     * `overflow`, `overflowX` and `overflowY` properties of the documentElement and body which must be passed in as a\n     * hash.\n     *\n     * Returns the results for viewport and body in an aggregated `{ window: ..., body: ...}` hash.\n     *\n     * For the basic resolution mechanism, see getAppliedOverflows(). When determining the effective overflow, the\n     * peculiarities of viewport and body are taken into account:\n     *\n     * - Viewport and body overflows are interdependent. If the nominal viewport overflow for a given axis is \"visible\",\n     *   the viewport inherits the body overflow for that axis, and the body overflow is set to \"visible\". Curiously,\n     *   that transfer is _not_ reflected in the computed values, it just manifests in behaviour.\n     *\n     * - Once that is done, if the viewport overflow is still \"visible\" for an axis, it is effectively turned into\n     *   \"auto\". Scroll bars appear when the content overflows the viewport (ie, \"auto\" behaviour). Hence, this function\n     *   will indeed report \"auto\". Again, the transformation is only manifest in behaviour, not in the computed values.\n     *\n     * - In iOS, if the effective overflow setting of the viewport is \"hidden\", it is ignored and treated as \"auto\".\n     *   Content can still overflow the viewport, and scroll bars appear as needed.\n     *\n     *   Now, the catch. This behaviour is impossible to feature-detect. The computed values are not at all affected by\n     *   it, and the results reported eg. for clientHeight, offsetHeight, scrollHeight of body and documentElement do\n     *   not differ between Safari on iOS and, say, Chrome on the desktop. The numbers don't give the behaviour away.\n     *\n     *   So we have to resort to browser sniffing here. It sucks, but there is literally no other option.\n     *\n     * NB Additional status properties (see getAppliedOverflows) are always generated here.\n     *\n     * @param {Object} documentElementProps            hash of documentElement properties (computed values)\n     * @param {string} documentElementProps.overflow\n     * @param {string} documentElementProps.overflowX\n     * @param {string} documentElementProps.overflowY\n     *\n     * @param {Object} bodyProps                       hash of body properties (computed values)\n     * @param {string} bodyProps.overflow\n     * @param {string} bodyProps.overflowX\n     * @param {string} bodyProps.overflowY\n     *\n     * @returns {{window: AppliedOverflow, body: AppliedOverflow}}\n     */\n    function getAppliedViewportOverflows (documentElementProps, bodyProps) {\n      var _window = getAppliedOverflows(documentElementProps, false),\n        body = getAppliedOverflows(bodyProps, false),\n        consolidated = { window: {}, body: {} }\n\n      // Handle the interdependent relationship between body and window (documentElement) overflow\n      if (_window.overflowX === 'visible') {\n        // If the window overflow is set to \"visible\", body props get transferred to the window, body changes to\n        // \"visible\". (Nothing really changes if both are set to \"visible\".)\n        consolidated.body.overflowX = 'visible'\n        consolidated.window.overflowX = body.overflowX\n      } else {\n        // No transfer of properties.\n        // - If body overflow is \"visible\", it remains that way, and the window stays as it is.\n        // - If body and window are set to properties other than \"visible\", they keep their divergent settings.\n        consolidated.body.overflowX = body.overflowX\n        consolidated.window.overflowX = _window.overflowX\n      }\n\n      // Repeat for overflowY\n      if (_window.overflowY === 'visible') {\n        consolidated.body.overflowY = 'visible'\n        consolidated.window.overflowY = body.overflowY\n      } else {\n        consolidated.body.overflowY = body.overflowY\n        consolidated.window.overflowY = _window.overflowY\n      }\n\n      // window.overflow(X/Y): \"visible\" actually means \"auto\" because scroll bars appear as needed; transform\n      if (consolidated.window.overflowX === 'visible') consolidated.window.overflowX = 'auto'\n      if (consolidated.window.overflowY === 'visible') consolidated.window.overflowY = 'auto'\n\n      // In iOS, window.overflow(X/Y): \"hidden\" actually means \"auto\"; transform\n      if (isIOS()) {\n        if (consolidated.window.overflowX === 'hidden') consolidated.window.overflowX = 'auto'\n        if (consolidated.window.overflowY === 'hidden') consolidated.window.overflowY = 'auto'\n      }\n\n      // Add the boolean status properties to the result\n      consolidated.window = getAppliedOverflows(consolidated.window, true)\n      consolidated.body = getAppliedOverflows(consolidated.body, true)\n\n      return consolidated\n    }\n\n    /**\n     * Establishes the container and returns it in a jQuery wrapper.\n     *\n     * Resolves and normalizes the input, which may be a document, HTMLElement, window, or selector string. Corrects\n     * likely mistakes, such as passing in a document or an iframe, rather than the corresponding window.\n     *\n     * @param {Window|Document|HTMLElement|HTMLIFrameElement|jQuery|string} container\n     * @returns {jQuery}\n     */\n    function wrapContainer (container) {\n      var $container,\n        isJquery = container instanceof $\n\n      if (!isJquery && !$.isWindow(container) && !container.nodeType && !isString(container))\n        throw new Error('Invalid container: not a window, node, jQuery object or selector string')\n\n      $container = isJquery ? container : container === root ? $root : $(container)\n\n      if (!$container.length) throw new Error('Invalid container: empty jQuery object')\n\n      container = $container[0]\n\n      if (container.nodeType === 9) {\n        // Document is passed in, transform to window\n        $container = wrapContainer(container.defaultView || container.parentWindow)\n      } else if (container.nodeType === 1 && container.tagName.toLowerCase() === 'iframe') {\n        // IFrame element is passed in, transform to IFrame content window\n        $container = wrapContainer(container.contentWindow)\n      }\n\n      // Check if the container matches the requirements\n      if (!$.isWindow($container[0]) && $container.css('overflow') === 'visible')\n        throw new Error(\n          'Invalid container: is set to overflow:visible. Containers must have the ability to obscure some of their content, otherwise the in-view test is pointless. Containers must be set to overflow:scroll/auto/hide, or be a window (or document, or iframe, as proxies for a window)'\n        )\n\n      return $container\n    }\n\n    /**\n     * Checks if the element is a descendant of the container, and throws an error otherwise. Also checks the type of\n     * the element (must indeed be an element node).\n     *\n     * For performance reasons, this check should *not* be run on every element in a set.\n     *\n     * @param {HTMLElement}                 elem\n     * @param {Window|Document|HTMLElement} container\n     */\n    function checkHierarchy (elem, container) {\n      var elemIsContained\n\n      if (elem.nodeType !== 1) throw new Error('Invalid node: is not an element')\n\n      if ($.isWindow(container)) {\n        elemIsContained =\n          elem.ownerDocument && container === (elem.ownerDocument.defaultView || elem.ownerDocument.parentWindow)\n      } else if (container.nodeType === 9) {\n        // We need a DOM element for this check, so we use the documentElement as a proxy if the container is a document.\n        elemIsContained = $.contains(container.documentElement, elem)\n      } else {\n        elemIsContained = $.contains(container, elem)\n      }\n\n      if (!elemIsContained) throw new Error('Invalid container: is not an ancestor of the element')\n    }\n\n    /**\n     * Spots likely option mistakes and throws appropriate errors.\n     *\n     * @param {Object} opts\n     */\n    function checkOptions (opts) {\n      var isNum, isNumWithUnit\n\n      if (\n        opts.direction &&\n        !(opts.direction === 'vertical' || opts.direction === 'horizontal' || opts.direction === 'both')\n      ) {\n        throw new Error('Invalid option value: direction = \"' + opts.direction + '\"')\n      }\n\n      if (opts.box && !(opts.box === 'border-box' || opts.box === 'content-box')) {\n        throw new Error('Invalid option value: box = \"' + opts.box + '\"')\n      }\n\n      if (opts.tolerance !== undefined) {\n        isNum = isNumber(opts.tolerance)\n        isNumWithUnit = isString(opts.tolerance) && /^[+-]?\\d*\\.?\\d+(px|%)?$/.test(opts.tolerance)\n        if (!(isNum || isNumWithUnit)) throw new Error('Invalid option value: tolerance = \"' + opts.tolerance + '\"')\n      }\n    }\n\n    /**\n     * Gets the width of a jQuery-wrapped container, excluding scroll bars. Also supports quirks mode for window\n     * containers, unlike jQuery's $( window ).width(). Makes use of caching if a cache object is provided.\n     *\n     * @param   {jQuery}  $container\n     * @param   {boolean} isWindow    required to speed up the process\n     * @param   {Object}  [cache]\n     * @returns {number}\n     */\n    function getNetContainerWidth ($container, isWindow, cache) {\n      var width\n\n      if (cache && cache.netContainerWidth !== undefined) {\n        width = cache.netContainerWidth\n      } else {\n        width = isWindow\n          ? getWindowDimension($container, 'Width')\n          : $container.innerWidth() - getContainerScrollbarWidths($container, cache).vertical\n\n        if (cache) cache.netContainerWidth = width\n      }\n\n      return width\n    }\n\n    /**\n     * Gets the height of a jQuery-wrapped container, excluding scroll bars. Also supports quirks mode for window\n     * containers, unlike jQuery's $( window ).height(). Makes use of caching if a cache object is provided.\n     *\n     * @param   {jQuery}  $container\n     * @param   {boolean} isWindow    required to speed up the process\n     * @param   {Object}  [cache]\n     * @returns {number}\n     */\n    function getNetContainerHeight ($container, isWindow, cache) {\n      var height\n\n      if (cache && cache.netContainerHeight !== undefined) {\n        height = cache.netContainerHeight\n      } else {\n        height = isWindow\n          ? getWindowDimension($container, 'Height')\n          : $container.innerHeight() - getContainerScrollbarWidths($container, cache).horizontal\n\n        if (cache) cache.netContainerHeight = height\n      }\n\n      return height\n    }\n\n    /**\n     * Gets the effective scroll bar widths of a given container. Makes use of caching if a cache object is provided.\n     *\n     * @param   {jQuery} $container\n     * @param   {Object} [cache]\n     * @returns {Object}\n     */\n    function getContainerScrollbarWidths ($container, cache) {\n      var containerScrollbarWidths\n\n      if (cache && cache.containerScrollbarWidths) {\n        containerScrollbarWidths = cache.containerScrollbarWidths\n      } else {\n        containerScrollbarWidths = effectiveScrollbarWith($container)\n        if (cache) cache.containerScrollbarWidths = containerScrollbarWidths\n      }\n\n      return containerScrollbarWidths\n    }\n\n    /**\n     * Gets the width or height of a jQuery-wrapped window. Use it instead of $container.width(). Supports quirks mode,\n     * unlike jQuery.\n     *\n     * Window dimensions are calculated as in Zakas, Professional Javascript (2012), p. 404. The standards mode part of\n     * it is the same as in jQuery, too.\n     *\n     * @param {jQuery} $window\n     * @param {string} dimension  \"Width\" or \"Height\" (capitalized!)\n     * @returns {number}\n     */\n    function getWindowDimension ($window, dimension) {\n      var doc = $window[0].document,\n        property = 'client' + dimension\n\n      return doc.compatMode === 'BackCompat' ? doc.body[property] : doc.documentElement[property]\n    }\n\n    /**\n     * Returns the computed style for a property, or an array of properties, as a hash.\n     *\n     * Building a CSS properties hash this way can be significantly faster than the more convenient, conventional jQuery\n     * approach, $( elem ).css( propertiesArray ).\n     *\n     * ATTN\n     * ====\n     *\n     * We are using an internal jQuery API here: $.css(). The current signature was introduced in jQuery 1.9.0. It may\n     * break without warning with any change of the minor version.\n     *\n     * For that reason, the $.css API is monitored by the tests in api.jquery.css.spec.js which verify that it works as\n     * expected.\n     *\n     * @param {HTMLElement}     elem\n     * @param {string|string[]} properties\n     * @param {Object}          [opts]\n     * @param {boolean}         [opts.toLowerCase=false]  ensures return values in lower case\n     * @param {boolean}         [opts.toFloat=false]      converts return values to numbers, using parseFloat\n     *\n     * @returns {Object}        property names and their values\n     */\n    function getCss (elem, properties, opts) {\n      var i,\n        length,\n        name,\n        props = {},\n        _window = elem.ownerDocument.defaultView || elem.ownerDocument.parentWindow,\n        computedStyles = _useGetComputedStyle ? _window.getComputedStyle(elem, null) : elem.currentStyle\n\n      opts || (opts = {})\n\n      if (!$.isArray(properties)) properties = [properties]\n      length = properties.length\n\n      for (i = 0; i < length; i++) {\n        name = properties[i]\n        props[name] = $.css(elem, name, false, computedStyles)\n        if (opts.toLowerCase && props[name] && props[name].toLowerCase) props[name] = props[name].toLowerCase()\n        if (opts.toFloat) props[name] = parseFloat(props[name])\n      }\n\n      return props\n    }\n\n    /**\n     * Returns the bounding client rect, including width and height properties. Ensures compatibility with IE8, which\n     * supports getBoundingClientRect but doesn't calculate width and height.\n     *\n     * Use only when width and height are actually needed.\n     *\n     * Will be removed when IE8 support is dropped entirely.\n     *\n     * @param   {HTMLElement} elem\n     * @returns {ClientRect}\n     */\n    function getBoundingClientRectCompat (elem) {\n      var elemRect = elem.getBoundingClientRect()\n\n      if (elemRect.width === undefined || elemRect.height === undefined) {\n        // Fix for IE8\n        elemRect = {\n          top: elemRect.top,\n          left: elemRect.left,\n          bottom: elemRect.bottom,\n          right: elemRect.right,\n          width: elemRect.right - elemRect.left,\n          height: elemRect.bottom - elemRect.top\n        }\n      }\n\n      return elemRect\n    }\n\n    /**\n     * Detects if the browser is on iOS. Works for Safari as well as other browsers, say, Chrome on iOS.\n     *\n     * Required for some iOS behaviour which can't be feature-detected in any way.\n     *\n     * @returns {boolean}\n     */\n    function isIOS () {\n      if (_isIOS === undefined) _isIOS = /iPad|iPhone|iPod/g.test(navigator.userAgent)\n      return _isIOS\n    }\n\n    /**\n     * Calls parseFloat on each value. Useful for removing units from numeric values.\n     *\n     * @param   {Object} object\n     * @returns {Object}\n     */\n    function toFloat (object) {\n      var transformed = {}\n\n      $.map(object, function (value, key) {\n        transformed[key] = parseFloat(value)\n      })\n\n      return transformed\n    }\n\n    /**\n     * Returns whether or not a value is of type number. Also rejects NaN as a number.\n     *\n     * NB This is not the same as $.isNumeric because $.isNumeric( \"3\" ) is true while isNumber( \"3\" ) is false.\n     *\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isNumber (value) {\n      // Done as in the Lodash compatibility build, but rejecting NaN as a number.\n      var isNumeric =\n        typeof value === 'number' ||\n        (value && typeof value === 'object' && Object.prototype.toString.call(value) === '[object Number]') ||\n        false\n\n      // Reject NaN before returning\n      return isNumeric && value === +value\n    }\n\n    function isString (value) {\n      // Done as in the Lodash compatibility build\n      return (\n        typeof value === 'string' ||\n        (value && typeof value === 'object' && Object.prototype.toString.call(value) === '[object String]') ||\n        false\n      )\n    }\n\n    /**\n     * Custom types.\n     *\n     * For easier documentation and type inference.\n     */\n\n    /**\n     * @name  AppliedOverflow\n     * @type  {Object}\n     *\n     * @property {string}  overflowX\n     * @property {string}  overflowY\n     * @property {boolean} overflowVisibleX\n     * @property {boolean} overflowVisibleY\n     * @property {boolean} overflowAutoX\n     * @property {boolean} overflowAutoY\n     * @property {boolean} overflowScrollX\n     * @property {boolean} overflowScrollY\n     * @property {boolean} overflowHiddenX\n     * @property {boolean} overflowHiddenY\n     */\n  })(typeof jQuery !== 'undefined' ? jQuery : $)\n})\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\")))\n\n//# sourceURL=webpack:///./src/public/js/plugins/jquery.isinview.js?");

/***/ }),

/***/ "./src/public/js/plugins/jquery.steps.js":
/*!***********************************************!*\
  !*** ./src/public/js/plugins/jquery.steps.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(jQuery) {/*!\n * jQuery Steps v1.1.0 - 09/04/2014\n * Copyright (c) 2014 Rafael Staib (http://www.jquery-steps.com)\n * Licensed under MIT http://www.opensource.org/licenses/MIT\n */\n;(function ($, undefined) {\n  $.fn.extend({\n    _aria: function (name, value) {\n      return this.attr('aria-' + name, value)\n    },\n\n    _removeAria: function (name) {\n      return this.removeAttr('aria-' + name)\n    },\n\n    _enableAria: function (enable) {\n      return enable == null || enable\n        ? this.removeClass('disabled')._aria('disabled', 'false')\n        : this.addClass('disabled')._aria('disabled', 'true')\n    },\n\n    _showAria: function (show) {\n      return show == null || show ? this.show()._aria('hidden', 'false') : this.hide()._aria('hidden', 'true')\n    },\n\n    _selectAria: function (select) {\n      return select == null || select\n        ? this.addClass('current')._aria('selected', 'true')\n        : this.removeClass('current')._aria('selected', 'false')\n    },\n\n    _id: function (id) {\n      return id ? this.attr('id', id) : this.attr('id')\n    }\n  })\n\n  if (!String.prototype.format) {\n    String.prototype.format = function () {\n      var args = arguments.length === 1 && $.isArray(arguments[0]) ? arguments[0] : arguments\n      var formattedString = this\n      for (var i = 0; i < args.length; i++) {\n        var pattern = new RegExp('\\\\{' + i + '\\\\}', 'gm')\n        formattedString = formattedString.replace(pattern, args[i])\n      }\n      return formattedString\n    }\n  }\n\n  /**\n   * A global unique id count.\n   *\n   * @static\n   * @private\n   * @property _uniqueId\n   * @type Integer\n   **/\n  var _uniqueId = 0\n\n  /**\n   * The plugin prefix for cookies.\n   *\n   * @final\n   * @private\n   * @property _cookiePrefix\n   * @type String\n   **/\n  var _cookiePrefix = 'jQu3ry_5teps_St@te_'\n\n  /**\n   * Suffix for the unique tab id.\n   *\n   * @final\n   * @private\n   * @property _tabSuffix\n   * @type String\n   * @since 0.9.7\n   **/\n  var _tabSuffix = '-t-'\n\n  /**\n   * Suffix for the unique tabpanel id.\n   *\n   * @final\n   * @private\n   * @property _tabpanelSuffix\n   * @type String\n   * @since 0.9.7\n   **/\n  var _tabpanelSuffix = '-p-'\n\n  /**\n   * Suffix for the unique title id.\n   *\n   * @final\n   * @private\n   * @property _titleSuffix\n   * @type String\n   * @since 0.9.7\n   **/\n  var _titleSuffix = '-h-'\n\n  /**\n   * An error message for an \"index out of range\" error.\n   *\n   * @final\n   * @private\n   * @property _indexOutOfRangeErrorMessage\n   * @type String\n   **/\n  var _indexOutOfRangeErrorMessage = 'Index out of range.'\n\n  /**\n   * An error message for an \"missing corresponding element\" error.\n   *\n   * @final\n   * @private\n   * @property _missingCorrespondingElementErrorMessage\n   * @type String\n   **/\n  var _missingCorrespondingElementErrorMessage = 'One or more corresponding step {0} are missing.'\n\n  /**\n   * Adds a step to the cache.\n   *\n   * @static\n   * @private\n   * @method addStepToCache\n   * @param wizard {Object} A jQuery wizard object\n   * @param step {Object} The step object to add\n   **/\n  function addStepToCache (wizard, step) {\n    getSteps(wizard).push(step)\n  }\n\n  function analyzeData (wizard, options, state) {\n    var stepTitles = wizard.children(options.headerTag),\n      stepContents = wizard.children(options.bodyTag)\n\n    // Validate content\n    if (stepTitles.length > stepContents.length) {\n      throwError(_missingCorrespondingElementErrorMessage, 'contents')\n    } else if (stepTitles.length < stepContents.length) {\n      throwError(_missingCorrespondingElementErrorMessage, 'titles')\n    }\n\n    var startIndex = options.startIndex\n\n    state.stepCount = stepTitles.length\n\n    // Tries to load the saved state (step position)\n    if (options.saveState && $.cookie) {\n      var savedState = $.cookie(_cookiePrefix + getUniqueId(wizard))\n      // Sets the saved position to the start index if not undefined or out of range\n      var savedIndex = parseInt(savedState, 0)\n      if (!isNaN(savedIndex) && savedIndex < state.stepCount) {\n        startIndex = savedIndex\n      }\n    }\n\n    state.currentIndex = startIndex\n\n    stepTitles.each(function (index) {\n      var item = $(this), // item == header\n        content = stepContents.eq(index),\n        modeData = content.data('mode'),\n        mode =\n          modeData == null\n            ? contentMode.html\n            : getValidEnumValue(\n                contentMode,\n                /^\\s*$/.test(modeData) || isNaN(modeData) ? modeData : parseInt(modeData, 0)\n              ),\n        contentUrl = mode === contentMode.html || content.data('url') === undefined ? '' : content.data('url'),\n        contentLoaded = mode !== contentMode.html && content.data('loaded') === '1',\n        step = $.extend({}, stepModel, {\n          title: item.html(),\n          content: mode === contentMode.html ? content.html() : '',\n          contentUrl: contentUrl,\n          contentMode: mode,\n          contentLoaded: contentLoaded\n        })\n\n      addStepToCache(wizard, step)\n    })\n  }\n\n  /**\n   * Triggers the onCanceled event.\n   *\n   * @static\n   * @private\n   * @method cancel\n   * @param wizard {Object} The jQuery wizard object\n   **/\n  function cancel (wizard) {\n    wizard.triggerHandler('canceled')\n  }\n\n  function decreaseCurrentIndexBy (state, decreaseBy) {\n    return state.currentIndex - decreaseBy\n  }\n\n  /**\n   * Removes the control functionality completely and transforms the current state to the initial HTML structure.\n   *\n   * @static\n   * @private\n   * @method destroy\n   * @param wizard {Object} A jQuery wizard object\n   **/\n  function destroy (wizard, options) {\n    var eventNamespace = getEventNamespace(wizard)\n\n    // Remove virtual data objects from the wizard\n    wizard\n      .unbind(eventNamespace)\n      .removeData('uid')\n      .removeData('options')\n      .removeData('state')\n      .removeData('steps')\n      .removeData('eventNamespace')\n      .find('.actions a')\n      .unbind(eventNamespace)\n\n    // Remove attributes and CSS classes from the wizard\n    wizard.removeClass(options.clearFixCssClass + ' vertical')\n\n    var contents = wizard.find('.content > *')\n\n    // Remove virtual data objects from panels and their titles\n    contents\n      .removeData('loaded')\n      .removeData('mode')\n      .removeData('url')\n\n    // Remove attributes, CSS classes and reset inline styles on all panels and their titles\n    contents\n      .removeAttr('id')\n      .removeAttr('role')\n      .removeAttr('tabindex')\n      .removeAttr('class')\n      .removeAttr('style')\n      ._removeAria('labelledby')\n      ._removeAria('hidden')\n\n    // Empty panels if the mode is set to 'async' or 'iframe'\n    wizard.find(\".content > [data-mode='async'],.content > [data-mode='iframe']\").empty()\n\n    var wizardSubstitute = $('<{0} class=\"{1}\"></{0}>'.format(wizard.get(0).tagName, wizard.attr('class')))\n\n    var wizardId = wizard._id()\n    if (wizardId != null && wizardId !== '') {\n      wizardSubstitute._id(wizardId)\n    }\n\n    wizardSubstitute.html(wizard.find('.content').html())\n    wizard.after(wizardSubstitute)\n    wizard.remove()\n\n    return wizardSubstitute\n  }\n\n  /**\n   * Triggers the onFinishing and onFinished event.\n   *\n   * @static\n   * @private\n   * @method finishStep\n   * @param wizard {Object} The jQuery wizard object\n   * @param state {Object} The state container of the current wizard\n   **/\n  function finishStep (wizard, state) {\n    var currentStep = wizard.find('.steps li').eq(state.currentIndex)\n\n    if (wizard.triggerHandler('finishing', [state.currentIndex])) {\n      currentStep.addClass('done').removeClass('error')\n      wizard.triggerHandler('finished', [state.currentIndex])\n    } else {\n      currentStep.addClass('error')\n    }\n  }\n\n  /**\n   * Gets or creates if not exist an unique event namespace for the given wizard instance.\n   *\n   * @static\n   * @private\n   * @method getEventNamespace\n   * @param wizard {Object} A jQuery wizard object\n   * @return {String} Returns the unique event namespace for the given wizard\n   */\n  function getEventNamespace (wizard) {\n    var eventNamespace = wizard.data('eventNamespace')\n\n    if (eventNamespace == null) {\n      eventNamespace = '.' + getUniqueId(wizard)\n      wizard.data('eventNamespace', eventNamespace)\n    }\n\n    return eventNamespace\n  }\n\n  function getStepAnchor (wizard, index) {\n    var uniqueId = getUniqueId(wizard)\n\n    return wizard.find('#' + uniqueId + _tabSuffix + index)\n  }\n\n  function getStepPanel (wizard, index) {\n    var uniqueId = getUniqueId(wizard)\n\n    return wizard.find('#' + uniqueId + _tabpanelSuffix + index)\n  }\n\n  function getStepTitle (wizard, index) {\n    var uniqueId = getUniqueId(wizard)\n\n    return wizard.find('#' + uniqueId + _titleSuffix + index)\n  }\n\n  function getOptions (wizard) {\n    return wizard.data('options')\n  }\n\n  function getState (wizard) {\n    return wizard.data('state')\n  }\n\n  function getSteps (wizard) {\n    return wizard.data('steps')\n  }\n\n  /**\n   * Gets a specific step object by index.\n   *\n   * @static\n   * @private\n   * @method getStep\n   * @param index {Integer} An integer that belongs to the position of a step\n   * @return {Object} A specific step object\n   **/\n  function getStep (wizard, index) {\n    var steps = getSteps(wizard)\n\n    if (index < 0 || index >= steps.length) {\n      throwError(_indexOutOfRangeErrorMessage)\n    }\n\n    return steps[index]\n  }\n\n  /**\n   * Gets or creates if not exist an unique id from the given wizard instance.\n   *\n   * @static\n   * @private\n   * @method getUniqueId\n   * @param wizard {Object} A jQuery wizard object\n   * @return {String} Returns the unique id for the given wizard\n   */\n  function getUniqueId (wizard) {\n    var uniqueId = wizard.data('uid')\n\n    if (uniqueId == null) {\n      uniqueId = wizard._id()\n      if (uniqueId == null) {\n        uniqueId = 'steps-uid-'.concat(_uniqueId)\n        wizard._id(uniqueId)\n      }\n\n      _uniqueId++\n      wizard.data('uid', uniqueId)\n    }\n\n    return uniqueId\n  }\n\n  /**\n   * Gets a valid enum value by checking a specific enum key or value.\n   *\n   * @static\n   * @private\n   * @method getValidEnumValue\n   * @param enumType {Object} Type of enum\n   * @param keyOrValue {Object} Key as `String` or value as `Integer` to check for\n   */\n  function getValidEnumValue (enumType, keyOrValue) {\n    validateArgument('enumType', enumType)\n    validateArgument('keyOrValue', keyOrValue)\n\n    // Is key\n    if (typeof keyOrValue === 'string') {\n      var value = enumType[keyOrValue]\n      if (value === undefined) {\n        throwError(\"The enum key '{0}' does not exist.\", keyOrValue)\n      }\n\n      return value\n    }\n    // Is value\n    else if (typeof keyOrValue === 'number') {\n      for (var key in enumType) {\n        if (enumType[key] === keyOrValue) {\n          return keyOrValue\n        }\n      }\n\n      throwError(\"Invalid enum value '{0}'.\", keyOrValue)\n    }\n    // Type is not supported\n    else {\n      throwError('Invalid key or value type.')\n    }\n  }\n\n  /**\n   * Routes to the next step.\n   *\n   * @static\n   * @private\n   * @method goToNextStep\n   * @param wizard {Object} The jQuery wizard object\n   * @param options {Object} Settings of the current wizard\n   * @param state {Object} The state container of the current wizard\n   * @return {Boolean} Indicates whether the action executed\n   **/\n  function goToNextStep (wizard, options, state) {\n    return paginationClick(wizard, options, state, increaseCurrentIndexBy(state, 1))\n  }\n\n  /**\n   * Routes to the previous step.\n   *\n   * @static\n   * @private\n   * @method goToPreviousStep\n   * @param wizard {Object} The jQuery wizard object\n   * @param options {Object} Settings of the current wizard\n   * @param state {Object} The state container of the current wizard\n   * @return {Boolean} Indicates whether the action executed\n   **/\n  function goToPreviousStep (wizard, options, state) {\n    return paginationClick(wizard, options, state, decreaseCurrentIndexBy(state, 1))\n  }\n\n  /**\n   * Routes to a specific step by a given index.\n   *\n   * @static\n   * @private\n   * @method goToStep\n   * @param wizard {Object} The jQuery wizard object\n   * @param options {Object} Settings of the current wizard\n   * @param state {Object} The state container of the current wizard\n   * @param index {Integer} The position (zero-based) to route to\n   * @return {Boolean} Indicates whether the action succeeded or failed\n   **/\n  function goToStep (wizard, options, state, index) {\n    if (index < 0 || index >= state.stepCount) {\n      throwError(_indexOutOfRangeErrorMessage)\n    }\n\n    if (options.forceMoveForward && index < state.currentIndex) {\n      return\n    }\n\n    var oldIndex = state.currentIndex\n    if (wizard.triggerHandler('stepChanging', [state.currentIndex, index])) {\n      // Save new state\n      state.currentIndex = index\n      saveCurrentStateToCookie(wizard, options, state)\n\n      // Change visualisation\n      refreshStepNavigation(wizard, options, state, oldIndex)\n      refreshPagination(wizard, options, state)\n      loadAsyncContent(wizard, options, state)\n      startTransitionEffect(wizard, options, state, index, oldIndex, function () {\n        wizard.triggerHandler('stepChanged', [index, oldIndex])\n      })\n    } else {\n      wizard\n        .find('.steps li')\n        .eq(oldIndex)\n        .addClass('error')\n    }\n\n    return true\n  }\n\n  function increaseCurrentIndexBy (state, increaseBy) {\n    return state.currentIndex + increaseBy\n  }\n\n  /**\n   * Initializes the component.\n   *\n   * @static\n   * @private\n   * @method initialize\n   * @param options {Object} The component settings\n   **/\n  function initialize (options) {\n    /*jshint -W040 */\n    var opts = $.extend(true, {}, defaults, options)\n\n    return this.each(function () {\n      var wizard = $(this)\n      var state = {\n        currentIndex: opts.startIndex,\n        currentStep: null,\n        stepCount: 0,\n        transitionElement: null\n      }\n\n      // Create data container\n      wizard.data('options', opts)\n      wizard.data('state', state)\n      wizard.data('steps', [])\n\n      analyzeData(wizard, opts, state)\n      render(wizard, opts, state)\n      registerEvents(wizard, opts)\n\n      // Trigger focus\n      if (opts.autoFocus && _uniqueId === 0) {\n        getStepAnchor(wizard, opts.startIndex).focus()\n      }\n\n      wizard.triggerHandler('init', [opts.startIndex])\n    })\n  }\n\n  /**\n   * Inserts a new step to a specific position.\n   *\n   * @static\n   * @private\n   * @method insertStep\n   * @param wizard {Object} The jQuery wizard object\n   * @param options {Object} Settings of the current wizard\n   * @param state {Object} The state container of the current wizard\n   * @param index {Integer} The position (zero-based) to add\n   * @param step {Object} The step object to add\n   * @example\n   *     $(\"#wizard\").steps().insert(0, {\n   *         title: \"Title\",\n   *         content: \"\", // optional\n   *         contentMode: \"async\", // optional\n   *         contentUrl: \"/Content/Step/1\" // optional\n   *     });\n   * @chainable\n   **/\n  function insertStep (wizard, options, state, index, step) {\n    if (index < 0 || index > state.stepCount) {\n      throwError(_indexOutOfRangeErrorMessage)\n    }\n\n    // TODO: Validate step object\n\n    // Change data\n    step = $.extend({}, stepModel, step)\n    insertStepToCache(wizard, index, step)\n    if (state.currentIndex !== state.stepCount && state.currentIndex >= index) {\n      state.currentIndex++\n      saveCurrentStateToCookie(wizard, options, state)\n    }\n    state.stepCount++\n\n    var contentContainer = wizard.find('.content'),\n      header = $('<{0}>{1}</{0}>'.format(options.headerTag, step.title)),\n      body = $('<{0}></{0}>'.format(options.bodyTag))\n\n    if (step.contentMode == null || step.contentMode === contentMode.html) {\n      body.html(step.content)\n    }\n\n    if (index === 0) {\n      contentContainer.prepend(body).prepend(header)\n    } else {\n      getStepPanel(wizard, index - 1)\n        .after(body)\n        .after(header)\n    }\n\n    renderBody(wizard, state, body, index)\n    renderTitle(wizard, options, state, header, index)\n    refreshSteps(wizard, options, state, index)\n    if (index === state.currentIndex) {\n      refreshStepNavigation(wizard, options, state)\n    }\n    refreshPagination(wizard, options, state)\n\n    return wizard\n  }\n\n  /**\n   * Inserts a step object to the cache at a specific position.\n   *\n   * @static\n   * @private\n   * @method insertStepToCache\n   * @param wizard {Object} A jQuery wizard object\n   * @param index {Integer} The position (zero-based) to add\n   * @param step {Object} The step object to add\n   **/\n  function insertStepToCache (wizard, index, step) {\n    getSteps(wizard).splice(index, 0, step)\n  }\n\n  /**\n   * Handles the keyup DOM event for pagination.\n   *\n   * @static\n   * @private\n   * @event keyup\n   * @param event {Object} An event object\n   */\n  function keyUpHandler (event) {\n    var wizard = $(this),\n      options = getOptions(wizard),\n      state = getState(wizard)\n\n    if (options.suppressPaginationOnFocus && wizard.find(':focus').is(':input')) {\n      event.preventDefault()\n      return false\n    }\n\n    var keyCodes = { left: 37, right: 39 }\n    if (event.keyCode === keyCodes.left) {\n      event.preventDefault()\n      goToPreviousStep(wizard, options, state)\n    } else if (event.keyCode === keyCodes.right) {\n      event.preventDefault()\n      goToNextStep(wizard, options, state)\n    }\n  }\n\n  /**\n   * Loads and includes async content.\n   *\n   * @static\n   * @private\n   * @method loadAsyncContent\n   * @param wizard {Object} A jQuery wizard object\n   * @param options {Object} Settings of the current wizard\n   * @param state {Object} The state container of the current wizard\n   */\n  function loadAsyncContent (wizard, options, state) {\n    if (state.stepCount > 0) {\n      var currentIndex = state.currentIndex,\n        currentStep = getStep(wizard, currentIndex)\n\n      if (!options.enableContentCache || !currentStep.contentLoaded) {\n        switch (getValidEnumValue(contentMode, currentStep.contentMode)) {\n          case contentMode.iframe:\n            wizard\n              .find('.content > .body')\n              .eq(state.currentIndex)\n              .empty()\n              .html('<iframe src=\"' + currentStep.contentUrl + '\" frameborder=\"0\" scrolling=\"no\" />')\n              .data('loaded', '1')\n            break\n\n          case contentMode.async:\n            var currentStepContent = getStepPanel(wizard, currentIndex)\n              ._aria('busy', 'true')\n              .empty()\n              .append(renderTemplate(options.loadingTemplate, { text: options.labels.loading }))\n\n            $.ajax({ url: currentStep.contentUrl, cache: false }).done(function (data) {\n              currentStepContent\n                .empty()\n                .html(data)\n                ._aria('busy', 'false')\n                .data('loaded', '1')\n              wizard.triggerHandler('contentLoaded', [currentIndex])\n            })\n            break\n        }\n      }\n    }\n  }\n\n  /**\n   * Fires the action next or previous click event.\n   *\n   * @static\n   * @private\n   * @method paginationClick\n   * @param wizard {Object} The jQuery wizard object\n   * @param options {Object} Settings of the current wizard\n   * @param state {Object} The state container of the current wizard\n   * @param index {Integer} The position (zero-based) to route to\n   * @return {Boolean} Indicates whether the event fired successfully or not\n   **/\n  function paginationClick (wizard, options, state, index) {\n    var oldIndex = state.currentIndex\n\n    if (index >= 0 && index < state.stepCount && !(options.forceMoveForward && index < state.currentIndex)) {\n      var anchor = getStepAnchor(wizard, index),\n        parent = anchor.parent(),\n        isDisabled = parent.hasClass('disabled')\n\n      // Enable the step to make the anchor clickable!\n      parent._enableAria()\n      anchor.click()\n\n      // An error occured\n      if (oldIndex === state.currentIndex && isDisabled) {\n        // Disable the step again if current index has not changed; prevents click action.\n        parent._enableAria(false)\n        return false\n      }\n\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * Fires when a pagination click happens.\n   *\n   * @static\n   * @private\n   * @event click\n   * @param event {Object} An event object\n   */\n  function paginationClickHandler (event) {\n    event.preventDefault()\n\n    var anchor = $(this),\n      wizard = anchor\n        .parent()\n        .parent()\n        .parent()\n        .parent(),\n      options = getOptions(wizard),\n      state = getState(wizard),\n      href = anchor.attr('href')\n\n    if (anchor.parent().hasClass('disabled')) return false\n\n    switch (href.substring(href.lastIndexOf('#') + 1)) {\n      case 'cancel':\n        cancel(wizard)\n        break\n\n      case 'finish':\n        finishStep(wizard, state)\n        break\n\n      case 'next':\n        goToNextStep(wizard, options, state)\n        break\n\n      case 'previous':\n        goToPreviousStep(wizard, options, state)\n        break\n    }\n\n    return false\n  }\n\n  /**\n   * Refreshs the visualization state for the entire pagination.\n   *\n   * @static\n   * @private\n   * @method refreshPagination\n   * @param wizard {Object} A jQuery wizard object\n   * @param options {Object} Settings of the current wizard\n   * @param state {Object} The state container of the current wizard\n   */\n  function refreshPagination (wizard, options, state) {\n    if (options.enablePagination) {\n      var finish = wizard.find(\".actions a[href$='#finish']\").parent(),\n        next = wizard.find(\".actions a[href$='#next']\").parent()\n\n      if (!options.forceMoveForward) {\n        var previous = wizard.find(\".actions a[href$='#previous']\").parent()\n        previous._enableAria(state.currentIndex > 0)\n      }\n\n      if (options.enableFinishButton && options.showFinishButtonAlways) {\n        finish._enableAria(state.stepCount > 0)\n        next._enableAria(state.stepCount > 1 && state.stepCount > state.currentIndex + 1)\n      } else {\n        finish._showAria(options.enableFinishButton && state.stepCount === state.currentIndex + 1)\n        next\n          ._showAria(state.stepCount === 0 || state.stepCount > state.currentIndex + 1)\n          ._enableAria(state.stepCount > state.currentIndex + 1 || !options.enableFinishButton)\n      }\n    }\n  }\n\n  /**\n   * Refreshs the visualization state for the step navigation (tabs).\n   *\n   * @static\n   * @private\n   * @method refreshStepNavigation\n   * @param wizard {Object} A jQuery wizard object\n   * @param options {Object} Settings of the current wizard\n   * @param state {Object} The state container of the current wizard\n   * @param [oldIndex] {Integer} The index of the prior step\n   */\n  function refreshStepNavigation (wizard, options, state, oldIndex) {\n    var currentOrNewStepAnchor = getStepAnchor(wizard, state.currentIndex),\n      currentInfo = $('<span class=\"current-info audible\">' + options.labels.current + ' </span>'),\n      stepTitles = wizard.find('.content > .title')\n\n    if (oldIndex != null) {\n      var oldStepAnchor = getStepAnchor(wizard, oldIndex)\n      oldStepAnchor\n        .parent()\n        .addClass('done')\n        .removeClass('error')\n        ._selectAria(false)\n      stepTitles\n        .eq(oldIndex)\n        .removeClass('current')\n        .next('.body')\n        .removeClass('current')\n      currentInfo = oldStepAnchor.find('.current-info')\n      currentOrNewStepAnchor.focus()\n    }\n\n    currentOrNewStepAnchor\n      .prepend(currentInfo)\n      .parent()\n      ._selectAria()\n      .removeClass('done')\n      ._enableAria()\n    stepTitles\n      .eq(state.currentIndex)\n      .addClass('current')\n      .next('.body')\n      .addClass('current')\n  }\n\n  /**\n   * Refreshes step buttons and their related titles beyond a certain position.\n   *\n   * @static\n   * @private\n   * @method refreshSteps\n   * @param wizard {Object} A jQuery wizard object\n   * @param options {Object} Settings of the current wizard\n   * @param state {Object} The state container of the current wizard\n   * @param index {Integer} The start point for refreshing ids\n   */\n  function refreshSteps (wizard, options, state, index) {\n    var uniqueId = getUniqueId(wizard)\n\n    for (var i = index; i < state.stepCount; i++) {\n      var uniqueStepId = uniqueId + _tabSuffix + i,\n        uniqueBodyId = uniqueId + _tabpanelSuffix + i,\n        uniqueHeaderId = uniqueId + _titleSuffix + i,\n        title = wizard\n          .find('.title')\n          .eq(i)\n          ._id(uniqueHeaderId)\n\n      wizard\n        .find('.steps a')\n        .eq(i)\n        ._id(uniqueStepId)\n        ._aria('controls', uniqueBodyId)\n        .attr('href', '#' + uniqueHeaderId)\n        .html(renderTemplate(options.titleTemplate, { index: i + 1, title: title.html() }))\n      wizard\n        .find('.body')\n        .eq(i)\n        ._id(uniqueBodyId)\n        ._aria('labelledby', uniqueHeaderId)\n    }\n  }\n\n  function registerEvents (wizard, options) {\n    var eventNamespace = getEventNamespace(wizard)\n\n    wizard.bind('canceled' + eventNamespace, options.onCanceled)\n    wizard.bind('contentLoaded' + eventNamespace, options.onContentLoaded)\n    wizard.bind('finishing' + eventNamespace, options.onFinishing)\n    wizard.bind('finished' + eventNamespace, options.onFinished)\n    wizard.bind('init' + eventNamespace, options.onInit)\n    wizard.bind('stepChanging' + eventNamespace, options.onStepChanging)\n    wizard.bind('stepChanged' + eventNamespace, options.onStepChanged)\n\n    if (options.enableKeyNavigation) {\n      wizard.bind('keyup' + eventNamespace, keyUpHandler)\n    }\n\n    wizard.find('.actions a').bind('click' + eventNamespace, paginationClickHandler)\n  }\n\n  /**\n   * Removes a specific step by an given index.\n   *\n   * @static\n   * @private\n   * @method removeStep\n   * @param wizard {Object} A jQuery wizard object\n   * @param options {Object} Settings of the current wizard\n   * @param state {Object} The state container of the current wizard\n   * @param index {Integer} The position (zero-based) of the step to remove\n   * @return Indecates whether the item is removed.\n   **/\n  function removeStep (wizard, options, state, index) {\n    // Index out of range and try deleting current item will return false.\n    if (index < 0 || index >= state.stepCount || state.currentIndex === index) {\n      return false\n    }\n\n    // Change data\n    removeStepFromCache(wizard, index)\n    if (state.currentIndex > index) {\n      state.currentIndex--\n      saveCurrentStateToCookie(wizard, options, state)\n    }\n    state.stepCount--\n\n    getStepTitle(wizard, index).remove()\n    getStepPanel(wizard, index).remove()\n    getStepAnchor(wizard, index)\n      .parent()\n      .remove()\n\n    // Set the \"first\" class to the new first step button\n    if (index === 0) {\n      wizard\n        .find('.steps li')\n        .first()\n        .addClass('first')\n    }\n\n    // Set the \"last\" class to the new last step button\n    if (index === state.stepCount) {\n      wizard\n        .find('.steps li')\n        .eq(index)\n        .addClass('last')\n    }\n\n    refreshSteps(wizard, options, state, index)\n    refreshPagination(wizard, options, state)\n\n    return true\n  }\n\n  function removeStepFromCache (wizard, index) {\n    getSteps(wizard).splice(index, 1)\n  }\n\n  /**\n   * Transforms the base html structure to a more sensible html structure.\n   *\n   * @static\n   * @private\n   * @method render\n   * @param wizard {Object} A jQuery wizard object\n   * @param options {Object} Settings of the current wizard\n   * @param state {Object} The state container of the current wizard\n   **/\n  function render (wizard, options, state) {\n    // Create a content wrapper and copy HTML from the intial wizard structure\n    var wrapperTemplate = '<{0} class=\"{1}\">{2}</{0}>',\n      orientation = getValidEnumValue(stepsOrientation, options.stepsOrientation),\n      verticalCssClass = orientation === stepsOrientation.vertical ? ' vertical' : '',\n      contentWrapper = $(\n        wrapperTemplate.format(options.contentContainerTag, 'content ' + options.clearFixCssClass, wizard.html())\n      ),\n      stepsWrapper = $(\n        wrapperTemplate.format(\n          options.stepsContainerTag,\n          'steps ' + options.clearFixCssClass,\n          '<ul role=\"tablist\"></ul>'\n        )\n      ),\n      stepTitles = contentWrapper.children(options.headerTag),\n      stepContents = contentWrapper.children(options.bodyTag)\n\n    // Transform the wizard wrapper and remove the inner HTML\n    wizard\n      .attr('role', 'application')\n      .empty()\n      .append(stepsWrapper)\n      .append(contentWrapper)\n      .addClass(options.cssClass + ' ' + options.clearFixCssClass + verticalCssClass)\n\n    // Add WIA-ARIA support\n    stepContents.each(function (index) {\n      renderBody(wizard, state, $(this), index)\n    })\n\n    stepTitles.each(function (index) {\n      renderTitle(wizard, options, state, $(this), index)\n    })\n\n    refreshStepNavigation(wizard, options, state)\n    renderPagination(wizard, options, state)\n  }\n\n  /**\n   * Transforms the body to a proper tabpanel.\n   *\n   * @static\n   * @private\n   * @method renderBody\n   * @param wizard {Object} A jQuery wizard object\n   * @param body {Object} A jQuery body object\n   * @param index {Integer} The position of the body\n   */\n  function renderBody (wizard, state, body, index) {\n    var uniqueId = getUniqueId(wizard),\n      uniqueBodyId = uniqueId + _tabpanelSuffix + index,\n      uniqueHeaderId = uniqueId + _titleSuffix + index\n\n    body\n      ._id(uniqueBodyId)\n      .attr('role', 'tabpanel')\n      ._aria('labelledby', uniqueHeaderId)\n      .addClass('body' + ' step-' + index)\n      .attr('data-step', index)\n      ._showAria(state.currentIndex === index)\n  }\n\n  /**\n   * Renders a pagination if enabled.\n   *\n   * @static\n   * @private\n   * @method renderPagination\n   * @param wizard {Object} A jQuery wizard object\n   * @param options {Object} Settings of the current wizard\n   * @param state {Object} The state container of the current wizard\n   */\n  function renderPagination (wizard, options, state) {\n    if (options.enablePagination) {\n      var pagination = '<{0} class=\"actions no-ajaxy {1}\"><ul role=\"menu\" aria-label=\"{2}\">{3}</ul></{0}>',\n        buttonTemplate = '<li class=\"button_{0} no-ajaxy\"><a href=\"#{0}\" role=\"menuitem\" class=\"no-ajaxy\">{1}</a></li>',\n        buttons = ''\n\n      if (!options.forceMoveForward) {\n        buttons += buttonTemplate.format('previous', options.labels.previous)\n      }\n\n      buttons += buttonTemplate.format('next', options.labels.next)\n\n      if (options.enableFinishButton) {\n        buttons += buttonTemplate.format('finish', options.labels.finish)\n      }\n\n      if (options.enableCancelButton) {\n        buttons += buttonTemplate.format('cancel', options.labels.cancel)\n      }\n\n      wizard.append(\n        pagination.format(options.actionContainerTag, options.clearFixCssClass, options.labels.pagination, buttons)\n      )\n\n      refreshPagination(wizard, options, state)\n      loadAsyncContent(wizard, options, state)\n    }\n  }\n\n  /**\n   * Renders a template and replaces all placeholder.\n   *\n   * @static\n   * @private\n   * @method renderTemplate\n   * @param template {String} A template\n   * @param substitutes {Object} A list of substitute\n   * @return {String} The rendered template\n   */\n  function renderTemplate (template, substitutes) {\n    var matches = template.match(/#([a-z]*)#/gi)\n\n    for (var i = 0; i < matches.length; i++) {\n      var match = matches[i],\n        key = match.substring(1, match.length - 1)\n\n      if (substitutes[key] === undefined) {\n        throwError(\"The key '{0}' does not exist in the substitute collection!\", key)\n      }\n\n      template = template.replace(match, substitutes[key])\n    }\n\n    return template\n  }\n\n  /**\n   * Transforms the title to a step item button.\n   *\n   * @static\n   * @private\n   * @method renderTitle\n   * @param wizard {Object} A jQuery wizard object\n   * @param options {Object} Settings of the current wizard\n   * @param state {Object} The state container of the current wizard\n   * @param header {Object} A jQuery header object\n   * @param index {Integer} The position of the header\n   */\n  function renderTitle (wizard, options, state, header, index) {\n    var uniqueId = getUniqueId(wizard),\n      uniqueStepId = uniqueId + _tabSuffix + index,\n      uniqueBodyId = uniqueId + _tabpanelSuffix + index,\n      uniqueHeaderId = uniqueId + _titleSuffix + index,\n      stepCollection = wizard.find('.steps > ul'),\n      title = renderTemplate(options.titleTemplate, {\n        index: index + 1,\n        title: header.html()\n      }),\n      stepItem = $(\n        '<li role=\"tab\"><a id=\"' +\n          uniqueStepId +\n          '\" href=\"#' +\n          uniqueHeaderId +\n          '\" aria-controls=\"' +\n          uniqueBodyId +\n          '\" class=\"no-ajaxy\">' +\n          title +\n          '</a></li>'\n      )\n\n    stepItem._enableAria(options.enableAllSteps || state.currentIndex > index)\n\n    if (state.currentIndex > index) {\n      stepItem.addClass('done')\n    }\n\n    header\n      ._id(uniqueHeaderId)\n      .attr('tabindex', '-1')\n      .addClass('title')\n\n    if (index === 0) {\n      stepCollection.prepend(stepItem)\n    } else {\n      stepCollection\n        .find('li')\n        .eq(index - 1)\n        .after(stepItem)\n    }\n\n    // Set the \"first\" class to the new first step button\n    if (index === 0) {\n      stepCollection\n        .find('li')\n        .removeClass('first')\n        .eq(index)\n        .addClass('first')\n    }\n\n    // Set the \"last\" class to the new last step button\n    if (index === state.stepCount - 1) {\n      stepCollection\n        .find('li')\n        .removeClass('last')\n        .eq(index)\n        .addClass('last')\n    }\n\n    // Register click event\n    stepItem.children('a').bind('click' + getEventNamespace(wizard), stepClickHandler)\n  }\n\n  /**\n   * Saves the current state to a cookie.\n   *\n   * @static\n   * @private\n   * @method saveCurrentStateToCookie\n   * @param wizard {Object} A jQuery wizard object\n   * @param options {Object} Settings of the current wizard\n   * @param state {Object} The state container of the current wizard\n   */\n  function saveCurrentStateToCookie (wizard, options, state) {\n    if (options.saveState && $.cookie) {\n      $.cookie(_cookiePrefix + getUniqueId(wizard), state.currentIndex)\n    }\n  }\n\n  function startTransitionEffect (wizard, options, state, index, oldIndex, doneCallback) {\n    var stepContents = wizard.find('.content > .body'),\n      effect = getValidEnumValue(transitionEffect, options.transitionEffect),\n      effectSpeed = options.transitionEffectSpeed,\n      newStep = stepContents.eq(index),\n      currentStep = stepContents.eq(oldIndex)\n\n    switch (effect) {\n      case transitionEffect.fade:\n      case transitionEffect.slide:\n        var hide = effect === transitionEffect.fade ? 'fadeOut' : 'slideUp',\n          show = effect === transitionEffect.fade ? 'fadeIn' : 'slideDown'\n\n        state.transitionElement = newStep\n        currentStep[hide](effectSpeed, function () {\n          var wizard = $(this)\n              ._showAria(false)\n              .parent()\n              .parent(),\n            state = getState(wizard)\n\n          if (state.transitionElement) {\n            state.transitionElement[show](effectSpeed, function () {\n              $(this)._showAria()\n            })\n              .promise()\n              .done(doneCallback)\n            state.transitionElement = null\n          }\n        })\n        break\n\n      case transitionEffect.slideLeft:\n        var outerWidth = currentStep.outerWidth(true),\n          posFadeOut = index > oldIndex ? -outerWidth : outerWidth,\n          posFadeIn = index > oldIndex ? outerWidth : -outerWidth\n\n        $.when(\n          currentStep.animate({ left: posFadeOut }, effectSpeed, function () {\n            $(this)._showAria(false)\n          }),\n          newStep\n            .css('left', posFadeIn + 'px')\n            ._showAria()\n            .animate({ left: 0 }, effectSpeed)\n        ).done(doneCallback)\n        break\n\n      default:\n        $.when(currentStep._showAria(false), newStep._showAria()).done(doneCallback)\n        break\n    }\n  }\n\n  /**\n   * Fires when a step click happens.\n   *\n   * @static\n   * @private\n   * @event click\n   * @param event {Object} An event object\n   */\n  function stepClickHandler (event) {\n    event.preventDefault()\n\n    var anchor = $(this),\n      wizard = anchor\n        .parent()\n        .parent()\n        .parent()\n        .parent(),\n      options = getOptions(wizard),\n      state = getState(wizard),\n      oldIndex = state.currentIndex\n\n    if (anchor.parent().is(':not(.disabled):not(.current)')) {\n      var href = anchor.attr('href'),\n        position = parseInt(href.substring(href.lastIndexOf('-') + 1), 0)\n\n      goToStep(wizard, options, state, position)\n    }\n\n    // If nothing has changed\n    if (oldIndex === state.currentIndex) {\n      getStepAnchor(wizard, oldIndex).focus()\n      return false\n    }\n\n    return false\n  }\n\n  function throwError (message) {\n    if (arguments.length > 1) {\n      message = message.format(Array.prototype.slice.call(arguments, 1))\n    }\n\n    throw new Error(message)\n  }\n\n  /**\n   * Checks an argument for null or undefined and throws an error if one check applies.\n   *\n   * @static\n   * @private\n   * @method validateArgument\n   * @param argumentName {String} The name of the given argument\n   * @param argumentValue {Object} The argument itself\n   */\n  function validateArgument (argumentName, argumentValue) {\n    if (argumentValue == null) {\n      throwError(\"The argument '{0}' is null or undefined.\", argumentName)\n    }\n  }\n\n  /**\n   * Represents a jQuery wizard plugin.\n   *\n   * @class steps\n   * @constructor\n   * @param [method={}] The name of the method as `String` or an JSON object for initialization\n   * @param [params=]* {Array} Additional arguments for a method call\n   * @chainable\n   **/\n  $.fn.steps = function (method) {\n    if ($.fn.steps[method]) {\n      return $.fn.steps[method].apply(this, Array.prototype.slice.call(arguments, 1))\n    } else if (typeof method === 'object' || !method) {\n      return initialize.apply(this, arguments)\n    } else {\n      $.error('Method ' + method + ' does not exist on jQuery.steps')\n    }\n  }\n\n  /**\n   * Adds a new step.\n   *\n   * @method add\n   * @param step {Object} The step object to add\n   * @chainable\n   **/\n  $.fn.steps.add = function (step) {\n    var state = getState(this)\n    return insertStep(this, getOptions(this), state, state.stepCount, step)\n  }\n\n  /**\n   * Gets the step count.\n   *\n   * @method count\n   * @return {Integer} step count\n   * @for steps\n   **/\n  $.fn.steps.count = function () {\n    var state = getState(this)\n    return state.stepCount\n  }\n\n  /**\n   * Removes the control functionality completely and transforms the current state to the initial HTML structure.\n   *\n   * @method destroy\n   * @chainable\n   **/\n  $.fn.steps.destroy = function () {\n    return destroy(this, getOptions(this))\n  }\n\n  /**\n   * Triggers the onFinishing and onFinished event.\n   *\n   * @method finish\n   **/\n  $.fn.steps.finish = function () {\n    finishStep(this, getState(this))\n  }\n\n  /**\n   * Gets the current step index.\n   *\n   * @method getCurrentIndex\n   * @return {Integer} The actual step index (zero-based)\n   * @for steps\n   **/\n  $.fn.steps.getCurrentIndex = function () {\n    return getState(this).currentIndex\n  }\n\n  /**\n   * Gets the current step object.\n   *\n   * @method getCurrentStep\n   * @return {Object} The actual step object\n   **/\n  $.fn.steps.getCurrentStep = function () {\n    return getStep(this, getState(this).currentIndex)\n  }\n\n  /**\n   * Gets a specific step object by index.\n   *\n   * @method getStep\n   * @param index {Integer} An integer that belongs to the position of a step\n   * @return {Object} A specific step object\n   **/\n  $.fn.steps.getStep = function (index) {\n    return getStep(this, index)\n  }\n\n  /**\n   * Inserts a new step to a specific position.\n   *\n   * @method insert\n   * @param index {Integer} The position (zero-based) to add\n   * @param step {Object} The step object to add\n   * @example\n   *     $(\"#wizard\").steps().insert(0, {\n   *         title: \"Title\",\n   *         content: \"\", // optional\n   *         contentMode: \"async\", // optional\n   *         contentUrl: \"/Content/Step/1\" // optional\n   *     });\n   * @chainable\n   **/\n  $.fn.steps.insert = function (index, step) {\n    return insertStep(this, getOptions(this), getState(this), index, step)\n  }\n\n  /**\n   * Routes to the next step.\n   *\n   * @method next\n   * @return {Boolean} Indicates whether the action executed\n   **/\n  $.fn.steps.next = function () {\n    return goToNextStep(this, getOptions(this), getState(this))\n  }\n\n  /**\n   * Routes to the previous step.\n   *\n   * @method previous\n   * @return {Boolean} Indicates whether the action executed\n   **/\n  $.fn.steps.previous = function () {\n    return goToPreviousStep(this, getOptions(this), getState(this))\n  }\n\n  /**\n   * Removes a specific step by an given index.\n   *\n   * @method remove\n   * @param index {Integer} The position (zero-based) of the step to remove\n   * @return Indecates whether the item is removed.\n   **/\n  $.fn.steps.remove = function (index) {\n    return removeStep(this, getOptions(this), getState(this), index)\n  }\n\n  /**\n   * Sets a specific step object by index.\n   *\n   * @method setStep\n   * @param index {Integer} An integer that belongs to the position of a step\n   **/\n  $.fn.steps.setStep = function (index) {\n    var options = getOptions(this),\n      state = getState(this)\n    return goToStep(this, options, state, index)\n  }\n\n  /**\n   * Skips an certain amount of steps.\n   *\n   * @method skip\n   * @param count {Integer} The amount of steps that should be skipped\n   * @return {Boolean} Indicates whether the action executed\n   **/\n  $.fn.steps.skip = function (count) {\n    throw new Error('Not yet implemented!')\n  }\n\n  /**\n   * An enum represents the different content types of a step and their loading mechanisms.\n   *\n   * @class contentMode\n   * @for steps\n   **/\n  var contentMode = ($.fn.steps.contentMode = {\n    /**\n     * HTML embedded content\n     *\n     * @readOnly\n     * @property html\n     * @type Integer\n     * @for contentMode\n     **/\n    html: 0,\n\n    /**\n     * IFrame embedded content\n     *\n     * @readOnly\n     * @property iframe\n     * @type Integer\n     * @for contentMode\n     **/\n    iframe: 1,\n\n    /**\n     * Async embedded content\n     *\n     * @readOnly\n     * @property async\n     * @type Integer\n     * @for contentMode\n     **/\n    async: 2\n  })\n\n  /**\n   * An enum represents the orientation of the steps navigation.\n   *\n   * @class stepsOrientation\n   * @for steps\n   **/\n  var stepsOrientation = ($.fn.steps.stepsOrientation = {\n    /**\n     * Horizontal orientation\n     *\n     * @readOnly\n     * @property horizontal\n     * @type Integer\n     * @for stepsOrientation\n     **/\n    horizontal: 0,\n\n    /**\n     * Vertical orientation\n     *\n     * @readOnly\n     * @property vertical\n     * @type Integer\n     * @for stepsOrientation\n     **/\n    vertical: 1\n  })\n\n  /**\n   * An enum that represents the various transition animations.\n   *\n   * @class transitionEffect\n   * @for steps\n   **/\n  var transitionEffect = ($.fn.steps.transitionEffect = {\n    /**\n     * No transition animation\n     *\n     * @readOnly\n     * @property none\n     * @type Integer\n     * @for transitionEffect\n     **/\n    none: 0,\n\n    /**\n     * Fade in transition\n     *\n     * @readOnly\n     * @property fade\n     * @type Integer\n     * @for transitionEffect\n     **/\n    fade: 1,\n\n    /**\n     * Slide up transition\n     *\n     * @readOnly\n     * @property slide\n     * @type Integer\n     * @for transitionEffect\n     **/\n    slide: 2,\n\n    /**\n     * Slide left transition\n     *\n     * @readOnly\n     * @property slideLeft\n     * @type Integer\n     * @for transitionEffect\n     **/\n    slideLeft: 3\n  })\n\n  var stepModel = ($.fn.steps.stepModel = {\n    title: '',\n    content: '',\n    contentUrl: '',\n    contentMode: contentMode.html,\n    contentLoaded: false\n  })\n\n  /**\n   * An object that represents the default settings.\n   * There are two possibities to override the sub-properties.\n   * Either by doing it generally (global) or on initialization.\n   *\n   * @static\n   * @class defaults\n   * @for steps\n   * @example\n   *   // Global approach\n   *   $.steps.defaults.headerTag = \"h3\";\n   * @example\n   *   // Initialization approach\n   *   $(\"#wizard\").steps({ headerTag: \"h3\" });\n   **/\n  var defaults = ($.fn.steps.defaults = {\n    /**\n     * The header tag is used to find the step button text within the declared wizard area.\n     *\n     * @property headerTag\n     * @type String\n     * @default \"h1\"\n     * @for defaults\n     **/\n    headerTag: 'h1',\n\n    /**\n     * The body tag is used to find the step content within the declared wizard area.\n     *\n     * @property bodyTag\n     * @type String\n     * @default \"div\"\n     * @for defaults\n     **/\n    bodyTag: 'div',\n\n    /**\n     * The content container tag which will be used to wrap all step contents.\n     *\n     * @property contentContainerTag\n     * @type String\n     * @default \"div\"\n     * @for defaults\n     **/\n    contentContainerTag: 'div',\n\n    /**\n     * The action container tag which will be used to wrap the pagination navigation.\n     *\n     * @property actionContainerTag\n     * @type String\n     * @default \"div\"\n     * @for defaults\n     **/\n    actionContainerTag: 'div',\n\n    /**\n     * The steps container tag which will be used to wrap the steps navigation.\n     *\n     * @property stepsContainerTag\n     * @type String\n     * @default \"div\"\n     * @for defaults\n     **/\n    stepsContainerTag: 'div',\n\n    /**\n     * The css class which will be added to the outer component wrapper.\n     *\n     * @property cssClass\n     * @type String\n     * @default \"wizard\"\n     * @for defaults\n     * @example\n     *     <div class=\"wizard\">\n     *         ...\n     *     </div>\n     **/\n    cssClass: 'wizard',\n\n    /**\n     * The css class which will be used for floating scenarios.\n     *\n     * @property clearFixCssClass\n     * @type String\n     * @default \"clearfix\"\n     * @for defaults\n     **/\n    clearFixCssClass: 'clearfix',\n\n    /**\n     * Determines whether the steps are vertically or horizontally oriented.\n     *\n     * @property stepsOrientation\n     * @type stepsOrientation\n     * @default horizontal\n     * @for defaults\n     * @since 1.0.0\n     **/\n    stepsOrientation: stepsOrientation.horizontal,\n\n    /*\n     * Tempplates\n     */\n\n    /**\n     * The title template which will be used to create a step button.\n     *\n     * @property titleTemplate\n     * @type String\n     * @default \"<span class=\\\"number\\\">#index#.</span> #title#\"\n     * @for defaults\n     **/\n    titleTemplate: '<span class=\"number\">#index#</span> <span class=\\'title\\'>#title#</span>',\n\n    /**\n     * The loading template which will be used to create the loading animation.\n     *\n     * @property loadingTemplate\n     * @type String\n     * @default \"<span class=\\\"spinner\\\"></span> #text#\"\n     * @for defaults\n     **/\n    loadingTemplate: '<span class=\"spinner\"></span> #text#',\n\n    /*\n     * Behaviour\n     */\n\n    /**\n     * Sets the focus to the first wizard instance in order to enable the key navigation from the begining if `true`.\n     *\n     * @property autoFocus\n     * @type Boolean\n     * @default false\n     * @for defaults\n     * @since 0.9.4\n     **/\n    autoFocus: false,\n\n    /**\n     * Enables all steps from the begining if `true` (all steps are clickable).\n     *\n     * @property enableAllSteps\n     * @type Boolean\n     * @default false\n     * @for defaults\n     **/\n    enableAllSteps: false,\n\n    /**\n     * Enables keyboard navigation if `true` (arrow left and arrow right).\n     *\n     * @property enableKeyNavigation\n     * @type Boolean\n     * @default true\n     * @for defaults\n     **/\n    enableKeyNavigation: true,\n\n    /**\n     * Enables pagination if `true`.\n     *\n     * @property enablePagination\n     * @type Boolean\n     * @default true\n     * @for defaults\n     **/\n    enablePagination: true,\n\n    /**\n     * Suppresses pagination if a form field is focused.\n     *\n     * @property suppressPaginationOnFocus\n     * @type Boolean\n     * @default true\n     * @for defaults\n     **/\n    suppressPaginationOnFocus: true,\n\n    /**\n     * Enables cache for async loaded or iframe embedded content.\n     *\n     * @property enableContentCache\n     * @type Boolean\n     * @default true\n     * @for defaults\n     **/\n    enableContentCache: true,\n\n    /**\n     * Shows the cancel button if enabled.\n     *\n     * @property enableCancelButton\n     * @type Boolean\n     * @default false\n     * @for defaults\n     **/\n    enableCancelButton: false,\n\n    /**\n     * Shows the finish button if enabled.\n     *\n     * @property enableFinishButton\n     * @type Boolean\n     * @default true\n     * @for defaults\n     **/\n    enableFinishButton: true,\n\n    /**\n     * Not yet implemented.\n     *\n     * @property preloadContent\n     * @type Boolean\n     * @default false\n     * @for defaults\n     **/\n    preloadContent: false,\n\n    /**\n     * Shows the finish button always (on each step; right beside the next button) if `true`.\n     * Otherwise the next button will be replaced by the finish button if the last step becomes active.\n     *\n     * @property showFinishButtonAlways\n     * @type Boolean\n     * @default false\n     * @for defaults\n     **/\n    showFinishButtonAlways: false,\n\n    /**\n     * Prevents jumping to a previous step.\n     *\n     * @property forceMoveForward\n     * @type Boolean\n     * @default false\n     * @for defaults\n     **/\n    forceMoveForward: false,\n\n    /**\n     * Saves the current state (step position) to a cookie.\n     * By coming next time the last active step becomes activated.\n     *\n     * @property saveState\n     * @type Boolean\n     * @default false\n     * @for defaults\n     **/\n    saveState: false,\n\n    /**\n     * The position to start on (zero-based).\n     *\n     * @property startIndex\n     * @type Integer\n     * @default 0\n     * @for defaults\n     **/\n    startIndex: 0,\n\n    /*\n     * Animation Effect Configuration\n     */\n\n    /**\n     * The animation effect which will be used for step transitions.\n     *\n     * @property transitionEffect\n     * @type transitionEffect\n     * @default none\n     * @for defaults\n     **/\n    transitionEffect: transitionEffect.none,\n\n    /**\n     * Animation speed for step transitions (in milliseconds).\n     *\n     * @property transitionEffectSpeed\n     * @type Integer\n     * @default 200\n     * @for defaults\n     **/\n    transitionEffectSpeed: 280,\n\n    /*\n     * Events\n     */\n\n    /**\n     * Fires before the step changes and can be used to prevent step changing by returning `false`.\n     * Very useful for form validation.\n     *\n     * @property onStepChanging\n     * @type Event\n     * @default function (event, currentIndex, newIndex) { return true; }\n     * @for defaults\n     **/\n    onStepChanging: function (event, currentIndex, newIndex) {\n      return true\n    },\n\n    /**\n     * Fires after the step has change.\n     *\n     * @property onStepChanged\n     * @type Event\n     * @default function (event, currentIndex, priorIndex) { }\n     * @for defaults\n     **/\n    onStepChanged: function (event, currentIndex, priorIndex) {},\n\n    /**\n     * Fires after cancelation.\n     *\n     * @property onCanceled\n     * @type Event\n     * @default function (event) { }\n     * @for defaults\n     **/\n    onCanceled: function (event) {},\n\n    /**\n     * Fires before finishing and can be used to prevent completion by returning `false`.\n     * Very useful for form validation.\n     *\n     * @property onFinishing\n     * @type Event\n     * @default function (event, currentIndex) { return true; }\n     * @for defaults\n     **/\n    onFinishing: function (event, currentIndex) {\n      return true\n    },\n\n    /**\n     * Fires after completion.\n     *\n     * @property onFinished\n     * @type Event\n     * @default function (event, currentIndex) { }\n     * @for defaults\n     **/\n    onFinished: function (event, currentIndex) {},\n\n    /**\n     * Fires after async content is loaded.\n     *\n     * @property onContentLoaded\n     * @type Event\n     * @default function (event, index) { }\n     * @for defaults\n     **/\n    onContentLoaded: function (event, currentIndex) {},\n\n    /**\n     * Fires when the wizard is initialized.\n     *\n     * @property onInit\n     * @type Event\n     * @default function (event) { }\n     * @for defaults\n     **/\n    onInit: function (event, currentIndex) {},\n\n    /**\n     * Contains all labels.\n     *\n     * @property labels\n     * @type Object\n     * @for defaults\n     **/\n    labels: {\n      /**\n       * Label for the cancel button.\n       *\n       * @property cancel\n       * @type String\n       * @default \"Cancel\"\n       * @for defaults\n       **/\n      cancel: 'Cancel',\n\n      /**\n       * This label is important for accessability reasons.\n       * Indicates which step is activated.\n       *\n       * @property current\n       * @type String\n       * @default \"current step:\"\n       * @for defaults\n       **/\n      current: 'current step:',\n\n      /**\n       * This label is important for accessability reasons and describes the kind of navigation.\n       *\n       * @property pagination\n       * @type String\n       * @default \"Pagination\"\n       * @for defaults\n       * @since 0.9.7\n       **/\n      pagination: 'Pagination',\n\n      /**\n       * Label for the finish button.\n       *\n       * @property finish\n       * @type String\n       * @default \"Finish\"\n       * @for defaults\n       **/\n      finish: 'Finish',\n\n      /**\n       * Label for the next button.\n       *\n       * @property next\n       * @type String\n       * @default \"Next\"\n       * @for defaults\n       **/\n      next: \"Next <i class='material-icons'>&#xE315;</i>\",\n\n      /**\n       * Label for the previous button.\n       *\n       * @property previous\n       * @type String\n       * @default \"Previous\"\n       * @for defaults\n       **/\n      previous: \"<i class='material-icons'>&#xE314;</i> Previous\",\n\n      /**\n       * Label for the loading animation.\n       *\n       * @property loading\n       * @type String\n       * @default \"Loading ...\"\n       * @for defaults\n       **/\n      loading: 'Loading ...'\n    }\n  })\n})(jQuery)\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\")))\n\n//# sourceURL=webpack:///./src/public/js/plugins/jquery.steps.js?");

/***/ }),

/***/ "./src/public/js/vendor/c3/c3.js":
/*!***************************************!*\
  !*** ./src/public/js/vendor/c3/c3.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* @license C3.js v0.6.12 | (c) C3 Team and other contributors | http://c3js.org/ */\n;(function (global, factory) {\n   true\n    ? (module.exports = factory())\n    : undefined\n})(this, function () {\n  'use strict'\n\n  function _typeof (obj) {\n    if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {\n      _typeof = function (obj) {\n        return typeof obj\n      }\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === 'function' && obj.constructor === Symbol && obj !== Symbol.prototype\n          ? 'symbol'\n          : typeof obj\n      }\n    }\n\n    return _typeof(obj)\n  }\n\n  function _classCallCheck (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError('Cannot call a class as a function')\n    }\n  }\n\n  function _defineProperty (obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      })\n    } else {\n      obj[key] = value\n    }\n\n    return obj\n  }\n\n  function ChartInternal (api) {\n    var $$ = this\n    $$.d3 = window.d3 ? window.d3 :  true ? __webpack_require__(/*! d3 */ \"./src/public/js/vendor/d3/d3.min.js\") : undefined\n    $$.api = api\n    $$.config = $$.getDefaultConfig()\n    $$.data = {}\n    $$.cache = {}\n    $$.axes = {}\n  }\n\n  function Chart (config) {\n    var $$ = (this.internal = new ChartInternal(this))\n    $$.loadConfig(config)\n    $$.beforeInit(config)\n    $$.init()\n    $$.afterInit(config) // bind \"this\" to nested API\n    ;(function bindThis (fn, target, argThis) {\n      Object.keys(fn).forEach(function (key) {\n        target[key] = fn[key].bind(argThis)\n\n        if (Object.keys(fn[key]).length > 0) {\n          bindThis(fn[key], target[key], argThis)\n        }\n      })\n    })(Chart.prototype, this, this)\n  }\n\n  function AxisInternal (component, params) {\n    var internal = this\n    internal.component = component\n    internal.params = params || {}\n    internal.d3 = component.d3\n    internal.scale = internal.d3.scaleLinear()\n    internal.range\n    internal.orient = 'bottom'\n    internal.innerTickSize = 6\n    internal.outerTickSize = this.params.withOuterTick ? 6 : 0\n    internal.tickPadding = 3\n    internal.tickValues = null\n    internal.tickFormat\n    internal.tickArguments\n    internal.tickOffset = 0\n    internal.tickCulling = true\n    internal.tickCentered\n    internal.tickTextCharSize\n    internal.tickTextRotate = internal.params.tickTextRotate\n    internal.tickLength\n    internal.axis = internal.generateAxis()\n  }\n\n  AxisInternal.prototype.axisX = function (selection, x, tickOffset) {\n    selection.attr('transform', function (d) {\n      return 'translate(' + Math.ceil(x(d) + tickOffset) + ', 0)'\n    })\n  }\n\n  AxisInternal.prototype.axisY = function (selection, y) {\n    selection.attr('transform', function (d) {\n      return 'translate(0,' + Math.ceil(y(d)) + ')'\n    })\n  }\n\n  AxisInternal.prototype.scaleExtent = function (domain) {\n    var start = domain[0],\n      stop = domain[domain.length - 1]\n    return start < stop ? [start, stop] : [stop, start]\n  }\n\n  AxisInternal.prototype.generateTicks = function (scale) {\n    var internal = this\n    var i,\n      domain,\n      ticks = []\n\n    if (scale.ticks) {\n      return scale.ticks.apply(scale, internal.tickArguments)\n    }\n\n    domain = scale.domain()\n\n    for (i = Math.ceil(domain[0]); i < domain[1]; i++) {\n      ticks.push(i)\n    }\n\n    if (ticks.length > 0 && ticks[0] > 0) {\n      ticks.unshift(ticks[0] - (ticks[1] - ticks[0]))\n    }\n\n    return ticks\n  }\n\n  AxisInternal.prototype.copyScale = function () {\n    var internal = this\n    var newScale = internal.scale.copy(),\n      domain\n\n    if (internal.params.isCategory) {\n      domain = internal.scale.domain()\n      newScale.domain([domain[0], domain[1] - 1])\n    }\n\n    return newScale\n  }\n\n  AxisInternal.prototype.textFormatted = function (v) {\n    var internal = this,\n      formatted = internal.tickFormat ? internal.tickFormat(v) : v\n    return typeof formatted !== 'undefined' ? formatted : ''\n  }\n\n  AxisInternal.prototype.updateRange = function () {\n    var internal = this\n    internal.range = internal.scale.rangeExtent\n      ? internal.scale.rangeExtent()\n      : internal.scaleExtent(internal.scale.range())\n    return internal.range\n  }\n\n  AxisInternal.prototype.updateTickTextCharSize = function (tick) {\n    var internal = this\n\n    if (internal.tickTextCharSize) {\n      return internal.tickTextCharSize\n    }\n\n    var size = {\n      h: 11.5,\n      w: 5.5\n    }\n    tick\n      .select('text')\n      .text(function (d) {\n        return internal.textFormatted(d)\n      })\n      .each(function (d) {\n        var box = this.getBoundingClientRect(),\n          text = internal.textFormatted(d),\n          h = box.height,\n          w = text ? box.width / text.length : undefined\n\n        if (h && w) {\n          size.h = h\n          size.w = w\n        }\n      })\n      .text('')\n    internal.tickTextCharSize = size\n    return size\n  }\n\n  AxisInternal.prototype.isVertical = function () {\n    return this.orient === 'left' || this.orient === 'right'\n  }\n\n  AxisInternal.prototype.tspanData = function (d, i, scale) {\n    var internal = this\n    var splitted = internal.params.tickMultiline\n      ? internal.splitTickText(d, scale)\n      : [].concat(internal.textFormatted(d))\n\n    if (internal.params.tickMultiline && internal.params.tickMultilineMax > 0) {\n      splitted = internal.ellipsify(splitted, internal.params.tickMultilineMax)\n    }\n\n    return splitted.map(function (s) {\n      return {\n        index: i,\n        splitted: s,\n        length: splitted.length\n      }\n    })\n  }\n\n  AxisInternal.prototype.splitTickText = function (d, scale) {\n    var internal = this,\n      tickText = internal.textFormatted(d),\n      maxWidth = internal.params.tickWidth,\n      subtext,\n      spaceIndex,\n      textWidth,\n      splitted = []\n\n    if (Object.prototype.toString.call(tickText) === '[object Array]') {\n      return tickText\n    }\n\n    if (!maxWidth || maxWidth <= 0) {\n      maxWidth = internal.isVertical() ? 95 : internal.params.isCategory ? Math.ceil(scale(1) - scale(0)) - 12 : 110\n    }\n\n    function split (splitted, text) {\n      spaceIndex = undefined\n\n      for (var i = 1; i < text.length; i++) {\n        if (text.charAt(i) === ' ') {\n          spaceIndex = i\n        }\n\n        subtext = text.substr(0, i + 1)\n        textWidth = internal.tickTextCharSize.w * subtext.length // if text width gets over tick width, split by space index or crrent index\n\n        if (maxWidth < textWidth) {\n          return split(\n            splitted.concat(text.substr(0, spaceIndex ? spaceIndex : i)),\n            text.slice(spaceIndex ? spaceIndex + 1 : i)\n          )\n        }\n      }\n\n      return splitted.concat(text)\n    }\n\n    return split(splitted, tickText + '')\n  }\n\n  AxisInternal.prototype.ellipsify = function (splitted, max) {\n    if (splitted.length <= max) {\n      return splitted\n    }\n\n    var ellipsified = splitted.slice(0, max)\n    var remaining = 3\n\n    for (var i = max - 1; i >= 0; i--) {\n      var available = ellipsified[i].length\n      ellipsified[i] = ellipsified[i].substr(0, available - remaining).padEnd(available, '.')\n      remaining -= available\n\n      if (remaining <= 0) {\n        break\n      }\n    }\n\n    return ellipsified\n  }\n\n  AxisInternal.prototype.updateTickLength = function () {\n    var internal = this\n    internal.tickLength = Math.max(internal.innerTickSize, 0) + internal.tickPadding\n  }\n\n  AxisInternal.prototype.lineY2 = function (d) {\n    var internal = this,\n      tickPosition = internal.scale(d) + (internal.tickCentered ? 0 : internal.tickOffset)\n    return internal.range[0] < tickPosition && tickPosition < internal.range[1] ? internal.innerTickSize : 0\n  }\n\n  AxisInternal.prototype.textY = function () {\n    var internal = this,\n      rotate = internal.tickTextRotate\n    return rotate ? 11.5 - 2.5 * (rotate / 15) * (rotate > 0 ? 1 : -1) : internal.tickLength\n  }\n\n  AxisInternal.prototype.textTransform = function () {\n    var internal = this,\n      rotate = internal.tickTextRotate\n    return rotate ? 'rotate(' + rotate + ')' : ''\n  }\n\n  AxisInternal.prototype.textTextAnchor = function () {\n    var internal = this,\n      rotate = internal.tickTextRotate\n    return rotate ? (rotate > 0 ? 'start' : 'end') : 'middle'\n  }\n\n  AxisInternal.prototype.tspanDx = function () {\n    var internal = this,\n      rotate = internal.tickTextRotate\n    return rotate ? 8 * Math.sin(Math.PI * (rotate / 180)) : 0\n  }\n\n  AxisInternal.prototype.tspanDy = function (d, i) {\n    var internal = this,\n      dy = internal.tickTextCharSize.h\n\n    if (i === 0) {\n      if (internal.isVertical()) {\n        dy = -((d.length - 1) * (internal.tickTextCharSize.h / 2) - 3)\n      } else {\n        dy = '.71em'\n      }\n    }\n\n    return dy\n  }\n\n  AxisInternal.prototype.generateAxis = function () {\n    var internal = this,\n      d3 = internal.d3,\n      params = internal.params\n\n    function axis (g, transition) {\n      var self\n      g.each(function () {\n        var g = (axis.g = d3.select(this))\n        var scale0 = this.__chart__ || internal.scale,\n          scale1 = (this.__chart__ = internal.copyScale())\n        var ticksValues = internal.tickValues ? internal.tickValues : internal.generateTicks(scale1),\n          ticks = g.selectAll('.tick').data(ticksValues, scale1),\n          tickEnter = ticks\n            .enter()\n            .insert('g', '.domain')\n            .attr('class', 'tick')\n            .style('opacity', 1e-6),\n          // MEMO: No exit transition. The reason is this transition affects max tick width calculation because old tick will be included in the ticks.\n          tickExit = ticks.exit().remove(),\n          tickUpdate = ticks.merge(tickEnter),\n          tickTransform,\n          tickX,\n          tickY\n\n        if (params.isCategory) {\n          internal.tickOffset = Math.ceil((scale1(1) - scale1(0)) / 2)\n          tickX = internal.tickCentered ? 0 : internal.tickOffset\n          tickY = internal.tickCentered ? internal.tickOffset : 0\n        } else {\n          internal.tickOffset = tickX = 0\n        }\n\n        internal.updateRange()\n        internal.updateTickLength()\n        internal.updateTickTextCharSize(g.select('.tick'))\n        var lineUpdate = tickUpdate.select('line').merge(tickEnter.append('line')),\n          textUpdate = tickUpdate.select('text').merge(tickEnter.append('text'))\n        var tspans = tickUpdate\n            .selectAll('text')\n            .selectAll('tspan')\n            .data(function (d, i) {\n              return internal.tspanData(d, i, scale1)\n            }),\n          tspanEnter = tspans.enter().append('tspan'),\n          tspanUpdate = tspanEnter.merge(tspans).text(function (d) {\n            return d.splitted\n          })\n        tspans.exit().remove()\n        var path = g.selectAll('.domain').data([0]),\n          pathUpdate = path\n            .enter()\n            .append('path')\n            .merge(path)\n            .attr('class', 'domain') // TODO: each attr should be one function and change its behavior by internal.orient, probably\n\n        switch (internal.orient) {\n          case 'bottom': {\n            tickTransform = internal.axisX\n            lineUpdate\n              .attr('x1', tickX)\n              .attr('x2', tickX)\n              .attr('y2', function (d, i) {\n                return internal.lineY2(d, i)\n              })\n            textUpdate\n              .attr('x', 0)\n              .attr('y', function (d, i) {\n                return internal.textY(d, i)\n              })\n              .attr('transform', function (d, i) {\n                return internal.textTransform(d, i)\n              })\n              .style('text-anchor', function (d, i) {\n                return internal.textTextAnchor(d, i)\n              })\n            tspanUpdate\n              .attr('x', 0)\n              .attr('dy', function (d, i) {\n                return internal.tspanDy(d, i)\n              })\n              .attr('dx', function (d, i) {\n                return internal.tspanDx(d, i)\n              })\n            pathUpdate.attr(\n              'd',\n              'M' +\n                internal.range[0] +\n                ',' +\n                internal.outerTickSize +\n                'V0H' +\n                internal.range[1] +\n                'V' +\n                internal.outerTickSize\n            )\n            break\n          }\n\n          case 'top': {\n            // TODO: rotated tick text\n            tickTransform = internal.axisX\n            lineUpdate\n              .attr('x1', tickX)\n              .attr('x2', tickX)\n              .attr('y2', function (d, i) {\n                return -1 * internal.lineY2(d, i)\n              })\n            textUpdate\n              .attr('x', 0)\n              .attr('y', function (d, i) {\n                return -1 * internal.textY(d, i) - (params.isCategory ? 2 : internal.tickLength - 2)\n              })\n              .attr('transform', function (d, i) {\n                return internal.textTransform(d, i)\n              })\n              .style('text-anchor', function (d, i) {\n                return internal.textTextAnchor(d, i)\n              })\n            tspanUpdate\n              .attr('x', 0)\n              .attr('dy', function (d, i) {\n                return internal.tspanDy(d, i)\n              })\n              .attr('dx', function (d, i) {\n                return internal.tspanDx(d, i)\n              })\n            pathUpdate.attr(\n              'd',\n              'M' +\n                internal.range[0] +\n                ',' +\n                -internal.outerTickSize +\n                'V0H' +\n                internal.range[1] +\n                'V' +\n                -internal.outerTickSize\n            )\n            break\n          }\n\n          case 'left': {\n            tickTransform = internal.axisY\n            lineUpdate\n              .attr('x2', -internal.innerTickSize)\n              .attr('y1', tickY)\n              .attr('y2', tickY)\n            textUpdate\n              .attr('x', -internal.tickLength)\n              .attr('y', internal.tickOffset)\n              .style('text-anchor', 'end')\n            tspanUpdate.attr('x', -internal.tickLength).attr('dy', function (d, i) {\n              return internal.tspanDy(d, i)\n            })\n            pathUpdate.attr(\n              'd',\n              'M' +\n                -internal.outerTickSize +\n                ',' +\n                internal.range[0] +\n                'H0V' +\n                internal.range[1] +\n                'H' +\n                -internal.outerTickSize\n            )\n            break\n          }\n\n          case 'right': {\n            tickTransform = internal.axisY\n            lineUpdate\n              .attr('x2', internal.innerTickSize)\n              .attr('y1', tickY)\n              .attr('y2', tickY)\n            textUpdate\n              .attr('x', internal.tickLength)\n              .attr('y', internal.tickOffset)\n              .style('text-anchor', 'start')\n            tspanUpdate.attr('x', internal.tickLength).attr('dy', function (d, i) {\n              return internal.tspanDy(d, i)\n            })\n            pathUpdate.attr(\n              'd',\n              'M' +\n                internal.outerTickSize +\n                ',' +\n                internal.range[0] +\n                'H0V' +\n                internal.range[1] +\n                'H' +\n                internal.outerTickSize\n            )\n            break\n          }\n        }\n\n        if (scale1.rangeBand) {\n          var x = scale1,\n            dx = x.rangeBand() / 2\n\n          scale0 = scale1 = function scale1 (d) {\n            return x(d) + dx\n          }\n        } else if (scale0.rangeBand) {\n          scale0 = scale1\n        } else {\n          tickExit.call(tickTransform, scale1, internal.tickOffset)\n        }\n\n        tickEnter.call(tickTransform, scale0, internal.tickOffset)\n        self = (transition ? tickUpdate.transition(transition) : tickUpdate)\n          .style('opacity', 1)\n          .call(tickTransform, scale1, internal.tickOffset)\n      })\n      return self\n    }\n\n    axis.scale = function (x) {\n      if (!arguments.length) {\n        return internal.scale\n      }\n\n      internal.scale = x\n      return axis\n    }\n\n    axis.orient = function (x) {\n      if (!arguments.length) {\n        return internal.orient\n      }\n\n      internal.orient =\n        x in\n        {\n          top: 1,\n          right: 1,\n          bottom: 1,\n          left: 1\n        }\n          ? x + ''\n          : 'bottom'\n      return axis\n    }\n\n    axis.tickFormat = function (format) {\n      if (!arguments.length) {\n        return internal.tickFormat\n      }\n\n      internal.tickFormat = format\n      return axis\n    }\n\n    axis.tickCentered = function (isCentered) {\n      if (!arguments.length) {\n        return internal.tickCentered\n      }\n\n      internal.tickCentered = isCentered\n      return axis\n    }\n\n    axis.tickOffset = function () {\n      return internal.tickOffset\n    }\n\n    axis.tickInterval = function () {\n      var interval, length\n\n      if (params.isCategory) {\n        interval = internal.tickOffset * 2\n      } else {\n        length =\n          axis.g\n            .select('path.domain')\n            .node()\n            .getTotalLength() -\n          internal.outerTickSize * 2\n        interval = length / axis.g.selectAll('line').size()\n      }\n\n      return interval === Infinity ? 0 : interval\n    }\n\n    axis.ticks = function () {\n      if (!arguments.length) {\n        return internal.tickArguments\n      }\n\n      internal.tickArguments = arguments\n      return axis\n    }\n\n    axis.tickCulling = function (culling) {\n      if (!arguments.length) {\n        return internal.tickCulling\n      }\n\n      internal.tickCulling = culling\n      return axis\n    }\n\n    axis.tickValues = function (x) {\n      if (typeof x === 'function') {\n        internal.tickValues = function () {\n          return x(internal.scale.domain())\n        }\n      } else {\n        if (!arguments.length) {\n          return internal.tickValues\n        }\n\n        internal.tickValues = x\n      }\n\n      return axis\n    }\n\n    return axis\n  }\n\n  var CLASS = {\n    target: 'c3-target',\n    chart: 'c3-chart',\n    chartLine: 'c3-chart-line',\n    chartLines: 'c3-chart-lines',\n    chartBar: 'c3-chart-bar',\n    chartBars: 'c3-chart-bars',\n    chartText: 'c3-chart-text',\n    chartTexts: 'c3-chart-texts',\n    chartArc: 'c3-chart-arc',\n    chartArcs: 'c3-chart-arcs',\n    chartArcsTitle: 'c3-chart-arcs-title',\n    chartArcsBackground: 'c3-chart-arcs-background',\n    chartArcsGaugeUnit: 'c3-chart-arcs-gauge-unit',\n    chartArcsGaugeMax: 'c3-chart-arcs-gauge-max',\n    chartArcsGaugeMin: 'c3-chart-arcs-gauge-min',\n    selectedCircle: 'c3-selected-circle',\n    selectedCircles: 'c3-selected-circles',\n    eventRect: 'c3-event-rect',\n    eventRects: 'c3-event-rects',\n    eventRectsSingle: 'c3-event-rects-single',\n    eventRectsMultiple: 'c3-event-rects-multiple',\n    zoomRect: 'c3-zoom-rect',\n    brush: 'c3-brush',\n    dragZoom: 'c3-drag-zoom',\n    focused: 'c3-focused',\n    defocused: 'c3-defocused',\n    region: 'c3-region',\n    regions: 'c3-regions',\n    title: 'c3-title',\n    tooltipContainer: 'c3-tooltip-container',\n    tooltip: 'c3-tooltip',\n    tooltipName: 'c3-tooltip-name',\n    shape: 'c3-shape',\n    shapes: 'c3-shapes',\n    line: 'c3-line',\n    lines: 'c3-lines',\n    bar: 'c3-bar',\n    bars: 'c3-bars',\n    circle: 'c3-circle',\n    circles: 'c3-circles',\n    arc: 'c3-arc',\n    arcLabelLine: 'c3-arc-label-line',\n    arcs: 'c3-arcs',\n    area: 'c3-area',\n    areas: 'c3-areas',\n    empty: 'c3-empty',\n    text: 'c3-text',\n    texts: 'c3-texts',\n    gaugeValue: 'c3-gauge-value',\n    grid: 'c3-grid',\n    gridLines: 'c3-grid-lines',\n    xgrid: 'c3-xgrid',\n    xgrids: 'c3-xgrids',\n    xgridLine: 'c3-xgrid-line',\n    xgridLines: 'c3-xgrid-lines',\n    xgridFocus: 'c3-xgrid-focus',\n    ygrid: 'c3-ygrid',\n    ygrids: 'c3-ygrids',\n    ygridLine: 'c3-ygrid-line',\n    ygridLines: 'c3-ygrid-lines',\n    axis: 'c3-axis',\n    axisX: 'c3-axis-x',\n    axisXLabel: 'c3-axis-x-label',\n    axisY: 'c3-axis-y',\n    axisYLabel: 'c3-axis-y-label',\n    axisY2: 'c3-axis-y2',\n    axisY2Label: 'c3-axis-y2-label',\n    legendBackground: 'c3-legend-background',\n    legendItem: 'c3-legend-item',\n    legendItemEvent: 'c3-legend-item-event',\n    legendItemTile: 'c3-legend-item-tile',\n    legendItemHidden: 'c3-legend-item-hidden',\n    legendItemFocused: 'c3-legend-item-focused',\n    dragarea: 'c3-dragarea',\n    EXPANDED: '_expanded_',\n    SELECTED: '_selected_',\n    INCLUDED: '_included_'\n  }\n\n  var asHalfPixel = function asHalfPixel (n) {\n    return Math.ceil(n) + 0.5\n  }\n  var ceil10 = function ceil10 (v) {\n    return Math.ceil(v / 10) * 10\n  }\n  var diffDomain = function diffDomain (d) {\n    return d[1] - d[0]\n  }\n  var getOption = function getOption (options, key, defaultValue) {\n    return isDefined(options[key]) ? options[key] : defaultValue\n  }\n  var getPathBox = function getPathBox (path) {\n    var box = path.getBoundingClientRect(),\n      items = [path.pathSegList.getItem(0), path.pathSegList.getItem(1)],\n      minX = items[0].x,\n      minY = Math.min(items[0].y, items[1].y)\n    return {\n      x: minX,\n      y: minY,\n      width: box.width,\n      height: box.height\n    }\n  }\n  var hasValue = function hasValue (dict, value) {\n    var found = false\n    Object.keys(dict).forEach(function (key) {\n      if (dict[key] === value) {\n        found = true\n      }\n    })\n    return found\n  }\n  var isArray = function isArray (o) {\n    return Array.isArray(o)\n  }\n  var isDefined = function isDefined (v) {\n    return typeof v !== 'undefined'\n  }\n  var isEmpty = function isEmpty (o) {\n    return (\n      typeof o === 'undefined' ||\n      o === null ||\n      (isString(o) && o.length === 0) ||\n      (_typeof(o) === 'object' && Object.keys(o).length === 0)\n    )\n  }\n  var isFunction = function isFunction (o) {\n    return typeof o === 'function'\n  }\n  var isString = function isString (o) {\n    return typeof o === 'string'\n  }\n  var isUndefined = function isUndefined (v) {\n    return typeof v === 'undefined'\n  }\n  var isValue = function isValue (v) {\n    return v || v === 0\n  }\n  var notEmpty = function notEmpty (o) {\n    return !isEmpty(o)\n  }\n  var sanitise = function sanitise (str) {\n    return typeof str === 'string' ? str.replace(/</g, '&lt;').replace(/>/g, '&gt;') : str\n  }\n\n  var Axis = function Axis (owner) {\n    _classCallCheck(this, Axis)\n\n    this.owner = owner\n    this.d3 = owner.d3\n    this.internal = AxisInternal\n  }\n\n  Axis.prototype.init = function init () {\n    var $$ = this.owner,\n      config = $$.config,\n      main = $$.main\n    $$.axes.x = main\n      .append('g')\n      .attr('class', CLASS.axis + ' ' + CLASS.axisX)\n      .attr('clip-path', config.axis_x_inner ? '' : $$.clipPathForXAxis)\n      .attr('transform', $$.getTranslate('x'))\n      .style('visibility', config.axis_x_show ? 'visible' : 'hidden')\n    $$.axes.x\n      .append('text')\n      .attr('class', CLASS.axisXLabel)\n      .attr('transform', config.axis_rotated ? 'rotate(-90)' : '')\n      .style('text-anchor', this.textAnchorForXAxisLabel.bind(this))\n    $$.axes.y = main\n      .append('g')\n      .attr('class', CLASS.axis + ' ' + CLASS.axisY)\n      .attr('clip-path', config.axis_y_inner ? '' : $$.clipPathForYAxis)\n      .attr('transform', $$.getTranslate('y'))\n      .style('visibility', config.axis_y_show ? 'visible' : 'hidden')\n    $$.axes.y\n      .append('text')\n      .attr('class', CLASS.axisYLabel)\n      .attr('transform', config.axis_rotated ? '' : 'rotate(-90)')\n      .style('text-anchor', this.textAnchorForYAxisLabel.bind(this))\n    $$.axes.y2 = main\n      .append('g')\n      .attr('class', CLASS.axis + ' ' + CLASS.axisY2) // clip-path?\n      .attr('transform', $$.getTranslate('y2'))\n      .style('visibility', config.axis_y2_show ? 'visible' : 'hidden')\n    $$.axes.y2\n      .append('text')\n      .attr('class', CLASS.axisY2Label)\n      .attr('transform', config.axis_rotated ? '' : 'rotate(-90)')\n      .style('text-anchor', this.textAnchorForY2AxisLabel.bind(this))\n  }\n\n  Axis.prototype.getXAxis = function getXAxis (\n    scale,\n    orient,\n    tickFormat,\n    tickValues,\n    withOuterTick,\n    withoutTransition,\n    withoutRotateTickText\n  ) {\n    var $$ = this.owner,\n      config = $$.config,\n      axisParams = {\n        isCategory: $$.isCategorized(),\n        withOuterTick: withOuterTick,\n        tickMultiline: config.axis_x_tick_multiline,\n        tickMultilineMax: config.axis_x_tick_multiline ? Number(config.axis_x_tick_multilineMax) : 0,\n        tickWidth: config.axis_x_tick_width,\n        tickTextRotate: withoutRotateTickText ? 0 : config.axis_x_tick_rotate,\n        withoutTransition: withoutTransition\n      },\n      axis = new this.internal(this, axisParams).axis.scale(scale).orient(orient)\n\n    if ($$.isTimeSeries() && tickValues && typeof tickValues !== 'function') {\n      tickValues = tickValues.map(function (v) {\n        return $$.parseDate(v)\n      })\n    } // Set tick\n\n    axis.tickFormat(tickFormat).tickValues(tickValues)\n\n    if ($$.isCategorized()) {\n      axis.tickCentered(config.axis_x_tick_centered)\n\n      if (isEmpty(config.axis_x_tick_culling)) {\n        config.axis_x_tick_culling = false\n      }\n    }\n\n    return axis\n  }\n\n  Axis.prototype.updateXAxisTickValues = function updateXAxisTickValues (targets, axis) {\n    var $$ = this.owner,\n      config = $$.config,\n      tickValues\n\n    if (config.axis_x_tick_fit || config.axis_x_tick_count) {\n      tickValues = this.generateTickValues(\n        $$.mapTargetsToUniqueXs(targets),\n        config.axis_x_tick_count,\n        $$.isTimeSeries()\n      )\n    }\n\n    if (axis) {\n      axis.tickValues(tickValues)\n    } else {\n      $$.xAxis.tickValues(tickValues)\n      $$.subXAxis.tickValues(tickValues)\n    }\n\n    return tickValues\n  }\n\n  Axis.prototype.getYAxis = function getYAxis (\n    scale,\n    orient,\n    tickFormat,\n    tickValues,\n    withOuterTick,\n    withoutTransition,\n    withoutRotateTickText\n  ) {\n    var $$ = this.owner,\n      config = $$.config,\n      axisParams = {\n        withOuterTick: withOuterTick,\n        withoutTransition: withoutTransition,\n        tickTextRotate: withoutRotateTickText ? 0 : config.axis_y_tick_rotate\n      },\n      axis = new this.internal(this, axisParams).axis\n        .scale(scale)\n        .orient(orient)\n        .tickFormat(tickFormat)\n\n    if ($$.isTimeSeriesY()) {\n      axis.ticks(config.axis_y_tick_time_type, config.axis_y_tick_time_interval)\n    } else {\n      axis.tickValues(tickValues)\n    }\n\n    return axis\n  }\n\n  Axis.prototype.getId = function getId (id) {\n    var config = this.owner.config\n    return id in config.data_axes ? config.data_axes[id] : 'y'\n  }\n\n  Axis.prototype.getXAxisTickFormat = function getXAxisTickFormat () {\n    // #2251 previously set any negative values to a whole number,\n    // however both should be truncated according to the users format specification\n    var $$ = this.owner,\n      config = $$.config\n    var format = $$.isTimeSeries()\n      ? $$.defaultAxisTimeFormat\n      : $$.isCategorized()\n      ? $$.categoryName\n      : function (v) {\n          return v\n        }\n\n    if (config.axis_x_tick_format) {\n      if (isFunction(config.axis_x_tick_format)) {\n        format = config.axis_x_tick_format\n      } else if ($$.isTimeSeries()) {\n        format = function format (date) {\n          return date ? $$.axisTimeFormat(config.axis_x_tick_format)(date) : ''\n        }\n      }\n    }\n\n    return isFunction(format)\n      ? function (v) {\n          return format.call($$, v)\n        }\n      : format\n  }\n\n  Axis.prototype.getTickValues = function getTickValues (tickValues, axis) {\n    return tickValues ? tickValues : axis ? axis.tickValues() : undefined\n  }\n\n  Axis.prototype.getXAxisTickValues = function getXAxisTickValues () {\n    return this.getTickValues(this.owner.config.axis_x_tick_values, this.owner.xAxis)\n  }\n\n  Axis.prototype.getYAxisTickValues = function getYAxisTickValues () {\n    return this.getTickValues(this.owner.config.axis_y_tick_values, this.owner.yAxis)\n  }\n\n  Axis.prototype.getY2AxisTickValues = function getY2AxisTickValues () {\n    return this.getTickValues(this.owner.config.axis_y2_tick_values, this.owner.y2Axis)\n  }\n\n  Axis.prototype.getLabelOptionByAxisId = function getLabelOptionByAxisId (axisId) {\n    var $$ = this.owner,\n      config = $$.config,\n      option\n\n    if (axisId === 'y') {\n      option = config.axis_y_label\n    } else if (axisId === 'y2') {\n      option = config.axis_y2_label\n    } else if (axisId === 'x') {\n      option = config.axis_x_label\n    }\n\n    return option\n  }\n\n  Axis.prototype.getLabelText = function getLabelText (axisId) {\n    var option = this.getLabelOptionByAxisId(axisId)\n    return isString(option) ? option : option ? option.text : null\n  }\n\n  Axis.prototype.setLabelText = function setLabelText (axisId, text) {\n    var $$ = this.owner,\n      config = $$.config,\n      option = this.getLabelOptionByAxisId(axisId)\n\n    if (isString(option)) {\n      if (axisId === 'y') {\n        config.axis_y_label = text\n      } else if (axisId === 'y2') {\n        config.axis_y2_label = text\n      } else if (axisId === 'x') {\n        config.axis_x_label = text\n      }\n    } else if (option) {\n      option.text = text\n    }\n  }\n\n  Axis.prototype.getLabelPosition = function getLabelPosition (axisId, defaultPosition) {\n    var option = this.getLabelOptionByAxisId(axisId),\n      position = option && _typeof(option) === 'object' && option.position ? option.position : defaultPosition\n    return {\n      isInner: position.indexOf('inner') >= 0,\n      isOuter: position.indexOf('outer') >= 0,\n      isLeft: position.indexOf('left') >= 0,\n      isCenter: position.indexOf('center') >= 0,\n      isRight: position.indexOf('right') >= 0,\n      isTop: position.indexOf('top') >= 0,\n      isMiddle: position.indexOf('middle') >= 0,\n      isBottom: position.indexOf('bottom') >= 0\n    }\n  }\n\n  Axis.prototype.getXAxisLabelPosition = function getXAxisLabelPosition () {\n    return this.getLabelPosition('x', this.owner.config.axis_rotated ? 'inner-top' : 'inner-right')\n  }\n\n  Axis.prototype.getYAxisLabelPosition = function getYAxisLabelPosition () {\n    return this.getLabelPosition('y', this.owner.config.axis_rotated ? 'inner-right' : 'inner-top')\n  }\n\n  Axis.prototype.getY2AxisLabelPosition = function getY2AxisLabelPosition () {\n    return this.getLabelPosition('y2', this.owner.config.axis_rotated ? 'inner-right' : 'inner-top')\n  }\n\n  Axis.prototype.getLabelPositionById = function getLabelPositionById (id) {\n    return id === 'y2'\n      ? this.getY2AxisLabelPosition()\n      : id === 'y'\n      ? this.getYAxisLabelPosition()\n      : this.getXAxisLabelPosition()\n  }\n\n  Axis.prototype.textForXAxisLabel = function textForXAxisLabel () {\n    return this.getLabelText('x')\n  }\n\n  Axis.prototype.textForYAxisLabel = function textForYAxisLabel () {\n    return this.getLabelText('y')\n  }\n\n  Axis.prototype.textForY2AxisLabel = function textForY2AxisLabel () {\n    return this.getLabelText('y2')\n  }\n\n  Axis.prototype.xForAxisLabel = function xForAxisLabel (forHorizontal, position) {\n    var $$ = this.owner\n\n    if (forHorizontal) {\n      return position.isLeft ? 0 : position.isCenter ? $$.width / 2 : $$.width\n    } else {\n      return position.isBottom ? -$$.height : position.isMiddle ? -$$.height / 2 : 0\n    }\n  }\n\n  Axis.prototype.dxForAxisLabel = function dxForAxisLabel (forHorizontal, position) {\n    if (forHorizontal) {\n      return position.isLeft ? '0.5em' : position.isRight ? '-0.5em' : '0'\n    } else {\n      return position.isTop ? '-0.5em' : position.isBottom ? '0.5em' : '0'\n    }\n  }\n\n  Axis.prototype.textAnchorForAxisLabel = function textAnchorForAxisLabel (forHorizontal, position) {\n    if (forHorizontal) {\n      return position.isLeft ? 'start' : position.isCenter ? 'middle' : 'end'\n    } else {\n      return position.isBottom ? 'start' : position.isMiddle ? 'middle' : 'end'\n    }\n  }\n\n  Axis.prototype.xForXAxisLabel = function xForXAxisLabel () {\n    return this.xForAxisLabel(!this.owner.config.axis_rotated, this.getXAxisLabelPosition())\n  }\n\n  Axis.prototype.xForYAxisLabel = function xForYAxisLabel () {\n    return this.xForAxisLabel(this.owner.config.axis_rotated, this.getYAxisLabelPosition())\n  }\n\n  Axis.prototype.xForY2AxisLabel = function xForY2AxisLabel () {\n    return this.xForAxisLabel(this.owner.config.axis_rotated, this.getY2AxisLabelPosition())\n  }\n\n  Axis.prototype.dxForXAxisLabel = function dxForXAxisLabel () {\n    return this.dxForAxisLabel(!this.owner.config.axis_rotated, this.getXAxisLabelPosition())\n  }\n\n  Axis.prototype.dxForYAxisLabel = function dxForYAxisLabel () {\n    return this.dxForAxisLabel(this.owner.config.axis_rotated, this.getYAxisLabelPosition())\n  }\n\n  Axis.prototype.dxForY2AxisLabel = function dxForY2AxisLabel () {\n    return this.dxForAxisLabel(this.owner.config.axis_rotated, this.getY2AxisLabelPosition())\n  }\n\n  Axis.prototype.dyForXAxisLabel = function dyForXAxisLabel () {\n    var $$ = this.owner,\n      config = $$.config,\n      position = this.getXAxisLabelPosition()\n\n    if (config.axis_rotated) {\n      return position.isInner ? '1.2em' : -25 - ($$.config.axis_x_inner ? 0 : this.getMaxTickWidth('x'))\n    } else {\n      return position.isInner ? '-0.5em' : config.axis_x_height ? config.axis_x_height - 10 : '3em'\n    }\n  }\n\n  Axis.prototype.dyForYAxisLabel = function dyForYAxisLabel () {\n    var $$ = this.owner,\n      position = this.getYAxisLabelPosition()\n\n    if ($$.config.axis_rotated) {\n      return position.isInner ? '-0.5em' : '3em'\n    } else {\n      return position.isInner ? '1.2em' : -10 - ($$.config.axis_y_inner ? 0 : this.getMaxTickWidth('y') + 10)\n    }\n  }\n\n  Axis.prototype.dyForY2AxisLabel = function dyForY2AxisLabel () {\n    var $$ = this.owner,\n      position = this.getY2AxisLabelPosition()\n\n    if ($$.config.axis_rotated) {\n      return position.isInner ? '1.2em' : '-2.2em'\n    } else {\n      return position.isInner ? '-0.5em' : 15 + ($$.config.axis_y2_inner ? 0 : this.getMaxTickWidth('y2') + 15)\n    }\n  }\n\n  Axis.prototype.textAnchorForXAxisLabel = function textAnchorForXAxisLabel () {\n    var $$ = this.owner\n    return this.textAnchorForAxisLabel(!$$.config.axis_rotated, this.getXAxisLabelPosition())\n  }\n\n  Axis.prototype.textAnchorForYAxisLabel = function textAnchorForYAxisLabel () {\n    var $$ = this.owner\n    return this.textAnchorForAxisLabel($$.config.axis_rotated, this.getYAxisLabelPosition())\n  }\n\n  Axis.prototype.textAnchorForY2AxisLabel = function textAnchorForY2AxisLabel () {\n    var $$ = this.owner\n    return this.textAnchorForAxisLabel($$.config.axis_rotated, this.getY2AxisLabelPosition())\n  }\n\n  Axis.prototype.getMaxTickWidth = function getMaxTickWidth (id, withoutRecompute) {\n    var $$ = this.owner,\n      config = $$.config,\n      maxWidth = 0,\n      targetsToShow,\n      scale,\n      axis,\n      dummy,\n      svg\n\n    if (withoutRecompute && $$.currentMaxTickWidths[id]) {\n      return $$.currentMaxTickWidths[id]\n    }\n\n    if ($$.svg) {\n      targetsToShow = $$.filterTargetsToShow($$.data.targets)\n\n      if (id === 'y') {\n        scale = $$.y.copy().domain($$.getYDomain(targetsToShow, 'y'))\n        axis = this.getYAxis(scale, $$.yOrient, config.axis_y_tick_format, $$.yAxisTickValues, false, true, true)\n      } else if (id === 'y2') {\n        scale = $$.y2.copy().domain($$.getYDomain(targetsToShow, 'y2'))\n        axis = this.getYAxis(scale, $$.y2Orient, config.axis_y2_tick_format, $$.y2AxisTickValues, false, true, true)\n      } else {\n        scale = $$.x.copy().domain($$.getXDomain(targetsToShow))\n        axis = this.getXAxis(scale, $$.xOrient, $$.xAxisTickFormat, $$.xAxisTickValues, false, true, true)\n        this.updateXAxisTickValues(targetsToShow, axis)\n      }\n\n      dummy = $$.d3\n        .select('body')\n        .append('div')\n        .classed('c3', true)\n      ;(svg = dummy\n        .append('svg')\n        .style('visibility', 'hidden')\n        .style('position', 'fixed')\n        .style('top', 0)\n        .style('left', 0)),\n        svg\n          .append('g')\n          .call(axis)\n          .each(function () {\n            $$.d3\n              .select(this)\n              .selectAll('text')\n              .each(function () {\n                var box = this.getBoundingClientRect()\n\n                if (maxWidth < box.width) {\n                  maxWidth = box.width\n                }\n              })\n            dummy.remove()\n          })\n    }\n\n    $$.currentMaxTickWidths[id] = maxWidth <= 0 ? $$.currentMaxTickWidths[id] : maxWidth\n    return $$.currentMaxTickWidths[id]\n  }\n\n  Axis.prototype.updateLabels = function updateLabels (withTransition) {\n    var $$ = this.owner\n    var axisXLabel = $$.main.select('.' + CLASS.axisX + ' .' + CLASS.axisXLabel),\n      axisYLabel = $$.main.select('.' + CLASS.axisY + ' .' + CLASS.axisYLabel),\n      axisY2Label = $$.main.select('.' + CLASS.axisY2 + ' .' + CLASS.axisY2Label)\n    ;(withTransition ? axisXLabel.transition() : axisXLabel)\n      .attr('x', this.xForXAxisLabel.bind(this))\n      .attr('dx', this.dxForXAxisLabel.bind(this))\n      .attr('dy', this.dyForXAxisLabel.bind(this))\n      .text(this.textForXAxisLabel.bind(this))\n    ;(withTransition ? axisYLabel.transition() : axisYLabel)\n      .attr('x', this.xForYAxisLabel.bind(this))\n      .attr('dx', this.dxForYAxisLabel.bind(this))\n      .attr('dy', this.dyForYAxisLabel.bind(this))\n      .text(this.textForYAxisLabel.bind(this))\n    ;(withTransition ? axisY2Label.transition() : axisY2Label)\n      .attr('x', this.xForY2AxisLabel.bind(this))\n      .attr('dx', this.dxForY2AxisLabel.bind(this))\n      .attr('dy', this.dyForY2AxisLabel.bind(this))\n      .text(this.textForY2AxisLabel.bind(this))\n  }\n\n  Axis.prototype.getPadding = function getPadding (padding, key, defaultValue, domainLength) {\n    var p = typeof padding === 'number' ? padding : padding[key]\n\n    if (!isValue(p)) {\n      return defaultValue\n    }\n\n    if (padding.unit === 'ratio') {\n      return padding[key] * domainLength\n    } // assume padding is pixels if unit is not specified\n\n    return this.convertPixelsToAxisPadding(p, domainLength)\n  }\n\n  Axis.prototype.convertPixelsToAxisPadding = function convertPixelsToAxisPadding (pixels, domainLength) {\n    var $$ = this.owner,\n      length = $$.config.axis_rotated ? $$.width : $$.height\n    return domainLength * (pixels / length)\n  }\n\n  Axis.prototype.generateTickValues = function generateTickValues (values, tickCount, forTimeSeries) {\n    var tickValues = values,\n      targetCount,\n      start,\n      end,\n      count,\n      interval,\n      i,\n      tickValue\n\n    if (tickCount) {\n      targetCount = isFunction(tickCount) ? tickCount() : tickCount // compute ticks according to tickCount\n\n      if (targetCount === 1) {\n        tickValues = [values[0]]\n      } else if (targetCount === 2) {\n        tickValues = [values[0], values[values.length - 1]]\n      } else if (targetCount > 2) {\n        count = targetCount - 2\n        start = values[0]\n        end = values[values.length - 1]\n        interval = (end - start) / (count + 1) // re-construct unique values\n\n        tickValues = [start]\n\n        for (i = 0; i < count; i++) {\n          tickValue = +start + interval * (i + 1)\n          tickValues.push(forTimeSeries ? new Date(tickValue) : tickValue)\n        }\n\n        tickValues.push(end)\n      }\n    }\n\n    if (!forTimeSeries) {\n      tickValues = tickValues.sort(function (a, b) {\n        return a - b\n      })\n    }\n\n    return tickValues\n  }\n\n  Axis.prototype.generateTransitions = function generateTransitions (duration) {\n    var $$ = this.owner,\n      axes = $$.axes\n    return {\n      axisX: duration ? axes.x.transition().duration(duration) : axes.x,\n      axisY: duration ? axes.y.transition().duration(duration) : axes.y,\n      axisY2: duration ? axes.y2.transition().duration(duration) : axes.y2,\n      axisSubX: duration ? axes.subx.transition().duration(duration) : axes.subx\n    }\n  }\n\n  Axis.prototype.redraw = function redraw (duration, isHidden) {\n    var $$ = this.owner,\n      transition = duration ? $$.d3.transition().duration(duration) : null\n    $$.axes.x.style('opacity', isHidden ? 0 : 1).call($$.xAxis, transition)\n    $$.axes.y.style('opacity', isHidden ? 0 : 1).call($$.yAxis, transition)\n    $$.axes.y2.style('opacity', isHidden ? 0 : 1).call($$.y2Axis, transition)\n    $$.axes.subx.style('opacity', isHidden ? 0 : 1).call($$.subXAxis, transition)\n  }\n\n  var c3 = {\n    version: '0.6.12',\n    chart: {\n      fn: Chart.prototype,\n      internal: {\n        fn: ChartInternal.prototype,\n        axis: {\n          fn: Axis.prototype,\n          internal: {\n            fn: AxisInternal.prototype\n          }\n        }\n      }\n    },\n    generate: function generate (config) {\n      return new Chart(config)\n    }\n  }\n\n  ChartInternal.prototype.beforeInit = function () {\n    // can do something\n  }\n\n  ChartInternal.prototype.afterInit = function () {\n    // can do something\n  }\n\n  ChartInternal.prototype.init = function () {\n    var $$ = this,\n      config = $$.config\n    $$.initParams()\n\n    if (config.data_url) {\n      $$.convertUrlToData(config.data_url, config.data_mimeType, config.data_headers, config.data_keys, $$.initWithData)\n    } else if (config.data_json) {\n      $$.initWithData($$.convertJsonToData(config.data_json, config.data_keys))\n    } else if (config.data_rows) {\n      $$.initWithData($$.convertRowsToData(config.data_rows))\n    } else if (config.data_columns) {\n      $$.initWithData($$.convertColumnsToData(config.data_columns))\n    } else {\n      throw Error('url or json or rows or columns is required.')\n    }\n  }\n\n  ChartInternal.prototype.initParams = function () {\n    var $$ = this,\n      d3 = $$.d3,\n      config = $$.config // MEMO: clipId needs to be unique because it conflicts when multiple charts exist\n\n    $$.clipId = 'c3-' + +new Date() + '-clip'\n    $$.clipIdForXAxis = $$.clipId + '-xaxis'\n    $$.clipIdForYAxis = $$.clipId + '-yaxis'\n    $$.clipIdForGrid = $$.clipId + '-grid'\n    $$.clipIdForSubchart = $$.clipId + '-subchart'\n    $$.clipPath = $$.getClipPath($$.clipId)\n    $$.clipPathForXAxis = $$.getClipPath($$.clipIdForXAxis)\n    $$.clipPathForYAxis = $$.getClipPath($$.clipIdForYAxis)\n    $$.clipPathForGrid = $$.getClipPath($$.clipIdForGrid)\n    $$.clipPathForSubchart = $$.getClipPath($$.clipIdForSubchart)\n    $$.dragStart = null\n    $$.dragging = false\n    $$.flowing = false\n    $$.cancelClick = false\n    $$.mouseover = false\n    $$.transiting = false\n    $$.color = $$.generateColor()\n    $$.levelColor = $$.generateLevelColor()\n    $$.dataTimeParse = (config.data_xLocaltime ? d3.timeParse : d3.utcParse)($$.config.data_xFormat)\n    $$.axisTimeFormat = config.axis_x_localtime ? d3.timeFormat : d3.utcFormat\n\n    $$.defaultAxisTimeFormat = function (date) {\n      if (date.getMilliseconds()) {\n        return d3.timeFormat('.%L')(date)\n      }\n\n      if (date.getSeconds()) {\n        return d3.timeFormat(':%S')(date)\n      }\n\n      if (date.getMinutes()) {\n        return d3.timeFormat('%I:%M')(date)\n      }\n\n      if (date.getHours()) {\n        return d3.timeFormat('%I %p')(date)\n      }\n\n      if (date.getDay() && date.getDate() !== 1) {\n        return d3.timeFormat('%-m/%-d')(date)\n      }\n\n      if (date.getDate() !== 1) {\n        return d3.timeFormat('%-m/%-d')(date)\n      }\n\n      if (date.getMonth()) {\n        return d3.timeFormat('%-m/%-d')(date)\n      }\n\n      return d3.timeFormat('%Y/%-m/%-d')(date)\n    }\n\n    $$.hiddenTargetIds = []\n    $$.hiddenLegendIds = []\n    $$.focusedTargetIds = []\n    $$.defocusedTargetIds = []\n    $$.xOrient = config.axis_rotated ? (config.axis_x_inner ? 'right' : 'left') : config.axis_x_inner ? 'top' : 'bottom'\n    $$.yOrient = config.axis_rotated ? (config.axis_y_inner ? 'top' : 'bottom') : config.axis_y_inner ? 'right' : 'left'\n    $$.y2Orient = config.axis_rotated\n      ? config.axis_y2_inner\n        ? 'bottom'\n        : 'top'\n      : config.axis_y2_inner\n      ? 'left'\n      : 'right'\n    $$.subXOrient = config.axis_rotated ? 'left' : 'bottom'\n    $$.isLegendRight = config.legend_position === 'right'\n    $$.isLegendInset = config.legend_position === 'inset'\n    $$.isLegendTop = config.legend_inset_anchor === 'top-left' || config.legend_inset_anchor === 'top-right'\n    $$.isLegendLeft = config.legend_inset_anchor === 'top-left' || config.legend_inset_anchor === 'bottom-left'\n    $$.legendStep = 0\n    $$.legendItemWidth = 0\n    $$.legendItemHeight = 0\n    $$.currentMaxTickWidths = {\n      x: 0,\n      y: 0,\n      y2: 0\n    }\n    $$.rotated_padding_left = 30\n    $$.rotated_padding_right = config.axis_rotated && !config.axis_x_show ? 0 : 30\n    $$.rotated_padding_top = 5\n    $$.withoutFadeIn = {}\n    $$.intervalForObserveInserted = undefined\n    $$.axes.subx = d3.selectAll([]) // needs when excluding subchart.js\n  }\n\n  ChartInternal.prototype.initChartElements = function () {\n    if (this.initBar) {\n      this.initBar()\n    }\n\n    if (this.initLine) {\n      this.initLine()\n    }\n\n    if (this.initArc) {\n      this.initArc()\n    }\n\n    if (this.initGauge) {\n      this.initGauge()\n    }\n\n    if (this.initText) {\n      this.initText()\n    }\n  }\n\n  ChartInternal.prototype.initWithData = function (data) {\n    var $$ = this,\n      d3 = $$.d3,\n      config = $$.config\n    var defs,\n      main,\n      binding = true\n    $$.axis = new Axis($$)\n\n    if (!config.bindto) {\n      $$.selectChart = d3.selectAll([])\n    } else if (typeof config.bindto.node === 'function') {\n      $$.selectChart = config.bindto\n    } else {\n      $$.selectChart = d3.select(config.bindto)\n    }\n\n    if ($$.selectChart.empty()) {\n      $$.selectChart = d3.select(document.createElement('div')).style('opacity', 0)\n      $$.observeInserted($$.selectChart)\n      binding = false\n    }\n\n    $$.selectChart.html('').classed('c3', true) // Init data as targets\n\n    $$.data.xs = {}\n    $$.data.targets = $$.convertDataToTargets(data)\n\n    if (config.data_filter) {\n      $$.data.targets = $$.data.targets.filter(config.data_filter)\n    } // Set targets to hide if needed\n\n    if (config.data_hide) {\n      $$.addHiddenTargetIds(config.data_hide === true ? $$.mapToIds($$.data.targets) : config.data_hide)\n    }\n\n    if (config.legend_hide) {\n      $$.addHiddenLegendIds(config.legend_hide === true ? $$.mapToIds($$.data.targets) : config.legend_hide)\n    } // Init sizes and scales\n\n    $$.updateSizes()\n    $$.updateScales() // Set domains for each scale\n\n    $$.x.domain(d3.extent($$.getXDomain($$.data.targets)))\n    $$.y.domain($$.getYDomain($$.data.targets, 'y'))\n    $$.y2.domain($$.getYDomain($$.data.targets, 'y2'))\n    $$.subX.domain($$.x.domain())\n    $$.subY.domain($$.y.domain())\n    $$.subY2.domain($$.y2.domain()) // Save original x domain for zoom update\n\n    $$.orgXDomain = $$.x.domain()\n    /*-- Basic Elements --*/\n    // Define svgs\n\n    $$.svg = $$.selectChart\n      .append('svg')\n      .style('overflow', 'hidden')\n      .on('mouseenter', function () {\n        return config.onmouseover.call($$)\n      })\n      .on('mouseleave', function () {\n        return config.onmouseout.call($$)\n      })\n\n    if ($$.config.svg_classname) {\n      $$.svg.attr('class', $$.config.svg_classname)\n    } // Define defs\n\n    defs = $$.svg.append('defs')\n    $$.clipChart = $$.appendClip(defs, $$.clipId)\n    $$.clipXAxis = $$.appendClip(defs, $$.clipIdForXAxis)\n    $$.clipYAxis = $$.appendClip(defs, $$.clipIdForYAxis)\n    $$.clipGrid = $$.appendClip(defs, $$.clipIdForGrid)\n    $$.clipSubchart = $$.appendClip(defs, $$.clipIdForSubchart)\n    $$.updateSvgSize() // Define regions\n\n    main = $$.main = $$.svg.append('g').attr('transform', $$.getTranslate('main'))\n\n    if ($$.initPie) {\n      $$.initPie()\n    }\n\n    if ($$.initDragZoom) {\n      $$.initDragZoom()\n    }\n\n    if ($$.initSubchart) {\n      $$.initSubchart()\n    }\n\n    if ($$.initTooltip) {\n      $$.initTooltip()\n    }\n\n    if ($$.initLegend) {\n      $$.initLegend()\n    }\n\n    if ($$.initTitle) {\n      $$.initTitle()\n    }\n\n    if ($$.initZoom) {\n      $$.initZoom()\n    } // Update selection based on size and scale\n    // TODO: currently this must be called after initLegend because of update of sizes, but it should be done in initSubchart.\n\n    if ($$.initSubchartBrush) {\n      $$.initSubchartBrush()\n    }\n    /*-- Main Region --*/\n    // text when empty\n\n    main\n      .append('text')\n      .attr('class', CLASS.text + ' ' + CLASS.empty)\n      .attr('text-anchor', 'middle') // horizontal centering of text at x position in all browsers.\n      .attr('dominant-baseline', 'middle') // vertical centering of text at y position in all browsers, except IE.\n    // Regions\n\n    $$.initRegion() // Grids\n\n    $$.initGrid() // Define g for chart area\n\n    main\n      .append('g')\n      .attr('clip-path', $$.clipPath)\n      .attr('class', CLASS.chart) // Grid lines\n\n    if (config.grid_lines_front) {\n      $$.initGridLines()\n    } // Cover whole with rects for events\n\n    $$.initEventRect() // Define g for chart\n\n    $$.initChartElements() // Add Axis\n\n    $$.axis.init() // Set targets\n\n    $$.updateTargets($$.data.targets) // Set default extent if defined\n\n    if (config.axis_x_selection) {\n      $$.brush.selectionAsValue($$.getDefaultSelection())\n    } // Draw with targets\n\n    if (binding) {\n      $$.updateDimension()\n      $$.config.oninit.call($$)\n      $$.redraw({\n        withTransition: false,\n        withTransform: true,\n        withUpdateXDomain: true,\n        withUpdateOrgXDomain: true,\n        withTransitionForAxis: false\n      })\n    } // Bind to resize event\n\n    $$.bindResize() // Bind to window focus event\n\n    $$.bindWindowFocus() // export element of the chart\n\n    $$.api.element = $$.selectChart.node()\n  }\n\n  ChartInternal.prototype.smoothLines = function (el, type) {\n    var $$ = this\n\n    if (type === 'grid') {\n      el.each(function () {\n        var g = $$.d3.select(this),\n          x1 = g.attr('x1'),\n          x2 = g.attr('x2'),\n          y1 = g.attr('y1'),\n          y2 = g.attr('y2')\n        g.attr({\n          x1: Math.ceil(x1),\n          x2: Math.ceil(x2),\n          y1: Math.ceil(y1),\n          y2: Math.ceil(y2)\n        })\n      })\n    }\n  }\n\n  ChartInternal.prototype.updateSizes = function () {\n    var $$ = this,\n      config = $$.config\n    var legendHeight = $$.legend ? $$.getLegendHeight() : 0,\n      legendWidth = $$.legend ? $$.getLegendWidth() : 0,\n      legendHeightForBottom = $$.isLegendRight || $$.isLegendInset ? 0 : legendHeight,\n      hasArc = $$.hasArcType(),\n      xAxisHeight = config.axis_rotated || hasArc ? 0 : $$.getHorizontalAxisHeight('x'),\n      subchartHeight = config.subchart_show && !hasArc ? config.subchart_size_height + xAxisHeight : 0\n    $$.currentWidth = $$.getCurrentWidth()\n    $$.currentHeight = $$.getCurrentHeight() // for main\n\n    $$.margin = config.axis_rotated\n      ? {\n          top: $$.getHorizontalAxisHeight('y2') + $$.getCurrentPaddingTop(),\n          right: hasArc ? 0 : $$.getCurrentPaddingRight(),\n          bottom: $$.getHorizontalAxisHeight('y') + legendHeightForBottom + $$.getCurrentPaddingBottom(),\n          left: subchartHeight + (hasArc ? 0 : $$.getCurrentPaddingLeft())\n        }\n      : {\n          top: 4 + $$.getCurrentPaddingTop(),\n          // for top tick text\n          right: hasArc ? 0 : $$.getCurrentPaddingRight(),\n          bottom: xAxisHeight + subchartHeight + legendHeightForBottom + $$.getCurrentPaddingBottom(),\n          left: hasArc ? 0 : $$.getCurrentPaddingLeft()\n        } // for subchart\n\n    $$.margin2 = config.axis_rotated\n      ? {\n          top: $$.margin.top,\n          right: NaN,\n          bottom: 20 + legendHeightForBottom,\n          left: $$.rotated_padding_left\n        }\n      : {\n          top: $$.currentHeight - subchartHeight - legendHeightForBottom,\n          right: NaN,\n          bottom: xAxisHeight + legendHeightForBottom,\n          left: $$.margin.left\n        } // for legend\n\n    $$.margin3 = {\n      top: 0,\n      right: NaN,\n      bottom: 0,\n      left: 0\n    }\n\n    if ($$.updateSizeForLegend) {\n      $$.updateSizeForLegend(legendHeight, legendWidth)\n    }\n\n    $$.width = $$.currentWidth - $$.margin.left - $$.margin.right\n    $$.height = $$.currentHeight - $$.margin.top - $$.margin.bottom\n\n    if ($$.width < 0) {\n      $$.width = 0\n    }\n\n    if ($$.height < 0) {\n      $$.height = 0\n    }\n\n    $$.width2 = config.axis_rotated ? $$.margin.left - $$.rotated_padding_left - $$.rotated_padding_right : $$.width\n    $$.height2 = config.axis_rotated ? $$.height : $$.currentHeight - $$.margin2.top - $$.margin2.bottom\n\n    if ($$.width2 < 0) {\n      $$.width2 = 0\n    }\n\n    if ($$.height2 < 0) {\n      $$.height2 = 0\n    } // for arc\n\n    $$.arcWidth = $$.width - ($$.isLegendRight ? legendWidth + 10 : 0)\n    $$.arcHeight = $$.height - ($$.isLegendRight ? 0 : 10)\n\n    if ($$.hasType('gauge') && !config.gauge_fullCircle) {\n      $$.arcHeight += $$.height - $$.getGaugeLabelHeight()\n    }\n\n    if ($$.updateRadius) {\n      $$.updateRadius()\n    }\n\n    if ($$.isLegendRight && hasArc) {\n      $$.margin3.left = $$.arcWidth / 2 + $$.radiusExpanded * 1.1\n    }\n  }\n\n  ChartInternal.prototype.updateTargets = function (targets) {\n    var $$ = this\n    /*-- Main --*/\n    //-- Text --//\n\n    $$.updateTargetsForText(targets) //-- Bar --//\n\n    $$.updateTargetsForBar(targets) //-- Line --//\n\n    $$.updateTargetsForLine(targets) //-- Arc --//\n\n    if ($$.hasArcType() && $$.updateTargetsForArc) {\n      $$.updateTargetsForArc(targets)\n    }\n    /*-- Sub --*/\n\n    if ($$.updateTargetsForSubchart) {\n      $$.updateTargetsForSubchart(targets)\n    } // Fade-in each chart\n\n    $$.showTargets()\n  }\n\n  ChartInternal.prototype.showTargets = function () {\n    var $$ = this\n    $$.svg\n      .selectAll('.' + CLASS.target)\n      .filter(function (d) {\n        return $$.isTargetToShow(d.id)\n      })\n      .transition()\n      .duration($$.config.transition_duration)\n      .style('opacity', 1)\n  }\n\n  ChartInternal.prototype.redraw = function (options, transitions) {\n    var $$ = this,\n      main = $$.main,\n      d3 = $$.d3,\n      config = $$.config\n    var areaIndices = $$.getShapeIndices($$.isAreaType),\n      barIndices = $$.getShapeIndices($$.isBarType),\n      lineIndices = $$.getShapeIndices($$.isLineType)\n    var withY,\n      withSubchart,\n      withTransition,\n      withTransitionForExit,\n      withTransitionForAxis,\n      withTransform,\n      withUpdateXDomain,\n      withUpdateOrgXDomain,\n      withTrimXDomain,\n      withLegend,\n      withEventRect,\n      withDimension,\n      withUpdateXAxis\n    var hideAxis = $$.hasArcType()\n    var drawArea, drawBar, drawLine, xForText, yForText\n    var duration, durationForExit, durationForAxis\n    var transitionsToWait, waitForDraw, flow, transition\n    var targetsToShow = $$.filterTargetsToShow($$.data.targets),\n      tickValues,\n      i,\n      intervalForCulling,\n      xDomainForZoom\n    var xv = $$.xv.bind($$),\n      cx,\n      cy\n    options = options || {}\n    withY = getOption(options, 'withY', true)\n    withSubchart = getOption(options, 'withSubchart', true)\n    withTransition = getOption(options, 'withTransition', true)\n    withTransform = getOption(options, 'withTransform', false)\n    withUpdateXDomain = getOption(options, 'withUpdateXDomain', false)\n    withUpdateOrgXDomain = getOption(options, 'withUpdateOrgXDomain', false)\n    withTrimXDomain = getOption(options, 'withTrimXDomain', true)\n    withUpdateXAxis = getOption(options, 'withUpdateXAxis', withUpdateXDomain)\n    withLegend = getOption(options, 'withLegend', false)\n    withEventRect = getOption(options, 'withEventRect', true)\n    withDimension = getOption(options, 'withDimension', true)\n    withTransitionForExit = getOption(options, 'withTransitionForExit', withTransition)\n    withTransitionForAxis = getOption(options, 'withTransitionForAxis', withTransition)\n    duration = withTransition ? config.transition_duration : 0\n    durationForExit = withTransitionForExit ? duration : 0\n    durationForAxis = withTransitionForAxis ? duration : 0\n    transitions = transitions || $$.axis.generateTransitions(durationForAxis) // update legend and transform each g\n\n    if (withLegend && config.legend_show) {\n      $$.updateLegend($$.mapToIds($$.data.targets), options, transitions)\n    } else if (withDimension) {\n      // need to update dimension (e.g. axis.y.tick.values) because y tick values should change\n      // no need to update axis in it because they will be updated in redraw()\n      $$.updateDimension(true)\n    } // MEMO: needed for grids calculation\n\n    if ($$.isCategorized() && targetsToShow.length === 0) {\n      $$.x.domain([0, $$.axes.x.selectAll('.tick').size()])\n    }\n\n    if (targetsToShow.length) {\n      $$.updateXDomain(targetsToShow, withUpdateXDomain, withUpdateOrgXDomain, withTrimXDomain)\n\n      if (!config.axis_x_tick_values) {\n        tickValues = $$.axis.updateXAxisTickValues(targetsToShow)\n      }\n    } else {\n      $$.xAxis.tickValues([])\n      $$.subXAxis.tickValues([])\n    }\n\n    if (config.zoom_rescale && !options.flow) {\n      xDomainForZoom = $$.x.orgDomain()\n    }\n\n    $$.y.domain($$.getYDomain(targetsToShow, 'y', xDomainForZoom))\n    $$.y2.domain($$.getYDomain(targetsToShow, 'y2', xDomainForZoom))\n\n    if (!config.axis_y_tick_values && config.axis_y_tick_count) {\n      $$.yAxis.tickValues($$.axis.generateTickValues($$.y.domain(), config.axis_y_tick_count))\n    }\n\n    if (!config.axis_y2_tick_values && config.axis_y2_tick_count) {\n      $$.y2Axis.tickValues($$.axis.generateTickValues($$.y2.domain(), config.axis_y2_tick_count))\n    } // axes\n\n    $$.axis.redraw(durationForAxis, hideAxis) // Update axis label\n\n    $$.axis.updateLabels(withTransition) // show/hide if manual culling needed\n\n    if ((withUpdateXDomain || withUpdateXAxis) && targetsToShow.length) {\n      if (config.axis_x_tick_culling && tickValues) {\n        for (i = 1; i < tickValues.length; i++) {\n          if (tickValues.length / i < config.axis_x_tick_culling_max) {\n            intervalForCulling = i\n            break\n          }\n        }\n\n        $$.svg.selectAll('.' + CLASS.axisX + ' .tick text').each(function (e) {\n          var index = tickValues.indexOf(e)\n\n          if (index >= 0) {\n            d3.select(this).style('display', index % intervalForCulling ? 'none' : 'block')\n          }\n        })\n      } else {\n        $$.svg.selectAll('.' + CLASS.axisX + ' .tick text').style('display', 'block')\n      }\n    } // setup drawer - MEMO: these must be called after axis updated\n\n    drawArea = $$.generateDrawArea ? $$.generateDrawArea(areaIndices, false) : undefined\n    drawBar = $$.generateDrawBar ? $$.generateDrawBar(barIndices) : undefined\n    drawLine = $$.generateDrawLine ? $$.generateDrawLine(lineIndices, false) : undefined\n    xForText = $$.generateXYForText(areaIndices, barIndices, lineIndices, true)\n    yForText = $$.generateXYForText(areaIndices, barIndices, lineIndices, false) // update circleY based on updated parameters\n\n    $$.updateCircleY() // generate circle x/y functions depending on updated params\n\n    cx = ($$.config.axis_rotated ? $$.circleY : $$.circleX).bind($$)\n    cy = ($$.config.axis_rotated ? $$.circleX : $$.circleY).bind($$) // Update sub domain\n\n    if (withY) {\n      $$.subY.domain($$.getYDomain(targetsToShow, 'y'))\n      $$.subY2.domain($$.getYDomain(targetsToShow, 'y2'))\n    } // xgrid focus\n\n    $$.updateXgridFocus() // Data empty label positioning and text.\n\n    main\n      .select('text.' + CLASS.text + '.' + CLASS.empty)\n      .attr('x', $$.width / 2)\n      .attr('y', $$.height / 2)\n      .text(config.data_empty_label_text)\n      .transition()\n      .style('opacity', targetsToShow.length ? 0 : 1) // event rect\n\n    if (withEventRect) {\n      $$.redrawEventRect()\n    } // grid\n\n    $$.updateGrid(duration) // rect for regions\n\n    $$.updateRegion(duration) // bars\n\n    $$.updateBar(durationForExit) // lines, areas and cricles\n\n    $$.updateLine(durationForExit)\n    $$.updateArea(durationForExit)\n    $$.updateCircle(cx, cy) // text\n\n    if ($$.hasDataLabel()) {\n      $$.updateText(xForText, yForText, durationForExit)\n    } // title\n\n    if ($$.redrawTitle) {\n      $$.redrawTitle()\n    } // arc\n\n    if ($$.redrawArc) {\n      $$.redrawArc(duration, durationForExit, withTransform)\n    } // subchart\n\n    if ($$.redrawSubchart) {\n      $$.redrawSubchart(withSubchart, transitions, duration, durationForExit, areaIndices, barIndices, lineIndices)\n    } // circles for select\n\n    main\n      .selectAll('.' + CLASS.selectedCircles)\n      .filter($$.isBarType.bind($$))\n      .selectAll('circle')\n      .remove()\n\n    if (options.flow) {\n      flow = $$.generateFlow({\n        targets: targetsToShow,\n        flow: options.flow,\n        duration: options.flow.duration,\n        drawBar: drawBar,\n        drawLine: drawLine,\n        drawArea: drawArea,\n        cx: cx,\n        cy: cy,\n        xv: xv,\n        xForText: xForText,\n        yForText: yForText\n      })\n    }\n\n    if ($$.isTabVisible()) {\n      // Only use transition if tab visible. See #938.\n      if (duration) {\n        // transition should be derived from one transition\n        transition = d3.transition().duration(duration)\n        transitionsToWait = []\n        ;[\n          $$.redrawBar(drawBar, true, transition),\n          $$.redrawLine(drawLine, true, transition),\n          $$.redrawArea(drawArea, true, transition),\n          $$.redrawCircle(cx, cy, true, transition),\n          $$.redrawText(xForText, yForText, options.flow, true, transition),\n          $$.redrawRegion(true, transition),\n          $$.redrawGrid(true, transition)\n        ].forEach(function (transitions) {\n          transitions.forEach(function (transition) {\n            transitionsToWait.push(transition)\n          })\n        }) // Wait for end of transitions to call flow and onrendered callback\n\n        waitForDraw = $$.generateWait()\n        transitionsToWait.forEach(function (t) {\n          waitForDraw.add(t)\n        })\n        waitForDraw(function () {\n          if (flow) {\n            flow()\n          }\n\n          if (config.onrendered) {\n            config.onrendered.call($$)\n          }\n        })\n      } else {\n        $$.redrawBar(drawBar)\n        $$.redrawLine(drawLine)\n        $$.redrawArea(drawArea)\n        $$.redrawCircle(cx, cy)\n        $$.redrawText(xForText, yForText, options.flow)\n        $$.redrawRegion()\n        $$.redrawGrid()\n\n        if (flow) {\n          flow()\n        }\n\n        if (config.onrendered) {\n          config.onrendered.call($$)\n        }\n      }\n    } // update fadein condition\n\n    $$.mapToIds($$.data.targets).forEach(function (id) {\n      $$.withoutFadeIn[id] = true\n    })\n  }\n\n  ChartInternal.prototype.updateAndRedraw = function (options) {\n    var $$ = this,\n      config = $$.config,\n      transitions\n    options = options || {} // same with redraw\n\n    options.withTransition = getOption(options, 'withTransition', true)\n    options.withTransform = getOption(options, 'withTransform', false)\n    options.withLegend = getOption(options, 'withLegend', false) // NOT same with redraw\n\n    options.withUpdateXDomain = getOption(options, 'withUpdateXDomain', true)\n    options.withUpdateOrgXDomain = getOption(options, 'withUpdateOrgXDomain', true)\n    options.withTransitionForExit = false\n    options.withTransitionForTransform = getOption(options, 'withTransitionForTransform', options.withTransition) // MEMO: this needs to be called before updateLegend and it means this ALWAYS needs to be called)\n\n    $$.updateSizes() // MEMO: called in updateLegend in redraw if withLegend\n\n    if (!(options.withLegend && config.legend_show)) {\n      transitions = $$.axis.generateTransitions(options.withTransitionForAxis ? config.transition_duration : 0) // Update scales\n\n      $$.updateScales()\n      $$.updateSvgSize() // Update g positions\n\n      $$.transformAll(options.withTransitionForTransform, transitions)\n    } // Draw with new sizes & scales\n\n    $$.redraw(options, transitions)\n  }\n\n  ChartInternal.prototype.redrawWithoutRescale = function () {\n    this.redraw({\n      withY: false,\n      withSubchart: false,\n      withEventRect: false,\n      withTransitionForAxis: false\n    })\n  }\n\n  ChartInternal.prototype.isTimeSeries = function () {\n    return this.config.axis_x_type === 'timeseries'\n  }\n\n  ChartInternal.prototype.isCategorized = function () {\n    return this.config.axis_x_type.indexOf('categor') >= 0\n  }\n\n  ChartInternal.prototype.isCustomX = function () {\n    var $$ = this,\n      config = $$.config\n    return !$$.isTimeSeries() && (config.data_x || notEmpty(config.data_xs))\n  }\n\n  ChartInternal.prototype.isTimeSeriesY = function () {\n    return this.config.axis_y_type === 'timeseries'\n  }\n\n  ChartInternal.prototype.getTranslate = function (target) {\n    var $$ = this,\n      config = $$.config,\n      x,\n      y\n\n    if (target === 'main') {\n      x = asHalfPixel($$.margin.left)\n      y = asHalfPixel($$.margin.top)\n    } else if (target === 'context') {\n      x = asHalfPixel($$.margin2.left)\n      y = asHalfPixel($$.margin2.top)\n    } else if (target === 'legend') {\n      x = $$.margin3.left\n      y = $$.margin3.top\n    } else if (target === 'x') {\n      x = 0\n      y = config.axis_rotated ? 0 : $$.height\n    } else if (target === 'y') {\n      x = 0\n      y = config.axis_rotated ? $$.height : 0\n    } else if (target === 'y2') {\n      x = config.axis_rotated ? 0 : $$.width\n      y = config.axis_rotated ? 1 : 0\n    } else if (target === 'subx') {\n      x = 0\n      y = config.axis_rotated ? 0 : $$.height2\n    } else if (target === 'arc') {\n      x = $$.arcWidth / 2\n      y = $$.arcHeight / 2 - ($$.hasType('gauge') ? 6 : 0) // to prevent wrong display of min and max label\n    }\n\n    return 'translate(' + x + ',' + y + ')'\n  }\n\n  ChartInternal.prototype.initialOpacity = function (d) {\n    return d.value !== null && this.withoutFadeIn[d.id] ? 1 : 0\n  }\n\n  ChartInternal.prototype.initialOpacityForCircle = function (d) {\n    return d.value !== null && this.withoutFadeIn[d.id] ? this.opacityForCircle(d) : 0\n  }\n\n  ChartInternal.prototype.opacityForCircle = function (d) {\n    var isPointShouldBeShown = isFunction(this.config.point_show) ? this.config.point_show(d) : this.config.point_show\n    var opacity = isPointShouldBeShown ? 1 : 0\n    return isValue(d.value) ? (this.isScatterType(d) ? 0.5 : opacity) : 0\n  }\n\n  ChartInternal.prototype.opacityForText = function () {\n    return this.hasDataLabel() ? 1 : 0\n  }\n\n  ChartInternal.prototype.xx = function (d) {\n    return d ? this.x(d.x) : null\n  }\n\n  ChartInternal.prototype.xv = function (d) {\n    var $$ = this,\n      value = d.value\n\n    if ($$.isTimeSeries()) {\n      value = $$.parseDate(d.value)\n    } else if ($$.isCategorized() && typeof d.value === 'string') {\n      value = $$.config.axis_x_categories.indexOf(d.value)\n    }\n\n    return Math.ceil($$.x(value))\n  }\n\n  ChartInternal.prototype.yv = function (d) {\n    var $$ = this,\n      yScale = d.axis && d.axis === 'y2' ? $$.y2 : $$.y\n    return Math.ceil(yScale(d.value))\n  }\n\n  ChartInternal.prototype.subxx = function (d) {\n    return d ? this.subX(d.x) : null\n  }\n\n  ChartInternal.prototype.transformMain = function (withTransition, transitions) {\n    var $$ = this,\n      xAxis,\n      yAxis,\n      y2Axis\n\n    if (transitions && transitions.axisX) {\n      xAxis = transitions.axisX\n    } else {\n      xAxis = $$.main.select('.' + CLASS.axisX)\n\n      if (withTransition) {\n        xAxis = xAxis.transition()\n      }\n    }\n\n    if (transitions && transitions.axisY) {\n      yAxis = transitions.axisY\n    } else {\n      yAxis = $$.main.select('.' + CLASS.axisY)\n\n      if (withTransition) {\n        yAxis = yAxis.transition()\n      }\n    }\n\n    if (transitions && transitions.axisY2) {\n      y2Axis = transitions.axisY2\n    } else {\n      y2Axis = $$.main.select('.' + CLASS.axisY2)\n\n      if (withTransition) {\n        y2Axis = y2Axis.transition()\n      }\n    }\n\n    ;(withTransition ? $$.main.transition() : $$.main).attr('transform', $$.getTranslate('main'))\n    xAxis.attr('transform', $$.getTranslate('x'))\n    yAxis.attr('transform', $$.getTranslate('y'))\n    y2Axis.attr('transform', $$.getTranslate('y2'))\n    $$.main.select('.' + CLASS.chartArcs).attr('transform', $$.getTranslate('arc'))\n  }\n\n  ChartInternal.prototype.transformAll = function (withTransition, transitions) {\n    var $$ = this\n    $$.transformMain(withTransition, transitions)\n\n    if ($$.config.subchart_show) {\n      $$.transformContext(withTransition, transitions)\n    }\n\n    if ($$.legend) {\n      $$.transformLegend(withTransition)\n    }\n  }\n\n  ChartInternal.prototype.updateSvgSize = function () {\n    var $$ = this,\n      brush = $$.svg.select('.c3-brush .overlay')\n    $$.svg.attr('width', $$.currentWidth).attr('height', $$.currentHeight)\n    $$.svg\n      .selectAll(['#' + $$.clipId, '#' + $$.clipIdForGrid])\n      .select('rect')\n      .attr('width', $$.width)\n      .attr('height', $$.height)\n    $$.svg\n      .select('#' + $$.clipIdForXAxis)\n      .select('rect')\n      .attr('x', $$.getXAxisClipX.bind($$))\n      .attr('y', $$.getXAxisClipY.bind($$))\n      .attr('width', $$.getXAxisClipWidth.bind($$))\n      .attr('height', $$.getXAxisClipHeight.bind($$))\n    $$.svg\n      .select('#' + $$.clipIdForYAxis)\n      .select('rect')\n      .attr('x', $$.getYAxisClipX.bind($$))\n      .attr('y', $$.getYAxisClipY.bind($$))\n      .attr('width', $$.getYAxisClipWidth.bind($$))\n      .attr('height', $$.getYAxisClipHeight.bind($$))\n    $$.svg\n      .select('#' + $$.clipIdForSubchart)\n      .select('rect')\n      .attr('width', $$.width)\n      .attr('height', brush.size() ? brush.attr('height') : 0)\n  }\n\n  ChartInternal.prototype.updateDimension = function (withoutAxis) {\n    var $$ = this\n\n    if (!withoutAxis) {\n      if ($$.config.axis_rotated) {\n        $$.axes.x.call($$.xAxis)\n        $$.axes.subx.call($$.subXAxis)\n      } else {\n        $$.axes.y.call($$.yAxis)\n        $$.axes.y2.call($$.y2Axis)\n      }\n    }\n\n    $$.updateSizes()\n    $$.updateScales()\n    $$.updateSvgSize()\n    $$.transformAll(false)\n  }\n\n  ChartInternal.prototype.observeInserted = function (selection) {\n    var $$ = this,\n      observer\n\n    if (typeof MutationObserver === 'undefined') {\n      window.console.error('MutationObserver not defined.')\n      return\n    }\n\n    observer = new MutationObserver(function (mutations) {\n      mutations.forEach(function (mutation) {\n        if (mutation.type === 'childList' && mutation.previousSibling) {\n          observer.disconnect() // need to wait for completion of load because size calculation requires the actual sizes determined after that completion\n\n          $$.intervalForObserveInserted = window.setInterval(function () {\n            // parentNode will NOT be null when completed\n            if (selection.node().parentNode) {\n              window.clearInterval($$.intervalForObserveInserted)\n              $$.updateDimension()\n\n              if ($$.brush) {\n                $$.brush.update()\n              }\n\n              $$.config.oninit.call($$)\n              $$.redraw({\n                withTransform: true,\n                withUpdateXDomain: true,\n                withUpdateOrgXDomain: true,\n                withTransition: false,\n                withTransitionForTransform: false,\n                withLegend: true\n              })\n              selection.transition().style('opacity', 1)\n            }\n          }, 10)\n        }\n      })\n    })\n    observer.observe(selection.node(), {\n      attributes: true,\n      childList: true,\n      characterData: true\n    })\n  }\n  /**\n   * Binds handlers to the window resize event.\n   */\n\n  ChartInternal.prototype.bindResize = function () {\n    var $$ = this,\n      config = $$.config\n    $$.resizeFunction = $$.generateResize() // need to call .remove\n\n    $$.resizeFunction.add(function () {\n      config.onresize.call($$)\n    })\n\n    if (config.resize_auto) {\n      $$.resizeFunction.add(function () {\n        if ($$.resizeTimeout !== undefined) {\n          window.clearTimeout($$.resizeTimeout)\n        }\n\n        $$.resizeTimeout = window.setTimeout(function () {\n          delete $$.resizeTimeout\n          $$.updateAndRedraw({\n            withUpdateXDomain: false,\n            withUpdateOrgXDomain: false,\n            withTransition: false,\n            withTransitionForTransform: false,\n            withLegend: true\n          })\n\n          if ($$.brush) {\n            $$.brush.update()\n          }\n        }, 100)\n      })\n    }\n\n    $$.resizeFunction.add(function () {\n      config.onresized.call($$)\n    })\n\n    $$.resizeIfElementDisplayed = function () {\n      // if element not displayed skip it\n      if ($$.api == null || !$$.api.element.offsetParent) {\n        return\n      }\n\n      $$.resizeFunction()\n    }\n\n    if (window.attachEvent) {\n      window.attachEvent('onresize', $$.resizeIfElementDisplayed)\n    } else if (window.addEventListener) {\n      window.addEventListener('resize', $$.resizeIfElementDisplayed, false)\n    } else {\n      // fallback to this, if this is a very old browser\n      var wrapper = window.onresize\n\n      if (!wrapper) {\n        // create a wrapper that will call all charts\n        wrapper = $$.generateResize()\n      } else if (!wrapper.add || !wrapper.remove) {\n        // there is already a handler registered, make sure we call it too\n        wrapper = $$.generateResize()\n        wrapper.add(window.onresize)\n      } // add this graph to the wrapper, we will be removed if the user calls destroy\n\n      wrapper.add($$.resizeFunction)\n\n      window.onresize = function () {\n        // if element not displayed skip it\n        if (!$$.api.element.offsetParent) {\n          return\n        }\n\n        wrapper()\n      }\n    }\n  }\n  /**\n   * Binds handlers to the window focus event.\n   */\n\n  ChartInternal.prototype.bindWindowFocus = function () {\n    var _this = this\n\n    if (this.windowFocusHandler) {\n      // The handler is already set\n      return\n    }\n\n    this.windowFocusHandler = function () {\n      _this.redraw()\n    }\n\n    window.addEventListener('focus', this.windowFocusHandler)\n  }\n  /**\n   * Unbinds from the window focus event.\n   */\n\n  ChartInternal.prototype.unbindWindowFocus = function () {\n    window.removeEventListener('focus', this.windowFocusHandler)\n    delete this.windowFocusHandler\n  }\n\n  ChartInternal.prototype.generateResize = function () {\n    var resizeFunctions = []\n\n    function callResizeFunctions () {\n      resizeFunctions.forEach(function (f) {\n        f()\n      })\n    }\n\n    callResizeFunctions.add = function (f) {\n      resizeFunctions.push(f)\n    }\n\n    callResizeFunctions.remove = function (f) {\n      for (var i = 0; i < resizeFunctions.length; i++) {\n        if (resizeFunctions[i] === f) {\n          resizeFunctions.splice(i, 1)\n          break\n        }\n      }\n    }\n\n    return callResizeFunctions\n  }\n\n  ChartInternal.prototype.endall = function (transition, callback) {\n    var n = 0\n    transition\n      .each(function () {\n        ++n\n      })\n      .on('end', function () {\n        if (!--n) {\n          callback.apply(this, arguments)\n        }\n      })\n  }\n\n  ChartInternal.prototype.generateWait = function () {\n    var transitionsToWait = [],\n      f = function f (callback) {\n        var timer = setInterval(function () {\n          var done = 0\n          transitionsToWait.forEach(function (t) {\n            if (t.empty()) {\n              done += 1\n              return\n            }\n\n            try {\n              t.transition()\n            } catch (e) {\n              done += 1\n            }\n          })\n\n          if (done === transitionsToWait.length) {\n            clearInterval(timer)\n\n            if (callback) {\n              callback()\n            }\n          }\n        }, 50)\n      }\n\n    f.add = function (transition) {\n      transitionsToWait.push(transition)\n    }\n\n    return f\n  }\n\n  ChartInternal.prototype.parseDate = function (date) {\n    var $$ = this,\n      parsedDate\n\n    if (date instanceof Date) {\n      parsedDate = date\n    } else if (typeof date === 'string') {\n      parsedDate = $$.dataTimeParse(date)\n    } else if (_typeof(date) === 'object') {\n      parsedDate = new Date(+date)\n    } else if (typeof date === 'number' && !isNaN(date)) {\n      parsedDate = new Date(+date)\n    }\n\n    if (!parsedDate || isNaN(+parsedDate)) {\n      window.console.error(\"Failed to parse x '\" + date + \"' to Date object\")\n    }\n\n    return parsedDate\n  }\n\n  ChartInternal.prototype.isTabVisible = function () {\n    return !document.hidden\n  }\n\n  ChartInternal.prototype.getPathBox = getPathBox\n  ChartInternal.prototype.CLASS = CLASS\n\n  /* jshint ignore:start */\n  // SVGPathSeg API polyfill\n  // https://github.com/progers/pathseg\n  //\n  // This is a drop-in replacement for the SVGPathSeg and SVGPathSegList APIs that were removed from\n  // SVG2 (https://lists.w3.org/Archives/Public/www-svg/2015Jun/0044.html), including the latest spec\n  // changes which were implemented in Firefox 43 and Chrome 46.\n  ;(function () {\n    if (!('SVGPathSeg' in window)) {\n      // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGPathSeg\n      window.SVGPathSeg = function (type, typeAsLetter, owningPathSegList) {\n        this.pathSegType = type\n        this.pathSegTypeAsLetter = typeAsLetter\n        this._owningPathSegList = owningPathSegList\n      }\n\n      window.SVGPathSeg.prototype.classname = 'SVGPathSeg'\n      window.SVGPathSeg.PATHSEG_UNKNOWN = 0\n      window.SVGPathSeg.PATHSEG_CLOSEPATH = 1\n      window.SVGPathSeg.PATHSEG_MOVETO_ABS = 2\n      window.SVGPathSeg.PATHSEG_MOVETO_REL = 3\n      window.SVGPathSeg.PATHSEG_LINETO_ABS = 4\n      window.SVGPathSeg.PATHSEG_LINETO_REL = 5\n      window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS = 6\n      window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL = 7\n      window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS = 8\n      window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL = 9\n      window.SVGPathSeg.PATHSEG_ARC_ABS = 10\n      window.SVGPathSeg.PATHSEG_ARC_REL = 11\n      window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS = 12\n      window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL = 13\n      window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS = 14\n      window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL = 15\n      window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = 16\n      window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL = 17\n      window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = 18\n      window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = 19 // Notify owning PathSegList on any changes so they can be synchronized back to the path element.\n\n      window.SVGPathSeg.prototype._segmentChanged = function () {\n        if (this._owningPathSegList) this._owningPathSegList.segmentChanged(this)\n      }\n\n      window.SVGPathSegClosePath = function (owningPathSegList) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CLOSEPATH, 'z', owningPathSegList)\n      }\n\n      window.SVGPathSegClosePath.prototype = Object.create(window.SVGPathSeg.prototype)\n\n      window.SVGPathSegClosePath.prototype.toString = function () {\n        return '[object SVGPathSegClosePath]'\n      }\n\n      window.SVGPathSegClosePath.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter\n      }\n\n      window.SVGPathSegClosePath.prototype.clone = function () {\n        return new window.SVGPathSegClosePath(undefined)\n      }\n\n      window.SVGPathSegMovetoAbs = function (owningPathSegList, x, y) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_MOVETO_ABS, 'M', owningPathSegList)\n        this._x = x\n        this._y = y\n      }\n\n      window.SVGPathSegMovetoAbs.prototype = Object.create(window.SVGPathSeg.prototype)\n\n      window.SVGPathSegMovetoAbs.prototype.toString = function () {\n        return '[object SVGPathSegMovetoAbs]'\n      }\n\n      window.SVGPathSegMovetoAbs.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y\n      }\n\n      window.SVGPathSegMovetoAbs.prototype.clone = function () {\n        return new window.SVGPathSegMovetoAbs(undefined, this._x, this._y)\n      }\n\n      Object.defineProperty(window.SVGPathSegMovetoAbs.prototype, 'x', {\n        get: function get () {\n          return this._x\n        },\n        set: function set (x) {\n          this._x = x\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegMovetoAbs.prototype, 'y', {\n        get: function get () {\n          return this._y\n        },\n        set: function set (y) {\n          this._y = y\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n\n      window.SVGPathSegMovetoRel = function (owningPathSegList, x, y) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_MOVETO_REL, 'm', owningPathSegList)\n        this._x = x\n        this._y = y\n      }\n\n      window.SVGPathSegMovetoRel.prototype = Object.create(window.SVGPathSeg.prototype)\n\n      window.SVGPathSegMovetoRel.prototype.toString = function () {\n        return '[object SVGPathSegMovetoRel]'\n      }\n\n      window.SVGPathSegMovetoRel.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y\n      }\n\n      window.SVGPathSegMovetoRel.prototype.clone = function () {\n        return new window.SVGPathSegMovetoRel(undefined, this._x, this._y)\n      }\n\n      Object.defineProperty(window.SVGPathSegMovetoRel.prototype, 'x', {\n        get: function get () {\n          return this._x\n        },\n        set: function set (x) {\n          this._x = x\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegMovetoRel.prototype, 'y', {\n        get: function get () {\n          return this._y\n        },\n        set: function set (y) {\n          this._y = y\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n\n      window.SVGPathSegLinetoAbs = function (owningPathSegList, x, y) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_ABS, 'L', owningPathSegList)\n        this._x = x\n        this._y = y\n      }\n\n      window.SVGPathSegLinetoAbs.prototype = Object.create(window.SVGPathSeg.prototype)\n\n      window.SVGPathSegLinetoAbs.prototype.toString = function () {\n        return '[object SVGPathSegLinetoAbs]'\n      }\n\n      window.SVGPathSegLinetoAbs.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y\n      }\n\n      window.SVGPathSegLinetoAbs.prototype.clone = function () {\n        return new window.SVGPathSegLinetoAbs(undefined, this._x, this._y)\n      }\n\n      Object.defineProperty(window.SVGPathSegLinetoAbs.prototype, 'x', {\n        get: function get () {\n          return this._x\n        },\n        set: function set (x) {\n          this._x = x\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegLinetoAbs.prototype, 'y', {\n        get: function get () {\n          return this._y\n        },\n        set: function set (y) {\n          this._y = y\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n\n      window.SVGPathSegLinetoRel = function (owningPathSegList, x, y) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_REL, 'l', owningPathSegList)\n        this._x = x\n        this._y = y\n      }\n\n      window.SVGPathSegLinetoRel.prototype = Object.create(window.SVGPathSeg.prototype)\n\n      window.SVGPathSegLinetoRel.prototype.toString = function () {\n        return '[object SVGPathSegLinetoRel]'\n      }\n\n      window.SVGPathSegLinetoRel.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y\n      }\n\n      window.SVGPathSegLinetoRel.prototype.clone = function () {\n        return new window.SVGPathSegLinetoRel(undefined, this._x, this._y)\n      }\n\n      Object.defineProperty(window.SVGPathSegLinetoRel.prototype, 'x', {\n        get: function get () {\n          return this._x\n        },\n        set: function set (x) {\n          this._x = x\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegLinetoRel.prototype, 'y', {\n        get: function get () {\n          return this._y\n        },\n        set: function set (y) {\n          this._y = y\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n\n      window.SVGPathSegCurvetoCubicAbs = function (owningPathSegList, x, y, x1, y1, x2, y2) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS, 'C', owningPathSegList)\n        this._x = x\n        this._y = y\n        this._x1 = x1\n        this._y1 = y1\n        this._x2 = x2\n        this._y2 = y2\n      }\n\n      window.SVGPathSegCurvetoCubicAbs.prototype = Object.create(window.SVGPathSeg.prototype)\n\n      window.SVGPathSegCurvetoCubicAbs.prototype.toString = function () {\n        return '[object SVGPathSegCurvetoCubicAbs]'\n      }\n\n      window.SVGPathSegCurvetoCubicAbs.prototype._asPathString = function () {\n        return (\n          this.pathSegTypeAsLetter +\n          ' ' +\n          this._x1 +\n          ' ' +\n          this._y1 +\n          ' ' +\n          this._x2 +\n          ' ' +\n          this._y2 +\n          ' ' +\n          this._x +\n          ' ' +\n          this._y\n        )\n      }\n\n      window.SVGPathSegCurvetoCubicAbs.prototype.clone = function () {\n        return new window.SVGPathSegCurvetoCubicAbs(undefined, this._x, this._y, this._x1, this._y1, this._x2, this._y2)\n      }\n\n      Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, 'x', {\n        get: function get () {\n          return this._x\n        },\n        set: function set (x) {\n          this._x = x\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, 'y', {\n        get: function get () {\n          return this._y\n        },\n        set: function set (y) {\n          this._y = y\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, 'x1', {\n        get: function get () {\n          return this._x1\n        },\n        set: function set (x1) {\n          this._x1 = x1\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, 'y1', {\n        get: function get () {\n          return this._y1\n        },\n        set: function set (y1) {\n          this._y1 = y1\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, 'x2', {\n        get: function get () {\n          return this._x2\n        },\n        set: function set (x2) {\n          this._x2 = x2\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, 'y2', {\n        get: function get () {\n          return this._y2\n        },\n        set: function set (y2) {\n          this._y2 = y2\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n\n      window.SVGPathSegCurvetoCubicRel = function (owningPathSegList, x, y, x1, y1, x2, y2) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL, 'c', owningPathSegList)\n        this._x = x\n        this._y = y\n        this._x1 = x1\n        this._y1 = y1\n        this._x2 = x2\n        this._y2 = y2\n      }\n\n      window.SVGPathSegCurvetoCubicRel.prototype = Object.create(window.SVGPathSeg.prototype)\n\n      window.SVGPathSegCurvetoCubicRel.prototype.toString = function () {\n        return '[object SVGPathSegCurvetoCubicRel]'\n      }\n\n      window.SVGPathSegCurvetoCubicRel.prototype._asPathString = function () {\n        return (\n          this.pathSegTypeAsLetter +\n          ' ' +\n          this._x1 +\n          ' ' +\n          this._y1 +\n          ' ' +\n          this._x2 +\n          ' ' +\n          this._y2 +\n          ' ' +\n          this._x +\n          ' ' +\n          this._y\n        )\n      }\n\n      window.SVGPathSegCurvetoCubicRel.prototype.clone = function () {\n        return new window.SVGPathSegCurvetoCubicRel(undefined, this._x, this._y, this._x1, this._y1, this._x2, this._y2)\n      }\n\n      Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, 'x', {\n        get: function get () {\n          return this._x\n        },\n        set: function set (x) {\n          this._x = x\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, 'y', {\n        get: function get () {\n          return this._y\n        },\n        set: function set (y) {\n          this._y = y\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, 'x1', {\n        get: function get () {\n          return this._x1\n        },\n        set: function set (x1) {\n          this._x1 = x1\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, 'y1', {\n        get: function get () {\n          return this._y1\n        },\n        set: function set (y1) {\n          this._y1 = y1\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, 'x2', {\n        get: function get () {\n          return this._x2\n        },\n        set: function set (x2) {\n          this._x2 = x2\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, 'y2', {\n        get: function get () {\n          return this._y2\n        },\n        set: function set (y2) {\n          this._y2 = y2\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n\n      window.SVGPathSegCurvetoQuadraticAbs = function (owningPathSegList, x, y, x1, y1) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS, 'Q', owningPathSegList)\n        this._x = x\n        this._y = y\n        this._x1 = x1\n        this._y1 = y1\n      }\n\n      window.SVGPathSegCurvetoQuadraticAbs.prototype = Object.create(window.SVGPathSeg.prototype)\n\n      window.SVGPathSegCurvetoQuadraticAbs.prototype.toString = function () {\n        return '[object SVGPathSegCurvetoQuadraticAbs]'\n      }\n\n      window.SVGPathSegCurvetoQuadraticAbs.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + ' ' + this._x1 + ' ' + this._y1 + ' ' + this._x + ' ' + this._y\n      }\n\n      window.SVGPathSegCurvetoQuadraticAbs.prototype.clone = function () {\n        return new window.SVGPathSegCurvetoQuadraticAbs(undefined, this._x, this._y, this._x1, this._y1)\n      }\n\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, 'x', {\n        get: function get () {\n          return this._x\n        },\n        set: function set (x) {\n          this._x = x\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, 'y', {\n        get: function get () {\n          return this._y\n        },\n        set: function set (y) {\n          this._y = y\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, 'x1', {\n        get: function get () {\n          return this._x1\n        },\n        set: function set (x1) {\n          this._x1 = x1\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, 'y1', {\n        get: function get () {\n          return this._y1\n        },\n        set: function set (y1) {\n          this._y1 = y1\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n\n      window.SVGPathSegCurvetoQuadraticRel = function (owningPathSegList, x, y, x1, y1) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL, 'q', owningPathSegList)\n        this._x = x\n        this._y = y\n        this._x1 = x1\n        this._y1 = y1\n      }\n\n      window.SVGPathSegCurvetoQuadraticRel.prototype = Object.create(window.SVGPathSeg.prototype)\n\n      window.SVGPathSegCurvetoQuadraticRel.prototype.toString = function () {\n        return '[object SVGPathSegCurvetoQuadraticRel]'\n      }\n\n      window.SVGPathSegCurvetoQuadraticRel.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + ' ' + this._x1 + ' ' + this._y1 + ' ' + this._x + ' ' + this._y\n      }\n\n      window.SVGPathSegCurvetoQuadraticRel.prototype.clone = function () {\n        return new window.SVGPathSegCurvetoQuadraticRel(undefined, this._x, this._y, this._x1, this._y1)\n      }\n\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, 'x', {\n        get: function get () {\n          return this._x\n        },\n        set: function set (x) {\n          this._x = x\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, 'y', {\n        get: function get () {\n          return this._y\n        },\n        set: function set (y) {\n          this._y = y\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, 'x1', {\n        get: function get () {\n          return this._x1\n        },\n        set: function set (x1) {\n          this._x1 = x1\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, 'y1', {\n        get: function get () {\n          return this._y1\n        },\n        set: function set (y1) {\n          this._y1 = y1\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n\n      window.SVGPathSegArcAbs = function (owningPathSegList, x, y, r1, r2, angle, largeArcFlag, sweepFlag) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_ARC_ABS, 'A', owningPathSegList)\n        this._x = x\n        this._y = y\n        this._r1 = r1\n        this._r2 = r2\n        this._angle = angle\n        this._largeArcFlag = largeArcFlag\n        this._sweepFlag = sweepFlag\n      }\n\n      window.SVGPathSegArcAbs.prototype = Object.create(window.SVGPathSeg.prototype)\n\n      window.SVGPathSegArcAbs.prototype.toString = function () {\n        return '[object SVGPathSegArcAbs]'\n      }\n\n      window.SVGPathSegArcAbs.prototype._asPathString = function () {\n        return (\n          this.pathSegTypeAsLetter +\n          ' ' +\n          this._r1 +\n          ' ' +\n          this._r2 +\n          ' ' +\n          this._angle +\n          ' ' +\n          (this._largeArcFlag ? '1' : '0') +\n          ' ' +\n          (this._sweepFlag ? '1' : '0') +\n          ' ' +\n          this._x +\n          ' ' +\n          this._y\n        )\n      }\n\n      window.SVGPathSegArcAbs.prototype.clone = function () {\n        return new window.SVGPathSegArcAbs(\n          undefined,\n          this._x,\n          this._y,\n          this._r1,\n          this._r2,\n          this._angle,\n          this._largeArcFlag,\n          this._sweepFlag\n        )\n      }\n\n      Object.defineProperty(window.SVGPathSegArcAbs.prototype, 'x', {\n        get: function get () {\n          return this._x\n        },\n        set: function set (x) {\n          this._x = x\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegArcAbs.prototype, 'y', {\n        get: function get () {\n          return this._y\n        },\n        set: function set (y) {\n          this._y = y\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegArcAbs.prototype, 'r1', {\n        get: function get () {\n          return this._r1\n        },\n        set: function set (r1) {\n          this._r1 = r1\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegArcAbs.prototype, 'r2', {\n        get: function get () {\n          return this._r2\n        },\n        set: function set (r2) {\n          this._r2 = r2\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegArcAbs.prototype, 'angle', {\n        get: function get () {\n          return this._angle\n        },\n        set: function set (angle) {\n          this._angle = angle\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegArcAbs.prototype, 'largeArcFlag', {\n        get: function get () {\n          return this._largeArcFlag\n        },\n        set: function set (largeArcFlag) {\n          this._largeArcFlag = largeArcFlag\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegArcAbs.prototype, 'sweepFlag', {\n        get: function get () {\n          return this._sweepFlag\n        },\n        set: function set (sweepFlag) {\n          this._sweepFlag = sweepFlag\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n\n      window.SVGPathSegArcRel = function (owningPathSegList, x, y, r1, r2, angle, largeArcFlag, sweepFlag) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_ARC_REL, 'a', owningPathSegList)\n        this._x = x\n        this._y = y\n        this._r1 = r1\n        this._r2 = r2\n        this._angle = angle\n        this._largeArcFlag = largeArcFlag\n        this._sweepFlag = sweepFlag\n      }\n\n      window.SVGPathSegArcRel.prototype = Object.create(window.SVGPathSeg.prototype)\n\n      window.SVGPathSegArcRel.prototype.toString = function () {\n        return '[object SVGPathSegArcRel]'\n      }\n\n      window.SVGPathSegArcRel.prototype._asPathString = function () {\n        return (\n          this.pathSegTypeAsLetter +\n          ' ' +\n          this._r1 +\n          ' ' +\n          this._r2 +\n          ' ' +\n          this._angle +\n          ' ' +\n          (this._largeArcFlag ? '1' : '0') +\n          ' ' +\n          (this._sweepFlag ? '1' : '0') +\n          ' ' +\n          this._x +\n          ' ' +\n          this._y\n        )\n      }\n\n      window.SVGPathSegArcRel.prototype.clone = function () {\n        return new window.SVGPathSegArcRel(\n          undefined,\n          this._x,\n          this._y,\n          this._r1,\n          this._r2,\n          this._angle,\n          this._largeArcFlag,\n          this._sweepFlag\n        )\n      }\n\n      Object.defineProperty(window.SVGPathSegArcRel.prototype, 'x', {\n        get: function get () {\n          return this._x\n        },\n        set: function set (x) {\n          this._x = x\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegArcRel.prototype, 'y', {\n        get: function get () {\n          return this._y\n        },\n        set: function set (y) {\n          this._y = y\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegArcRel.prototype, 'r1', {\n        get: function get () {\n          return this._r1\n        },\n        set: function set (r1) {\n          this._r1 = r1\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegArcRel.prototype, 'r2', {\n        get: function get () {\n          return this._r2\n        },\n        set: function set (r2) {\n          this._r2 = r2\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegArcRel.prototype, 'angle', {\n        get: function get () {\n          return this._angle\n        },\n        set: function set (angle) {\n          this._angle = angle\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegArcRel.prototype, 'largeArcFlag', {\n        get: function get () {\n          return this._largeArcFlag\n        },\n        set: function set (largeArcFlag) {\n          this._largeArcFlag = largeArcFlag\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegArcRel.prototype, 'sweepFlag', {\n        get: function get () {\n          return this._sweepFlag\n        },\n        set: function set (sweepFlag) {\n          this._sweepFlag = sweepFlag\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n\n      window.SVGPathSegLinetoHorizontalAbs = function (owningPathSegList, x) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS, 'H', owningPathSegList)\n        this._x = x\n      }\n\n      window.SVGPathSegLinetoHorizontalAbs.prototype = Object.create(window.SVGPathSeg.prototype)\n\n      window.SVGPathSegLinetoHorizontalAbs.prototype.toString = function () {\n        return '[object SVGPathSegLinetoHorizontalAbs]'\n      }\n\n      window.SVGPathSegLinetoHorizontalAbs.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + ' ' + this._x\n      }\n\n      window.SVGPathSegLinetoHorizontalAbs.prototype.clone = function () {\n        return new window.SVGPathSegLinetoHorizontalAbs(undefined, this._x)\n      }\n\n      Object.defineProperty(window.SVGPathSegLinetoHorizontalAbs.prototype, 'x', {\n        get: function get () {\n          return this._x\n        },\n        set: function set (x) {\n          this._x = x\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n\n      window.SVGPathSegLinetoHorizontalRel = function (owningPathSegList, x) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL, 'h', owningPathSegList)\n        this._x = x\n      }\n\n      window.SVGPathSegLinetoHorizontalRel.prototype = Object.create(window.SVGPathSeg.prototype)\n\n      window.SVGPathSegLinetoHorizontalRel.prototype.toString = function () {\n        return '[object SVGPathSegLinetoHorizontalRel]'\n      }\n\n      window.SVGPathSegLinetoHorizontalRel.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + ' ' + this._x\n      }\n\n      window.SVGPathSegLinetoHorizontalRel.prototype.clone = function () {\n        return new window.SVGPathSegLinetoHorizontalRel(undefined, this._x)\n      }\n\n      Object.defineProperty(window.SVGPathSegLinetoHorizontalRel.prototype, 'x', {\n        get: function get () {\n          return this._x\n        },\n        set: function set (x) {\n          this._x = x\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n\n      window.SVGPathSegLinetoVerticalAbs = function (owningPathSegList, y) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS, 'V', owningPathSegList)\n        this._y = y\n      }\n\n      window.SVGPathSegLinetoVerticalAbs.prototype = Object.create(window.SVGPathSeg.prototype)\n\n      window.SVGPathSegLinetoVerticalAbs.prototype.toString = function () {\n        return '[object SVGPathSegLinetoVerticalAbs]'\n      }\n\n      window.SVGPathSegLinetoVerticalAbs.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + ' ' + this._y\n      }\n\n      window.SVGPathSegLinetoVerticalAbs.prototype.clone = function () {\n        return new window.SVGPathSegLinetoVerticalAbs(undefined, this._y)\n      }\n\n      Object.defineProperty(window.SVGPathSegLinetoVerticalAbs.prototype, 'y', {\n        get: function get () {\n          return this._y\n        },\n        set: function set (y) {\n          this._y = y\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n\n      window.SVGPathSegLinetoVerticalRel = function (owningPathSegList, y) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL, 'v', owningPathSegList)\n        this._y = y\n      }\n\n      window.SVGPathSegLinetoVerticalRel.prototype = Object.create(window.SVGPathSeg.prototype)\n\n      window.SVGPathSegLinetoVerticalRel.prototype.toString = function () {\n        return '[object SVGPathSegLinetoVerticalRel]'\n      }\n\n      window.SVGPathSegLinetoVerticalRel.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + ' ' + this._y\n      }\n\n      window.SVGPathSegLinetoVerticalRel.prototype.clone = function () {\n        return new window.SVGPathSegLinetoVerticalRel(undefined, this._y)\n      }\n\n      Object.defineProperty(window.SVGPathSegLinetoVerticalRel.prototype, 'y', {\n        get: function get () {\n          return this._y\n        },\n        set: function set (y) {\n          this._y = y\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n\n      window.SVGPathSegCurvetoCubicSmoothAbs = function (owningPathSegList, x, y, x2, y2) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS, 'S', owningPathSegList)\n        this._x = x\n        this._y = y\n        this._x2 = x2\n        this._y2 = y2\n      }\n\n      window.SVGPathSegCurvetoCubicSmoothAbs.prototype = Object.create(window.SVGPathSeg.prototype)\n\n      window.SVGPathSegCurvetoCubicSmoothAbs.prototype.toString = function () {\n        return '[object SVGPathSegCurvetoCubicSmoothAbs]'\n      }\n\n      window.SVGPathSegCurvetoCubicSmoothAbs.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + ' ' + this._x2 + ' ' + this._y2 + ' ' + this._x + ' ' + this._y\n      }\n\n      window.SVGPathSegCurvetoCubicSmoothAbs.prototype.clone = function () {\n        return new window.SVGPathSegCurvetoCubicSmoothAbs(undefined, this._x, this._y, this._x2, this._y2)\n      }\n\n      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, 'x', {\n        get: function get () {\n          return this._x\n        },\n        set: function set (x) {\n          this._x = x\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, 'y', {\n        get: function get () {\n          return this._y\n        },\n        set: function set (y) {\n          this._y = y\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, 'x2', {\n        get: function get () {\n          return this._x2\n        },\n        set: function set (x2) {\n          this._x2 = x2\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, 'y2', {\n        get: function get () {\n          return this._y2\n        },\n        set: function set (y2) {\n          this._y2 = y2\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n\n      window.SVGPathSegCurvetoCubicSmoothRel = function (owningPathSegList, x, y, x2, y2) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL, 's', owningPathSegList)\n        this._x = x\n        this._y = y\n        this._x2 = x2\n        this._y2 = y2\n      }\n\n      window.SVGPathSegCurvetoCubicSmoothRel.prototype = Object.create(window.SVGPathSeg.prototype)\n\n      window.SVGPathSegCurvetoCubicSmoothRel.prototype.toString = function () {\n        return '[object SVGPathSegCurvetoCubicSmoothRel]'\n      }\n\n      window.SVGPathSegCurvetoCubicSmoothRel.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + ' ' + this._x2 + ' ' + this._y2 + ' ' + this._x + ' ' + this._y\n      }\n\n      window.SVGPathSegCurvetoCubicSmoothRel.prototype.clone = function () {\n        return new window.SVGPathSegCurvetoCubicSmoothRel(undefined, this._x, this._y, this._x2, this._y2)\n      }\n\n      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, 'x', {\n        get: function get () {\n          return this._x\n        },\n        set: function set (x) {\n          this._x = x\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, 'y', {\n        get: function get () {\n          return this._y\n        },\n        set: function set (y) {\n          this._y = y\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, 'x2', {\n        get: function get () {\n          return this._x2\n        },\n        set: function set (x2) {\n          this._x2 = x2\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, 'y2', {\n        get: function get () {\n          return this._y2\n        },\n        set: function set (y2) {\n          this._y2 = y2\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n\n      window.SVGPathSegCurvetoQuadraticSmoothAbs = function (owningPathSegList, x, y) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS, 'T', owningPathSegList)\n        this._x = x\n        this._y = y\n      }\n\n      window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype = Object.create(window.SVGPathSeg.prototype)\n\n      window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype.toString = function () {\n        return '[object SVGPathSegCurvetoQuadraticSmoothAbs]'\n      }\n\n      window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y\n      }\n\n      window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype.clone = function () {\n        return new window.SVGPathSegCurvetoQuadraticSmoothAbs(undefined, this._x, this._y)\n      }\n\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype, 'x', {\n        get: function get () {\n          return this._x\n        },\n        set: function set (x) {\n          this._x = x\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype, 'y', {\n        get: function get () {\n          return this._y\n        },\n        set: function set (y) {\n          this._y = y\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n\n      window.SVGPathSegCurvetoQuadraticSmoothRel = function (owningPathSegList, x, y) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL, 't', owningPathSegList)\n        this._x = x\n        this._y = y\n      }\n\n      window.SVGPathSegCurvetoQuadraticSmoothRel.prototype = Object.create(window.SVGPathSeg.prototype)\n\n      window.SVGPathSegCurvetoQuadraticSmoothRel.prototype.toString = function () {\n        return '[object SVGPathSegCurvetoQuadraticSmoothRel]'\n      }\n\n      window.SVGPathSegCurvetoQuadraticSmoothRel.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + ' ' + this._x + ' ' + this._y\n      }\n\n      window.SVGPathSegCurvetoQuadraticSmoothRel.prototype.clone = function () {\n        return new window.SVGPathSegCurvetoQuadraticSmoothRel(undefined, this._x, this._y)\n      }\n\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothRel.prototype, 'x', {\n        get: function get () {\n          return this._x\n        },\n        set: function set (x) {\n          this._x = x\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothRel.prototype, 'y', {\n        get: function get () {\n          return this._y\n        },\n        set: function set (y) {\n          this._y = y\n\n          this._segmentChanged()\n        },\n        enumerable: true\n      }) // Add createSVGPathSeg* functions to window.SVGPathElement.\n      // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-Interfacewindow.SVGPathElement.\n\n      window.SVGPathElement.prototype.createSVGPathSegClosePath = function () {\n        return new window.SVGPathSegClosePath(undefined)\n      }\n\n      window.SVGPathElement.prototype.createSVGPathSegMovetoAbs = function (x, y) {\n        return new window.SVGPathSegMovetoAbs(undefined, x, y)\n      }\n\n      window.SVGPathElement.prototype.createSVGPathSegMovetoRel = function (x, y) {\n        return new window.SVGPathSegMovetoRel(undefined, x, y)\n      }\n\n      window.SVGPathElement.prototype.createSVGPathSegLinetoAbs = function (x, y) {\n        return new window.SVGPathSegLinetoAbs(undefined, x, y)\n      }\n\n      window.SVGPathElement.prototype.createSVGPathSegLinetoRel = function (x, y) {\n        return new window.SVGPathSegLinetoRel(undefined, x, y)\n      }\n\n      window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicAbs = function (x, y, x1, y1, x2, y2) {\n        return new window.SVGPathSegCurvetoCubicAbs(undefined, x, y, x1, y1, x2, y2)\n      }\n\n      window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicRel = function (x, y, x1, y1, x2, y2) {\n        return new window.SVGPathSegCurvetoCubicRel(undefined, x, y, x1, y1, x2, y2)\n      }\n\n      window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticAbs = function (x, y, x1, y1) {\n        return new window.SVGPathSegCurvetoQuadraticAbs(undefined, x, y, x1, y1)\n      }\n\n      window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticRel = function (x, y, x1, y1) {\n        return new window.SVGPathSegCurvetoQuadraticRel(undefined, x, y, x1, y1)\n      }\n\n      window.SVGPathElement.prototype.createSVGPathSegArcAbs = function (x, y, r1, r2, angle, largeArcFlag, sweepFlag) {\n        return new window.SVGPathSegArcAbs(undefined, x, y, r1, r2, angle, largeArcFlag, sweepFlag)\n      }\n\n      window.SVGPathElement.prototype.createSVGPathSegArcRel = function (x, y, r1, r2, angle, largeArcFlag, sweepFlag) {\n        return new window.SVGPathSegArcRel(undefined, x, y, r1, r2, angle, largeArcFlag, sweepFlag)\n      }\n\n      window.SVGPathElement.prototype.createSVGPathSegLinetoHorizontalAbs = function (x) {\n        return new window.SVGPathSegLinetoHorizontalAbs(undefined, x)\n      }\n\n      window.SVGPathElement.prototype.createSVGPathSegLinetoHorizontalRel = function (x) {\n        return new window.SVGPathSegLinetoHorizontalRel(undefined, x)\n      }\n\n      window.SVGPathElement.prototype.createSVGPathSegLinetoVerticalAbs = function (y) {\n        return new window.SVGPathSegLinetoVerticalAbs(undefined, y)\n      }\n\n      window.SVGPathElement.prototype.createSVGPathSegLinetoVerticalRel = function (y) {\n        return new window.SVGPathSegLinetoVerticalRel(undefined, y)\n      }\n\n      window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothAbs = function (x, y, x2, y2) {\n        return new window.SVGPathSegCurvetoCubicSmoothAbs(undefined, x, y, x2, y2)\n      }\n\n      window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothRel = function (x, y, x2, y2) {\n        return new window.SVGPathSegCurvetoCubicSmoothRel(undefined, x, y, x2, y2)\n      }\n\n      window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothAbs = function (x, y) {\n        return new window.SVGPathSegCurvetoQuadraticSmoothAbs(undefined, x, y)\n      }\n\n      window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothRel = function (x, y) {\n        return new window.SVGPathSegCurvetoQuadraticSmoothRel(undefined, x, y)\n      }\n\n      if (!('getPathSegAtLength' in window.SVGPathElement.prototype)) {\n        // Add getPathSegAtLength to SVGPathElement.\n        // Spec: https://www.w3.org/TR/SVG11/single-page.html#paths-__svg__SVGPathElement__getPathSegAtLength\n        // This polyfill requires SVGPathElement.getTotalLength to implement the distance-along-a-path algorithm.\n        window.SVGPathElement.prototype.getPathSegAtLength = function (distance) {\n          if (distance === undefined || !isFinite(distance)) throw 'Invalid arguments.'\n          var measurementElement = document.createElementNS('http://www.w3.org/2000/svg', 'path')\n          measurementElement.setAttribute('d', this.getAttribute('d'))\n          var lastPathSegment = measurementElement.pathSegList.numberOfItems - 1 // If the path is empty, return 0.\n\n          if (lastPathSegment <= 0) return 0\n\n          do {\n            measurementElement.pathSegList.removeItem(lastPathSegment)\n            if (distance > measurementElement.getTotalLength()) break\n            lastPathSegment--\n          } while (lastPathSegment > 0)\n\n          return lastPathSegment\n        }\n      }\n    }\n\n    if (!('SVGPathSegList' in window)) {\n      // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGPathSegList\n      window.SVGPathSegList = function (pathElement) {\n        this._pathElement = pathElement\n        this._list = this._parsePath(this._pathElement.getAttribute('d')) // Use a MutationObserver to catch changes to the path's \"d\" attribute.\n\n        this._mutationObserverConfig = {\n          attributes: true,\n          attributeFilter: ['d']\n        }\n        this._pathElementMutationObserver = new MutationObserver(this._updateListFromPathMutations.bind(this))\n\n        this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig)\n      }\n\n      window.SVGPathSegList.prototype.classname = 'SVGPathSegList'\n      Object.defineProperty(window.SVGPathSegList.prototype, 'numberOfItems', {\n        get: function get () {\n          this._checkPathSynchronizedToList()\n\n          return this._list.length\n        },\n        enumerable: true\n      }) // Add the pathSegList accessors to window.SVGPathElement.\n      // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGAnimatedPathData\n\n      Object.defineProperty(window.SVGPathElement.prototype, 'pathSegList', {\n        get: function get () {\n          if (!this._pathSegList) this._pathSegList = new window.SVGPathSegList(this)\n          return this._pathSegList\n        },\n        enumerable: true\n      }) // FIXME: The following are not implemented and simply return window.SVGPathElement.pathSegList.\n\n      Object.defineProperty(window.SVGPathElement.prototype, 'normalizedPathSegList', {\n        get: function get () {\n          return this.pathSegList\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathElement.prototype, 'animatedPathSegList', {\n        get: function get () {\n          return this.pathSegList\n        },\n        enumerable: true\n      })\n      Object.defineProperty(window.SVGPathElement.prototype, 'animatedNormalizedPathSegList', {\n        get: function get () {\n          return this.pathSegList\n        },\n        enumerable: true\n      }) // Process any pending mutations to the path element and update the list as needed.\n      // This should be the first call of all public functions and is needed because\n      // MutationObservers are not synchronous so we can have pending asynchronous mutations.\n\n      window.SVGPathSegList.prototype._checkPathSynchronizedToList = function () {\n        this._updateListFromPathMutations(this._pathElementMutationObserver.takeRecords())\n      }\n\n      window.SVGPathSegList.prototype._updateListFromPathMutations = function (mutationRecords) {\n        if (!this._pathElement) return\n        var hasPathMutations = false\n        mutationRecords.forEach(function (record) {\n          if (record.attributeName == 'd') hasPathMutations = true\n        })\n        if (hasPathMutations) this._list = this._parsePath(this._pathElement.getAttribute('d'))\n      } // Serialize the list and update the path's 'd' attribute.\n\n      window.SVGPathSegList.prototype._writeListToPath = function () {\n        this._pathElementMutationObserver.disconnect()\n\n        this._pathElement.setAttribute('d', window.SVGPathSegList._pathSegArrayAsString(this._list))\n\n        this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig)\n      } // When a path segment changes the list needs to be synchronized back to the path element.\n\n      window.SVGPathSegList.prototype.segmentChanged = function (pathSeg) {\n        this._writeListToPath()\n      }\n\n      window.SVGPathSegList.prototype.clear = function () {\n        this._checkPathSynchronizedToList()\n\n        this._list.forEach(function (pathSeg) {\n          pathSeg._owningPathSegList = null\n        })\n\n        this._list = []\n\n        this._writeListToPath()\n      }\n\n      window.SVGPathSegList.prototype.initialize = function (newItem) {\n        this._checkPathSynchronizedToList()\n\n        this._list = [newItem]\n        newItem._owningPathSegList = this\n\n        this._writeListToPath()\n\n        return newItem\n      }\n\n      window.SVGPathSegList.prototype._checkValidIndex = function (index) {\n        if (isNaN(index) || index < 0 || index >= this.numberOfItems) throw 'INDEX_SIZE_ERR'\n      }\n\n      window.SVGPathSegList.prototype.getItem = function (index) {\n        this._checkPathSynchronizedToList()\n\n        this._checkValidIndex(index)\n\n        return this._list[index]\n      }\n\n      window.SVGPathSegList.prototype.insertItemBefore = function (newItem, index) {\n        this._checkPathSynchronizedToList() // Spec: If the index is greater than or equal to numberOfItems, then the new item is appended to the end of the list.\n\n        if (index > this.numberOfItems) index = this.numberOfItems\n\n        if (newItem._owningPathSegList) {\n          // SVG2 spec says to make a copy.\n          newItem = newItem.clone()\n        }\n\n        this._list.splice(index, 0, newItem)\n\n        newItem._owningPathSegList = this\n\n        this._writeListToPath()\n\n        return newItem\n      }\n\n      window.SVGPathSegList.prototype.replaceItem = function (newItem, index) {\n        this._checkPathSynchronizedToList()\n\n        if (newItem._owningPathSegList) {\n          // SVG2 spec says to make a copy.\n          newItem = newItem.clone()\n        }\n\n        this._checkValidIndex(index)\n\n        this._list[index] = newItem\n        newItem._owningPathSegList = this\n\n        this._writeListToPath()\n\n        return newItem\n      }\n\n      window.SVGPathSegList.prototype.removeItem = function (index) {\n        this._checkPathSynchronizedToList()\n\n        this._checkValidIndex(index)\n\n        var item = this._list[index]\n\n        this._list.splice(index, 1)\n\n        this._writeListToPath()\n\n        return item\n      }\n\n      window.SVGPathSegList.prototype.appendItem = function (newItem) {\n        this._checkPathSynchronizedToList()\n\n        if (newItem._owningPathSegList) {\n          // SVG2 spec says to make a copy.\n          newItem = newItem.clone()\n        }\n\n        this._list.push(newItem)\n\n        newItem._owningPathSegList = this // TODO: Optimize this to just append to the existing attribute.\n\n        this._writeListToPath()\n\n        return newItem\n      }\n\n      window.SVGPathSegList._pathSegArrayAsString = function (pathSegArray) {\n        var string = ''\n        var first = true\n        pathSegArray.forEach(function (pathSeg) {\n          if (first) {\n            first = false\n            string += pathSeg._asPathString()\n          } else {\n            string += ' ' + pathSeg._asPathString()\n          }\n        })\n        return string\n      } // This closely follows SVGPathParser::parsePath from Source/core/svg/SVGPathParser.cpp.\n\n      window.SVGPathSegList.prototype._parsePath = function (string) {\n        if (!string || string.length == 0) return []\n        var owningPathSegList = this\n\n        var Builder = function Builder () {\n          this.pathSegList = []\n        }\n\n        Builder.prototype.appendSegment = function (pathSeg) {\n          this.pathSegList.push(pathSeg)\n        }\n\n        var Source = function Source (string) {\n          this._string = string\n          this._currentIndex = 0\n          this._endIndex = this._string.length\n          this._previousCommand = window.SVGPathSeg.PATHSEG_UNKNOWN\n\n          this._skipOptionalSpaces()\n        }\n\n        Source.prototype._isCurrentSpace = function () {\n          var character = this._string[this._currentIndex]\n          return (\n            character <= ' ' &&\n            (character == ' ' || character == '\\n' || character == '\\t' || character == '\\r' || character == '\\f')\n          )\n        }\n\n        Source.prototype._skipOptionalSpaces = function () {\n          while (this._currentIndex < this._endIndex && this._isCurrentSpace()) {\n            this._currentIndex++\n          }\n\n          return this._currentIndex < this._endIndex\n        }\n\n        Source.prototype._skipOptionalSpacesOrDelimiter = function () {\n          if (\n            this._currentIndex < this._endIndex &&\n            !this._isCurrentSpace() &&\n            this._string.charAt(this._currentIndex) != ','\n          )\n            return false\n\n          if (this._skipOptionalSpaces()) {\n            if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == ',') {\n              this._currentIndex++\n\n              this._skipOptionalSpaces()\n            }\n          }\n\n          return this._currentIndex < this._endIndex\n        }\n\n        Source.prototype.hasMoreData = function () {\n          return this._currentIndex < this._endIndex\n        }\n\n        Source.prototype.peekSegmentType = function () {\n          var lookahead = this._string[this._currentIndex]\n          return this._pathSegTypeFromChar(lookahead)\n        }\n\n        Source.prototype._pathSegTypeFromChar = function (lookahead) {\n          switch (lookahead) {\n            case 'Z':\n            case 'z':\n              return window.SVGPathSeg.PATHSEG_CLOSEPATH\n\n            case 'M':\n              return window.SVGPathSeg.PATHSEG_MOVETO_ABS\n\n            case 'm':\n              return window.SVGPathSeg.PATHSEG_MOVETO_REL\n\n            case 'L':\n              return window.SVGPathSeg.PATHSEG_LINETO_ABS\n\n            case 'l':\n              return window.SVGPathSeg.PATHSEG_LINETO_REL\n\n            case 'C':\n              return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS\n\n            case 'c':\n              return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL\n\n            case 'Q':\n              return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS\n\n            case 'q':\n              return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL\n\n            case 'A':\n              return window.SVGPathSeg.PATHSEG_ARC_ABS\n\n            case 'a':\n              return window.SVGPathSeg.PATHSEG_ARC_REL\n\n            case 'H':\n              return window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS\n\n            case 'h':\n              return window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL\n\n            case 'V':\n              return window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS\n\n            case 'v':\n              return window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL\n\n            case 'S':\n              return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS\n\n            case 's':\n              return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL\n\n            case 'T':\n              return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS\n\n            case 't':\n              return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL\n\n            default:\n              return window.SVGPathSeg.PATHSEG_UNKNOWN\n          }\n        }\n\n        Source.prototype._nextCommandHelper = function (lookahead, previousCommand) {\n          // Check for remaining coordinates in the current command.\n          if (\n            (lookahead == '+' || lookahead == '-' || lookahead == '.' || (lookahead >= '0' && lookahead <= '9')) &&\n            previousCommand != window.SVGPathSeg.PATHSEG_CLOSEPATH\n          ) {\n            if (previousCommand == window.SVGPathSeg.PATHSEG_MOVETO_ABS) return window.SVGPathSeg.PATHSEG_LINETO_ABS\n            if (previousCommand == window.SVGPathSeg.PATHSEG_MOVETO_REL) return window.SVGPathSeg.PATHSEG_LINETO_REL\n            return previousCommand\n          }\n\n          return window.SVGPathSeg.PATHSEG_UNKNOWN\n        }\n\n        Source.prototype.initialCommandIsMoveTo = function () {\n          // If the path is empty it is still valid, so return true.\n          if (!this.hasMoreData()) return true\n          var command = this.peekSegmentType() // Path must start with moveTo.\n\n          return command == window.SVGPathSeg.PATHSEG_MOVETO_ABS || command == window.SVGPathSeg.PATHSEG_MOVETO_REL\n        } // Parse a number from an SVG path. This very closely follows genericParseNumber(...) from Source/core/svg/SVGParserUtilities.cpp.\n        // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-PathDataBNF\n\n        Source.prototype._parseNumber = function () {\n          var exponent = 0\n          var integer = 0\n          var frac = 1\n          var decimal = 0\n          var sign = 1\n          var expsign = 1\n          var startIndex = this._currentIndex\n\n          this._skipOptionalSpaces() // Read the sign.\n\n          if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == '+')\n            this._currentIndex++\n          else if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == '-') {\n            this._currentIndex++\n            sign = -1\n          }\n          if (\n            this._currentIndex == this._endIndex ||\n            ((this._string.charAt(this._currentIndex) < '0' || this._string.charAt(this._currentIndex) > '9') &&\n              this._string.charAt(this._currentIndex) != '.')\n          )\n            // The first character of a number must be one of [0-9+-.].\n            return undefined // Read the integer part, build right-to-left.\n\n          var startIntPartIndex = this._currentIndex\n\n          while (\n            this._currentIndex < this._endIndex &&\n            this._string.charAt(this._currentIndex) >= '0' &&\n            this._string.charAt(this._currentIndex) <= '9'\n          ) {\n            this._currentIndex++\n          } // Advance to first non-digit.\n\n          if (this._currentIndex != startIntPartIndex) {\n            var scanIntPartIndex = this._currentIndex - 1\n            var multiplier = 1\n\n            while (scanIntPartIndex >= startIntPartIndex) {\n              integer += multiplier * (this._string.charAt(scanIntPartIndex--) - '0')\n              multiplier *= 10\n            }\n          } // Read the decimals.\n\n          if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == '.') {\n            this._currentIndex++ // There must be a least one digit following the .\n\n            if (\n              this._currentIndex >= this._endIndex ||\n              this._string.charAt(this._currentIndex) < '0' ||\n              this._string.charAt(this._currentIndex) > '9'\n            )\n              return undefined\n\n            while (\n              this._currentIndex < this._endIndex &&\n              this._string.charAt(this._currentIndex) >= '0' &&\n              this._string.charAt(this._currentIndex) <= '9'\n            ) {\n              frac *= 10\n              decimal += (this._string.charAt(this._currentIndex) - '0') / frac\n              this._currentIndex += 1\n            }\n          } // Read the exponent part.\n\n          if (\n            this._currentIndex != startIndex &&\n            this._currentIndex + 1 < this._endIndex &&\n            (this._string.charAt(this._currentIndex) == 'e' || this._string.charAt(this._currentIndex) == 'E') &&\n            this._string.charAt(this._currentIndex + 1) != 'x' &&\n            this._string.charAt(this._currentIndex + 1) != 'm'\n          ) {\n            this._currentIndex++ // Read the sign of the exponent.\n\n            if (this._string.charAt(this._currentIndex) == '+') {\n              this._currentIndex++\n            } else if (this._string.charAt(this._currentIndex) == '-') {\n              this._currentIndex++\n              expsign = -1\n            } // There must be an exponent.\n\n            if (\n              this._currentIndex >= this._endIndex ||\n              this._string.charAt(this._currentIndex) < '0' ||\n              this._string.charAt(this._currentIndex) > '9'\n            )\n              return undefined\n\n            while (\n              this._currentIndex < this._endIndex &&\n              this._string.charAt(this._currentIndex) >= '0' &&\n              this._string.charAt(this._currentIndex) <= '9'\n            ) {\n              exponent *= 10\n              exponent += this._string.charAt(this._currentIndex) - '0'\n              this._currentIndex++\n            }\n          }\n\n          var number = integer + decimal\n          number *= sign\n          if (exponent) number *= Math.pow(10, expsign * exponent)\n          if (startIndex == this._currentIndex) return undefined\n\n          this._skipOptionalSpacesOrDelimiter()\n\n          return number\n        }\n\n        Source.prototype._parseArcFlag = function () {\n          if (this._currentIndex >= this._endIndex) return undefined\n          var flag = false\n\n          var flagChar = this._string.charAt(this._currentIndex++)\n\n          if (flagChar == '0') flag = false\n          else if (flagChar == '1') flag = true\n          else return undefined\n\n          this._skipOptionalSpacesOrDelimiter()\n\n          return flag\n        }\n\n        Source.prototype.parseSegment = function () {\n          var lookahead = this._string[this._currentIndex]\n\n          var command = this._pathSegTypeFromChar(lookahead)\n\n          if (command == window.SVGPathSeg.PATHSEG_UNKNOWN) {\n            // Possibly an implicit command. Not allowed if this is the first command.\n            if (this._previousCommand == window.SVGPathSeg.PATHSEG_UNKNOWN) return null\n            command = this._nextCommandHelper(lookahead, this._previousCommand)\n            if (command == window.SVGPathSeg.PATHSEG_UNKNOWN) return null\n          } else {\n            this._currentIndex++\n          }\n\n          this._previousCommand = command\n\n          switch (command) {\n            case window.SVGPathSeg.PATHSEG_MOVETO_REL:\n              return new window.SVGPathSegMovetoRel(owningPathSegList, this._parseNumber(), this._parseNumber())\n\n            case window.SVGPathSeg.PATHSEG_MOVETO_ABS:\n              return new window.SVGPathSegMovetoAbs(owningPathSegList, this._parseNumber(), this._parseNumber())\n\n            case window.SVGPathSeg.PATHSEG_LINETO_REL:\n              return new window.SVGPathSegLinetoRel(owningPathSegList, this._parseNumber(), this._parseNumber())\n\n            case window.SVGPathSeg.PATHSEG_LINETO_ABS:\n              return new window.SVGPathSegLinetoAbs(owningPathSegList, this._parseNumber(), this._parseNumber())\n\n            case window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:\n              return new window.SVGPathSegLinetoHorizontalRel(owningPathSegList, this._parseNumber())\n\n            case window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:\n              return new window.SVGPathSegLinetoHorizontalAbs(owningPathSegList, this._parseNumber())\n\n            case window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL:\n              return new window.SVGPathSegLinetoVerticalRel(owningPathSegList, this._parseNumber())\n\n            case window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS:\n              return new window.SVGPathSegLinetoVerticalAbs(owningPathSegList, this._parseNumber())\n\n            case window.SVGPathSeg.PATHSEG_CLOSEPATH:\n              this._skipOptionalSpaces()\n\n              return new window.SVGPathSegClosePath(owningPathSegList)\n\n            case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL:\n              var points = {\n                x1: this._parseNumber(),\n                y1: this._parseNumber(),\n                x2: this._parseNumber(),\n                y2: this._parseNumber(),\n                x: this._parseNumber(),\n                y: this._parseNumber()\n              }\n              return new window.SVGPathSegCurvetoCubicRel(\n                owningPathSegList,\n                points.x,\n                points.y,\n                points.x1,\n                points.y1,\n                points.x2,\n                points.y2\n              )\n\n            case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS:\n              var points = {\n                x1: this._parseNumber(),\n                y1: this._parseNumber(),\n                x2: this._parseNumber(),\n                y2: this._parseNumber(),\n                x: this._parseNumber(),\n                y: this._parseNumber()\n              }\n              return new window.SVGPathSegCurvetoCubicAbs(\n                owningPathSegList,\n                points.x,\n                points.y,\n                points.x1,\n                points.y1,\n                points.x2,\n                points.y2\n              )\n\n            case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:\n              var points = {\n                x2: this._parseNumber(),\n                y2: this._parseNumber(),\n                x: this._parseNumber(),\n                y: this._parseNumber()\n              }\n              return new window.SVGPathSegCurvetoCubicSmoothRel(\n                owningPathSegList,\n                points.x,\n                points.y,\n                points.x2,\n                points.y2\n              )\n\n            case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:\n              var points = {\n                x2: this._parseNumber(),\n                y2: this._parseNumber(),\n                x: this._parseNumber(),\n                y: this._parseNumber()\n              }\n              return new window.SVGPathSegCurvetoCubicSmoothAbs(\n                owningPathSegList,\n                points.x,\n                points.y,\n                points.x2,\n                points.y2\n              )\n\n            case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:\n              var points = {\n                x1: this._parseNumber(),\n                y1: this._parseNumber(),\n                x: this._parseNumber(),\n                y: this._parseNumber()\n              }\n              return new window.SVGPathSegCurvetoQuadraticRel(\n                owningPathSegList,\n                points.x,\n                points.y,\n                points.x1,\n                points.y1\n              )\n\n            case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:\n              var points = {\n                x1: this._parseNumber(),\n                y1: this._parseNumber(),\n                x: this._parseNumber(),\n                y: this._parseNumber()\n              }\n              return new window.SVGPathSegCurvetoQuadraticAbs(\n                owningPathSegList,\n                points.x,\n                points.y,\n                points.x1,\n                points.y1\n              )\n\n            case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:\n              return new window.SVGPathSegCurvetoQuadraticSmoothRel(\n                owningPathSegList,\n                this._parseNumber(),\n                this._parseNumber()\n              )\n\n            case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:\n              return new window.SVGPathSegCurvetoQuadraticSmoothAbs(\n                owningPathSegList,\n                this._parseNumber(),\n                this._parseNumber()\n              )\n\n            case window.SVGPathSeg.PATHSEG_ARC_REL:\n              var points = {\n                x1: this._parseNumber(),\n                y1: this._parseNumber(),\n                arcAngle: this._parseNumber(),\n                arcLarge: this._parseArcFlag(),\n                arcSweep: this._parseArcFlag(),\n                x: this._parseNumber(),\n                y: this._parseNumber()\n              }\n              return new window.SVGPathSegArcRel(\n                owningPathSegList,\n                points.x,\n                points.y,\n                points.x1,\n                points.y1,\n                points.arcAngle,\n                points.arcLarge,\n                points.arcSweep\n              )\n\n            case window.SVGPathSeg.PATHSEG_ARC_ABS:\n              var points = {\n                x1: this._parseNumber(),\n                y1: this._parseNumber(),\n                arcAngle: this._parseNumber(),\n                arcLarge: this._parseArcFlag(),\n                arcSweep: this._parseArcFlag(),\n                x: this._parseNumber(),\n                y: this._parseNumber()\n              }\n              return new window.SVGPathSegArcAbs(\n                owningPathSegList,\n                points.x,\n                points.y,\n                points.x1,\n                points.y1,\n                points.arcAngle,\n                points.arcLarge,\n                points.arcSweep\n              )\n\n            default:\n              throw 'Unknown path seg type.'\n          }\n        }\n\n        var builder = new Builder()\n        var source = new Source(string)\n        if (!source.initialCommandIsMoveTo()) return []\n\n        while (source.hasMoreData()) {\n          var pathSeg = source.parseSegment()\n          if (!pathSeg) return []\n          builder.appendSegment(pathSeg)\n        }\n\n        return builder.pathSegList\n      }\n    }\n  })() // String.padEnd polyfill for IE11\n  //\n  // https://github.com/uxitten/polyfill/blob/master/string.polyfill.js\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd\n\n  if (!String.prototype.padEnd) {\n    String.prototype.padEnd = function padEnd (targetLength, padString) {\n      targetLength = targetLength >> 0 //floor if number or convert non-number to 0;\n\n      padString = String(typeof padString !== 'undefined' ? padString : ' ')\n\n      if (this.length > targetLength) {\n        return String(this)\n      } else {\n        targetLength = targetLength - this.length\n\n        if (targetLength > padString.length) {\n          padString += padString.repeat(targetLength / padString.length) //append to original to ensure we are longer than needed\n        }\n\n        return String(this) + padString.slice(0, targetLength)\n      }\n    }\n  }\n  /* jshint ignore:end */\n\n  Chart.prototype.axis = function () {}\n\n  Chart.prototype.axis.labels = function (labels) {\n    var $$ = this.internal\n\n    if (arguments.length) {\n      Object.keys(labels).forEach(function (axisId) {\n        $$.axis.setLabelText(axisId, labels[axisId])\n      })\n      $$.axis.updateLabels()\n    } // TODO: return some values?\n  }\n\n  Chart.prototype.axis.max = function (max) {\n    var $$ = this.internal,\n      config = $$.config\n\n    if (arguments.length) {\n      if (_typeof(max) === 'object') {\n        if (isValue(max.x)) {\n          config.axis_x_max = max.x\n        }\n\n        if (isValue(max.y)) {\n          config.axis_y_max = max.y\n        }\n\n        if (isValue(max.y2)) {\n          config.axis_y2_max = max.y2\n        }\n      } else {\n        config.axis_y_max = config.axis_y2_max = max\n      }\n\n      $$.redraw({\n        withUpdateOrgXDomain: true,\n        withUpdateXDomain: true\n      })\n    } else {\n      return {\n        x: config.axis_x_max,\n        y: config.axis_y_max,\n        y2: config.axis_y2_max\n      }\n    }\n  }\n\n  Chart.prototype.axis.min = function (min) {\n    var $$ = this.internal,\n      config = $$.config\n\n    if (arguments.length) {\n      if (_typeof(min) === 'object') {\n        if (isValue(min.x)) {\n          config.axis_x_min = min.x\n        }\n\n        if (isValue(min.y)) {\n          config.axis_y_min = min.y\n        }\n\n        if (isValue(min.y2)) {\n          config.axis_y2_min = min.y2\n        }\n      } else {\n        config.axis_y_min = config.axis_y2_min = min\n      }\n\n      $$.redraw({\n        withUpdateOrgXDomain: true,\n        withUpdateXDomain: true\n      })\n    } else {\n      return {\n        x: config.axis_x_min,\n        y: config.axis_y_min,\n        y2: config.axis_y2_min\n      }\n    }\n  }\n\n  Chart.prototype.axis.range = function (range) {\n    if (arguments.length) {\n      if (isDefined(range.max)) {\n        this.axis.max(range.max)\n      }\n\n      if (isDefined(range.min)) {\n        this.axis.min(range.min)\n      }\n    } else {\n      return {\n        max: this.axis.max(),\n        min: this.axis.min()\n      }\n    }\n  }\n\n  Chart.prototype.category = function (i, category) {\n    var $$ = this.internal,\n      config = $$.config\n\n    if (arguments.length > 1) {\n      config.axis_x_categories[i] = category\n      $$.redraw()\n    }\n\n    return config.axis_x_categories[i]\n  }\n\n  Chart.prototype.categories = function (categories) {\n    var $$ = this.internal,\n      config = $$.config\n\n    if (!arguments.length) {\n      return config.axis_x_categories\n    }\n\n    config.axis_x_categories = categories\n    $$.redraw()\n    return config.axis_x_categories\n  }\n\n  Chart.prototype.resize = function (size) {\n    var $$ = this.internal,\n      config = $$.config\n    config.size_width = size ? size.width : null\n    config.size_height = size ? size.height : null\n    this.flush()\n  }\n\n  Chart.prototype.flush = function () {\n    var $$ = this.internal\n    $$.updateAndRedraw({\n      withLegend: true,\n      withTransition: false,\n      withTransitionForTransform: false\n    })\n  }\n\n  Chart.prototype.destroy = function () {\n    var $$ = this.internal\n    window.clearInterval($$.intervalForObserveInserted)\n\n    if ($$.resizeTimeout !== undefined) {\n      window.clearTimeout($$.resizeTimeout)\n    }\n\n    if (window.detachEvent) {\n      window.detachEvent('onresize', $$.resizeIfElementDisplayed)\n    } else if (window.removeEventListener) {\n      window.removeEventListener('resize', $$.resizeIfElementDisplayed)\n    } else {\n      var wrapper = window.onresize // check if no one else removed our wrapper and remove our resizeFunction from it\n\n      if (wrapper && wrapper.add && wrapper.remove) {\n        wrapper.remove($$.resizeFunction)\n      }\n    } // Removes the inner resize functions\n\n    $$.resizeFunction.remove() // Unbinds from the window focus event\n\n    $$.unbindWindowFocus()\n    $$.selectChart.classed('c3', false).html('') // MEMO: this is needed because the reference of some elements will not be released, then memory leak will happen.\n\n    Object.keys($$).forEach(function (key) {\n      $$[key] = null\n    })\n    return null\n  }\n\n  Chart.prototype.color = function (id) {\n    var $$ = this.internal\n    return $$.color(id) // more patterns\n  }\n\n  Chart.prototype.data = function (targetIds) {\n    var targets = this.internal.data.targets\n    return typeof targetIds === 'undefined'\n      ? targets\n      : targets.filter(function (t) {\n          return [].concat(targetIds).indexOf(t.id) >= 0\n        })\n  }\n\n  Chart.prototype.data.shown = function (targetIds) {\n    return this.internal.filterTargetsToShow(this.data(targetIds))\n  }\n\n  Chart.prototype.data.values = function (targetId) {\n    var targets,\n      values = null\n\n    if (targetId) {\n      targets = this.data(targetId)\n      values = targets[0]\n        ? targets[0].values.map(function (d) {\n            return d.value\n          })\n        : null\n    }\n\n    return values\n  }\n\n  Chart.prototype.data.names = function (names) {\n    this.internal.clearLegendItemTextBoxCache()\n    return this.internal.updateDataAttributes('names', names)\n  }\n\n  Chart.prototype.data.colors = function (colors) {\n    return this.internal.updateDataAttributes('colors', colors)\n  }\n\n  Chart.prototype.data.axes = function (axes) {\n    return this.internal.updateDataAttributes('axes', axes)\n  }\n\n  Chart.prototype.flow = function (args) {\n    var $$ = this.internal,\n      targets,\n      data,\n      notfoundIds = [],\n      orgDataCount = $$.getMaxDataCount(),\n      dataCount,\n      domain,\n      baseTarget,\n      baseValue,\n      length = 0,\n      tail = 0,\n      diff,\n      to\n\n    if (args.json) {\n      data = $$.convertJsonToData(args.json, args.keys)\n    } else if (args.rows) {\n      data = $$.convertRowsToData(args.rows)\n    } else if (args.columns) {\n      data = $$.convertColumnsToData(args.columns)\n    } else {\n      return\n    }\n\n    targets = $$.convertDataToTargets(data, true) // Update/Add data\n\n    $$.data.targets.forEach(function (t) {\n      var found = false,\n        i,\n        j\n\n      for (i = 0; i < targets.length; i++) {\n        if (t.id === targets[i].id) {\n          found = true\n\n          if (t.values[t.values.length - 1]) {\n            tail = t.values[t.values.length - 1].index + 1\n          }\n\n          length = targets[i].values.length\n\n          for (j = 0; j < length; j++) {\n            targets[i].values[j].index = tail + j\n\n            if (!$$.isTimeSeries()) {\n              targets[i].values[j].x = tail + j\n            }\n          }\n\n          t.values = t.values.concat(targets[i].values)\n          targets.splice(i, 1)\n          break\n        }\n      }\n\n      if (!found) {\n        notfoundIds.push(t.id)\n      }\n    }) // Append null for not found targets\n\n    $$.data.targets.forEach(function (t) {\n      var i, j\n\n      for (i = 0; i < notfoundIds.length; i++) {\n        if (t.id === notfoundIds[i]) {\n          tail = t.values[t.values.length - 1].index + 1\n\n          for (j = 0; j < length; j++) {\n            t.values.push({\n              id: t.id,\n              index: tail + j,\n              x: $$.isTimeSeries() ? $$.getOtherTargetX(tail + j) : tail + j,\n              value: null\n            })\n          }\n        }\n      }\n    }) // Generate null values for new target\n\n    if ($$.data.targets.length) {\n      targets.forEach(function (t) {\n        var i,\n          missing = []\n\n        for (i = $$.data.targets[0].values[0].index; i < tail; i++) {\n          missing.push({\n            id: t.id,\n            index: i,\n            x: $$.isTimeSeries() ? $$.getOtherTargetX(i) : i,\n            value: null\n          })\n        }\n\n        t.values.forEach(function (v) {\n          v.index += tail\n\n          if (!$$.isTimeSeries()) {\n            v.x += tail\n          }\n        })\n        t.values = missing.concat(t.values)\n      })\n    }\n\n    $$.data.targets = $$.data.targets.concat(targets) // add remained\n    // check data count because behavior needs to change when it's only one\n\n    dataCount = $$.getMaxDataCount()\n    baseTarget = $$.data.targets[0]\n    baseValue = baseTarget.values[0] // Update length to flow if needed\n\n    if (isDefined(args.to)) {\n      length = 0\n      to = $$.isTimeSeries() ? $$.parseDate(args.to) : args.to\n      baseTarget.values.forEach(function (v) {\n        if (v.x < to) {\n          length++\n        }\n      })\n    } else if (isDefined(args.length)) {\n      length = args.length\n    } // If only one data, update the domain to flow from left edge of the chart\n\n    if (!orgDataCount) {\n      if ($$.isTimeSeries()) {\n        if (baseTarget.values.length > 1) {\n          diff = baseTarget.values[baseTarget.values.length - 1].x - baseValue.x\n        } else {\n          diff = baseValue.x - $$.getXDomain($$.data.targets)[0]\n        }\n      } else {\n        diff = 1\n      }\n\n      domain = [baseValue.x - diff, baseValue.x]\n      $$.updateXDomain(null, true, true, false, domain)\n    } else if (orgDataCount === 1) {\n      if ($$.isTimeSeries()) {\n        diff = (baseTarget.values[baseTarget.values.length - 1].x - baseValue.x) / 2\n        domain = [new Date(+baseValue.x - diff), new Date(+baseValue.x + diff)]\n        $$.updateXDomain(null, true, true, false, domain)\n      }\n    } // Set targets\n\n    $$.updateTargets($$.data.targets) // Redraw with new targets\n\n    $$.redraw({\n      flow: {\n        index: baseValue.index,\n        length: length,\n        duration: isValue(args.duration) ? args.duration : $$.config.transition_duration,\n        done: args.done,\n        orgDataCount: orgDataCount\n      },\n      withLegend: true,\n      withTransition: orgDataCount > 1,\n      withTrimXDomain: false,\n      withUpdateXAxis: true\n    })\n  }\n\n  ChartInternal.prototype.generateFlow = function (args) {\n    var $$ = this,\n      config = $$.config,\n      d3 = $$.d3\n    return function () {\n      var targets = args.targets,\n        flow = args.flow,\n        drawBar = args.drawBar,\n        drawLine = args.drawLine,\n        drawArea = args.drawArea,\n        cx = args.cx,\n        cy = args.cy,\n        xv = args.xv,\n        xForText = args.xForText,\n        yForText = args.yForText,\n        duration = args.duration\n\n      var translateX,\n        scaleX = 1,\n        transform,\n        flowIndex = flow.index,\n        flowLength = flow.length,\n        flowStart = $$.getValueOnIndex($$.data.targets[0].values, flowIndex),\n        flowEnd = $$.getValueOnIndex($$.data.targets[0].values, flowIndex + flowLength),\n        orgDomain = $$.x.domain(),\n        domain,\n        durationForFlow = flow.duration || duration,\n        done = flow.done || function () {},\n        wait = $$.generateWait()\n\n      var xgrid, xgridLines, mainRegion, mainText, mainBar, mainLine, mainArea, mainCircle // set flag\n\n      $$.flowing = true // remove head data after rendered\n\n      $$.data.targets.forEach(function (d) {\n        d.values.splice(0, flowLength)\n      }) // update x domain to generate axis elements for flow\n\n      domain = $$.updateXDomain(targets, true, true) // update elements related to x scale\n\n      if ($$.updateXGrid) {\n        $$.updateXGrid(true)\n      }\n\n      xgrid = $$.xgrid || d3.selectAll([]) // xgrid needs to be obtained after updateXGrid\n\n      xgridLines = $$.xgridLines || d3.selectAll([])\n      mainRegion = $$.mainRegion || d3.selectAll([])\n      mainText = $$.mainText || d3.selectAll([])\n      mainBar = $$.mainBar || d3.selectAll([])\n      mainLine = $$.mainLine || d3.selectAll([])\n      mainArea = $$.mainArea || d3.selectAll([])\n      mainCircle = $$.mainCircle || d3.selectAll([]) // generate transform to flow\n\n      if (!flow.orgDataCount) {\n        // if empty\n        if ($$.data.targets[0].values.length !== 1) {\n          translateX = $$.x(orgDomain[0]) - $$.x(domain[0])\n        } else {\n          if ($$.isTimeSeries()) {\n            flowStart = $$.getValueOnIndex($$.data.targets[0].values, 0)\n            flowEnd = $$.getValueOnIndex($$.data.targets[0].values, $$.data.targets[0].values.length - 1)\n            translateX = $$.x(flowStart.x) - $$.x(flowEnd.x)\n          } else {\n            translateX = diffDomain(domain) / 2\n          }\n        }\n      } else if (flow.orgDataCount === 1 || (flowStart && flowStart.x) === (flowEnd && flowEnd.x)) {\n        translateX = $$.x(orgDomain[0]) - $$.x(domain[0])\n      } else {\n        if ($$.isTimeSeries()) {\n          translateX = $$.x(orgDomain[0]) - $$.x(domain[0])\n        } else {\n          translateX = $$.x(flowStart.x) - $$.x(flowEnd.x)\n        }\n      }\n\n      scaleX = diffDomain(orgDomain) / diffDomain(domain)\n      transform = 'translate(' + translateX + ',0) scale(' + scaleX + ',1)'\n      $$.hideXGridFocus()\n      var flowTransition = d3\n        .transition()\n        .ease(d3.easeLinear)\n        .duration(durationForFlow)\n      wait.add($$.xAxis($$.axes.x, flowTransition))\n      wait.add(mainBar.transition(flowTransition).attr('transform', transform))\n      wait.add(mainLine.transition(flowTransition).attr('transform', transform))\n      wait.add(mainArea.transition(flowTransition).attr('transform', transform))\n      wait.add(mainCircle.transition(flowTransition).attr('transform', transform))\n      wait.add(mainText.transition(flowTransition).attr('transform', transform))\n      wait.add(\n        mainRegion\n          .filter($$.isRegionOnX)\n          .transition(flowTransition)\n          .attr('transform', transform)\n      )\n      wait.add(xgrid.transition(flowTransition).attr('transform', transform))\n      wait.add(xgridLines.transition(flowTransition).attr('transform', transform))\n      wait(function () {\n        var i,\n          shapes = [],\n          texts = [] // remove flowed elements\n\n        if (flowLength) {\n          for (i = 0; i < flowLength; i++) {\n            shapes.push('.' + CLASS.shape + '-' + (flowIndex + i))\n            texts.push('.' + CLASS.text + '-' + (flowIndex + i))\n          }\n\n          $$.svg\n            .selectAll('.' + CLASS.shapes)\n            .selectAll(shapes)\n            .remove()\n          $$.svg\n            .selectAll('.' + CLASS.texts)\n            .selectAll(texts)\n            .remove()\n          $$.svg.select('.' + CLASS.xgrid).remove()\n        } // draw again for removing flowed elements and reverting attr\n\n        xgrid\n          .attr('transform', null)\n          .attr('x1', $$.xgridAttr.x1)\n          .attr('x2', $$.xgridAttr.x2)\n          .attr('y1', $$.xgridAttr.y1)\n          .attr('y2', $$.xgridAttr.y2)\n          .style('opacity', $$.xgridAttr.opacity)\n        xgridLines.attr('transform', null)\n        xgridLines\n          .select('line')\n          .attr('x1', config.axis_rotated ? 0 : xv)\n          .attr('x2', config.axis_rotated ? $$.width : xv)\n        xgridLines\n          .select('text')\n          .attr('x', config.axis_rotated ? $$.width : 0)\n          .attr('y', xv)\n        mainBar.attr('transform', null).attr('d', drawBar)\n        mainLine.attr('transform', null).attr('d', drawLine)\n        mainArea.attr('transform', null).attr('d', drawArea)\n        mainCircle\n          .attr('transform', null)\n          .attr('cx', cx)\n          .attr('cy', cy)\n        mainText\n          .attr('transform', null)\n          .attr('x', xForText)\n          .attr('y', yForText)\n          .style('fill-opacity', $$.opacityForText.bind($$))\n        mainRegion.attr('transform', null)\n        mainRegion\n          .filter($$.isRegionOnX)\n          .attr('x', $$.regionX.bind($$))\n          .attr('width', $$.regionWidth.bind($$)) // callback for end of flow\n\n        done()\n        $$.flowing = false\n      })\n    }\n  }\n\n  Chart.prototype.focus = function (targetIds) {\n    var $$ = this.internal,\n      candidates\n    targetIds = $$.mapToTargetIds(targetIds)\n    ;(candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)))), this.revert()\n    this.defocus()\n    candidates.classed(CLASS.focused, true).classed(CLASS.defocused, false)\n\n    if ($$.hasArcType()) {\n      $$.expandArc(targetIds)\n    }\n\n    $$.toggleFocusLegend(targetIds, true)\n    $$.focusedTargetIds = targetIds\n    $$.defocusedTargetIds = $$.defocusedTargetIds.filter(function (id) {\n      return targetIds.indexOf(id) < 0\n    })\n  }\n\n  Chart.prototype.defocus = function (targetIds) {\n    var $$ = this.internal,\n      candidates\n    targetIds = $$.mapToTargetIds(targetIds)\n    ;(candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$)))),\n      candidates.classed(CLASS.focused, false).classed(CLASS.defocused, true)\n\n    if ($$.hasArcType()) {\n      $$.unexpandArc(targetIds)\n    }\n\n    $$.toggleFocusLegend(targetIds, false)\n    $$.focusedTargetIds = $$.focusedTargetIds.filter(function (id) {\n      return targetIds.indexOf(id) < 0\n    })\n    $$.defocusedTargetIds = targetIds\n  }\n\n  Chart.prototype.revert = function (targetIds) {\n    var $$ = this.internal,\n      candidates\n    targetIds = $$.mapToTargetIds(targetIds)\n    candidates = $$.svg.selectAll($$.selectorTargets(targetIds)) // should be for all targets\n\n    candidates.classed(CLASS.focused, false).classed(CLASS.defocused, false)\n\n    if ($$.hasArcType()) {\n      $$.unexpandArc(targetIds)\n    }\n\n    if ($$.config.legend_show) {\n      $$.showLegend(targetIds.filter($$.isLegendToShow.bind($$)))\n      $$.legend\n        .selectAll($$.selectorLegends(targetIds))\n        .filter(function () {\n          return $$.d3.select(this).classed(CLASS.legendItemFocused)\n        })\n        .classed(CLASS.legendItemFocused, false)\n    }\n\n    $$.focusedTargetIds = []\n    $$.defocusedTargetIds = []\n  }\n\n  Chart.prototype.xgrids = function (grids) {\n    var $$ = this.internal,\n      config = $$.config\n\n    if (!grids) {\n      return config.grid_x_lines\n    }\n\n    config.grid_x_lines = grids\n    $$.redrawWithoutRescale()\n    return config.grid_x_lines\n  }\n\n  Chart.prototype.xgrids.add = function (grids) {\n    var $$ = this.internal\n    return this.xgrids($$.config.grid_x_lines.concat(grids ? grids : []))\n  }\n\n  Chart.prototype.xgrids.remove = function (params) {\n    // TODO: multiple\n    var $$ = this.internal\n    $$.removeGridLines(params, true)\n  }\n\n  Chart.prototype.ygrids = function (grids) {\n    var $$ = this.internal,\n      config = $$.config\n\n    if (!grids) {\n      return config.grid_y_lines\n    }\n\n    config.grid_y_lines = grids\n    $$.redrawWithoutRescale()\n    return config.grid_y_lines\n  }\n\n  Chart.prototype.ygrids.add = function (grids) {\n    var $$ = this.internal\n    return this.ygrids($$.config.grid_y_lines.concat(grids ? grids : []))\n  }\n\n  Chart.prototype.ygrids.remove = function (params) {\n    // TODO: multiple\n    var $$ = this.internal\n    $$.removeGridLines(params, false)\n  }\n\n  Chart.prototype.groups = function (groups) {\n    var $$ = this.internal,\n      config = $$.config\n\n    if (isUndefined(groups)) {\n      return config.data_groups\n    }\n\n    config.data_groups = groups\n    $$.redraw()\n    return config.data_groups\n  }\n\n  Chart.prototype.legend = function () {}\n\n  Chart.prototype.legend.show = function (targetIds) {\n    var $$ = this.internal\n    $$.showLegend($$.mapToTargetIds(targetIds))\n    $$.updateAndRedraw({\n      withLegend: true\n    })\n  }\n\n  Chart.prototype.legend.hide = function (targetIds) {\n    var $$ = this.internal\n    $$.hideLegend($$.mapToTargetIds(targetIds))\n    $$.updateAndRedraw({\n      withLegend: false\n    })\n  }\n\n  Chart.prototype.load = function (args) {\n    var $$ = this.internal,\n      config = $$.config // update xs if specified\n\n    if (args.xs) {\n      $$.addXs(args.xs)\n    } // update names if exists\n\n    if ('names' in args) {\n      Chart.prototype.data.names.bind(this)(args.names)\n    } // update classes if exists\n\n    if ('classes' in args) {\n      Object.keys(args.classes).forEach(function (id) {\n        config.data_classes[id] = args.classes[id]\n      })\n    } // update categories if exists\n\n    if ('categories' in args && $$.isCategorized()) {\n      config.axis_x_categories = args.categories\n    } // update axes if exists\n\n    if ('axes' in args) {\n      Object.keys(args.axes).forEach(function (id) {\n        config.data_axes[id] = args.axes[id]\n      })\n    } // update colors if exists\n\n    if ('colors' in args) {\n      Object.keys(args.colors).forEach(function (id) {\n        config.data_colors[id] = args.colors[id]\n      })\n    } // use cache if exists\n\n    if ('cacheIds' in args && $$.hasCaches(args.cacheIds)) {\n      $$.load($$.getCaches(args.cacheIds), args.done)\n      return\n    } // unload if needed\n\n    if ('unload' in args) {\n      // TODO: do not unload if target will load (included in url/rows/columns)\n      $$.unload($$.mapToTargetIds(typeof args.unload === 'boolean' && args.unload ? null : args.unload), function () {\n        $$.loadFromArgs(args)\n      })\n    } else {\n      $$.loadFromArgs(args)\n    }\n  }\n\n  Chart.prototype.unload = function (args) {\n    var $$ = this.internal\n    args = args || {}\n\n    if (args instanceof Array) {\n      args = {\n        ids: args\n      }\n    } else if (typeof args === 'string') {\n      args = {\n        ids: [args]\n      }\n    }\n\n    $$.unload($$.mapToTargetIds(args.ids), function () {\n      $$.redraw({\n        withUpdateOrgXDomain: true,\n        withUpdateXDomain: true,\n        withLegend: true\n      })\n\n      if (args.done) {\n        args.done()\n      }\n    })\n  }\n\n  Chart.prototype.regions = function (regions) {\n    var $$ = this.internal,\n      config = $$.config\n\n    if (!regions) {\n      return config.regions\n    }\n\n    config.regions = regions\n    $$.redrawWithoutRescale()\n    return config.regions\n  }\n\n  Chart.prototype.regions.add = function (regions) {\n    var $$ = this.internal,\n      config = $$.config\n\n    if (!regions) {\n      return config.regions\n    }\n\n    config.regions = config.regions.concat(regions)\n    $$.redrawWithoutRescale()\n    return config.regions\n  }\n\n  Chart.prototype.regions.remove = function (options) {\n    var $$ = this.internal,\n      config = $$.config,\n      duration,\n      classes,\n      regions\n    options = options || {}\n    duration = getOption(options, 'duration', config.transition_duration)\n    classes = getOption(options, 'classes', [CLASS.region])\n    regions = $$.main.select('.' + CLASS.regions).selectAll(\n      classes.map(function (c) {\n        return '.' + c\n      })\n    )\n    ;(duration ? regions.transition().duration(duration) : regions).style('opacity', 0).remove()\n    config.regions = config.regions.filter(function (region) {\n      var found = false\n\n      if (!region['class']) {\n        return true\n      }\n\n      region['class'].split(' ').forEach(function (c) {\n        if (classes.indexOf(c) >= 0) {\n          found = true\n        }\n      })\n      return !found\n    })\n    return config.regions\n  }\n\n  Chart.prototype.selected = function (targetId) {\n    var $$ = this.internal,\n      d3 = $$.d3\n    return d3.merge(\n      $$.main\n        .selectAll('.' + CLASS.shapes + $$.getTargetSelectorSuffix(targetId))\n        .selectAll('.' + CLASS.shape)\n        .filter(function () {\n          return d3.select(this).classed(CLASS.SELECTED)\n        })\n        .map(function (d) {\n          return d.map(function (d) {\n            var data = d.__data__\n            return data.data ? data.data : data\n          })\n        })\n    )\n  }\n\n  Chart.prototype.select = function (ids, indices, resetOther) {\n    var $$ = this.internal,\n      d3 = $$.d3,\n      config = $$.config\n\n    if (!config.data_selection_enabled) {\n      return\n    }\n\n    $$.main\n      .selectAll('.' + CLASS.shapes)\n      .selectAll('.' + CLASS.shape)\n      .each(function (d, i) {\n        var shape = d3.select(this),\n          id = d.data ? d.data.id : d.id,\n          toggle = $$.getToggle(this, d).bind($$),\n          isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,\n          isTargetIndex = !indices || indices.indexOf(i) >= 0,\n          isSelected = shape.classed(CLASS.SELECTED) // line/area selection not supported yet\n\n        if (shape.classed(CLASS.line) || shape.classed(CLASS.area)) {\n          return\n        }\n\n        if (isTargetId && isTargetIndex) {\n          if (config.data_selection_isselectable(d) && !isSelected) {\n            toggle(true, shape.classed(CLASS.SELECTED, true), d, i)\n          }\n        } else if (isDefined(resetOther) && resetOther) {\n          if (isSelected) {\n            toggle(false, shape.classed(CLASS.SELECTED, false), d, i)\n          }\n        }\n      })\n  }\n\n  Chart.prototype.unselect = function (ids, indices) {\n    var $$ = this.internal,\n      d3 = $$.d3,\n      config = $$.config\n\n    if (!config.data_selection_enabled) {\n      return\n    }\n\n    $$.main\n      .selectAll('.' + CLASS.shapes)\n      .selectAll('.' + CLASS.shape)\n      .each(function (d, i) {\n        var shape = d3.select(this),\n          id = d.data ? d.data.id : d.id,\n          toggle = $$.getToggle(this, d).bind($$),\n          isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,\n          isTargetIndex = !indices || indices.indexOf(i) >= 0,\n          isSelected = shape.classed(CLASS.SELECTED) // line/area selection not supported yet\n\n        if (shape.classed(CLASS.line) || shape.classed(CLASS.area)) {\n          return\n        }\n\n        if (isTargetId && isTargetIndex) {\n          if (config.data_selection_isselectable(d)) {\n            if (isSelected) {\n              toggle(false, shape.classed(CLASS.SELECTED, false), d, i)\n            }\n          }\n        }\n      })\n  }\n\n  Chart.prototype.show = function (targetIds, options) {\n    var $$ = this.internal,\n      targets\n    targetIds = $$.mapToTargetIds(targetIds)\n    options = options || {}\n    $$.removeHiddenTargetIds(targetIds)\n    targets = $$.svg.selectAll($$.selectorTargets(targetIds))\n    targets\n      .transition()\n      .style('display', 'initial', 'important')\n      .style('opacity', 1, 'important')\n      .call($$.endall, function () {\n        targets.style('opacity', null).style('opacity', 1)\n      })\n\n    if (options.withLegend) {\n      $$.showLegend(targetIds)\n    }\n\n    $$.redraw({\n      withUpdateOrgXDomain: true,\n      withUpdateXDomain: true,\n      withLegend: true\n    })\n  }\n\n  Chart.prototype.hide = function (targetIds, options) {\n    var $$ = this.internal,\n      targets\n    targetIds = $$.mapToTargetIds(targetIds)\n    options = options || {}\n    $$.addHiddenTargetIds(targetIds)\n    targets = $$.svg.selectAll($$.selectorTargets(targetIds))\n    targets\n      .transition()\n      .style('opacity', 0, 'important')\n      .call($$.endall, function () {\n        targets.style('opacity', null).style('opacity', 0)\n        targets.style('display', 'none')\n      })\n\n    if (options.withLegend) {\n      $$.hideLegend(targetIds)\n    }\n\n    $$.redraw({\n      withUpdateOrgXDomain: true,\n      withUpdateXDomain: true,\n      withLegend: true\n    })\n  }\n\n  Chart.prototype.toggle = function (targetIds, options) {\n    var that = this,\n      $$ = this.internal\n    $$.mapToTargetIds(targetIds).forEach(function (targetId) {\n      $$.isTargetToShow(targetId) ? that.hide(targetId, options) : that.show(targetId, options)\n    })\n  }\n\n  Chart.prototype.tooltip = function () {}\n\n  Chart.prototype.tooltip.show = function (args) {\n    var $$ = this.internal,\n      targets,\n      data,\n      mouse = {} // determine mouse position on the chart\n\n    if (args.mouse) {\n      mouse = args.mouse\n    } else {\n      // determine focus data\n      if (args.data) {\n        data = args.data\n      } else if (typeof args.x !== 'undefined') {\n        if (args.id) {\n          targets = $$.data.targets.filter(function (t) {\n            return t.id === args.id\n          })\n        } else {\n          targets = $$.data.targets\n        }\n\n        data = $$.filterByX(targets, args.x).slice(0, 1)[0]\n      }\n\n      mouse = data ? $$.getMousePosition(data) : null\n    } // emulate mouse events to show\n\n    $$.dispatchEvent('mousemove', mouse)\n    $$.config.tooltip_onshow.call($$, data)\n  }\n\n  Chart.prototype.tooltip.hide = function () {\n    // TODO: get target data by checking the state of focus\n    this.internal.dispatchEvent('mouseout', 0)\n    this.internal.config.tooltip_onhide.call(this)\n  }\n\n  Chart.prototype.transform = function (type, targetIds) {\n    var $$ = this.internal,\n      options =\n        ['pie', 'donut'].indexOf(type) >= 0\n          ? {\n              withTransform: true\n            }\n          : null\n    $$.transformTo(targetIds, type, options)\n  }\n\n  ChartInternal.prototype.transformTo = function (targetIds, type, optionsForRedraw) {\n    var $$ = this,\n      withTransitionForAxis = !$$.hasArcType(),\n      options = optionsForRedraw || {\n        withTransitionForAxis: withTransitionForAxis\n      }\n    options.withTransitionForTransform = false\n    $$.transiting = false\n    $$.setTargetType(targetIds, type)\n    $$.updateTargets($$.data.targets) // this is needed when transforming to arc\n\n    $$.updateAndRedraw(options)\n  }\n\n  Chart.prototype.x = function (x) {\n    var $$ = this.internal\n\n    if (arguments.length) {\n      $$.updateTargetX($$.data.targets, x)\n      $$.redraw({\n        withUpdateOrgXDomain: true,\n        withUpdateXDomain: true\n      })\n    }\n\n    return $$.data.xs\n  }\n\n  Chart.prototype.xs = function (xs) {\n    var $$ = this.internal\n\n    if (arguments.length) {\n      $$.updateTargetXs($$.data.targets, xs)\n      $$.redraw({\n        withUpdateOrgXDomain: true,\n        withUpdateXDomain: true\n      })\n    }\n\n    return $$.data.xs\n  }\n\n  Chart.prototype.zoom = function (domain) {\n    var $$ = this.internal\n\n    if (domain) {\n      if ($$.isTimeSeries()) {\n        domain = domain.map(function (x) {\n          return $$.parseDate(x)\n        })\n      }\n\n      if ($$.config.subchart_show) {\n        $$.brush.selectionAsValue(domain, true)\n      } else {\n        $$.updateXDomain(null, true, false, false, domain)\n        $$.redraw({\n          withY: $$.config.zoom_rescale,\n          withSubchart: false\n        })\n      }\n\n      $$.config.zoom_onzoom.call(this, $$.x.orgDomain())\n      return domain\n    } else {\n      return $$.x.domain()\n    }\n  }\n\n  Chart.prototype.zoom.enable = function (enabled) {\n    var $$ = this.internal\n    $$.config.zoom_enabled = enabled\n    $$.updateAndRedraw()\n  }\n\n  Chart.prototype.unzoom = function () {\n    var $$ = this.internal\n\n    if ($$.config.subchart_show) {\n      $$.brush.clear()\n    } else {\n      $$.updateXDomain(null, true, false, false, $$.subX.domain())\n      $$.redraw({\n        withY: $$.config.zoom_rescale,\n        withSubchart: false\n      })\n    }\n  }\n\n  Chart.prototype.zoom.max = function (max) {\n    var $$ = this.internal,\n      config = $$.config,\n      d3 = $$.d3\n\n    if (max === 0 || max) {\n      config.zoom_x_max = d3.max([$$.orgXDomain[1], max])\n    } else {\n      return config.zoom_x_max\n    }\n  }\n\n  Chart.prototype.zoom.min = function (min) {\n    var $$ = this.internal,\n      config = $$.config,\n      d3 = $$.d3\n\n    if (min === 0 || min) {\n      config.zoom_x_min = d3.min([$$.orgXDomain[0], min])\n    } else {\n      return config.zoom_x_min\n    }\n  }\n\n  Chart.prototype.zoom.range = function (range) {\n    if (arguments.length) {\n      if (isDefined(range.max)) {\n        this.domain.max(range.max)\n      }\n\n      if (isDefined(range.min)) {\n        this.domain.min(range.min)\n      }\n    } else {\n      return {\n        max: this.domain.max(),\n        min: this.domain.min()\n      }\n    }\n  }\n\n  ChartInternal.prototype.initPie = function () {\n    var $$ = this,\n      d3 = $$.d3\n    $$.pie = d3.pie().value(function (d) {\n      return d.values.reduce(function (a, b) {\n        return a + b.value\n      }, 0)\n    })\n    var orderFct = $$.getOrderFunction() // we need to reverse the returned order if asc or desc to have the slice in expected order.\n\n    if (orderFct && ($$.isOrderAsc() || $$.isOrderDesc())) {\n      var defaultSort = orderFct\n\n      orderFct = function orderFct (t1, t2) {\n        return defaultSort(t1, t2) * -1\n      }\n    }\n\n    $$.pie.sort(orderFct || null)\n  }\n\n  ChartInternal.prototype.updateRadius = function () {\n    var $$ = this,\n      config = $$.config,\n      w = config.gauge_width || config.donut_width,\n      gaugeArcWidth = $$.filterTargetsToShow($$.data.targets).length * $$.config.gauge_arcs_minWidth\n    $$.radiusExpanded = (Math.min($$.arcWidth, $$.arcHeight) / 2) * ($$.hasType('gauge') ? 0.85 : 1)\n    $$.radius = $$.radiusExpanded * 0.95\n    $$.innerRadiusRatio = w ? ($$.radius - w) / $$.radius : 0.6\n    $$.innerRadius = $$.hasType('donut') || $$.hasType('gauge') ? $$.radius * $$.innerRadiusRatio : 0\n    $$.gaugeArcWidth = w\n      ? w\n      : gaugeArcWidth <= $$.radius - $$.innerRadius\n      ? $$.radius - $$.innerRadius\n      : gaugeArcWidth <= $$.radius\n      ? gaugeArcWidth\n      : $$.radius\n  }\n\n  ChartInternal.prototype.updateArc = function () {\n    var $$ = this\n    $$.svgArc = $$.getSvgArc()\n    $$.svgArcExpanded = $$.getSvgArcExpanded()\n    $$.svgArcExpandedSub = $$.getSvgArcExpanded(0.98)\n  }\n\n  ChartInternal.prototype.updateAngle = function (d) {\n    var $$ = this,\n      config = $$.config,\n      found = false,\n      index = 0,\n      gMin,\n      gMax,\n      gTic,\n      gValue\n\n    if (!config) {\n      return null\n    }\n\n    $$.pie($$.filterTargetsToShow($$.data.targets)).forEach(function (t) {\n      if (!found && t.data.id === d.data.id) {\n        found = true\n        d = t\n        d.index = index\n      }\n\n      index++\n    })\n\n    if (isNaN(d.startAngle)) {\n      d.startAngle = 0\n    }\n\n    if (isNaN(d.endAngle)) {\n      d.endAngle = d.startAngle\n    }\n\n    if ($$.isGaugeType(d.data)) {\n      gMin = config.gauge_min\n      gMax = config.gauge_max\n      gTic = (Math.PI * (config.gauge_fullCircle ? 2 : 1)) / (gMax - gMin)\n      gValue = d.value < gMin ? 0 : d.value < gMax ? d.value - gMin : gMax - gMin\n      d.startAngle = config.gauge_startingAngle\n      d.endAngle = d.startAngle + gTic * gValue\n    }\n\n    return found ? d : null\n  }\n\n  ChartInternal.prototype.getSvgArc = function () {\n    var $$ = this,\n      hasGaugeType = $$.hasType('gauge'),\n      singleArcWidth = $$.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length,\n      arc = $$.d3\n        .arc()\n        .outerRadius(function (d) {\n          return hasGaugeType ? $$.radius - singleArcWidth * d.index : $$.radius\n        })\n        .innerRadius(function (d) {\n          return hasGaugeType ? $$.radius - singleArcWidth * (d.index + 1) : $$.innerRadius\n        }),\n      newArc = function newArc (d, withoutUpdate) {\n        var updated\n\n        if (withoutUpdate) {\n          return arc(d)\n        } // for interpolate\n\n        updated = $$.updateAngle(d)\n        return updated ? arc(updated) : 'M 0 0'\n      } // TODO: extends all function\n\n    newArc.centroid = arc.centroid\n    return newArc\n  }\n\n  ChartInternal.prototype.getSvgArcExpanded = function (rate) {\n    rate = rate || 1\n    var $$ = this,\n      hasGaugeType = $$.hasType('gauge'),\n      singleArcWidth = $$.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length,\n      expandWidth = Math.min($$.radiusExpanded * rate - $$.radius, singleArcWidth * 0.8 - (1 - rate) * 100),\n      arc = $$.d3\n        .arc()\n        .outerRadius(function (d) {\n          return hasGaugeType ? $$.radius - singleArcWidth * d.index + expandWidth : $$.radiusExpanded * rate\n        })\n        .innerRadius(function (d) {\n          return hasGaugeType ? $$.radius - singleArcWidth * (d.index + 1) : $$.innerRadius\n        })\n    return function (d) {\n      var updated = $$.updateAngle(d)\n      return updated ? arc(updated) : 'M 0 0'\n    }\n  }\n\n  ChartInternal.prototype.getArc = function (d, withoutUpdate, force) {\n    return force || this.isArcType(d.data) ? this.svgArc(d, withoutUpdate) : 'M 0 0'\n  }\n\n  ChartInternal.prototype.transformForArcLabel = function (d) {\n    var $$ = this,\n      config = $$.config,\n      updated = $$.updateAngle(d),\n      c,\n      x,\n      y,\n      h,\n      ratio,\n      translate = '',\n      hasGauge = $$.hasType('gauge')\n\n    if (updated && !hasGauge) {\n      c = this.svgArc.centroid(updated)\n      x = isNaN(c[0]) ? 0 : c[0]\n      y = isNaN(c[1]) ? 0 : c[1]\n      h = Math.sqrt(x * x + y * y)\n\n      if ($$.hasType('donut') && config.donut_label_ratio) {\n        ratio = isFunction(config.donut_label_ratio)\n          ? config.donut_label_ratio(d, $$.radius, h)\n          : config.donut_label_ratio\n      } else if ($$.hasType('pie') && config.pie_label_ratio) {\n        ratio = isFunction(config.pie_label_ratio) ? config.pie_label_ratio(d, $$.radius, h) : config.pie_label_ratio\n      } else {\n        ratio = $$.radius && h ? ((36 / $$.radius > 0.375 ? 1.175 - 36 / $$.radius : 0.8) * $$.radius) / h : 0\n      }\n\n      translate = 'translate(' + x * ratio + ',' + y * ratio + ')'\n    } else if (updated && hasGauge && $$.filterTargetsToShow($$.data.targets).length > 1) {\n      var y1 = Math.sin(updated.endAngle - Math.PI / 2)\n      x = Math.cos(updated.endAngle - Math.PI / 2) * ($$.radiusExpanded + 25)\n      y = y1 * ($$.radiusExpanded + 15 - Math.abs(y1 * 10)) + 3\n      translate = 'translate(' + x + ',' + y + ')'\n    }\n\n    return translate\n  }\n\n  ChartInternal.prototype.getArcRatio = function (d) {\n    var $$ = this,\n      config = $$.config,\n      whole = Math.PI * ($$.hasType('gauge') && !config.gauge_fullCircle ? 1 : 2)\n    return d ? (d.endAngle - d.startAngle) / whole : null\n  }\n\n  ChartInternal.prototype.convertToArcData = function (d) {\n    return this.addName({\n      id: d.data.id,\n      value: d.value,\n      ratio: this.getArcRatio(d),\n      index: d.index\n    })\n  }\n\n  ChartInternal.prototype.textForArcLabel = function (d) {\n    var $$ = this,\n      updated,\n      value,\n      ratio,\n      id,\n      format\n\n    if (!$$.shouldShowArcLabel()) {\n      return ''\n    }\n\n    updated = $$.updateAngle(d)\n    value = updated ? updated.value : null\n    ratio = $$.getArcRatio(updated)\n    id = d.data.id\n\n    if (!$$.hasType('gauge') && !$$.meetsArcLabelThreshold(ratio)) {\n      return ''\n    }\n\n    format = $$.getArcLabelFormat()\n    return format ? format(value, ratio, id) : $$.defaultArcValueFormat(value, ratio)\n  }\n\n  ChartInternal.prototype.textForGaugeMinMax = function (value, isMax) {\n    var $$ = this,\n      format = $$.getGaugeLabelExtents()\n    return format ? format(value, isMax) : value\n  }\n\n  ChartInternal.prototype.expandArc = function (targetIds) {\n    var $$ = this,\n      interval // MEMO: avoid to cancel transition\n\n    if ($$.transiting) {\n      interval = window.setInterval(function () {\n        if (!$$.transiting) {\n          window.clearInterval(interval)\n\n          if ($$.legend.selectAll('.c3-legend-item-focused').size() > 0) {\n            $$.expandArc(targetIds)\n          }\n        }\n      }, 10)\n      return\n    }\n\n    targetIds = $$.mapToTargetIds(targetIds)\n    $$.svg.selectAll($$.selectorTargets(targetIds, '.' + CLASS.chartArc)).each(function (d) {\n      if (!$$.shouldExpand(d.data.id)) {\n        return\n      }\n\n      $$.d3\n        .select(this)\n        .selectAll('path')\n        .transition()\n        .duration($$.expandDuration(d.data.id))\n        .attr('d', $$.svgArcExpanded)\n        .transition()\n        .duration($$.expandDuration(d.data.id) * 2)\n        .attr('d', $$.svgArcExpandedSub)\n        .each(function (d) {\n          if ($$.isDonutType(d.data));\n        })\n    })\n  }\n\n  ChartInternal.prototype.unexpandArc = function (targetIds) {\n    var $$ = this\n\n    if ($$.transiting) {\n      return\n    }\n\n    targetIds = $$.mapToTargetIds(targetIds)\n    $$.svg\n      .selectAll($$.selectorTargets(targetIds, '.' + CLASS.chartArc))\n      .selectAll('path')\n      .transition()\n      .duration(function (d) {\n        return $$.expandDuration(d.data.id)\n      })\n      .attr('d', $$.svgArc)\n    $$.svg.selectAll('.' + CLASS.arc)\n  }\n\n  ChartInternal.prototype.expandDuration = function (id) {\n    var $$ = this,\n      config = $$.config\n\n    if ($$.isDonutType(id)) {\n      return config.donut_expand_duration\n    } else if ($$.isGaugeType(id)) {\n      return config.gauge_expand_duration\n    } else if ($$.isPieType(id)) {\n      return config.pie_expand_duration\n    } else {\n      return 50\n    }\n  }\n\n  ChartInternal.prototype.shouldExpand = function (id) {\n    var $$ = this,\n      config = $$.config\n    return (\n      ($$.isDonutType(id) && config.donut_expand) ||\n      ($$.isGaugeType(id) && config.gauge_expand) ||\n      ($$.isPieType(id) && config.pie_expand)\n    )\n  }\n\n  ChartInternal.prototype.shouldShowArcLabel = function () {\n    var $$ = this,\n      config = $$.config,\n      shouldShow = true\n\n    if ($$.hasType('donut')) {\n      shouldShow = config.donut_label_show\n    } else if ($$.hasType('pie')) {\n      shouldShow = config.pie_label_show\n    } // when gauge, always true\n\n    return shouldShow\n  }\n\n  ChartInternal.prototype.meetsArcLabelThreshold = function (ratio) {\n    var $$ = this,\n      config = $$.config,\n      threshold = $$.hasType('donut') ? config.donut_label_threshold : config.pie_label_threshold\n    return ratio >= threshold\n  }\n\n  ChartInternal.prototype.getArcLabelFormat = function () {\n    var $$ = this,\n      config = $$.config,\n      format = config.pie_label_format\n\n    if ($$.hasType('gauge')) {\n      format = config.gauge_label_format\n    } else if ($$.hasType('donut')) {\n      format = config.donut_label_format\n    }\n\n    return format\n  }\n\n  ChartInternal.prototype.getGaugeLabelExtents = function () {\n    var $$ = this,\n      config = $$.config\n    return config.gauge_label_extents\n  }\n\n  ChartInternal.prototype.getArcTitle = function () {\n    var $$ = this\n    return $$.hasType('donut') ? $$.config.donut_title : ''\n  }\n\n  ChartInternal.prototype.updateTargetsForArc = function (targets) {\n    var $$ = this,\n      main = $$.main,\n      mainPies,\n      mainPieEnter,\n      classChartArc = $$.classChartArc.bind($$),\n      classArcs = $$.classArcs.bind($$),\n      classFocus = $$.classFocus.bind($$)\n    mainPies = main\n      .select('.' + CLASS.chartArcs)\n      .selectAll('.' + CLASS.chartArc)\n      .data($$.pie(targets))\n      .attr('class', function (d) {\n        return classChartArc(d) + classFocus(d.data)\n      })\n    mainPieEnter = mainPies\n      .enter()\n      .append('g')\n      .attr('class', classChartArc)\n    mainPieEnter.append('g').attr('class', classArcs)\n    mainPieEnter\n      .append('text')\n      .attr('dy', $$.hasType('gauge') ? '-.1em' : '.35em')\n      .style('opacity', 0)\n      .style('text-anchor', 'middle')\n      .style('pointer-events', 'none') // MEMO: can not keep same color..., but not bad to update color in redraw\n    //mainPieUpdate.exit().remove();\n  }\n\n  ChartInternal.prototype.initArc = function () {\n    var $$ = this\n    $$.arcs = $$.main\n      .select('.' + CLASS.chart)\n      .append('g')\n      .attr('class', CLASS.chartArcs)\n      .attr('transform', $$.getTranslate('arc'))\n    $$.arcs\n      .append('text')\n      .attr('class', CLASS.chartArcsTitle)\n      .style('text-anchor', 'middle')\n      .text($$.getArcTitle())\n  }\n\n  ChartInternal.prototype.redrawArc = function (duration, durationForExit, withTransform) {\n    var $$ = this,\n      d3 = $$.d3,\n      config = $$.config,\n      main = $$.main,\n      arcs,\n      mainArc,\n      arcLabelLines,\n      mainArcLabelLine,\n      hasGaugeType = $$.hasType('gauge')\n    arcs = main\n      .selectAll('.' + CLASS.arcs)\n      .selectAll('.' + CLASS.arc)\n      .data($$.arcData.bind($$))\n    mainArc = arcs\n      .enter()\n      .append('path')\n      .attr('class', $$.classArc.bind($$))\n      .style('fill', function (d) {\n        return $$.color(d.data)\n      })\n      .style('cursor', function (d) {\n        return config.interaction_enabled && config.data_selection_isselectable(d) ? 'pointer' : null\n      })\n      .each(function (d) {\n        if ($$.isGaugeType(d.data)) {\n          d.startAngle = d.endAngle = config.gauge_startingAngle\n        }\n\n        this._current = d\n      })\n      .merge(arcs)\n\n    if (hasGaugeType) {\n      arcLabelLines = main\n        .selectAll('.' + CLASS.arcs)\n        .selectAll('.' + CLASS.arcLabelLine)\n        .data($$.arcData.bind($$))\n      mainArcLabelLine = arcLabelLines\n        .enter()\n        .append('rect')\n        .attr('class', function (d) {\n          return CLASS.arcLabelLine + ' ' + CLASS.target + ' ' + CLASS.target + '-' + d.data.id\n        })\n        .merge(arcLabelLines)\n\n      if ($$.filterTargetsToShow($$.data.targets).length === 1) {\n        mainArcLabelLine.style('display', 'none')\n      } else {\n        mainArcLabelLine\n          .style('fill', function (d) {\n            return $$.levelColor ? $$.levelColor(d.data.values[0].value) : $$.color(d.data)\n          })\n          .style('display', config.gauge_labelLine_show ? '' : 'none')\n          .each(function (d) {\n            var lineLength = 0,\n              lineThickness = 2,\n              x = 0,\n              y = 0,\n              transform = ''\n\n            if ($$.hiddenTargetIds.indexOf(d.data.id) < 0) {\n              var updated = $$.updateAngle(d),\n                innerLineLength =\n                  ($$.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length) * (updated.index + 1),\n                lineAngle = updated.endAngle - Math.PI / 2,\n                arcInnerRadius = $$.radius - innerLineLength,\n                linePositioningAngle = lineAngle - (arcInnerRadius === 0 ? 0 : 1 / arcInnerRadius)\n              lineLength = $$.radiusExpanded - $$.radius + innerLineLength\n              x = Math.cos(linePositioningAngle) * arcInnerRadius\n              y = Math.sin(linePositioningAngle) * arcInnerRadius\n              transform = 'rotate(' + (lineAngle * 180) / Math.PI + ', ' + x + ', ' + y + ')'\n            }\n\n            d3.select(this)\n              .attr('x', x)\n              .attr('y', y)\n              .attr('width', lineLength)\n              .attr('height', lineThickness)\n              .attr('transform', transform)\n              .style('stroke-dasharray', '0, ' + (lineLength + lineThickness) + ', 0')\n          })\n      }\n    }\n\n    mainArc\n      .attr('transform', function (d) {\n        return !$$.isGaugeType(d.data) && withTransform ? 'scale(0)' : ''\n      })\n      .on(\n        'mouseover',\n        config.interaction_enabled\n          ? function (d) {\n              var updated, arcData\n\n              if ($$.transiting) {\n                // skip while transiting\n                return\n              }\n\n              updated = $$.updateAngle(d)\n\n              if (updated) {\n                arcData = $$.convertToArcData(updated) // transitions\n\n                $$.expandArc(updated.data.id)\n                $$.api.focus(updated.data.id)\n                $$.toggleFocusLegend(updated.data.id, true)\n                $$.config.data_onmouseover(arcData, this)\n              }\n            }\n          : null\n      )\n      .on(\n        'mousemove',\n        config.interaction_enabled\n          ? function (d) {\n              var updated = $$.updateAngle(d),\n                arcData,\n                selectedData\n\n              if (updated) {\n                ;(arcData = $$.convertToArcData(updated)), (selectedData = [arcData])\n                $$.showTooltip(selectedData, this)\n              }\n            }\n          : null\n      )\n      .on(\n        'mouseout',\n        config.interaction_enabled\n          ? function (d) {\n              var updated, arcData\n\n              if ($$.transiting) {\n                // skip while transiting\n                return\n              }\n\n              updated = $$.updateAngle(d)\n\n              if (updated) {\n                arcData = $$.convertToArcData(updated) // transitions\n\n                $$.unexpandArc(updated.data.id)\n                $$.api.revert()\n                $$.revertLegend()\n                $$.hideTooltip()\n                $$.config.data_onmouseout(arcData, this)\n              }\n            }\n          : null\n      )\n      .on(\n        'click',\n        config.interaction_enabled\n          ? function (d, i) {\n              var updated = $$.updateAngle(d),\n                arcData\n\n              if (updated) {\n                arcData = $$.convertToArcData(updated)\n\n                if ($$.toggleShape) {\n                  $$.toggleShape(this, arcData, i)\n                }\n\n                $$.config.data_onclick.call($$.api, arcData, this)\n              }\n            }\n          : null\n      )\n      .each(function () {\n        $$.transiting = true\n      })\n      .transition()\n      .duration(duration)\n      .attrTween('d', function (d) {\n        var updated = $$.updateAngle(d),\n          interpolate\n\n        if (!updated) {\n          return function () {\n            return 'M 0 0'\n          }\n        } //                if (this._current === d) {\n        //                    this._current = {\n        //                        startAngle: Math.PI*2,\n        //                        endAngle: Math.PI*2,\n        //                    };\n        //                }\n\n        if (isNaN(this._current.startAngle)) {\n          this._current.startAngle = 0\n        }\n\n        if (isNaN(this._current.endAngle)) {\n          this._current.endAngle = this._current.startAngle\n        }\n\n        interpolate = d3.interpolate(this._current, updated)\n        this._current = interpolate(0)\n        return function (t) {\n          var interpolated = interpolate(t)\n          interpolated.data = d.data // data.id will be updated by interporator\n\n          return $$.getArc(interpolated, true)\n        }\n      })\n      .attr('transform', withTransform ? 'scale(1)' : '')\n      .style('fill', function (d) {\n        return $$.levelColor ? $$.levelColor(d.data.values[0].value) : $$.color(d.data.id)\n      }) // Where gauge reading color would receive customization.\n      .call($$.endall, function () {\n        $$.transiting = false\n      })\n    arcs\n      .exit()\n      .transition()\n      .duration(durationForExit)\n      .style('opacity', 0)\n      .remove()\n    main\n      .selectAll('.' + CLASS.chartArc)\n      .select('text')\n      .style('opacity', 0)\n      .attr('class', function (d) {\n        return $$.isGaugeType(d.data) ? CLASS.gaugeValue : ''\n      })\n      .text($$.textForArcLabel.bind($$))\n      .attr('transform', $$.transformForArcLabel.bind($$))\n      .style('font-size', function (d) {\n        return $$.isGaugeType(d.data) && $$.filterTargetsToShow($$.data.targets).length === 1\n          ? Math.round($$.radius / 5) + 'px'\n          : ''\n      })\n      .transition()\n      .duration(duration)\n      .style('opacity', function (d) {\n        return $$.isTargetToShow(d.data.id) && $$.isArcType(d.data) ? 1 : 0\n      })\n    main.select('.' + CLASS.chartArcsTitle).style('opacity', $$.hasType('donut') || hasGaugeType ? 1 : 0)\n\n    if (hasGaugeType) {\n      var index = 0\n      var backgroundArc = $$.arcs\n        .select('g.' + CLASS.chartArcsBackground)\n        .selectAll('path.' + CLASS.chartArcsBackground)\n        .data($$.data.targets)\n      backgroundArc\n        .enter()\n        .append('path')\n        .attr('class', function (d, i) {\n          return CLASS.chartArcsBackground + ' ' + CLASS.chartArcsBackground + '-' + i\n        })\n        .merge(backgroundArc)\n        .attr('d', function (d1) {\n          if ($$.hiddenTargetIds.indexOf(d1.id) >= 0) {\n            return 'M 0 0'\n          }\n\n          var d = {\n            data: [\n              {\n                value: config.gauge_max\n              }\n            ],\n            startAngle: config.gauge_startingAngle,\n            endAngle: -1 * config.gauge_startingAngle * (config.gauge_fullCircle ? Math.PI : 1),\n            index: index++\n          }\n          return $$.getArc(d, true, true)\n        })\n      backgroundArc.exit().remove()\n      $$.arcs\n        .select('.' + CLASS.chartArcsGaugeUnit)\n        .attr('dy', '.75em')\n        .text(config.gauge_label_show ? config.gauge_units : '')\n      $$.arcs\n        .select('.' + CLASS.chartArcsGaugeMin)\n        .attr('dx', -1 * ($$.innerRadius + ($$.radius - $$.innerRadius) / (config.gauge_fullCircle ? 1 : 2)) + 'px')\n        .attr('dy', '1.2em')\n        .text(config.gauge_label_show ? $$.textForGaugeMinMax(config.gauge_min, false) : '')\n      $$.arcs\n        .select('.' + CLASS.chartArcsGaugeMax)\n        .attr('dx', $$.innerRadius + ($$.radius - $$.innerRadius) / (config.gauge_fullCircle ? 1 : 2) + 'px')\n        .attr('dy', '1.2em')\n        .text(config.gauge_label_show ? $$.textForGaugeMinMax(config.gauge_max, true) : '')\n    }\n  }\n\n  ChartInternal.prototype.initGauge = function () {\n    var arcs = this.arcs\n\n    if (this.hasType('gauge')) {\n      arcs.append('g').attr('class', CLASS.chartArcsBackground)\n      arcs\n        .append('text')\n        .attr('class', CLASS.chartArcsGaugeUnit)\n        .style('text-anchor', 'middle')\n        .style('pointer-events', 'none')\n      arcs\n        .append('text')\n        .attr('class', CLASS.chartArcsGaugeMin)\n        .style('text-anchor', 'middle')\n        .style('pointer-events', 'none')\n      arcs\n        .append('text')\n        .attr('class', CLASS.chartArcsGaugeMax)\n        .style('text-anchor', 'middle')\n        .style('pointer-events', 'none')\n    }\n  }\n\n  ChartInternal.prototype.getGaugeLabelHeight = function () {\n    return this.config.gauge_label_show ? 20 : 0\n  }\n\n  ChartInternal.prototype.hasCaches = function (ids) {\n    for (var i = 0; i < ids.length; i++) {\n      if (!(ids[i] in this.cache)) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  ChartInternal.prototype.addCache = function (id, target) {\n    this.cache[id] = this.cloneTarget(target)\n  }\n\n  ChartInternal.prototype.getCaches = function (ids) {\n    var targets = [],\n      i\n\n    for (i = 0; i < ids.length; i++) {\n      if (ids[i] in this.cache) {\n        targets.push(this.cloneTarget(this.cache[ids[i]]))\n      }\n    }\n\n    return targets\n  }\n\n  ChartInternal.prototype.categoryName = function (i) {\n    var config = this.config\n    return i < config.axis_x_categories.length ? config.axis_x_categories[i] : i\n  }\n\n  ChartInternal.prototype.generateTargetClass = function (targetId) {\n    return targetId || targetId === 0 ? ('-' + targetId).replace(/\\s/g, '-') : ''\n  }\n\n  ChartInternal.prototype.generateClass = function (prefix, targetId) {\n    return ' ' + prefix + ' ' + prefix + this.generateTargetClass(targetId)\n  }\n\n  ChartInternal.prototype.classText = function (d) {\n    return this.generateClass(CLASS.text, d.index)\n  }\n\n  ChartInternal.prototype.classTexts = function (d) {\n    return this.generateClass(CLASS.texts, d.id)\n  }\n\n  ChartInternal.prototype.classShape = function (d) {\n    return this.generateClass(CLASS.shape, d.index)\n  }\n\n  ChartInternal.prototype.classShapes = function (d) {\n    return this.generateClass(CLASS.shapes, d.id)\n  }\n\n  ChartInternal.prototype.classLine = function (d) {\n    return this.classShape(d) + this.generateClass(CLASS.line, d.id)\n  }\n\n  ChartInternal.prototype.classLines = function (d) {\n    return this.classShapes(d) + this.generateClass(CLASS.lines, d.id)\n  }\n\n  ChartInternal.prototype.classCircle = function (d) {\n    return this.classShape(d) + this.generateClass(CLASS.circle, d.index)\n  }\n\n  ChartInternal.prototype.classCircles = function (d) {\n    return this.classShapes(d) + this.generateClass(CLASS.circles, d.id)\n  }\n\n  ChartInternal.prototype.classBar = function (d) {\n    return this.classShape(d) + this.generateClass(CLASS.bar, d.index)\n  }\n\n  ChartInternal.prototype.classBars = function (d) {\n    return this.classShapes(d) + this.generateClass(CLASS.bars, d.id)\n  }\n\n  ChartInternal.prototype.classArc = function (d) {\n    return this.classShape(d.data) + this.generateClass(CLASS.arc, d.data.id)\n  }\n\n  ChartInternal.prototype.classArcs = function (d) {\n    return this.classShapes(d.data) + this.generateClass(CLASS.arcs, d.data.id)\n  }\n\n  ChartInternal.prototype.classArea = function (d) {\n    return this.classShape(d) + this.generateClass(CLASS.area, d.id)\n  }\n\n  ChartInternal.prototype.classAreas = function (d) {\n    return this.classShapes(d) + this.generateClass(CLASS.areas, d.id)\n  }\n\n  ChartInternal.prototype.classRegion = function (d, i) {\n    return this.generateClass(CLASS.region, i) + ' ' + ('class' in d ? d['class'] : '')\n  }\n\n  ChartInternal.prototype.classEvent = function (d) {\n    return this.generateClass(CLASS.eventRect, d.index)\n  }\n\n  ChartInternal.prototype.classTarget = function (id) {\n    var $$ = this\n    var additionalClassSuffix = $$.config.data_classes[id],\n      additionalClass = ''\n\n    if (additionalClassSuffix) {\n      additionalClass = ' ' + CLASS.target + '-' + additionalClassSuffix\n    }\n\n    return $$.generateClass(CLASS.target, id) + additionalClass\n  }\n\n  ChartInternal.prototype.classFocus = function (d) {\n    return this.classFocused(d) + this.classDefocused(d)\n  }\n\n  ChartInternal.prototype.classFocused = function (d) {\n    return ' ' + (this.focusedTargetIds.indexOf(d.id) >= 0 ? CLASS.focused : '')\n  }\n\n  ChartInternal.prototype.classDefocused = function (d) {\n    return ' ' + (this.defocusedTargetIds.indexOf(d.id) >= 0 ? CLASS.defocused : '')\n  }\n\n  ChartInternal.prototype.classChartText = function (d) {\n    return CLASS.chartText + this.classTarget(d.id)\n  }\n\n  ChartInternal.prototype.classChartLine = function (d) {\n    return CLASS.chartLine + this.classTarget(d.id)\n  }\n\n  ChartInternal.prototype.classChartBar = function (d) {\n    return CLASS.chartBar + this.classTarget(d.id)\n  }\n\n  ChartInternal.prototype.classChartArc = function (d) {\n    return CLASS.chartArc + this.classTarget(d.data.id)\n  }\n\n  ChartInternal.prototype.getTargetSelectorSuffix = function (targetId) {\n    return this.generateTargetClass(targetId).replace(/([?!@#$%^&*()_=+,.<>'\":;\\[\\]\\/|~`{}\\\\])/g, '\\\\$1')\n  }\n\n  ChartInternal.prototype.selectorTarget = function (id, prefix) {\n    return (prefix || '') + '.' + CLASS.target + this.getTargetSelectorSuffix(id)\n  }\n\n  ChartInternal.prototype.selectorTargets = function (ids, prefix) {\n    var $$ = this\n    ids = ids || []\n    return ids.length\n      ? ids.map(function (id) {\n          return $$.selectorTarget(id, prefix)\n        })\n      : null\n  }\n\n  ChartInternal.prototype.selectorLegend = function (id) {\n    return '.' + CLASS.legendItem + this.getTargetSelectorSuffix(id)\n  }\n\n  ChartInternal.prototype.selectorLegends = function (ids) {\n    var $$ = this\n    return ids && ids.length\n      ? ids.map(function (id) {\n          return $$.selectorLegend(id)\n        })\n      : null\n  }\n\n  ChartInternal.prototype.getClipPath = function (id) {\n    var isIE9 = window.navigator.appVersion.toLowerCase().indexOf('msie 9.') >= 0\n    return 'url(' + (isIE9 ? '' : document.URL.split('#')[0]) + '#' + id + ')'\n  }\n\n  ChartInternal.prototype.appendClip = function (parent, id) {\n    return parent\n      .append('clipPath')\n      .attr('id', id)\n      .append('rect')\n  }\n\n  ChartInternal.prototype.getAxisClipX = function (forHorizontal) {\n    // axis line width + padding for left\n    var left = Math.max(30, this.margin.left)\n    return forHorizontal ? -(1 + left) : -(left - 1)\n  }\n\n  ChartInternal.prototype.getAxisClipY = function (forHorizontal) {\n    return forHorizontal ? -20 : -this.margin.top\n  }\n\n  ChartInternal.prototype.getXAxisClipX = function () {\n    var $$ = this\n    return $$.getAxisClipX(!$$.config.axis_rotated)\n  }\n\n  ChartInternal.prototype.getXAxisClipY = function () {\n    var $$ = this\n    return $$.getAxisClipY(!$$.config.axis_rotated)\n  }\n\n  ChartInternal.prototype.getYAxisClipX = function () {\n    var $$ = this\n    return $$.config.axis_y_inner ? -1 : $$.getAxisClipX($$.config.axis_rotated)\n  }\n\n  ChartInternal.prototype.getYAxisClipY = function () {\n    var $$ = this\n    return $$.getAxisClipY($$.config.axis_rotated)\n  }\n\n  ChartInternal.prototype.getAxisClipWidth = function (forHorizontal) {\n    var $$ = this,\n      left = Math.max(30, $$.margin.left),\n      right = Math.max(30, $$.margin.right) // width + axis line width + padding for left/right\n\n    return forHorizontal ? $$.width + 2 + left + right : $$.margin.left + 20\n  }\n\n  ChartInternal.prototype.getAxisClipHeight = function (forHorizontal) {\n    // less than 20 is not enough to show the axis label 'outer' without legend\n    return (forHorizontal ? this.margin.bottom : this.margin.top + this.height) + 20\n  }\n\n  ChartInternal.prototype.getXAxisClipWidth = function () {\n    var $$ = this\n    return $$.getAxisClipWidth(!$$.config.axis_rotated)\n  }\n\n  ChartInternal.prototype.getXAxisClipHeight = function () {\n    var $$ = this\n    return $$.getAxisClipHeight(!$$.config.axis_rotated)\n  }\n\n  ChartInternal.prototype.getYAxisClipWidth = function () {\n    var $$ = this\n    return $$.getAxisClipWidth($$.config.axis_rotated) + ($$.config.axis_y_inner ? 20 : 0)\n  }\n\n  ChartInternal.prototype.getYAxisClipHeight = function () {\n    var $$ = this\n    return $$.getAxisClipHeight($$.config.axis_rotated)\n  }\n\n  ChartInternal.prototype.generateColor = function () {\n    var $$ = this,\n      config = $$.config,\n      d3 = $$.d3,\n      colors = config.data_colors,\n      pattern = notEmpty(config.color_pattern) ? config.color_pattern : d3.schemeCategory10,\n      callback = config.data_color,\n      ids = []\n    return function (d) {\n      var id = d.id || (d.data && d.data.id) || d,\n        color // if callback function is provided\n\n      if (colors[id] instanceof Function) {\n        color = colors[id](d)\n      } // if specified, choose that color\n      else if (colors[id]) {\n        color = colors[id]\n      } // if not specified, choose from pattern\n      else {\n        if (ids.indexOf(id) < 0) {\n          ids.push(id)\n        }\n\n        color = pattern[ids.indexOf(id) % pattern.length]\n        colors[id] = color\n      }\n\n      return callback instanceof Function ? callback(color, d) : color\n    }\n  }\n\n  ChartInternal.prototype.generateLevelColor = function () {\n    var $$ = this,\n      config = $$.config,\n      colors = config.color_pattern,\n      threshold = config.color_threshold,\n      asValue = threshold.unit === 'value',\n      values = threshold.values && threshold.values.length ? threshold.values : [],\n      max = threshold.max || 100\n    return notEmpty(threshold) && notEmpty(colors)\n      ? function (value) {\n          var i,\n            v,\n            color = colors[colors.length - 1]\n\n          for (i = 0; i < values.length; i++) {\n            v = asValue ? value : (value * 100) / max\n\n            if (v < values[i]) {\n              color = colors[i]\n              break\n            }\n          }\n\n          return color\n        }\n      : null\n  }\n\n  ChartInternal.prototype.getDefaultConfig = function () {\n    var config = {\n      bindto: '#chart',\n      svg_classname: undefined,\n      size_width: undefined,\n      size_height: undefined,\n      padding_left: undefined,\n      padding_right: undefined,\n      padding_top: undefined,\n      padding_bottom: undefined,\n      resize_auto: true,\n      zoom_enabled: false,\n      zoom_initialRange: undefined,\n      zoom_type: 'scroll',\n      zoom_disableDefaultBehavior: false,\n      zoom_privileged: false,\n      zoom_rescale: false,\n      zoom_onzoom: function zoom_onzoom () {},\n      zoom_onzoomstart: function zoom_onzoomstart () {},\n      zoom_onzoomend: function zoom_onzoomend () {},\n      zoom_x_min: undefined,\n      zoom_x_max: undefined,\n      interaction_brighten: true,\n      interaction_enabled: true,\n      onmouseover: function onmouseover () {},\n      onmouseout: function onmouseout () {},\n      onresize: function onresize () {},\n      onresized: function onresized () {},\n      oninit: function oninit () {},\n      onrendered: function onrendered () {},\n      transition_duration: 350,\n      data_x: undefined,\n      data_xs: {},\n      data_xFormat: '%Y-%m-%d',\n      data_xLocaltime: true,\n      data_xSort: true,\n      data_idConverter: function data_idConverter (id) {\n        return id\n      },\n      data_names: {},\n      data_classes: {},\n      data_groups: [],\n      data_axes: {},\n      data_type: undefined,\n      data_types: {},\n      data_labels: {},\n      data_order: 'desc',\n      data_regions: {},\n      data_color: undefined,\n      data_colors: {},\n      data_hide: false,\n      data_filter: undefined,\n      data_selection_enabled: false,\n      data_selection_grouped: false,\n      data_selection_isselectable: function data_selection_isselectable () {\n        return true\n      },\n      data_selection_multiple: true,\n      data_selection_draggable: false,\n      data_onclick: function data_onclick () {},\n      data_onmouseover: function data_onmouseover () {},\n      data_onmouseout: function data_onmouseout () {},\n      data_onselected: function data_onselected () {},\n      data_onunselected: function data_onunselected () {},\n      data_url: undefined,\n      data_headers: undefined,\n      data_json: undefined,\n      data_rows: undefined,\n      data_columns: undefined,\n      data_mimeType: undefined,\n      data_keys: undefined,\n      // configuration for no plot-able data supplied.\n      data_empty_label_text: '',\n      // subchart\n      subchart_show: false,\n      subchart_size_height: 60,\n      subchart_axis_x_show: true,\n      subchart_onbrush: function subchart_onbrush () {},\n      // color\n      color_pattern: [],\n      color_threshold: {},\n      // legend\n      legend_show: true,\n      legend_hide: false,\n      legend_position: 'bottom',\n      legend_inset_anchor: 'top-left',\n      legend_inset_x: 10,\n      legend_inset_y: 0,\n      legend_inset_step: undefined,\n      legend_item_onclick: undefined,\n      legend_item_onmouseover: undefined,\n      legend_item_onmouseout: undefined,\n      legend_equally: false,\n      legend_padding: 0,\n      legend_item_tile_width: 10,\n      legend_item_tile_height: 10,\n      // axis\n      axis_rotated: false,\n      axis_x_show: true,\n      axis_x_type: 'indexed',\n      axis_x_localtime: true,\n      axis_x_categories: [],\n      axis_x_tick_centered: false,\n      axis_x_tick_format: undefined,\n      axis_x_tick_culling: {},\n      axis_x_tick_culling_max: 10,\n      axis_x_tick_count: undefined,\n      axis_x_tick_fit: true,\n      axis_x_tick_values: null,\n      axis_x_tick_rotate: 0,\n      axis_x_tick_outer: true,\n      axis_x_tick_multiline: true,\n      axis_x_tick_multilineMax: 0,\n      axis_x_tick_width: null,\n      axis_x_max: undefined,\n      axis_x_min: undefined,\n      axis_x_padding: {},\n      axis_x_height: undefined,\n      axis_x_selection: undefined,\n      axis_x_label: {},\n      axis_x_inner: undefined,\n      axis_y_show: true,\n      axis_y_type: undefined,\n      axis_y_max: undefined,\n      axis_y_min: undefined,\n      axis_y_inverted: false,\n      axis_y_center: undefined,\n      axis_y_inner: undefined,\n      axis_y_label: {},\n      axis_y_tick_format: undefined,\n      axis_y_tick_outer: true,\n      axis_y_tick_values: null,\n      axis_y_tick_rotate: 0,\n      axis_y_tick_count: undefined,\n      axis_y_tick_time_type: undefined,\n      axis_y_tick_time_interval: undefined,\n      axis_y_padding: {},\n      axis_y_default: undefined,\n      axis_y2_show: false,\n      axis_y2_max: undefined,\n      axis_y2_min: undefined,\n      axis_y2_inverted: false,\n      axis_y2_center: undefined,\n      axis_y2_inner: undefined,\n      axis_y2_label: {},\n      axis_y2_tick_format: undefined,\n      axis_y2_tick_outer: true,\n      axis_y2_tick_values: null,\n      axis_y2_tick_count: undefined,\n      axis_y2_padding: {},\n      axis_y2_default: undefined,\n      // grid\n      grid_x_show: false,\n      grid_x_type: 'tick',\n      grid_x_lines: [],\n      grid_y_show: false,\n      // not used\n      // grid_y_type: 'tick',\n      grid_y_lines: [],\n      grid_y_ticks: 10,\n      grid_focus_show: true,\n      grid_lines_front: true,\n      // point - point of each data\n      point_show: true,\n      point_r: 2.5,\n      point_sensitivity: 10,\n      point_focus_expand_enabled: true,\n      point_focus_expand_r: undefined,\n      point_select_r: undefined,\n      // line\n      line_connectNull: false,\n      line_step_type: 'step',\n      // bar\n      bar_width: undefined,\n      bar_width_ratio: 0.6,\n      bar_width_max: undefined,\n      bar_zerobased: true,\n      bar_space: 0,\n      // area\n      area_zerobased: true,\n      area_above: false,\n      // pie\n      pie_label_show: true,\n      pie_label_format: undefined,\n      pie_label_threshold: 0.05,\n      pie_label_ratio: undefined,\n      pie_expand: {},\n      pie_expand_duration: 50,\n      // gauge\n      gauge_fullCircle: false,\n      gauge_label_show: true,\n      gauge_labelLine_show: true,\n      gauge_label_format: undefined,\n      gauge_min: 0,\n      gauge_max: 100,\n      gauge_startingAngle: (-1 * Math.PI) / 2,\n      gauge_label_extents: undefined,\n      gauge_units: undefined,\n      gauge_width: undefined,\n      gauge_arcs_minWidth: 5,\n      gauge_expand: {},\n      gauge_expand_duration: 50,\n      // donut\n      donut_label_show: true,\n      donut_label_format: undefined,\n      donut_label_threshold: 0.05,\n      donut_label_ratio: undefined,\n      donut_width: undefined,\n      donut_title: '',\n      donut_expand: {},\n      donut_expand_duration: 50,\n      // spline\n      spline_interpolation_type: 'cardinal',\n      // region - region to change style\n      regions: [],\n      // tooltip - show when mouseover on each data\n      tooltip_show: true,\n      tooltip_grouped: true,\n      tooltip_order: undefined,\n      tooltip_format_title: undefined,\n      tooltip_format_name: undefined,\n      tooltip_format_value: undefined,\n      tooltip_position: undefined,\n      tooltip_contents: function tooltip_contents (d, defaultTitleFormat, defaultValueFormat, color) {\n        return this.getTooltipContent ? this.getTooltipContent(d, defaultTitleFormat, defaultValueFormat, color) : ''\n      },\n      tooltip_init_show: false,\n      tooltip_init_x: 0,\n      tooltip_init_position: {\n        top: '0px',\n        left: '50px'\n      },\n      tooltip_onshow: function tooltip_onshow () {},\n      tooltip_onhide: function tooltip_onhide () {},\n      // title\n      title_text: undefined,\n      title_padding: {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      },\n      title_position: 'top-center'\n    }\n    Object.keys(this.additionalConfig).forEach(function (key) {\n      config[key] = this.additionalConfig[key]\n    }, this)\n    return config\n  }\n\n  ChartInternal.prototype.additionalConfig = {}\n\n  ChartInternal.prototype.loadConfig = function (config) {\n    var this_config = this.config,\n      target,\n      keys,\n      read\n\n    function find () {\n      var key = keys.shift() //        console.log(\"key =>\", key, \", target =>\", target);\n\n      if (key && target && _typeof(target) === 'object' && key in target) {\n        target = target[key]\n        return find()\n      } else if (!key) {\n        return target\n      } else {\n        return undefined\n      }\n    }\n\n    Object.keys(this_config).forEach(function (key) {\n      target = config\n      keys = key.split('_')\n      read = find() //        console.log(\"CONFIG : \", key, read);\n\n      if (isDefined(read)) {\n        this_config[key] = read\n      }\n    })\n  }\n\n  ChartInternal.prototype.convertUrlToData = function (url, mimeType, headers, keys, done) {\n    var $$ = this,\n      type = mimeType ? mimeType : 'csv',\n      f,\n      converter\n\n    if (type === 'json') {\n      f = $$.d3.json\n      converter = $$.convertJsonToData\n    } else if (type === 'tsv') {\n      f = $$.d3.tsv\n      converter = $$.convertXsvToData\n    } else {\n      f = $$.d3.csv\n      converter = $$.convertXsvToData\n    }\n\n    f(url, headers)\n      .then(function (data) {\n        done.call($$, converter.call($$, data, keys))\n      })\n      .catch(function (error) {\n        throw error\n      })\n  }\n\n  ChartInternal.prototype.convertXsvToData = function (xsv) {\n    var keys = xsv.columns,\n      rows = xsv\n\n    if (rows.length === 0) {\n      return {\n        keys: keys,\n        rows: [\n          keys.reduce(function (row, key) {\n            return Object.assign(row, _defineProperty({}, key, null))\n          }, {})\n        ]\n      }\n    } else {\n      // [].concat() is to convert result into a plain array otherwise\n      // test is not happy because rows have properties.\n      return {\n        keys: keys,\n        rows: [].concat(xsv)\n      }\n    }\n  }\n\n  ChartInternal.prototype.convertJsonToData = function (json, keys) {\n    var $$ = this,\n      new_rows = [],\n      targetKeys,\n      data\n\n    if (keys) {\n      // when keys specified, json would be an array that includes objects\n      if (keys.x) {\n        targetKeys = keys.value.concat(keys.x)\n        $$.config.data_x = keys.x\n      } else {\n        targetKeys = keys.value\n      }\n\n      new_rows.push(targetKeys)\n      json.forEach(function (o) {\n        var new_row = []\n        targetKeys.forEach(function (key) {\n          // convert undefined to null because undefined data will be removed in convertDataToTargets()\n          var v = $$.findValueInJson(o, key)\n\n          if (isUndefined(v)) {\n            v = null\n          }\n\n          new_row.push(v)\n        })\n        new_rows.push(new_row)\n      })\n      data = $$.convertRowsToData(new_rows)\n    } else {\n      Object.keys(json).forEach(function (key) {\n        new_rows.push([key].concat(json[key]))\n      })\n      data = $$.convertColumnsToData(new_rows)\n    }\n\n    return data\n  }\n\n  ChartInternal.prototype.findValueInJson = function (object, path) {\n    path = path.replace(/\\[(\\w+)\\]/g, '.$1') // convert indexes to properties (replace [] with .)\n\n    path = path.replace(/^\\./, '') // strip a leading dot\n\n    var pathArray = path.split('.')\n\n    for (var i = 0; i < pathArray.length; ++i) {\n      var k = pathArray[i]\n\n      if (k in object) {\n        object = object[k]\n      } else {\n        return\n      }\n    }\n\n    return object\n  }\n  /**\n   * Converts the rows to normalized data.\n   * @param {any[][]} rows The row data\n   * @return {Object}\n   */\n\n  ChartInternal.prototype.convertRowsToData = function (rows) {\n    var newRows = []\n    var keys = rows[0]\n\n    for (var i = 1; i < rows.length; i++) {\n      var newRow = {}\n\n      for (var j = 0; j < rows[i].length; j++) {\n        if (isUndefined(rows[i][j])) {\n          throw new Error('Source data is missing a component at (' + i + ',' + j + ')!')\n        }\n\n        newRow[keys[j]] = rows[i][j]\n      }\n\n      newRows.push(newRow)\n    }\n\n    return {\n      keys: keys,\n      rows: newRows\n    }\n  }\n  /**\n   * Converts the columns to normalized data.\n   * @param {any[][]} columns The column data\n   * @return {Object}\n   */\n\n  ChartInternal.prototype.convertColumnsToData = function (columns) {\n    var newRows = []\n    var keys = []\n\n    for (var i = 0; i < columns.length; i++) {\n      var key = columns[i][0]\n\n      for (var j = 1; j < columns[i].length; j++) {\n        if (isUndefined(newRows[j - 1])) {\n          newRows[j - 1] = {}\n        }\n\n        if (isUndefined(columns[i][j])) {\n          throw new Error('Source data is missing a component at (' + i + ',' + j + ')!')\n        }\n\n        newRows[j - 1][key] = columns[i][j]\n      }\n\n      keys.push(key)\n    }\n\n    return {\n      keys: keys,\n      rows: newRows\n    }\n  }\n  /**\n   * Converts the data format into the target format.\n   * @param {!Object} data\n   * @param {!Array} data.keys Ordered list of target IDs.\n   * @param {!Array} data.rows Rows of data to convert.\n   * @param {boolean} appendXs True to append to $$.data.xs, False to replace.\n   * @return {!Array}\n   */\n\n  ChartInternal.prototype.convertDataToTargets = function (data, appendXs) {\n    var $$ = this,\n      config = $$.config,\n      targets,\n      ids,\n      xs,\n      keys // handles format where keys are not orderly provided\n\n    if (isArray(data)) {\n      keys = Object.keys(data[0])\n    } else {\n      keys = data.keys\n      data = data.rows\n    }\n\n    ids = keys.filter($$.isNotX, $$)\n    xs = keys.filter($$.isX, $$) // save x for update data by load when custom x and c3.x API\n\n    ids.forEach(function (id) {\n      var xKey = $$.getXKey(id)\n\n      if ($$.isCustomX() || $$.isTimeSeries()) {\n        // if included in input data\n        if (xs.indexOf(xKey) >= 0) {\n          $$.data.xs[id] = (appendXs && $$.data.xs[id] ? $$.data.xs[id] : []).concat(\n            data\n              .map(function (d) {\n                return d[xKey]\n              })\n              .filter(isValue)\n              .map(function (rawX, i) {\n                return $$.generateTargetX(rawX, id, i)\n              })\n          )\n        } // if not included in input data, find from preloaded data of other id's x\n        else if (config.data_x) {\n          $$.data.xs[id] = $$.getOtherTargetXs()\n        } // if not included in input data, find from preloaded data\n        else if (notEmpty(config.data_xs)) {\n          $$.data.xs[id] = $$.getXValuesOfXKey(xKey, $$.data.targets)\n        } // MEMO: if no x included, use same x of current will be used\n      } else {\n        $$.data.xs[id] = data.map(function (d, i) {\n          return i\n        })\n      }\n    }) // check x is defined\n\n    ids.forEach(function (id) {\n      if (!$$.data.xs[id]) {\n        throw new Error('x is not defined for id = \"' + id + '\".')\n      }\n    }) // convert to target\n\n    targets = ids.map(function (id, index) {\n      var convertedId = config.data_idConverter(id)\n      return {\n        id: convertedId,\n        id_org: id,\n        values: data\n          .map(function (d, i) {\n            var xKey = $$.getXKey(id),\n              rawX = d[xKey],\n              value = d[id] !== null && !isNaN(d[id]) ? +d[id] : null,\n              x // use x as categories if custom x and categorized\n\n            if ($$.isCustomX() && $$.isCategorized() && !isUndefined(rawX)) {\n              if (index === 0 && i === 0) {\n                config.axis_x_categories = []\n              }\n\n              x = config.axis_x_categories.indexOf(rawX)\n\n              if (x === -1) {\n                x = config.axis_x_categories.length\n                config.axis_x_categories.push(rawX)\n              }\n            } else {\n              x = $$.generateTargetX(rawX, id, i)\n            } // mark as x = undefined if value is undefined and filter to remove after mapped\n\n            if (isUndefined(d[id]) || $$.data.xs[id].length <= i) {\n              x = undefined\n            }\n\n            return {\n              x: x,\n              value: value,\n              id: convertedId\n            }\n          })\n          .filter(function (v) {\n            return isDefined(v.x)\n          })\n      }\n    }) // finish targets\n\n    targets.forEach(function (t) {\n      var i // sort values by its x\n\n      if (config.data_xSort) {\n        t.values = t.values.sort(function (v1, v2) {\n          var x1 = v1.x || v1.x === 0 ? v1.x : Infinity,\n            x2 = v2.x || v2.x === 0 ? v2.x : Infinity\n          return x1 - x2\n        })\n      } // indexing each value\n\n      i = 0\n      t.values.forEach(function (v) {\n        v.index = i++\n      }) // this needs to be sorted because its index and value.index is identical\n\n      $$.data.xs[t.id].sort(function (v1, v2) {\n        return v1 - v2\n      })\n    }) // cache information about values\n\n    $$.hasNegativeValue = $$.hasNegativeValueInTargets(targets)\n    $$.hasPositiveValue = $$.hasPositiveValueInTargets(targets) // set target types\n\n    if (config.data_type) {\n      $$.setTargetType(\n        $$.mapToIds(targets).filter(function (id) {\n          return !(id in config.data_types)\n        }),\n        config.data_type\n      )\n    } // cache as original id keyed\n\n    targets.forEach(function (d) {\n      $$.addCache(d.id_org, d)\n    })\n    return targets\n  }\n\n  ChartInternal.prototype.isX = function (key) {\n    var $$ = this,\n      config = $$.config\n    return (config.data_x && key === config.data_x) || (notEmpty(config.data_xs) && hasValue(config.data_xs, key))\n  }\n\n  ChartInternal.prototype.isNotX = function (key) {\n    return !this.isX(key)\n  }\n\n  ChartInternal.prototype.getXKey = function (id) {\n    var $$ = this,\n      config = $$.config\n    return config.data_x ? config.data_x : notEmpty(config.data_xs) ? config.data_xs[id] : null\n  }\n\n  ChartInternal.prototype.getXValuesOfXKey = function (key, targets) {\n    var $$ = this,\n      xValues,\n      ids = targets && notEmpty(targets) ? $$.mapToIds(targets) : []\n    ids.forEach(function (id) {\n      if ($$.getXKey(id) === key) {\n        xValues = $$.data.xs[id]\n      }\n    })\n    return xValues\n  }\n\n  ChartInternal.prototype.getXValue = function (id, i) {\n    var $$ = this\n    return id in $$.data.xs && $$.data.xs[id] && isValue($$.data.xs[id][i]) ? $$.data.xs[id][i] : i\n  }\n\n  ChartInternal.prototype.getOtherTargetXs = function () {\n    var $$ = this,\n      idsForX = Object.keys($$.data.xs)\n    return idsForX.length ? $$.data.xs[idsForX[0]] : null\n  }\n\n  ChartInternal.prototype.getOtherTargetX = function (index) {\n    var xs = this.getOtherTargetXs()\n    return xs && index < xs.length ? xs[index] : null\n  }\n\n  ChartInternal.prototype.addXs = function (xs) {\n    var $$ = this\n    Object.keys(xs).forEach(function (id) {\n      $$.config.data_xs[id] = xs[id]\n    })\n  }\n\n  ChartInternal.prototype.addName = function (data) {\n    var $$ = this,\n      name\n\n    if (data) {\n      name = $$.config.data_names[data.id]\n      data.name = name !== undefined ? name : data.id\n    }\n\n    return data\n  }\n\n  ChartInternal.prototype.getValueOnIndex = function (values, index) {\n    var valueOnIndex = values.filter(function (v) {\n      return v.index === index\n    })\n    return valueOnIndex.length ? valueOnIndex[0] : null\n  }\n\n  ChartInternal.prototype.updateTargetX = function (targets, x) {\n    var $$ = this\n    targets.forEach(function (t) {\n      t.values.forEach(function (v, i) {\n        v.x = $$.generateTargetX(x[i], t.id, i)\n      })\n      $$.data.xs[t.id] = x\n    })\n  }\n\n  ChartInternal.prototype.updateTargetXs = function (targets, xs) {\n    var $$ = this\n    targets.forEach(function (t) {\n      if (xs[t.id]) {\n        $$.updateTargetX([t], xs[t.id])\n      }\n    })\n  }\n\n  ChartInternal.prototype.generateTargetX = function (rawX, id, index) {\n    var $$ = this,\n      x\n\n    if ($$.isTimeSeries()) {\n      x = rawX ? $$.parseDate(rawX) : $$.parseDate($$.getXValue(id, index))\n    } else if ($$.isCustomX() && !$$.isCategorized()) {\n      x = isValue(rawX) ? +rawX : $$.getXValue(id, index)\n    } else {\n      x = index\n    }\n\n    return x\n  }\n\n  ChartInternal.prototype.cloneTarget = function (target) {\n    return {\n      id: target.id,\n      id_org: target.id_org,\n      values: target.values.map(function (d) {\n        return {\n          x: d.x,\n          value: d.value,\n          id: d.id\n        }\n      })\n    }\n  }\n\n  ChartInternal.prototype.getMaxDataCount = function () {\n    var $$ = this\n    return $$.d3.max($$.data.targets, function (t) {\n      return t.values.length\n    })\n  }\n\n  ChartInternal.prototype.mapToIds = function (targets) {\n    return targets.map(function (d) {\n      return d.id\n    })\n  }\n\n  ChartInternal.prototype.mapToTargetIds = function (ids) {\n    var $$ = this\n    return ids ? [].concat(ids) : $$.mapToIds($$.data.targets)\n  }\n\n  ChartInternal.prototype.hasTarget = function (targets, id) {\n    var ids = this.mapToIds(targets),\n      i\n\n    for (i = 0; i < ids.length; i++) {\n      if (ids[i] === id) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  ChartInternal.prototype.isTargetToShow = function (targetId) {\n    return this.hiddenTargetIds.indexOf(targetId) < 0\n  }\n\n  ChartInternal.prototype.isLegendToShow = function (targetId) {\n    return this.hiddenLegendIds.indexOf(targetId) < 0\n  }\n\n  ChartInternal.prototype.filterTargetsToShow = function (targets) {\n    var $$ = this\n    return targets.filter(function (t) {\n      return $$.isTargetToShow(t.id)\n    })\n  }\n\n  ChartInternal.prototype.mapTargetsToUniqueXs = function (targets) {\n    var $$ = this\n    var xs = $$.d3\n      .set(\n        $$.d3.merge(\n          targets.map(function (t) {\n            return t.values.map(function (v) {\n              return +v.x\n            })\n          })\n        )\n      )\n      .values()\n    xs = $$.isTimeSeries()\n      ? xs.map(function (x) {\n          return new Date(+x)\n        })\n      : xs.map(function (x) {\n          return +x\n        })\n    return xs.sort(function (a, b) {\n      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN\n    })\n  }\n\n  ChartInternal.prototype.addHiddenTargetIds = function (targetIds) {\n    targetIds = targetIds instanceof Array ? targetIds : new Array(targetIds)\n\n    for (var i = 0; i < targetIds.length; i++) {\n      if (this.hiddenTargetIds.indexOf(targetIds[i]) < 0) {\n        this.hiddenTargetIds = this.hiddenTargetIds.concat(targetIds[i])\n      }\n    }\n  }\n\n  ChartInternal.prototype.removeHiddenTargetIds = function (targetIds) {\n    this.hiddenTargetIds = this.hiddenTargetIds.filter(function (id) {\n      return targetIds.indexOf(id) < 0\n    })\n  }\n\n  ChartInternal.prototype.addHiddenLegendIds = function (targetIds) {\n    targetIds = targetIds instanceof Array ? targetIds : new Array(targetIds)\n\n    for (var i = 0; i < targetIds.length; i++) {\n      if (this.hiddenLegendIds.indexOf(targetIds[i]) < 0) {\n        this.hiddenLegendIds = this.hiddenLegendIds.concat(targetIds[i])\n      }\n    }\n  }\n\n  ChartInternal.prototype.removeHiddenLegendIds = function (targetIds) {\n    this.hiddenLegendIds = this.hiddenLegendIds.filter(function (id) {\n      return targetIds.indexOf(id) < 0\n    })\n  }\n\n  ChartInternal.prototype.getValuesAsIdKeyed = function (targets) {\n    var ys = {}\n    targets.forEach(function (t) {\n      ys[t.id] = []\n      t.values.forEach(function (v) {\n        ys[t.id].push(v.value)\n      })\n    })\n    return ys\n  }\n\n  ChartInternal.prototype.checkValueInTargets = function (targets, checker) {\n    var ids = Object.keys(targets),\n      i,\n      j,\n      values\n\n    for (i = 0; i < ids.length; i++) {\n      values = targets[ids[i]].values\n\n      for (j = 0; j < values.length; j++) {\n        if (checker(values[j].value)) {\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n\n  ChartInternal.prototype.hasNegativeValueInTargets = function (targets) {\n    return this.checkValueInTargets(targets, function (v) {\n      return v < 0\n    })\n  }\n\n  ChartInternal.prototype.hasPositiveValueInTargets = function (targets) {\n    return this.checkValueInTargets(targets, function (v) {\n      return v > 0\n    })\n  }\n\n  ChartInternal.prototype.isOrderDesc = function () {\n    var config = this.config\n    return typeof config.data_order === 'string' && config.data_order.toLowerCase() === 'desc'\n  }\n\n  ChartInternal.prototype.isOrderAsc = function () {\n    var config = this.config\n    return typeof config.data_order === 'string' && config.data_order.toLowerCase() === 'asc'\n  }\n\n  ChartInternal.prototype.getOrderFunction = function () {\n    var $$ = this,\n      config = $$.config,\n      orderAsc = $$.isOrderAsc(),\n      orderDesc = $$.isOrderDesc()\n\n    if (orderAsc || orderDesc) {\n      var reducer = function reducer (p, c) {\n        return p + Math.abs(c.value)\n      }\n\n      return function (t1, t2) {\n        var t1Sum = t1.values.reduce(reducer, 0),\n          t2Sum = t2.values.reduce(reducer, 0)\n        return orderAsc ? t2Sum - t1Sum : t1Sum - t2Sum\n      }\n    } else if (isFunction(config.data_order)) {\n      return config.data_order\n    } else if (isArray(config.data_order)) {\n      var order = config.data_order\n      return function (t1, t2) {\n        return order.indexOf(t1.id) - order.indexOf(t2.id)\n      }\n    }\n  }\n\n  ChartInternal.prototype.orderTargets = function (targets) {\n    var fct = this.getOrderFunction()\n\n    if (fct) {\n      targets.sort(fct)\n    }\n\n    return targets\n  }\n\n  ChartInternal.prototype.filterByX = function (targets, x) {\n    return this.d3\n      .merge(\n        targets.map(function (t) {\n          return t.values\n        })\n      )\n      .filter(function (v) {\n        return v.x - x === 0\n      })\n  }\n\n  ChartInternal.prototype.filterRemoveNull = function (data) {\n    return data.filter(function (d) {\n      return isValue(d.value)\n    })\n  }\n\n  ChartInternal.prototype.filterByXDomain = function (targets, xDomain) {\n    return targets.map(function (t) {\n      return {\n        id: t.id,\n        id_org: t.id_org,\n        values: t.values.filter(function (v) {\n          return xDomain[0] <= v.x && v.x <= xDomain[1]\n        })\n      }\n    })\n  }\n\n  ChartInternal.prototype.hasDataLabel = function () {\n    var config = this.config\n\n    if (typeof config.data_labels === 'boolean' && config.data_labels) {\n      return true\n    } else if (_typeof(config.data_labels) === 'object' && notEmpty(config.data_labels)) {\n      return true\n    }\n\n    return false\n  }\n\n  ChartInternal.prototype.getDataLabelLength = function (min, max, key) {\n    var $$ = this,\n      lengths = [0, 0],\n      paddingCoef = 1.3\n    $$.selectChart\n      .select('svg')\n      .selectAll('.dummy')\n      .data([min, max])\n      .enter()\n      .append('text')\n      .text(function (d) {\n        return $$.dataLabelFormat(d.id)(d)\n      })\n      .each(function (d, i) {\n        lengths[i] = this.getBoundingClientRect()[key] * paddingCoef\n      })\n      .remove()\n    return lengths\n  }\n  /**\n   * Returns true if the given data point is not arc type, otherwise false.\n   * @param {Object} d The data point\n   * @return {boolean}\n   */\n\n  ChartInternal.prototype.isNoneArc = function (d) {\n    return this.hasTarget(this.data.targets, d.id)\n  }\n  /**\n   * Returns true if the given data point is arc type, otherwise false.\n   * @param {Object} d The data point\n   * @return {boolean}\n   */\n\n  ChartInternal.prototype.isArc = function (d) {\n    return 'data' in d && this.hasTarget(this.data.targets, d.data.id)\n  }\n\n  ChartInternal.prototype.findClosestFromTargets = function (targets, pos) {\n    var $$ = this,\n      candidates // map to array of closest points of each target\n\n    candidates = targets.map(function (target) {\n      return $$.findClosest(target.values, pos)\n    }) // decide closest point and return\n\n    return $$.findClosest(candidates, pos)\n  }\n\n  ChartInternal.prototype.findClosest = function (values, pos) {\n    var $$ = this,\n      minDist = $$.config.point_sensitivity,\n      closest // find mouseovering bar\n\n    values\n      .filter(function (v) {\n        return v && $$.isBarType(v.id)\n      })\n      .forEach(function (v) {\n        var shape = $$.main\n          .select('.' + CLASS.bars + $$.getTargetSelectorSuffix(v.id) + ' .' + CLASS.bar + '-' + v.index)\n          .node()\n\n        if (!closest && $$.isWithinBar($$.d3.mouse(shape), shape)) {\n          closest = v\n        }\n      }) // find closest point from non-bar\n\n    values\n      .filter(function (v) {\n        return v && !$$.isBarType(v.id)\n      })\n      .forEach(function (v) {\n        var d = $$.dist(v, pos)\n\n        if (d < minDist) {\n          minDist = d\n          closest = v\n        }\n      })\n    return closest\n  }\n\n  ChartInternal.prototype.dist = function (data, pos) {\n    var $$ = this,\n      config = $$.config,\n      xIndex = config.axis_rotated ? 1 : 0,\n      yIndex = config.axis_rotated ? 0 : 1,\n      y = $$.circleY(data, data.index),\n      x = $$.x(data.x)\n    return Math.sqrt(Math.pow(x - pos[xIndex], 2) + Math.pow(y - pos[yIndex], 2))\n  }\n\n  ChartInternal.prototype.convertValuesToStep = function (values) {\n    var converted = [].concat(values),\n      i\n\n    if (!this.isCategorized()) {\n      return values\n    }\n\n    for (i = values.length + 1; 0 < i; i--) {\n      converted[i] = converted[i - 1]\n    }\n\n    converted[0] = {\n      x: converted[0].x - 1,\n      value: converted[0].value,\n      id: converted[0].id\n    }\n    converted[values.length + 1] = {\n      x: converted[values.length].x + 1,\n      value: converted[values.length].value,\n      id: converted[values.length].id\n    }\n    return converted\n  }\n\n  ChartInternal.prototype.updateDataAttributes = function (name, attrs) {\n    var $$ = this,\n      config = $$.config,\n      current = config['data_' + name]\n\n    if (typeof attrs === 'undefined') {\n      return current\n    }\n\n    Object.keys(attrs).forEach(function (id) {\n      current[id] = attrs[id]\n    })\n    $$.redraw({\n      withLegend: true\n    })\n    return current\n  }\n\n  ChartInternal.prototype.load = function (targets, args) {\n    var $$ = this\n\n    if (targets) {\n      // filter loading targets if needed\n      if (args.filter) {\n        targets = targets.filter(args.filter)\n      } // set type if args.types || args.type specified\n\n      if (args.type || args.types) {\n        targets.forEach(function (t) {\n          var type = args.types && args.types[t.id] ? args.types[t.id] : args.type\n          $$.setTargetType(t.id, type)\n        })\n      } // Update/Add data\n\n      $$.data.targets.forEach(function (d) {\n        for (var i = 0; i < targets.length; i++) {\n          if (d.id === targets[i].id) {\n            d.values = targets[i].values\n            targets.splice(i, 1)\n            break\n          }\n        }\n      })\n      $$.data.targets = $$.data.targets.concat(targets) // add remained\n    } // Set targets\n\n    $$.updateTargets($$.data.targets) // Redraw with new targets\n\n    $$.redraw({\n      withUpdateOrgXDomain: true,\n      withUpdateXDomain: true,\n      withLegend: true\n    })\n\n    if (args.done) {\n      args.done()\n    }\n  }\n\n  ChartInternal.prototype.loadFromArgs = function (args) {\n    var $$ = this\n\n    if (args.data) {\n      $$.load($$.convertDataToTargets(args.data), args)\n    } else if (args.url) {\n      $$.convertUrlToData(args.url, args.mimeType, args.headers, args.keys, function (data) {\n        $$.load($$.convertDataToTargets(data), args)\n      })\n    } else if (args.json) {\n      $$.load($$.convertDataToTargets($$.convertJsonToData(args.json, args.keys)), args)\n    } else if (args.rows) {\n      $$.load($$.convertDataToTargets($$.convertRowsToData(args.rows)), args)\n    } else if (args.columns) {\n      $$.load($$.convertDataToTargets($$.convertColumnsToData(args.columns)), args)\n    } else {\n      $$.load(null, args)\n    }\n  }\n\n  ChartInternal.prototype.unload = function (targetIds, done) {\n    var $$ = this\n\n    if (!done) {\n      done = function done () {}\n    } // filter existing target\n\n    targetIds = targetIds.filter(function (id) {\n      return $$.hasTarget($$.data.targets, id)\n    }) // If no target, call done and return\n\n    if (!targetIds || targetIds.length === 0) {\n      done()\n      return\n    }\n\n    $$.svg\n      .selectAll(\n        targetIds.map(function (id) {\n          return $$.selectorTarget(id)\n        })\n      )\n      .transition()\n      .style('opacity', 0)\n      .remove()\n      .call($$.endall, done)\n    targetIds.forEach(function (id) {\n      // Reset fadein for future load\n      $$.withoutFadeIn[id] = false // Remove target's elements\n\n      if ($$.legend) {\n        $$.legend.selectAll('.' + CLASS.legendItem + $$.getTargetSelectorSuffix(id)).remove()\n      } // Remove target\n\n      $$.data.targets = $$.data.targets.filter(function (t) {\n        return t.id !== id\n      })\n    })\n  }\n\n  ChartInternal.prototype.getYDomainMin = function (targets) {\n    var $$ = this,\n      config = $$.config,\n      ids = $$.mapToIds(targets),\n      ys = $$.getValuesAsIdKeyed(targets),\n      j,\n      k,\n      baseId,\n      idsInGroup,\n      id,\n      hasNegativeValue\n\n    if (config.data_groups.length > 0) {\n      hasNegativeValue = $$.hasNegativeValueInTargets(targets)\n\n      for (j = 0; j < config.data_groups.length; j++) {\n        // Determine baseId\n        idsInGroup = config.data_groups[j].filter(function (id) {\n          return ids.indexOf(id) >= 0\n        })\n\n        if (idsInGroup.length === 0) {\n          continue\n        }\n\n        baseId = idsInGroup[0] // Consider negative values\n\n        if (hasNegativeValue && ys[baseId]) {\n          ys[baseId].forEach(function (v, i) {\n            ys[baseId][i] = v < 0 ? v : 0\n          })\n        } // Compute min\n\n        for (k = 1; k < idsInGroup.length; k++) {\n          id = idsInGroup[k]\n\n          if (!ys[id]) {\n            continue\n          }\n\n          ys[id].forEach(function (v, i) {\n            if ($$.axis.getId(id) === $$.axis.getId(baseId) && ys[baseId] && !(hasNegativeValue && +v > 0)) {\n              ys[baseId][i] += +v\n            }\n          })\n        }\n      }\n    }\n\n    return $$.d3.min(\n      Object.keys(ys).map(function (key) {\n        return $$.d3.min(ys[key])\n      })\n    )\n  }\n\n  ChartInternal.prototype.getYDomainMax = function (targets) {\n    var $$ = this,\n      config = $$.config,\n      ids = $$.mapToIds(targets),\n      ys = $$.getValuesAsIdKeyed(targets),\n      j,\n      k,\n      baseId,\n      idsInGroup,\n      id,\n      hasPositiveValue\n\n    if (config.data_groups.length > 0) {\n      hasPositiveValue = $$.hasPositiveValueInTargets(targets)\n\n      for (j = 0; j < config.data_groups.length; j++) {\n        // Determine baseId\n        idsInGroup = config.data_groups[j].filter(function (id) {\n          return ids.indexOf(id) >= 0\n        })\n\n        if (idsInGroup.length === 0) {\n          continue\n        }\n\n        baseId = idsInGroup[0] // Consider positive values\n\n        if (hasPositiveValue && ys[baseId]) {\n          ys[baseId].forEach(function (v, i) {\n            ys[baseId][i] = v > 0 ? v : 0\n          })\n        } // Compute max\n\n        for (k = 1; k < idsInGroup.length; k++) {\n          id = idsInGroup[k]\n\n          if (!ys[id]) {\n            continue\n          }\n\n          ys[id].forEach(function (v, i) {\n            if ($$.axis.getId(id) === $$.axis.getId(baseId) && ys[baseId] && !(hasPositiveValue && +v < 0)) {\n              ys[baseId][i] += +v\n            }\n          })\n        }\n      }\n    }\n\n    return $$.d3.max(\n      Object.keys(ys).map(function (key) {\n        return $$.d3.max(ys[key])\n      })\n    )\n  }\n\n  ChartInternal.prototype.getYDomain = function (targets, axisId, xDomain) {\n    var $$ = this,\n      config = $$.config,\n      targetsByAxisId = targets.filter(function (t) {\n        return $$.axis.getId(t.id) === axisId\n      }),\n      yTargets = xDomain ? $$.filterByXDomain(targetsByAxisId, xDomain) : targetsByAxisId,\n      yMin = axisId === 'y2' ? config.axis_y2_min : config.axis_y_min,\n      yMax = axisId === 'y2' ? config.axis_y2_max : config.axis_y_max,\n      yDomainMin = $$.getYDomainMin(yTargets),\n      yDomainMax = $$.getYDomainMax(yTargets),\n      domain,\n      domainLength,\n      padding,\n      padding_top,\n      padding_bottom,\n      center = axisId === 'y2' ? config.axis_y2_center : config.axis_y_center,\n      yDomainAbs,\n      lengths,\n      diff,\n      ratio,\n      isAllPositive,\n      isAllNegative,\n      isZeroBased =\n        ($$.hasType('bar', yTargets) && config.bar_zerobased) ||\n        ($$.hasType('area', yTargets) && config.area_zerobased),\n      isInverted = axisId === 'y2' ? config.axis_y2_inverted : config.axis_y_inverted,\n      showHorizontalDataLabel = $$.hasDataLabel() && config.axis_rotated,\n      showVerticalDataLabel = $$.hasDataLabel() && !config.axis_rotated // MEMO: avoid inverting domain unexpectedly\n\n    yDomainMin = isValue(yMin) ? yMin : isValue(yMax) ? (yDomainMin < yMax ? yDomainMin : yMax - 10) : yDomainMin\n    yDomainMax = isValue(yMax) ? yMax : isValue(yMin) ? (yMin < yDomainMax ? yDomainMax : yMin + 10) : yDomainMax\n\n    if (yTargets.length === 0) {\n      // use current domain if target of axisId is none\n      return axisId === 'y2' ? $$.y2.domain() : $$.y.domain()\n    }\n\n    if (isNaN(yDomainMin)) {\n      // set minimum to zero when not number\n      yDomainMin = 0\n    }\n\n    if (isNaN(yDomainMax)) {\n      // set maximum to have same value as yDomainMin\n      yDomainMax = yDomainMin\n    }\n\n    if (yDomainMin === yDomainMax) {\n      yDomainMin < 0 ? (yDomainMax = 0) : (yDomainMin = 0)\n    }\n\n    isAllPositive = yDomainMin >= 0 && yDomainMax >= 0\n    isAllNegative = yDomainMin <= 0 && yDomainMax <= 0 // Cancel zerobased if axis_*_min / axis_*_max specified\n\n    if ((isValue(yMin) && isAllPositive) || (isValue(yMax) && isAllNegative)) {\n      isZeroBased = false\n    } // Bar/Area chart should be 0-based if all positive|negative\n\n    if (isZeroBased) {\n      if (isAllPositive) {\n        yDomainMin = 0\n      }\n\n      if (isAllNegative) {\n        yDomainMax = 0\n      }\n    }\n\n    domainLength = Math.abs(yDomainMax - yDomainMin)\n    padding = padding_top = padding_bottom = domainLength * 0.1\n\n    if (typeof center !== 'undefined') {\n      yDomainAbs = Math.max(Math.abs(yDomainMin), Math.abs(yDomainMax))\n      yDomainMax = center + yDomainAbs\n      yDomainMin = center - yDomainAbs\n    } // add padding for data label\n\n    if (showHorizontalDataLabel) {\n      lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, 'width')\n      diff = diffDomain($$.y.range())\n      ratio = [lengths[0] / diff, lengths[1] / diff]\n      padding_top += domainLength * (ratio[1] / (1 - ratio[0] - ratio[1]))\n      padding_bottom += domainLength * (ratio[0] / (1 - ratio[0] - ratio[1]))\n    } else if (showVerticalDataLabel) {\n      lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, 'height')\n      padding_top += $$.axis.convertPixelsToAxisPadding(lengths[1], domainLength)\n      padding_bottom += $$.axis.convertPixelsToAxisPadding(lengths[0], domainLength)\n    }\n\n    if (axisId === 'y' && notEmpty(config.axis_y_padding)) {\n      padding_top = $$.axis.getPadding(config.axis_y_padding, 'top', padding_top, domainLength)\n      padding_bottom = $$.axis.getPadding(config.axis_y_padding, 'bottom', padding_bottom, domainLength)\n    }\n\n    if (axisId === 'y2' && notEmpty(config.axis_y2_padding)) {\n      padding_top = $$.axis.getPadding(config.axis_y2_padding, 'top', padding_top, domainLength)\n      padding_bottom = $$.axis.getPadding(config.axis_y2_padding, 'bottom', padding_bottom, domainLength)\n    } // Bar/Area chart should be 0-based if all positive|negative\n\n    if (isZeroBased) {\n      if (isAllPositive) {\n        padding_bottom = yDomainMin\n      }\n\n      if (isAllNegative) {\n        padding_top = -yDomainMax\n      }\n    }\n\n    domain = [yDomainMin - padding_bottom, yDomainMax + padding_top]\n    return isInverted ? domain.reverse() : domain\n  }\n\n  ChartInternal.prototype.getXDomainMin = function (targets) {\n    var $$ = this,\n      config = $$.config\n    return isDefined(config.axis_x_min)\n      ? $$.isTimeSeries()\n        ? this.parseDate(config.axis_x_min)\n        : config.axis_x_min\n      : $$.d3.min(targets, function (t) {\n          return $$.d3.min(t.values, function (v) {\n            return v.x\n          })\n        })\n  }\n\n  ChartInternal.prototype.getXDomainMax = function (targets) {\n    var $$ = this,\n      config = $$.config\n    return isDefined(config.axis_x_max)\n      ? $$.isTimeSeries()\n        ? this.parseDate(config.axis_x_max)\n        : config.axis_x_max\n      : $$.d3.max(targets, function (t) {\n          return $$.d3.max(t.values, function (v) {\n            return v.x\n          })\n        })\n  }\n\n  ChartInternal.prototype.getXDomainPadding = function (domain) {\n    var $$ = this,\n      config = $$.config,\n      diff = domain[1] - domain[0],\n      maxDataCount,\n      padding,\n      paddingLeft,\n      paddingRight\n\n    if ($$.isCategorized()) {\n      padding = 0\n    } else if ($$.hasType('bar')) {\n      maxDataCount = $$.getMaxDataCount()\n      padding = maxDataCount > 1 ? diff / (maxDataCount - 1) / 2 : 0.5\n    } else {\n      padding = diff * 0.01\n    }\n\n    if (_typeof(config.axis_x_padding) === 'object' && notEmpty(config.axis_x_padding)) {\n      paddingLeft = isValue(config.axis_x_padding.left) ? config.axis_x_padding.left : padding\n      paddingRight = isValue(config.axis_x_padding.right) ? config.axis_x_padding.right : padding\n    } else if (typeof config.axis_x_padding === 'number') {\n      paddingLeft = paddingRight = config.axis_x_padding\n    } else {\n      paddingLeft = paddingRight = padding\n    }\n\n    return {\n      left: paddingLeft,\n      right: paddingRight\n    }\n  }\n\n  ChartInternal.prototype.getXDomain = function (targets) {\n    var $$ = this,\n      xDomain = [$$.getXDomainMin(targets), $$.getXDomainMax(targets)],\n      firstX = xDomain[0],\n      lastX = xDomain[1],\n      padding = $$.getXDomainPadding(xDomain),\n      min = 0,\n      max = 0 // show center of x domain if min and max are the same\n\n    if (firstX - lastX === 0 && !$$.isCategorized()) {\n      if ($$.isTimeSeries()) {\n        firstX = new Date(firstX.getTime() * 0.5)\n        lastX = new Date(lastX.getTime() * 1.5)\n      } else {\n        firstX = firstX === 0 ? 1 : firstX * 0.5\n        lastX = lastX === 0 ? -1 : lastX * 1.5\n      }\n    }\n\n    if (firstX || firstX === 0) {\n      min = $$.isTimeSeries() ? new Date(firstX.getTime() - padding.left) : firstX - padding.left\n    }\n\n    if (lastX || lastX === 0) {\n      max = $$.isTimeSeries() ? new Date(lastX.getTime() + padding.right) : lastX + padding.right\n    }\n\n    return [min, max]\n  }\n\n  ChartInternal.prototype.updateXDomain = function (\n    targets,\n    withUpdateXDomain,\n    withUpdateOrgXDomain,\n    withTrim,\n    domain\n  ) {\n    var $$ = this,\n      config = $$.config\n\n    if (withUpdateOrgXDomain) {\n      $$.x.domain(domain ? domain : $$.d3.extent($$.getXDomain(targets)))\n      $$.orgXDomain = $$.x.domain()\n\n      if (config.zoom_enabled) {\n        $$.zoom.update()\n      }\n\n      $$.subX.domain($$.x.domain())\n\n      if ($$.brush) {\n        $$.brush.updateScale($$.subX)\n      }\n    }\n\n    if (withUpdateXDomain) {\n      $$.x.domain(domain ? domain : !$$.brush || $$.brush.empty() ? $$.orgXDomain : $$.brush.selectionAsValue())\n    } // Trim domain when too big by zoom mousemove event\n\n    if (withTrim) {\n      $$.x.domain($$.trimXDomain($$.x.orgDomain()))\n    }\n\n    return $$.x.domain()\n  }\n\n  ChartInternal.prototype.trimXDomain = function (domain) {\n    var zoomDomain = this.getZoomDomain(),\n      min = zoomDomain[0],\n      max = zoomDomain[1]\n\n    if (domain[0] <= min) {\n      domain[1] = +domain[1] + (min - domain[0])\n      domain[0] = min\n    }\n\n    if (max <= domain[1]) {\n      domain[0] = +domain[0] - (domain[1] - max)\n      domain[1] = max\n    }\n\n    return domain\n  }\n\n  ChartInternal.prototype.drag = function (mouse) {\n    var $$ = this,\n      config = $$.config,\n      main = $$.main,\n      d3 = $$.d3\n    var sx, sy, mx, my, minX, maxX, minY, maxY\n\n    if ($$.hasArcType()) {\n      return\n    }\n\n    if (!config.data_selection_enabled) {\n      return\n    } // do nothing if not selectable\n\n    if (!config.data_selection_multiple) {\n      return\n    } // skip when single selection because drag is used for multiple selection\n\n    sx = $$.dragStart[0]\n    sy = $$.dragStart[1]\n    mx = mouse[0]\n    my = mouse[1]\n    minX = Math.min(sx, mx)\n    maxX = Math.max(sx, mx)\n    minY = config.data_selection_grouped ? $$.margin.top : Math.min(sy, my)\n    maxY = config.data_selection_grouped ? $$.height : Math.max(sy, my)\n    main\n      .select('.' + CLASS.dragarea)\n      .attr('x', minX)\n      .attr('y', minY)\n      .attr('width', maxX - minX)\n      .attr('height', maxY - minY) // TODO: binary search when multiple xs\n\n    main\n      .selectAll('.' + CLASS.shapes)\n      .selectAll('.' + CLASS.shape)\n      .filter(function (d) {\n        return config.data_selection_isselectable(d)\n      })\n      .each(function (d, i) {\n        var shape = d3.select(this),\n          isSelected = shape.classed(CLASS.SELECTED),\n          isIncluded = shape.classed(CLASS.INCLUDED),\n          _x,\n          _y,\n          _w,\n          _h,\n          toggle,\n          isWithin = false,\n          box\n\n        if (shape.classed(CLASS.circle)) {\n          _x = shape.attr('cx') * 1\n          _y = shape.attr('cy') * 1\n          toggle = $$.togglePoint\n          isWithin = minX < _x && _x < maxX && minY < _y && _y < maxY\n        } else if (shape.classed(CLASS.bar)) {\n          box = getPathBox(this)\n          _x = box.x\n          _y = box.y\n          _w = box.width\n          _h = box.height\n          toggle = $$.togglePath\n          isWithin = !(maxX < _x || _x + _w < minX) && !(maxY < _y || _y + _h < minY)\n        } else {\n          // line/area selection not supported yet\n          return\n        }\n\n        if (isWithin ^ isIncluded) {\n          shape.classed(CLASS.INCLUDED, !isIncluded) // TODO: included/unincluded callback here\n\n          shape.classed(CLASS.SELECTED, !isSelected)\n          toggle.call($$, !isSelected, shape, d, i)\n        }\n      })\n  }\n\n  ChartInternal.prototype.dragstart = function (mouse) {\n    var $$ = this,\n      config = $$.config\n\n    if ($$.hasArcType()) {\n      return\n    }\n\n    if (!config.data_selection_enabled) {\n      return\n    } // do nothing if not selectable\n\n    $$.dragStart = mouse\n    $$.main\n      .select('.' + CLASS.chart)\n      .append('rect')\n      .attr('class', CLASS.dragarea)\n      .style('opacity', 0.1)\n    $$.dragging = true\n  }\n\n  ChartInternal.prototype.dragend = function () {\n    var $$ = this,\n      config = $$.config\n\n    if ($$.hasArcType()) {\n      return\n    }\n\n    if (!config.data_selection_enabled) {\n      return\n    } // do nothing if not selectable\n\n    $$.main\n      .select('.' + CLASS.dragarea)\n      .transition()\n      .duration(100)\n      .style('opacity', 0)\n      .remove()\n    $$.main.selectAll('.' + CLASS.shape).classed(CLASS.INCLUDED, false)\n    $$.dragging = false\n  }\n\n  ChartInternal.prototype.getYFormat = function (forArc) {\n    var $$ = this,\n      formatForY = forArc && !$$.hasType('gauge') ? $$.defaultArcValueFormat : $$.yFormat,\n      formatForY2 = forArc && !$$.hasType('gauge') ? $$.defaultArcValueFormat : $$.y2Format\n    return function (v, ratio, id) {\n      var format = $$.axis.getId(id) === 'y2' ? formatForY2 : formatForY\n      return format.call($$, v, ratio)\n    }\n  }\n\n  ChartInternal.prototype.yFormat = function (v) {\n    var $$ = this,\n      config = $$.config,\n      format = config.axis_y_tick_format ? config.axis_y_tick_format : $$.defaultValueFormat\n    return format(v)\n  }\n\n  ChartInternal.prototype.y2Format = function (v) {\n    var $$ = this,\n      config = $$.config,\n      format = config.axis_y2_tick_format ? config.axis_y2_tick_format : $$.defaultValueFormat\n    return format(v)\n  }\n\n  ChartInternal.prototype.defaultValueFormat = function (v) {\n    return isValue(v) ? +v : ''\n  }\n\n  ChartInternal.prototype.defaultArcValueFormat = function (v, ratio) {\n    return (ratio * 100).toFixed(1) + '%'\n  }\n\n  ChartInternal.prototype.dataLabelFormat = function (targetId) {\n    var $$ = this,\n      data_labels = $$.config.data_labels,\n      format,\n      defaultFormat = function defaultFormat (v) {\n        return isValue(v) ? +v : ''\n      } // find format according to axis id\n\n    if (typeof data_labels.format === 'function') {\n      format = data_labels.format\n    } else if (_typeof(data_labels.format) === 'object') {\n      if (data_labels.format[targetId]) {\n        format = data_labels.format[targetId] === true ? defaultFormat : data_labels.format[targetId]\n      } else {\n        format = function format () {\n          return ''\n        }\n      }\n    } else {\n      format = defaultFormat\n    }\n\n    return format\n  }\n\n  ChartInternal.prototype.initGrid = function () {\n    var $$ = this,\n      config = $$.config,\n      d3 = $$.d3\n    $$.grid = $$.main\n      .append('g')\n      .attr('clip-path', $$.clipPathForGrid)\n      .attr('class', CLASS.grid)\n\n    if (config.grid_x_show) {\n      $$.grid.append('g').attr('class', CLASS.xgrids)\n    }\n\n    if (config.grid_y_show) {\n      $$.grid.append('g').attr('class', CLASS.ygrids)\n    }\n\n    if (config.grid_focus_show) {\n      $$.grid\n        .append('g')\n        .attr('class', CLASS.xgridFocus)\n        .append('line')\n        .attr('class', CLASS.xgridFocus)\n    }\n\n    $$.xgrid = d3.selectAll([])\n\n    if (!config.grid_lines_front) {\n      $$.initGridLines()\n    }\n  }\n\n  ChartInternal.prototype.initGridLines = function () {\n    var $$ = this,\n      d3 = $$.d3\n    $$.gridLines = $$.main\n      .append('g')\n      .attr('clip-path', $$.clipPathForGrid)\n      .attr('class', CLASS.grid + ' ' + CLASS.gridLines)\n    $$.gridLines.append('g').attr('class', CLASS.xgridLines)\n    $$.gridLines.append('g').attr('class', CLASS.ygridLines)\n    $$.xgridLines = d3.selectAll([])\n  }\n\n  ChartInternal.prototype.updateXGrid = function (withoutUpdate) {\n    var $$ = this,\n      config = $$.config,\n      d3 = $$.d3,\n      xgridData = $$.generateGridData(config.grid_x_type, $$.x),\n      tickOffset = $$.isCategorized() ? $$.xAxis.tickOffset() : 0\n    $$.xgridAttr = config.axis_rotated\n      ? {\n          x1: 0,\n          x2: $$.width,\n          y1: function y1 (d) {\n            return $$.x(d) - tickOffset\n          },\n          y2: function y2 (d) {\n            return $$.x(d) - tickOffset\n          }\n        }\n      : {\n          x1: function x1 (d) {\n            return $$.x(d) + tickOffset\n          },\n          x2: function x2 (d) {\n            return $$.x(d) + tickOffset\n          },\n          y1: 0,\n          y2: $$.height\n        }\n\n    $$.xgridAttr.opacity = function () {\n      var pos = +d3.select(this).attr(config.axis_rotated ? 'y1' : 'x1')\n      return pos === (config.axis_rotated ? $$.height : 0) ? 0 : 1\n    }\n\n    var xgrid = $$.main\n      .select('.' + CLASS.xgrids)\n      .selectAll('.' + CLASS.xgrid)\n      .data(xgridData)\n    var xgridEnter = xgrid\n      .enter()\n      .append('line')\n      .attr('class', CLASS.xgrid)\n      .attr('x1', $$.xgridAttr.x1)\n      .attr('x2', $$.xgridAttr.x2)\n      .attr('y1', $$.xgridAttr.y1)\n      .attr('y2', $$.xgridAttr.y2)\n      .style('opacity', 0)\n    $$.xgrid = xgridEnter.merge(xgrid)\n\n    if (!withoutUpdate) {\n      $$.xgrid\n        .attr('x1', $$.xgridAttr.x1)\n        .attr('x2', $$.xgridAttr.x2)\n        .attr('y1', $$.xgridAttr.y1)\n        .attr('y2', $$.xgridAttr.y2)\n        .style('opacity', $$.xgridAttr.opacity)\n    }\n\n    xgrid.exit().remove()\n  }\n\n  ChartInternal.prototype.updateYGrid = function () {\n    var $$ = this,\n      config = $$.config,\n      gridValues = $$.yAxis.tickValues() || $$.y.ticks(config.grid_y_ticks)\n    var ygrid = $$.main\n      .select('.' + CLASS.ygrids)\n      .selectAll('.' + CLASS.ygrid)\n      .data(gridValues)\n    var ygridEnter = ygrid\n      .enter()\n      .append('line') // TODO: x1, x2, y1, y2, opacity need to be set here maybe\n      .attr('class', CLASS.ygrid)\n    $$.ygrid = ygridEnter.merge(ygrid)\n    $$.ygrid\n      .attr('x1', config.axis_rotated ? $$.y : 0)\n      .attr('x2', config.axis_rotated ? $$.y : $$.width)\n      .attr('y1', config.axis_rotated ? 0 : $$.y)\n      .attr('y2', config.axis_rotated ? $$.height : $$.y)\n    ygrid.exit().remove()\n    $$.smoothLines($$.ygrid, 'grid')\n  }\n\n  ChartInternal.prototype.gridTextAnchor = function (d) {\n    return d.position ? d.position : 'end'\n  }\n\n  ChartInternal.prototype.gridTextDx = function (d) {\n    return d.position === 'start' ? 4 : d.position === 'middle' ? 0 : -4\n  }\n\n  ChartInternal.prototype.xGridTextX = function (d) {\n    return d.position === 'start' ? -this.height : d.position === 'middle' ? -this.height / 2 : 0\n  }\n\n  ChartInternal.prototype.yGridTextX = function (d) {\n    return d.position === 'start' ? 0 : d.position === 'middle' ? this.width / 2 : this.width\n  }\n\n  ChartInternal.prototype.updateGrid = function (duration) {\n    var $$ = this,\n      main = $$.main,\n      config = $$.config,\n      xgridLine,\n      xgridLineEnter,\n      ygridLine,\n      ygridLineEnter,\n      xv = $$.xv.bind($$),\n      yv = $$.yv.bind($$),\n      xGridTextX = $$.xGridTextX.bind($$),\n      yGridTextX = $$.yGridTextX.bind($$) // hide if arc type\n\n    $$.grid.style('visibility', $$.hasArcType() ? 'hidden' : 'visible')\n    main.select('line.' + CLASS.xgridFocus).style('visibility', 'hidden')\n\n    if (config.grid_x_show) {\n      $$.updateXGrid()\n    }\n\n    xgridLine = main\n      .select('.' + CLASS.xgridLines)\n      .selectAll('.' + CLASS.xgridLine)\n      .data(config.grid_x_lines) // enter\n\n    xgridLineEnter = xgridLine\n      .enter()\n      .append('g')\n      .attr('class', function (d) {\n        return CLASS.xgridLine + (d['class'] ? ' ' + d['class'] : '')\n      })\n    xgridLineEnter\n      .append('line')\n      .attr('x1', config.axis_rotated ? 0 : xv)\n      .attr('x2', config.axis_rotated ? $$.width : xv)\n      .attr('y1', config.axis_rotated ? xv : 0)\n      .attr('y2', config.axis_rotated ? xv : $$.height)\n      .style('opacity', 0)\n    xgridLineEnter\n      .append('text')\n      .attr('text-anchor', $$.gridTextAnchor)\n      .attr('transform', config.axis_rotated ? '' : 'rotate(-90)')\n      .attr('x', config.axis_rotated ? yGridTextX : xGridTextX)\n      .attr('y', xv)\n      .attr('dx', $$.gridTextDx)\n      .attr('dy', -5)\n      .style('opacity', 0) // udpate\n\n    $$.xgridLines = xgridLineEnter.merge(xgridLine) // done in d3.transition() of the end of this function\n    // exit\n\n    xgridLine\n      .exit()\n      .transition()\n      .duration(duration)\n      .style('opacity', 0)\n      .remove() // Y-Grid\n\n    if (config.grid_y_show) {\n      $$.updateYGrid()\n    }\n\n    ygridLine = main\n      .select('.' + CLASS.ygridLines)\n      .selectAll('.' + CLASS.ygridLine)\n      .data(config.grid_y_lines) // enter\n\n    ygridLineEnter = ygridLine\n      .enter()\n      .append('g')\n      .attr('class', function (d) {\n        return CLASS.ygridLine + (d['class'] ? ' ' + d['class'] : '')\n      })\n    ygridLineEnter\n      .append('line')\n      .attr('x1', config.axis_rotated ? yv : 0)\n      .attr('x2', config.axis_rotated ? yv : $$.width)\n      .attr('y1', config.axis_rotated ? 0 : yv)\n      .attr('y2', config.axis_rotated ? $$.height : yv)\n      .style('opacity', 0)\n    ygridLineEnter\n      .append('text')\n      .attr('text-anchor', $$.gridTextAnchor)\n      .attr('transform', config.axis_rotated ? 'rotate(-90)' : '')\n      .attr('x', config.axis_rotated ? xGridTextX : yGridTextX)\n      .attr('y', yv)\n      .attr('dx', $$.gridTextDx)\n      .attr('dy', -5)\n      .style('opacity', 0) // update\n\n    $$.ygridLines = ygridLineEnter.merge(ygridLine)\n    $$.ygridLines\n      .select('line')\n      .transition()\n      .duration(duration)\n      .attr('x1', config.axis_rotated ? yv : 0)\n      .attr('x2', config.axis_rotated ? yv : $$.width)\n      .attr('y1', config.axis_rotated ? 0 : yv)\n      .attr('y2', config.axis_rotated ? $$.height : yv)\n      .style('opacity', 1)\n    $$.ygridLines\n      .select('text')\n      .transition()\n      .duration(duration)\n      .attr('x', config.axis_rotated ? $$.xGridTextX.bind($$) : $$.yGridTextX.bind($$))\n      .attr('y', yv)\n      .text(function (d) {\n        return d.text\n      })\n      .style('opacity', 1) // exit\n\n    ygridLine\n      .exit()\n      .transition()\n      .duration(duration)\n      .style('opacity', 0)\n      .remove()\n  }\n\n  ChartInternal.prototype.redrawGrid = function (withTransition, transition) {\n    var $$ = this,\n      config = $$.config,\n      xv = $$.xv.bind($$),\n      lines = $$.xgridLines.select('line'),\n      texts = $$.xgridLines.select('text')\n    return [\n      (withTransition ? lines.transition(transition) : lines)\n        .attr('x1', config.axis_rotated ? 0 : xv)\n        .attr('x2', config.axis_rotated ? $$.width : xv)\n        .attr('y1', config.axis_rotated ? xv : 0)\n        .attr('y2', config.axis_rotated ? xv : $$.height)\n        .style('opacity', 1),\n      (withTransition ? texts.transition(transition) : texts)\n        .attr('x', config.axis_rotated ? $$.yGridTextX.bind($$) : $$.xGridTextX.bind($$))\n        .attr('y', xv)\n        .text(function (d) {\n          return d.text\n        })\n        .style('opacity', 1)\n    ]\n  }\n\n  ChartInternal.prototype.showXGridFocus = function (selectedData) {\n    var $$ = this,\n      config = $$.config,\n      dataToShow = selectedData.filter(function (d) {\n        return d && isValue(d.value)\n      }),\n      focusEl = $$.main.selectAll('line.' + CLASS.xgridFocus),\n      xx = $$.xx.bind($$)\n\n    if (!config.tooltip_show) {\n      return\n    } // Hide when scatter plot exists\n\n    if ($$.hasType('scatter') || $$.hasArcType()) {\n      return\n    }\n\n    focusEl\n      .style('visibility', 'visible')\n      .data([dataToShow[0]])\n      .attr(config.axis_rotated ? 'y1' : 'x1', xx)\n      .attr(config.axis_rotated ? 'y2' : 'x2', xx)\n    $$.smoothLines(focusEl, 'grid')\n  }\n\n  ChartInternal.prototype.hideXGridFocus = function () {\n    this.main.select('line.' + CLASS.xgridFocus).style('visibility', 'hidden')\n  }\n\n  ChartInternal.prototype.updateXgridFocus = function () {\n    var $$ = this,\n      config = $$.config\n    $$.main\n      .select('line.' + CLASS.xgridFocus)\n      .attr('x1', config.axis_rotated ? 0 : -10)\n      .attr('x2', config.axis_rotated ? $$.width : -10)\n      .attr('y1', config.axis_rotated ? -10 : 0)\n      .attr('y2', config.axis_rotated ? -10 : $$.height)\n  }\n\n  ChartInternal.prototype.generateGridData = function (type, scale) {\n    var $$ = this,\n      gridData = [],\n      xDomain,\n      firstYear,\n      lastYear,\n      i,\n      tickNum = $$.main\n        .select('.' + CLASS.axisX)\n        .selectAll('.tick')\n        .size()\n\n    if (type === 'year') {\n      xDomain = $$.getXDomain()\n      firstYear = xDomain[0].getFullYear()\n      lastYear = xDomain[1].getFullYear()\n\n      for (i = firstYear; i <= lastYear; i++) {\n        gridData.push(new Date(i + '-01-01 00:00:00'))\n      }\n    } else {\n      gridData = scale.ticks(10)\n\n      if (gridData.length > tickNum) {\n        // use only int\n        gridData = gridData.filter(function (d) {\n          return ('' + d).indexOf('.') < 0\n        })\n      }\n    }\n\n    return gridData\n  }\n\n  ChartInternal.prototype.getGridFilterToRemove = function (params) {\n    return params\n      ? function (line) {\n          var found = false\n          ;[].concat(params).forEach(function (param) {\n            if (\n              ('value' in param && line.value === param.value) ||\n              ('class' in param && line['class'] === param['class'])\n            ) {\n              found = true\n            }\n          })\n          return found\n        }\n      : function () {\n          return true\n        }\n  }\n\n  ChartInternal.prototype.removeGridLines = function (params, forX) {\n    var $$ = this,\n      config = $$.config,\n      toRemove = $$.getGridFilterToRemove(params),\n      toShow = function toShow (line) {\n        return !toRemove(line)\n      },\n      classLines = forX ? CLASS.xgridLines : CLASS.ygridLines,\n      classLine = forX ? CLASS.xgridLine : CLASS.ygridLine\n\n    $$.main\n      .select('.' + classLines)\n      .selectAll('.' + classLine)\n      .filter(toRemove)\n      .transition()\n      .duration(config.transition_duration)\n      .style('opacity', 0)\n      .remove()\n\n    if (forX) {\n      config.grid_x_lines = config.grid_x_lines.filter(toShow)\n    } else {\n      config.grid_y_lines = config.grid_y_lines.filter(toShow)\n    }\n  }\n\n  ChartInternal.prototype.initEventRect = function () {\n    var $$ = this,\n      config = $$.config\n    $$.main\n      .select('.' + CLASS.chart)\n      .append('g')\n      .attr('class', CLASS.eventRects)\n      .style('fill-opacity', 0)\n    $$.eventRect = $$.main\n      .select('.' + CLASS.eventRects)\n      .append('rect')\n      .attr('class', CLASS.eventRect) // event rect handle zoom event as well\n\n    if (config.zoom_enabled && $$.zoom) {\n      $$.eventRect.call($$.zoom).on('dblclick.zoom', null)\n\n      if (config.zoom_initialRange) {\n        // WORKAROUND: Add transition to apply transform immediately when no subchart\n        $$.eventRect\n          .transition()\n          .duration(0)\n          .call($$.zoom.transform, $$.zoomTransform(config.zoom_initialRange))\n      }\n    }\n  }\n\n  ChartInternal.prototype.redrawEventRect = function () {\n    var $$ = this,\n      d3 = $$.d3,\n      config = $$.config,\n      x,\n      y,\n      w,\n      h // TODO: rotated not supported yet\n\n    x = 0\n    y = 0\n    w = $$.width\n    h = $$.height\n\n    function mouseout () {\n      $$.svg.select('.' + CLASS.eventRect).style('cursor', null)\n      $$.hideXGridFocus()\n      $$.hideTooltip()\n      $$.unexpandCircles()\n      $$.unexpandBars()\n    } // rects for mouseover\n\n    $$.main\n      .select('.' + CLASS.eventRects)\n      .style('cursor', config.zoom_enabled ? (config.axis_rotated ? 'ns-resize' : 'ew-resize') : null)\n    $$.eventRect\n      .attr('x', x)\n      .attr('y', y)\n      .attr('width', w)\n      .attr('height', h)\n      .on(\n        'mouseout',\n        config.interaction_enabled\n          ? function () {\n              if (!config) {\n                return\n              } // chart is destroyed\n\n              if ($$.hasArcType()) {\n                return\n              }\n\n              mouseout()\n            }\n          : null\n      )\n      .on(\n        'mousemove',\n        config.interaction_enabled\n          ? function () {\n              var targetsToShow, mouse, closest, sameXData, selectedData\n\n              if ($$.dragging) {\n                return\n              } // do nothing when dragging\n\n              if ($$.hasArcType(targetsToShow)) {\n                return\n              }\n\n              targetsToShow = $$.filterTargetsToShow($$.data.targets)\n              mouse = d3.mouse(this)\n              closest = $$.findClosestFromTargets(targetsToShow, mouse)\n\n              if ($$.mouseover && (!closest || closest.id !== $$.mouseover.id)) {\n                config.data_onmouseout.call($$.api, $$.mouseover)\n                $$.mouseover = undefined\n              }\n\n              if (!closest) {\n                mouseout()\n                return\n              }\n\n              if ($$.isScatterType(closest) || !config.tooltip_grouped) {\n                sameXData = [closest]\n              } else {\n                sameXData = $$.filterByX(targetsToShow, closest.x)\n              } // show tooltip when cursor is close to some point\n\n              selectedData = sameXData.map(function (d) {\n                return $$.addName(d)\n              })\n              $$.showTooltip(selectedData, this) // expand points\n\n              if (config.point_focus_expand_enabled) {\n                $$.unexpandCircles()\n                selectedData.forEach(function (d) {\n                  $$.expandCircles(d.index, d.id, false)\n                })\n              }\n\n              $$.expandBars(closest.index, closest.id, true) // Show xgrid focus line\n\n              $$.showXGridFocus(selectedData) // Show cursor as pointer if point is close to mouse position\n\n              if ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) {\n                $$.svg.select('.' + CLASS.eventRect).style('cursor', 'pointer')\n\n                if (!$$.mouseover) {\n                  config.data_onmouseover.call($$.api, closest)\n                  $$.mouseover = closest\n                }\n              }\n            }\n          : null\n      )\n      .on(\n        'click',\n        config.interaction_enabled\n          ? function () {\n              var targetsToShow, mouse, closest, sameXData\n\n              if ($$.hasArcType(targetsToShow)) {\n                return\n              }\n\n              targetsToShow = $$.filterTargetsToShow($$.data.targets)\n              mouse = d3.mouse(this)\n              closest = $$.findClosestFromTargets(targetsToShow, mouse)\n\n              if (!closest) {\n                return\n              } // select if selection enabled\n\n              if ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) {\n                if ($$.isScatterType(closest) || !config.data_selection_grouped) {\n                  sameXData = [closest]\n                } else {\n                  sameXData = $$.filterByX(targetsToShow, closest.x)\n                }\n\n                sameXData.forEach(function (d) {\n                  $$.main\n                    .selectAll('.' + CLASS.shapes + $$.getTargetSelectorSuffix(d.id))\n                    .selectAll('.' + CLASS.shape + '-' + d.index)\n                    .each(function () {\n                      if (config.data_selection_grouped || $$.isWithinShape(this, d)) {\n                        $$.toggleShape(this, d, d.index)\n                        config.data_onclick.call($$.api, d, this)\n                      }\n                    })\n                })\n              }\n            }\n          : null\n      )\n      .call(\n        config.interaction_enabled && config.data_selection_draggable && $$.drag\n          ? d3\n              .drag()\n              .on('drag', function () {\n                $$.drag(d3.mouse(this))\n              })\n              .on('start', function () {\n                $$.dragstart(d3.mouse(this))\n              })\n              .on('end', function () {\n                $$.dragend()\n              })\n          : function () {}\n      )\n  }\n\n  ChartInternal.prototype.getMousePosition = function (data) {\n    var $$ = this\n    return [$$.x(data.x), $$.getYScale(data.id)(data.value)]\n  }\n\n  ChartInternal.prototype.dispatchEvent = function (type, mouse) {\n    var $$ = this,\n      selector = '.' + CLASS.eventRect,\n      eventRect = $$.main.select(selector).node(),\n      box = eventRect.getBoundingClientRect(),\n      x = box.left + (mouse ? mouse[0] : 0),\n      y = box.top + (mouse ? mouse[1] : 0),\n      event = document.createEvent('MouseEvents')\n    event.initMouseEvent(type, true, true, window, 0, x, y, x, y, false, false, false, false, 0, null)\n    eventRect.dispatchEvent(event)\n  }\n\n  ChartInternal.prototype.initLegend = function () {\n    var $$ = this\n    $$.legendItemTextBox = {}\n    $$.legendHasRendered = false\n    $$.legend = $$.svg.append('g').attr('transform', $$.getTranslate('legend'))\n\n    if (!$$.config.legend_show) {\n      $$.legend.style('visibility', 'hidden')\n      $$.hiddenLegendIds = $$.mapToIds($$.data.targets)\n      return\n    } // MEMO: call here to update legend box and tranlate for all\n    // MEMO: translate will be upated by this, so transform not needed in updateLegend()\n\n    $$.updateLegendWithDefaults()\n  }\n\n  ChartInternal.prototype.updateLegendWithDefaults = function () {\n    var $$ = this\n    $$.updateLegend($$.mapToIds($$.data.targets), {\n      withTransform: false,\n      withTransitionForTransform: false,\n      withTransition: false\n    })\n  }\n\n  ChartInternal.prototype.updateSizeForLegend = function (legendHeight, legendWidth) {\n    var $$ = this,\n      config = $$.config,\n      insetLegendPosition = {\n        top: $$.isLegendTop\n          ? $$.getCurrentPaddingTop() + config.legend_inset_y + 5.5\n          : $$.currentHeight - legendHeight - $$.getCurrentPaddingBottom() - config.legend_inset_y,\n        left: $$.isLegendLeft\n          ? $$.getCurrentPaddingLeft() + config.legend_inset_x + 0.5\n          : $$.currentWidth - legendWidth - $$.getCurrentPaddingRight() - config.legend_inset_x + 0.5\n      }\n    $$.margin3 = {\n      top: $$.isLegendRight ? 0 : $$.isLegendInset ? insetLegendPosition.top : $$.currentHeight - legendHeight,\n      right: NaN,\n      bottom: 0,\n      left: $$.isLegendRight ? $$.currentWidth - legendWidth : $$.isLegendInset ? insetLegendPosition.left : 0\n    }\n  }\n\n  ChartInternal.prototype.transformLegend = function (withTransition) {\n    var $$ = this\n    ;(withTransition ? $$.legend.transition() : $$.legend).attr('transform', $$.getTranslate('legend'))\n  }\n\n  ChartInternal.prototype.updateLegendStep = function (step) {\n    this.legendStep = step\n  }\n\n  ChartInternal.prototype.updateLegendItemWidth = function (w) {\n    this.legendItemWidth = w\n  }\n\n  ChartInternal.prototype.updateLegendItemHeight = function (h) {\n    this.legendItemHeight = h\n  }\n\n  ChartInternal.prototype.getLegendWidth = function () {\n    var $$ = this\n    return $$.config.legend_show\n      ? $$.isLegendRight || $$.isLegendInset\n        ? $$.legendItemWidth * ($$.legendStep + 1)\n        : $$.currentWidth\n      : 0\n  }\n\n  ChartInternal.prototype.getLegendHeight = function () {\n    var $$ = this,\n      h = 0\n\n    if ($$.config.legend_show) {\n      if ($$.isLegendRight) {\n        h = $$.currentHeight\n      } else {\n        h = Math.max(20, $$.legendItemHeight) * ($$.legendStep + 1)\n      }\n    }\n\n    return h\n  }\n\n  ChartInternal.prototype.opacityForLegend = function (legendItem) {\n    return legendItem.classed(CLASS.legendItemHidden) ? null : 1\n  }\n\n  ChartInternal.prototype.opacityForUnfocusedLegend = function (legendItem) {\n    return legendItem.classed(CLASS.legendItemHidden) ? null : 0.3\n  }\n\n  ChartInternal.prototype.toggleFocusLegend = function (targetIds, focus) {\n    var $$ = this\n    targetIds = $$.mapToTargetIds(targetIds)\n    $$.legend\n      .selectAll('.' + CLASS.legendItem)\n      .filter(function (id) {\n        return targetIds.indexOf(id) >= 0\n      })\n      .classed(CLASS.legendItemFocused, focus)\n      .transition()\n      .duration(100)\n      .style('opacity', function () {\n        var opacity = focus ? $$.opacityForLegend : $$.opacityForUnfocusedLegend\n        return opacity.call($$, $$.d3.select(this))\n      })\n  }\n\n  ChartInternal.prototype.revertLegend = function () {\n    var $$ = this,\n      d3 = $$.d3\n    $$.legend\n      .selectAll('.' + CLASS.legendItem)\n      .classed(CLASS.legendItemFocused, false)\n      .transition()\n      .duration(100)\n      .style('opacity', function () {\n        return $$.opacityForLegend(d3.select(this))\n      })\n  }\n\n  ChartInternal.prototype.showLegend = function (targetIds) {\n    var $$ = this,\n      config = $$.config\n\n    if (!config.legend_show) {\n      config.legend_show = true\n      $$.legend.style('visibility', 'visible')\n\n      if (!$$.legendHasRendered) {\n        $$.updateLegendWithDefaults()\n      }\n    }\n\n    $$.removeHiddenLegendIds(targetIds)\n    $$.legend\n      .selectAll($$.selectorLegends(targetIds))\n      .style('visibility', 'visible')\n      .transition()\n      .style('opacity', function () {\n        return $$.opacityForLegend($$.d3.select(this))\n      })\n  }\n\n  ChartInternal.prototype.hideLegend = function (targetIds) {\n    var $$ = this,\n      config = $$.config\n\n    if (config.legend_show && isEmpty(targetIds)) {\n      config.legend_show = false\n      $$.legend.style('visibility', 'hidden')\n    }\n\n    $$.addHiddenLegendIds(targetIds)\n    $$.legend\n      .selectAll($$.selectorLegends(targetIds))\n      .style('opacity', 0)\n      .style('visibility', 'hidden')\n  }\n\n  ChartInternal.prototype.clearLegendItemTextBoxCache = function () {\n    this.legendItemTextBox = {}\n  }\n\n  ChartInternal.prototype.updateLegend = function (targetIds, options, transitions) {\n    var $$ = this,\n      config = $$.config\n    var xForLegend,\n      xForLegendText,\n      xForLegendRect,\n      yForLegend,\n      yForLegendText,\n      yForLegendRect,\n      x1ForLegendTile,\n      x2ForLegendTile,\n      yForLegendTile\n    var paddingTop = 4,\n      paddingRight = 10,\n      maxWidth = 0,\n      maxHeight = 0,\n      posMin = 10,\n      tileWidth = config.legend_item_tile_width + 5\n    var l,\n      totalLength = 0,\n      offsets = {},\n      widths = {},\n      heights = {},\n      margins = [0],\n      steps = {},\n      step = 0\n    var withTransition, withTransitionForTransform\n    var texts, rects, tiles, background // Skip elements when their name is set to null\n\n    targetIds = targetIds.filter(function (id) {\n      return !isDefined(config.data_names[id]) || config.data_names[id] !== null\n    })\n    options = options || {}\n    withTransition = getOption(options, 'withTransition', true)\n    withTransitionForTransform = getOption(options, 'withTransitionForTransform', true)\n\n    function getTextBox (textElement, id) {\n      if (!$$.legendItemTextBox[id]) {\n        $$.legendItemTextBox[id] = $$.getTextRect(textElement.textContent, CLASS.legendItem, textElement)\n      }\n\n      return $$.legendItemTextBox[id]\n    }\n\n    function updatePositions (textElement, id, index) {\n      var reset = index === 0,\n        isLast = index === targetIds.length - 1,\n        box = getTextBox(textElement, id),\n        itemWidth =\n          box.width +\n          tileWidth +\n          (isLast && !($$.isLegendRight || $$.isLegendInset) ? 0 : paddingRight) +\n          config.legend_padding,\n        itemHeight = box.height + paddingTop,\n        itemLength = $$.isLegendRight || $$.isLegendInset ? itemHeight : itemWidth,\n        areaLength = $$.isLegendRight || $$.isLegendInset ? $$.getLegendHeight() : $$.getLegendWidth(),\n        margin,\n        maxLength // MEMO: care about condifion of step, totalLength\n\n      function updateValues (id, withoutStep) {\n        if (!withoutStep) {\n          margin = (areaLength - totalLength - itemLength) / 2\n\n          if (margin < posMin) {\n            margin = (areaLength - itemLength) / 2\n            totalLength = 0\n            step++\n          }\n        }\n\n        steps[id] = step\n        margins[step] = $$.isLegendInset ? 10 : margin\n        offsets[id] = totalLength\n        totalLength += itemLength\n      }\n\n      if (reset) {\n        totalLength = 0\n        step = 0\n        maxWidth = 0\n        maxHeight = 0\n      }\n\n      if (config.legend_show && !$$.isLegendToShow(id)) {\n        widths[id] = heights[id] = steps[id] = offsets[id] = 0\n        return\n      }\n\n      widths[id] = itemWidth\n      heights[id] = itemHeight\n\n      if (!maxWidth || itemWidth >= maxWidth) {\n        maxWidth = itemWidth\n      }\n\n      if (!maxHeight || itemHeight >= maxHeight) {\n        maxHeight = itemHeight\n      }\n\n      maxLength = $$.isLegendRight || $$.isLegendInset ? maxHeight : maxWidth\n\n      if (config.legend_equally) {\n        Object.keys(widths).forEach(function (id) {\n          widths[id] = maxWidth\n        })\n        Object.keys(heights).forEach(function (id) {\n          heights[id] = maxHeight\n        })\n        margin = (areaLength - maxLength * targetIds.length) / 2\n\n        if (margin < posMin) {\n          totalLength = 0\n          step = 0\n          targetIds.forEach(function (id) {\n            updateValues(id)\n          })\n        } else {\n          updateValues(id, true)\n        }\n      } else {\n        updateValues(id)\n      }\n    }\n\n    if ($$.isLegendInset) {\n      step = config.legend_inset_step ? config.legend_inset_step : targetIds.length\n      $$.updateLegendStep(step)\n    }\n\n    if ($$.isLegendRight) {\n      xForLegend = function xForLegend (id) {\n        return maxWidth * steps[id]\n      }\n\n      yForLegend = function yForLegend (id) {\n        return margins[steps[id]] + offsets[id]\n      }\n    } else if ($$.isLegendInset) {\n      xForLegend = function xForLegend (id) {\n        return maxWidth * steps[id] + 10\n      }\n\n      yForLegend = function yForLegend (id) {\n        return margins[steps[id]] + offsets[id]\n      }\n    } else {\n      xForLegend = function xForLegend (id) {\n        return margins[steps[id]] + offsets[id]\n      }\n\n      yForLegend = function yForLegend (id) {\n        return maxHeight * steps[id]\n      }\n    }\n\n    xForLegendText = function xForLegendText (id, i) {\n      return xForLegend(id, i) + 4 + config.legend_item_tile_width\n    }\n\n    yForLegendText = function yForLegendText (id, i) {\n      return yForLegend(id, i) + 9\n    }\n\n    xForLegendRect = function xForLegendRect (id, i) {\n      return xForLegend(id, i)\n    }\n\n    yForLegendRect = function yForLegendRect (id, i) {\n      return yForLegend(id, i) - 5\n    }\n\n    x1ForLegendTile = function x1ForLegendTile (id, i) {\n      return xForLegend(id, i) - 2\n    }\n\n    x2ForLegendTile = function x2ForLegendTile (id, i) {\n      return xForLegend(id, i) - 2 + config.legend_item_tile_width\n    }\n\n    yForLegendTile = function yForLegendTile (id, i) {\n      return yForLegend(id, i) + 4\n    } // Define g for legend area\n\n    l = $$.legend\n      .selectAll('.' + CLASS.legendItem)\n      .data(targetIds)\n      .enter()\n      .append('g')\n      .attr('class', function (id) {\n        return $$.generateClass(CLASS.legendItem, id)\n      })\n      .style('visibility', function (id) {\n        return $$.isLegendToShow(id) ? 'visible' : 'hidden'\n      })\n      .style('cursor', 'pointer')\n      .on('click', function (id) {\n        if (config.legend_item_onclick) {\n          config.legend_item_onclick.call($$, id)\n        } else {\n          if ($$.d3.event.altKey) {\n            $$.api.hide()\n            $$.api.show(id)\n          } else {\n            $$.api.toggle(id)\n            $$.isTargetToShow(id) ? $$.api.focus(id) : $$.api.revert()\n          }\n        }\n      })\n      .on('mouseover', function (id) {\n        if (config.legend_item_onmouseover) {\n          config.legend_item_onmouseover.call($$, id)\n        } else {\n          $$.d3.select(this).classed(CLASS.legendItemFocused, true)\n\n          if (!$$.transiting && $$.isTargetToShow(id)) {\n            $$.api.focus(id)\n          }\n        }\n      })\n      .on('mouseout', function (id) {\n        if (config.legend_item_onmouseout) {\n          config.legend_item_onmouseout.call($$, id)\n        } else {\n          $$.d3.select(this).classed(CLASS.legendItemFocused, false)\n          $$.api.revert()\n        }\n      })\n    l.append('text')\n      .text(function (id) {\n        return isDefined(config.data_names[id]) ? config.data_names[id] : id\n      })\n      .each(function (id, i) {\n        updatePositions(this, id, i)\n      })\n      .style('pointer-events', 'none')\n      .attr('x', $$.isLegendRight || $$.isLegendInset ? xForLegendText : -200)\n      .attr('y', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendText)\n    l.append('rect')\n      .attr('class', CLASS.legendItemEvent)\n      .style('fill-opacity', 0)\n      .attr('x', $$.isLegendRight || $$.isLegendInset ? xForLegendRect : -200)\n      .attr('y', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendRect)\n    l.append('line')\n      .attr('class', CLASS.legendItemTile)\n      .style('stroke', $$.color)\n      .style('pointer-events', 'none')\n      .attr('x1', $$.isLegendRight || $$.isLegendInset ? x1ForLegendTile : -200)\n      .attr('y1', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendTile)\n      .attr('x2', $$.isLegendRight || $$.isLegendInset ? x2ForLegendTile : -200)\n      .attr('y2', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendTile)\n      .attr('stroke-width', config.legend_item_tile_height) // Set background for inset legend\n\n    background = $$.legend.select('.' + CLASS.legendBackground + ' rect')\n\n    if ($$.isLegendInset && maxWidth > 0 && background.size() === 0) {\n      background = $$.legend\n        .insert('g', '.' + CLASS.legendItem)\n        .attr('class', CLASS.legendBackground)\n        .append('rect')\n    }\n\n    texts = $$.legend\n      .selectAll('text')\n      .data(targetIds)\n      .text(function (id) {\n        return isDefined(config.data_names[id]) ? config.data_names[id] : id\n      }) // MEMO: needed for update\n      .each(function (id, i) {\n        updatePositions(this, id, i)\n      })\n    ;(withTransition ? texts.transition() : texts).attr('x', xForLegendText).attr('y', yForLegendText)\n    rects = $$.legend.selectAll('rect.' + CLASS.legendItemEvent).data(targetIds)\n    ;(withTransition ? rects.transition() : rects)\n      .attr('width', function (id) {\n        return widths[id]\n      })\n      .attr('height', function (id) {\n        return heights[id]\n      })\n      .attr('x', xForLegendRect)\n      .attr('y', yForLegendRect)\n    tiles = $$.legend.selectAll('line.' + CLASS.legendItemTile).data(targetIds)\n    ;(withTransition ? tiles.transition() : tiles)\n      .style(\n        'stroke',\n        $$.levelColor\n          ? function (id) {\n              return $$.levelColor($$.cache[id].values[0].value)\n            }\n          : $$.color\n      )\n      .attr('x1', x1ForLegendTile)\n      .attr('y1', yForLegendTile)\n      .attr('x2', x2ForLegendTile)\n      .attr('y2', yForLegendTile)\n\n    if (background) {\n      ;(withTransition ? background.transition() : background)\n        .attr('height', $$.getLegendHeight() - 12)\n        .attr('width', maxWidth * (step + 1) + 10)\n    } // toggle legend state\n\n    $$.legend.selectAll('.' + CLASS.legendItem).classed(CLASS.legendItemHidden, function (id) {\n      return !$$.isTargetToShow(id)\n    }) // Update all to reflect change of legend\n\n    $$.updateLegendItemWidth(maxWidth)\n    $$.updateLegendItemHeight(maxHeight)\n    $$.updateLegendStep(step) // Update size and scale\n\n    $$.updateSizes()\n    $$.updateScales()\n    $$.updateSvgSize() // Update g positions\n\n    $$.transformAll(withTransitionForTransform, transitions)\n    $$.legendHasRendered = true\n  }\n\n  ChartInternal.prototype.initRegion = function () {\n    var $$ = this\n    $$.region = $$.main\n      .append('g')\n      .attr('clip-path', $$.clipPath)\n      .attr('class', CLASS.regions)\n  }\n\n  ChartInternal.prototype.updateRegion = function (duration) {\n    var $$ = this,\n      config = $$.config // hide if arc type\n\n    $$.region.style('visibility', $$.hasArcType() ? 'hidden' : 'visible')\n    var mainRegion = $$.main\n      .select('.' + CLASS.regions)\n      .selectAll('.' + CLASS.region)\n      .data(config.regions)\n    var mainRegionEnter = mainRegion\n      .enter()\n      .append('rect')\n      .attr('x', $$.regionX.bind($$))\n      .attr('y', $$.regionY.bind($$))\n      .attr('width', $$.regionWidth.bind($$))\n      .attr('height', $$.regionHeight.bind($$))\n      .style('fill-opacity', 0)\n    $$.mainRegion = mainRegionEnter.merge(mainRegion).attr('class', $$.classRegion.bind($$))\n    mainRegion\n      .exit()\n      .transition()\n      .duration(duration)\n      .style('opacity', 0)\n      .remove()\n  }\n\n  ChartInternal.prototype.redrawRegion = function (withTransition, transition) {\n    var $$ = this,\n      regions = $$.mainRegion\n    return [\n      (withTransition ? regions.transition(transition) : regions)\n        .attr('x', $$.regionX.bind($$))\n        .attr('y', $$.regionY.bind($$))\n        .attr('width', $$.regionWidth.bind($$))\n        .attr('height', $$.regionHeight.bind($$))\n        .style('fill-opacity', function (d) {\n          return isValue(d.opacity) ? d.opacity : 0.1\n        })\n    ]\n  }\n\n  ChartInternal.prototype.regionX = function (d) {\n    var $$ = this,\n      config = $$.config,\n      xPos,\n      yScale = d.axis === 'y' ? $$.y : $$.y2\n\n    if (d.axis === 'y' || d.axis === 'y2') {\n      xPos = config.axis_rotated ? ('start' in d ? yScale(d.start) : 0) : 0\n    } else {\n      xPos = config.axis_rotated ? 0 : 'start' in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.start) : d.start) : 0\n    }\n\n    return xPos\n  }\n\n  ChartInternal.prototype.regionY = function (d) {\n    var $$ = this,\n      config = $$.config,\n      yPos,\n      yScale = d.axis === 'y' ? $$.y : $$.y2\n\n    if (d.axis === 'y' || d.axis === 'y2') {\n      yPos = config.axis_rotated ? 0 : 'end' in d ? yScale(d.end) : 0\n    } else {\n      yPos = config.axis_rotated ? ('start' in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.start) : d.start) : 0) : 0\n    }\n\n    return yPos\n  }\n\n  ChartInternal.prototype.regionWidth = function (d) {\n    var $$ = this,\n      config = $$.config,\n      start = $$.regionX(d),\n      end,\n      yScale = d.axis === 'y' ? $$.y : $$.y2\n\n    if (d.axis === 'y' || d.axis === 'y2') {\n      end = config.axis_rotated ? ('end' in d ? yScale(d.end) : $$.width) : $$.width\n    } else {\n      end = config.axis_rotated\n        ? $$.width\n        : 'end' in d\n        ? $$.x($$.isTimeSeries() ? $$.parseDate(d.end) : d.end)\n        : $$.width\n    }\n\n    return end < start ? 0 : end - start\n  }\n\n  ChartInternal.prototype.regionHeight = function (d) {\n    var $$ = this,\n      config = $$.config,\n      start = this.regionY(d),\n      end,\n      yScale = d.axis === 'y' ? $$.y : $$.y2\n\n    if (d.axis === 'y' || d.axis === 'y2') {\n      end = config.axis_rotated ? $$.height : 'start' in d ? yScale(d.start) : $$.height\n    } else {\n      end = config.axis_rotated\n        ? 'end' in d\n          ? $$.x($$.isTimeSeries() ? $$.parseDate(d.end) : d.end)\n          : $$.height\n        : $$.height\n    }\n\n    return end < start ? 0 : end - start\n  }\n\n  ChartInternal.prototype.isRegionOnX = function (d) {\n    return !d.axis || d.axis === 'x'\n  }\n\n  ChartInternal.prototype.getScale = function (min, max, forTimeseries) {\n    return (forTimeseries ? this.d3.scaleTime() : this.d3.scaleLinear()).range([min, max])\n  }\n\n  ChartInternal.prototype.getX = function (min, max, domain, offset) {\n    var $$ = this,\n      scale = $$.getScale(min, max, $$.isTimeSeries()),\n      _scale = domain ? scale.domain(domain) : scale,\n      key // Define customized scale if categorized axis\n\n    if ($$.isCategorized()) {\n      offset =\n        offset ||\n        function () {\n          return 0\n        }\n\n      scale = function scale (d, raw) {\n        var v = _scale(d) + offset(d)\n        return raw ? v : Math.ceil(v)\n      }\n    } else {\n      scale = function scale (d, raw) {\n        var v = _scale(d)\n\n        return raw ? v : Math.ceil(v)\n      }\n    } // define functions\n\n    for (key in _scale) {\n      scale[key] = _scale[key]\n    }\n\n    scale.orgDomain = function () {\n      return _scale.domain()\n    } // define custom domain() for categorized axis\n\n    if ($$.isCategorized()) {\n      scale.domain = function (domain) {\n        if (!arguments.length) {\n          domain = this.orgDomain()\n          return [domain[0], domain[1] + 1]\n        }\n\n        _scale.domain(domain)\n\n        return scale\n      }\n    }\n\n    return scale\n  }\n\n  ChartInternal.prototype.getY = function (min, max, domain) {\n    var scale = this.getScale(min, max, this.isTimeSeriesY())\n\n    if (domain) {\n      scale.domain(domain)\n    }\n\n    return scale\n  }\n\n  ChartInternal.prototype.getYScale = function (id) {\n    return this.axis.getId(id) === 'y2' ? this.y2 : this.y\n  }\n\n  ChartInternal.prototype.getSubYScale = function (id) {\n    return this.axis.getId(id) === 'y2' ? this.subY2 : this.subY\n  }\n\n  ChartInternal.prototype.updateScales = function () {\n    var $$ = this,\n      config = $$.config,\n      forInit = !$$.x // update edges\n\n    $$.xMin = config.axis_rotated ? 1 : 0\n    $$.xMax = config.axis_rotated ? $$.height : $$.width\n    $$.yMin = config.axis_rotated ? 0 : $$.height\n    $$.yMax = config.axis_rotated ? $$.width : 1\n    $$.subXMin = $$.xMin\n    $$.subXMax = $$.xMax\n    $$.subYMin = config.axis_rotated ? 0 : $$.height2\n    $$.subYMax = config.axis_rotated ? $$.width2 : 1 // update scales\n\n    $$.x = $$.getX($$.xMin, $$.xMax, forInit ? undefined : $$.x.orgDomain(), function () {\n      return $$.xAxis.tickOffset()\n    })\n    $$.y = $$.getY($$.yMin, $$.yMax, forInit ? config.axis_y_default : $$.y.domain())\n    $$.y2 = $$.getY($$.yMin, $$.yMax, forInit ? config.axis_y2_default : $$.y2.domain())\n    $$.subX = $$.getX($$.xMin, $$.xMax, $$.orgXDomain, function (d) {\n      return d % 1 ? 0 : $$.subXAxis.tickOffset()\n    })\n    $$.subY = $$.getY($$.subYMin, $$.subYMax, forInit ? config.axis_y_default : $$.subY.domain())\n    $$.subY2 = $$.getY($$.subYMin, $$.subYMax, forInit ? config.axis_y2_default : $$.subY2.domain()) // update axes\n\n    $$.xAxisTickFormat = $$.axis.getXAxisTickFormat()\n    $$.xAxisTickValues = $$.axis.getXAxisTickValues()\n    $$.yAxisTickValues = $$.axis.getYAxisTickValues()\n    $$.y2AxisTickValues = $$.axis.getY2AxisTickValues()\n    $$.xAxis = $$.axis.getXAxis($$.x, $$.xOrient, $$.xAxisTickFormat, $$.xAxisTickValues, config.axis_x_tick_outer)\n    $$.subXAxis = $$.axis.getXAxis(\n      $$.subX,\n      $$.subXOrient,\n      $$.xAxisTickFormat,\n      $$.xAxisTickValues,\n      config.axis_x_tick_outer\n    )\n    $$.yAxis = $$.axis.getYAxis(\n      $$.y,\n      $$.yOrient,\n      config.axis_y_tick_format,\n      $$.yAxisTickValues,\n      config.axis_y_tick_outer\n    )\n    $$.y2Axis = $$.axis.getYAxis(\n      $$.y2,\n      $$.y2Orient,\n      config.axis_y2_tick_format,\n      $$.y2AxisTickValues,\n      config.axis_y2_tick_outer\n    ) // Set initialized scales to brush and zoom\n\n    if (!forInit) {\n      if ($$.brush) {\n        $$.brush.updateScale($$.subX)\n      }\n    } // update for arc\n\n    if ($$.updateArc) {\n      $$.updateArc()\n    }\n  }\n\n  ChartInternal.prototype.selectPoint = function (target, d, i) {\n    var $$ = this,\n      config = $$.config,\n      cx = (config.axis_rotated ? $$.circleY : $$.circleX).bind($$),\n      cy = (config.axis_rotated ? $$.circleX : $$.circleY).bind($$),\n      r = $$.pointSelectR.bind($$)\n    config.data_onselected.call($$.api, d, target.node()) // add selected-circle on low layer g\n\n    $$.main\n      .select('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(d.id))\n      .selectAll('.' + CLASS.selectedCircle + '-' + i)\n      .data([d])\n      .enter()\n      .append('circle')\n      .attr('class', function () {\n        return $$.generateClass(CLASS.selectedCircle, i)\n      })\n      .attr('cx', cx)\n      .attr('cy', cy)\n      .attr('stroke', function () {\n        return $$.color(d)\n      })\n      .attr('r', function (d) {\n        return $$.pointSelectR(d) * 1.4\n      })\n      .transition()\n      .duration(100)\n      .attr('r', r)\n  }\n\n  ChartInternal.prototype.unselectPoint = function (target, d, i) {\n    var $$ = this\n    $$.config.data_onunselected.call($$.api, d, target.node()) // remove selected-circle from low layer g\n\n    $$.main\n      .select('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(d.id))\n      .selectAll('.' + CLASS.selectedCircle + '-' + i)\n      .transition()\n      .duration(100)\n      .attr('r', 0)\n      .remove()\n  }\n\n  ChartInternal.prototype.togglePoint = function (selected, target, d, i) {\n    selected ? this.selectPoint(target, d, i) : this.unselectPoint(target, d, i)\n  }\n\n  ChartInternal.prototype.selectPath = function (target, d) {\n    var $$ = this\n    $$.config.data_onselected.call($$, d, target.node())\n\n    if ($$.config.interaction_brighten) {\n      target\n        .transition()\n        .duration(100)\n        .style('fill', function () {\n          return $$.d3.rgb($$.color(d)).brighter(0.75)\n        })\n    }\n  }\n\n  ChartInternal.prototype.unselectPath = function (target, d) {\n    var $$ = this\n    $$.config.data_onunselected.call($$, d, target.node())\n\n    if ($$.config.interaction_brighten) {\n      target\n        .transition()\n        .duration(100)\n        .style('fill', function () {\n          return $$.color(d)\n        })\n    }\n  }\n\n  ChartInternal.prototype.togglePath = function (selected, target, d, i) {\n    selected ? this.selectPath(target, d, i) : this.unselectPath(target, d, i)\n  }\n\n  ChartInternal.prototype.getToggle = function (that, d) {\n    var $$ = this,\n      toggle\n\n    if (that.nodeName === 'circle') {\n      if ($$.isStepType(d)) {\n        // circle is hidden in step chart, so treat as within the click area\n        toggle = function toggle () {} // TODO: how to select step chart?\n      } else {\n        toggle = $$.togglePoint\n      }\n    } else if (that.nodeName === 'path') {\n      toggle = $$.togglePath\n    }\n\n    return toggle\n  }\n\n  ChartInternal.prototype.toggleShape = function (that, d, i) {\n    var $$ = this,\n      d3 = $$.d3,\n      config = $$.config,\n      shape = d3.select(that),\n      isSelected = shape.classed(CLASS.SELECTED),\n      toggle = $$.getToggle(that, d).bind($$)\n\n    if (config.data_selection_enabled && config.data_selection_isselectable(d)) {\n      if (!config.data_selection_multiple) {\n        $$.main\n          .selectAll('.' + CLASS.shapes + (config.data_selection_grouped ? $$.getTargetSelectorSuffix(d.id) : ''))\n          .selectAll('.' + CLASS.shape)\n          .each(function (d, i) {\n            var shape = d3.select(this)\n\n            if (shape.classed(CLASS.SELECTED)) {\n              toggle(false, shape.classed(CLASS.SELECTED, false), d, i)\n            }\n          })\n      }\n\n      shape.classed(CLASS.SELECTED, !isSelected)\n      toggle(!isSelected, shape, d, i)\n    }\n  }\n\n  ChartInternal.prototype.initBar = function () {\n    var $$ = this\n    $$.main\n      .select('.' + CLASS.chart)\n      .append('g')\n      .attr('class', CLASS.chartBars)\n  }\n\n  ChartInternal.prototype.updateTargetsForBar = function (targets) {\n    var $$ = this,\n      config = $$.config,\n      mainBars,\n      mainBarEnter,\n      classChartBar = $$.classChartBar.bind($$),\n      classBars = $$.classBars.bind($$),\n      classFocus = $$.classFocus.bind($$)\n    mainBars = $$.main\n      .select('.' + CLASS.chartBars)\n      .selectAll('.' + CLASS.chartBar)\n      .data(targets)\n      .attr('class', function (d) {\n        return classChartBar(d) + classFocus(d)\n      })\n    mainBarEnter = mainBars\n      .enter()\n      .append('g')\n      .attr('class', classChartBar)\n      .style('pointer-events', 'none') // Bars for each data\n\n    mainBarEnter\n      .append('g')\n      .attr('class', classBars)\n      .style('cursor', function (d) {\n        return config.data_selection_isselectable(d) ? 'pointer' : null\n      })\n  }\n\n  ChartInternal.prototype.updateBar = function (durationForExit) {\n    var $$ = this,\n      barData = $$.barData.bind($$),\n      classBar = $$.classBar.bind($$),\n      initialOpacity = $$.initialOpacity.bind($$),\n      color = function color (d) {\n        return $$.color(d.id)\n      }\n\n    var mainBar = $$.main\n      .selectAll('.' + CLASS.bars)\n      .selectAll('.' + CLASS.bar)\n      .data(barData)\n    var mainBarEnter = mainBar\n      .enter()\n      .append('path')\n      .attr('class', classBar)\n      .style('stroke', color)\n      .style('fill', color)\n    $$.mainBar = mainBarEnter.merge(mainBar).style('opacity', initialOpacity)\n    mainBar\n      .exit()\n      .transition()\n      .duration(durationForExit)\n      .style('opacity', 0)\n  }\n\n  ChartInternal.prototype.redrawBar = function (drawBar, withTransition, transition) {\n    return [\n      (withTransition ? this.mainBar.transition(transition) : this.mainBar)\n        .attr('d', drawBar)\n        .style('stroke', this.color)\n        .style('fill', this.color)\n        .style('opacity', 1)\n    ]\n  }\n\n  ChartInternal.prototype.getBarW = function (axis, barTargetsNum) {\n    var $$ = this,\n      config = $$.config,\n      w =\n        typeof config.bar_width === 'number'\n          ? config.bar_width\n          : barTargetsNum\n          ? (axis.tickInterval() * config.bar_width_ratio) / barTargetsNum\n          : 0\n    return config.bar_width_max && w > config.bar_width_max ? config.bar_width_max : w\n  }\n\n  ChartInternal.prototype.getBars = function (i, id) {\n    var $$ = this\n    return (id ? $$.main.selectAll('.' + CLASS.bars + $$.getTargetSelectorSuffix(id)) : $$.main).selectAll(\n      '.' + CLASS.bar + (isValue(i) ? '-' + i : '')\n    )\n  }\n\n  ChartInternal.prototype.expandBars = function (i, id, reset) {\n    var $$ = this\n\n    if (reset) {\n      $$.unexpandBars()\n    }\n\n    $$.getBars(i, id).classed(CLASS.EXPANDED, true)\n  }\n\n  ChartInternal.prototype.unexpandBars = function (i) {\n    var $$ = this\n    $$.getBars(i).classed(CLASS.EXPANDED, false)\n  }\n\n  ChartInternal.prototype.generateDrawBar = function (barIndices, isSub) {\n    var $$ = this,\n      config = $$.config,\n      getPoints = $$.generateGetBarPoints(barIndices, isSub)\n    return function (d, i) {\n      // 4 points that make a bar\n      var points = getPoints(d, i) // switch points if axis is rotated, not applicable for sub chart\n\n      var indexX = config.axis_rotated ? 1 : 0\n      var indexY = config.axis_rotated ? 0 : 1\n      var path =\n        'M ' +\n        points[0][indexX] +\n        ',' +\n        points[0][indexY] +\n        ' ' +\n        'L' +\n        points[1][indexX] +\n        ',' +\n        points[1][indexY] +\n        ' ' +\n        'L' +\n        points[2][indexX] +\n        ',' +\n        points[2][indexY] +\n        ' ' +\n        'L' +\n        points[3][indexX] +\n        ',' +\n        points[3][indexY] +\n        ' ' +\n        'z'\n      return path\n    }\n  }\n\n  ChartInternal.prototype.generateGetBarPoints = function (barIndices, isSub) {\n    var $$ = this,\n      axis = isSub ? $$.subXAxis : $$.xAxis,\n      barTargetsNum = barIndices.__max__ + 1,\n      barW = $$.getBarW(axis, barTargetsNum),\n      barX = $$.getShapeX(barW, barTargetsNum, barIndices, !!isSub),\n      barY = $$.getShapeY(!!isSub),\n      barOffset = $$.getShapeOffset($$.isBarType, barIndices, !!isSub),\n      barSpaceOffset = barW * ($$.config.bar_space / 2),\n      yScale = isSub ? $$.getSubYScale : $$.getYScale\n    return function (d, i) {\n      var y0 = yScale.call($$, d.id)(0),\n        offset = barOffset(d, i) || y0,\n        // offset is for stacked bar chart\n        posX = barX(d),\n        posY = barY(d) // fix posY not to overflow opposite quadrant\n\n      if ($$.config.axis_rotated) {\n        if ((0 < d.value && posY < y0) || (d.value < 0 && y0 < posY)) {\n          posY = y0\n        }\n      } // 4 points that make a bar\n\n      return [\n        [posX + barSpaceOffset, offset],\n        [posX + barSpaceOffset, posY - (y0 - offset)],\n        [posX + barW - barSpaceOffset, posY - (y0 - offset)],\n        [posX + barW - barSpaceOffset, offset]\n      ]\n    }\n  }\n\n  ChartInternal.prototype.isWithinBar = function (mouse, that) {\n    var box = that.getBoundingClientRect(),\n      seg0 = that.pathSegList.getItem(0),\n      seg1 = that.pathSegList.getItem(1),\n      x = Math.min(seg0.x, seg1.x),\n      y = Math.min(seg0.y, seg1.y),\n      w = box.width,\n      h = box.height,\n      offset = 2,\n      sx = x - offset,\n      ex = x + w + offset,\n      sy = y + h + offset,\n      ey = y - offset\n    return sx < mouse[0] && mouse[0] < ex && ey < mouse[1] && mouse[1] < sy\n  }\n\n  ChartInternal.prototype.getShapeIndices = function (typeFilter) {\n    var $$ = this,\n      config = $$.config,\n      indices = {},\n      i = 0,\n      j,\n      k\n    $$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$)).forEach(function (d) {\n      for (j = 0; j < config.data_groups.length; j++) {\n        if (config.data_groups[j].indexOf(d.id) < 0) {\n          continue\n        }\n\n        for (k = 0; k < config.data_groups[j].length; k++) {\n          if (config.data_groups[j][k] in indices) {\n            indices[d.id] = indices[config.data_groups[j][k]]\n            break\n          }\n        }\n      }\n\n      if (isUndefined(indices[d.id])) {\n        indices[d.id] = i++\n      }\n    })\n    indices.__max__ = i - 1\n    return indices\n  }\n\n  ChartInternal.prototype.getShapeX = function (offset, targetsNum, indices, isSub) {\n    var $$ = this,\n      scale = isSub ? $$.subX : $$.x\n    return function (d) {\n      var index = d.id in indices ? indices[d.id] : 0\n      return d.x || d.x === 0 ? scale(d.x) - offset * (targetsNum / 2 - index) : 0\n    }\n  }\n\n  ChartInternal.prototype.getShapeY = function (isSub) {\n    var $$ = this\n    return function (d) {\n      var scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id)\n      return scale(d.value)\n    }\n  }\n\n  ChartInternal.prototype.getShapeOffset = function (typeFilter, indices, isSub) {\n    var $$ = this,\n      targets = $$.orderTargets($$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$))),\n      targetIds = targets.map(function (t) {\n        return t.id\n      })\n    return function (d, i) {\n      var scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id),\n        y0 = scale(0),\n        offset = y0\n      targets.forEach(function (t) {\n        var values = $$.isStepType(d) ? $$.convertValuesToStep(t.values) : t.values\n\n        if (t.id === d.id || indices[t.id] !== indices[d.id]) {\n          return\n        }\n\n        if (targetIds.indexOf(t.id) < targetIds.indexOf(d.id)) {\n          // check if the x values line up\n          if (typeof values[i] === 'undefined' || +values[i].x !== +d.x) {\n            // \"+\" for timeseries\n            // if not, try to find the value that does line up\n            i = -1\n            values.forEach(function (v, j) {\n              if (v.x === d.x) {\n                i = j\n              }\n            })\n          }\n\n          if (i in values && values[i].value * d.value >= 0) {\n            offset += scale(values[i].value) - y0\n          }\n        }\n      })\n      return offset\n    }\n  }\n\n  ChartInternal.prototype.isWithinShape = function (that, d) {\n    var $$ = this,\n      shape = $$.d3.select(that),\n      isWithin\n\n    if (!$$.isTargetToShow(d.id)) {\n      isWithin = false\n    } else if (that.nodeName === 'circle') {\n      isWithin = $$.isStepType(d)\n        ? $$.isWithinStep(that, $$.getYScale(d.id)(d.value))\n        : $$.isWithinCircle(that, $$.pointSelectR(d) * 1.5)\n    } else if (that.nodeName === 'path') {\n      isWithin = shape.classed(CLASS.bar) ? $$.isWithinBar($$.d3.mouse(that), that) : true\n    }\n\n    return isWithin\n  }\n\n  ChartInternal.prototype.getInterpolate = function (d) {\n    var $$ = this,\n      d3 = $$.d3,\n      types = {\n        linear: d3.curveLinear,\n        'linear-closed': d3.curveLinearClosed,\n        basis: d3.curveBasis,\n        'basis-open': d3.curveBasisOpen,\n        'basis-closed': d3.curveBasisClosed,\n        bundle: d3.curveBundle,\n        cardinal: d3.curveCardinal,\n        'cardinal-open': d3.curveCardinalOpen,\n        'cardinal-closed': d3.curveCardinalClosed,\n        monotone: d3.curveMonotoneX,\n        step: d3.curveStep,\n        'step-before': d3.curveStepBefore,\n        'step-after': d3.curveStepAfter\n      },\n      type\n\n    if ($$.isSplineType(d)) {\n      type = types[$$.config.spline_interpolation_type] || types.cardinal\n    } else if ($$.isStepType(d)) {\n      type = types[$$.config.line_step_type]\n    } else {\n      type = types.linear\n    }\n\n    return type\n  }\n\n  ChartInternal.prototype.initLine = function () {\n    var $$ = this\n    $$.main\n      .select('.' + CLASS.chart)\n      .append('g')\n      .attr('class', CLASS.chartLines)\n  }\n\n  ChartInternal.prototype.updateTargetsForLine = function (targets) {\n    var $$ = this,\n      config = $$.config,\n      mainLines,\n      mainLineEnter,\n      classChartLine = $$.classChartLine.bind($$),\n      classLines = $$.classLines.bind($$),\n      classAreas = $$.classAreas.bind($$),\n      classCircles = $$.classCircles.bind($$),\n      classFocus = $$.classFocus.bind($$)\n    mainLines = $$.main\n      .select('.' + CLASS.chartLines)\n      .selectAll('.' + CLASS.chartLine)\n      .data(targets)\n      .attr('class', function (d) {\n        return classChartLine(d) + classFocus(d)\n      })\n    mainLineEnter = mainLines\n      .enter()\n      .append('g')\n      .attr('class', classChartLine)\n      .style('opacity', 0)\n      .style('pointer-events', 'none') // Lines for each data\n\n    mainLineEnter.append('g').attr('class', classLines) // Areas\n\n    mainLineEnter.append('g').attr('class', classAreas) // Circles for each data point on lines\n\n    mainLineEnter.append('g').attr('class', function (d) {\n      return $$.generateClass(CLASS.selectedCircles, d.id)\n    })\n    mainLineEnter\n      .append('g')\n      .attr('class', classCircles)\n      .style('cursor', function (d) {\n        return config.data_selection_isselectable(d) ? 'pointer' : null\n      }) // Update date for selected circles\n\n    targets.forEach(function (t) {\n      $$.main\n        .selectAll('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(t.id))\n        .selectAll('.' + CLASS.selectedCircle)\n        .each(function (d) {\n          d.value = t.values[d.index].value\n        })\n    }) // MEMO: can not keep same color...\n    //mainLineUpdate.exit().remove();\n  }\n\n  ChartInternal.prototype.updateLine = function (durationForExit) {\n    var $$ = this\n    var mainLine = $$.main\n      .selectAll('.' + CLASS.lines)\n      .selectAll('.' + CLASS.line)\n      .data($$.lineData.bind($$))\n    var mainLineEnter = mainLine\n      .enter()\n      .append('path')\n      .attr('class', $$.classLine.bind($$))\n      .style('stroke', $$.color)\n    $$.mainLine = mainLineEnter\n      .merge(mainLine)\n      .style('opacity', $$.initialOpacity.bind($$))\n      .style('shape-rendering', function (d) {\n        return $$.isStepType(d) ? 'crispEdges' : ''\n      })\n      .attr('transform', null)\n    mainLine\n      .exit()\n      .transition()\n      .duration(durationForExit)\n      .style('opacity', 0)\n  }\n\n  ChartInternal.prototype.redrawLine = function (drawLine, withTransition, transition) {\n    return [\n      (withTransition ? this.mainLine.transition(transition) : this.mainLine)\n        .attr('d', drawLine)\n        .style('stroke', this.color)\n        .style('opacity', 1)\n    ]\n  }\n\n  ChartInternal.prototype.generateDrawLine = function (lineIndices, isSub) {\n    var $$ = this,\n      config = $$.config,\n      line = $$.d3.line(),\n      getPoints = $$.generateGetLinePoints(lineIndices, isSub),\n      yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,\n      xValue = function xValue (d) {\n        return (isSub ? $$.subxx : $$.xx).call($$, d)\n      },\n      yValue = function yValue (d, i) {\n        return config.data_groups.length > 0 ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)(d.value)\n      }\n\n    line = config.axis_rotated ? line.x(yValue).y(xValue) : line.x(xValue).y(yValue)\n\n    if (!config.line_connectNull) {\n      line = line.defined(function (d) {\n        return d.value != null\n      })\n    }\n\n    return function (d) {\n      var values = config.line_connectNull ? $$.filterRemoveNull(d.values) : d.values,\n        x = isSub ? $$.subX : $$.x,\n        y = yScaleGetter.call($$, d.id),\n        x0 = 0,\n        y0 = 0,\n        path\n\n      if ($$.isLineType(d)) {\n        if (config.data_regions[d.id]) {\n          path = $$.lineWithRegions(values, x, y, config.data_regions[d.id])\n        } else {\n          if ($$.isStepType(d)) {\n            values = $$.convertValuesToStep(values)\n          }\n\n          path = line.curve($$.getInterpolate(d))(values)\n        }\n      } else {\n        if (values[0]) {\n          x0 = x(values[0].x)\n          y0 = y(values[0].value)\n        }\n\n        path = config.axis_rotated ? 'M ' + y0 + ' ' + x0 : 'M ' + x0 + ' ' + y0\n      }\n\n      return path ? path : 'M 0 0'\n    }\n  }\n\n  ChartInternal.prototype.generateGetLinePoints = function (lineIndices, isSub) {\n    // partial duplication of generateGetBarPoints\n    var $$ = this,\n      config = $$.config,\n      lineTargetsNum = lineIndices.__max__ + 1,\n      x = $$.getShapeX(0, lineTargetsNum, lineIndices, !!isSub),\n      y = $$.getShapeY(!!isSub),\n      lineOffset = $$.getShapeOffset($$.isLineType, lineIndices, !!isSub),\n      yScale = isSub ? $$.getSubYScale : $$.getYScale\n    return function (d, i) {\n      var y0 = yScale.call($$, d.id)(0),\n        offset = lineOffset(d, i) || y0,\n        // offset is for stacked area chart\n        posX = x(d),\n        posY = y(d) // fix posY not to overflow opposite quadrant\n\n      if (config.axis_rotated) {\n        if ((0 < d.value && posY < y0) || (d.value < 0 && y0 < posY)) {\n          posY = y0\n        }\n      } // 1 point that marks the line position\n\n      return [\n        [posX, posY - (y0 - offset)],\n        [posX, posY - (y0 - offset)], // needed for compatibility\n        [posX, posY - (y0 - offset)], // needed for compatibility\n        [posX, posY - (y0 - offset)] // needed for compatibility\n      ]\n    }\n  }\n\n  ChartInternal.prototype.lineWithRegions = function (d, x, y, _regions) {\n    var $$ = this,\n      config = $$.config,\n      prev = -1,\n      i,\n      j,\n      s = 'M',\n      sWithRegion,\n      xp,\n      yp,\n      dx,\n      dy,\n      dd,\n      diff,\n      diffx2,\n      xOffset = $$.isCategorized() ? 0.5 : 0,\n      xValue,\n      yValue,\n      regions = []\n\n    function isWithinRegions (x, regions) {\n      var i\n\n      for (i = 0; i < regions.length; i++) {\n        if (regions[i].start < x && x <= regions[i].end) {\n          return true\n        }\n      }\n\n      return false\n    } // Check start/end of regions\n\n    if (isDefined(_regions)) {\n      for (i = 0; i < _regions.length; i++) {\n        regions[i] = {}\n\n        if (isUndefined(_regions[i].start)) {\n          regions[i].start = d[0].x\n        } else {\n          regions[i].start = $$.isTimeSeries() ? $$.parseDate(_regions[i].start) : _regions[i].start\n        }\n\n        if (isUndefined(_regions[i].end)) {\n          regions[i].end = d[d.length - 1].x\n        } else {\n          regions[i].end = $$.isTimeSeries() ? $$.parseDate(_regions[i].end) : _regions[i].end\n        }\n      }\n    } // Set scales\n\n    xValue = config.axis_rotated\n      ? function (d) {\n          return y(d.value)\n        }\n      : function (d) {\n          return x(d.x)\n        }\n    yValue = config.axis_rotated\n      ? function (d) {\n          return x(d.x)\n        }\n      : function (d) {\n          return y(d.value)\n        } // Define svg generator function for region\n\n    function generateM (points) {\n      return 'M' + points[0][0] + ' ' + points[0][1] + ' ' + points[1][0] + ' ' + points[1][1]\n    }\n\n    if ($$.isTimeSeries()) {\n      sWithRegion = function sWithRegion (d0, d1, j, diff) {\n        var x0 = d0.x.getTime(),\n          x_diff = d1.x - d0.x,\n          xv0 = new Date(x0 + x_diff * j),\n          xv1 = new Date(x0 + x_diff * (j + diff)),\n          points\n\n        if (config.axis_rotated) {\n          points = [[y(yp(j)), x(xv0)], [y(yp(j + diff)), x(xv1)]]\n        } else {\n          points = [[x(xv0), y(yp(j))], [x(xv1), y(yp(j + diff))]]\n        }\n\n        return generateM(points)\n      }\n    } else {\n      sWithRegion = function sWithRegion (d0, d1, j, diff) {\n        var points\n\n        if (config.axis_rotated) {\n          points = [[y(yp(j), true), x(xp(j))], [y(yp(j + diff), true), x(xp(j + diff))]]\n        } else {\n          points = [[x(xp(j), true), y(yp(j))], [x(xp(j + diff), true), y(yp(j + diff))]]\n        }\n\n        return generateM(points)\n      }\n    } // Generate\n\n    for (i = 0; i < d.length; i++) {\n      // Draw as normal\n      if (isUndefined(regions) || !isWithinRegions(d[i].x, regions)) {\n        s += ' ' + xValue(d[i]) + ' ' + yValue(d[i])\n      } // Draw with region // TODO: Fix for horizotal charts\n      else {\n        xp = $$.getScale(d[i - 1].x + xOffset, d[i].x + xOffset, $$.isTimeSeries())\n        yp = $$.getScale(d[i - 1].value, d[i].value)\n        dx = x(d[i].x) - x(d[i - 1].x)\n        dy = y(d[i].value) - y(d[i - 1].value)\n        dd = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2))\n        diff = 2 / dd\n        diffx2 = diff * 2\n\n        for (j = diff; j <= 1; j += diffx2) {\n          s += sWithRegion(d[i - 1], d[i], j, diff)\n        }\n      }\n\n      prev = d[i].x\n    }\n\n    return s\n  }\n\n  ChartInternal.prototype.updateArea = function (durationForExit) {\n    var $$ = this,\n      d3 = $$.d3\n    var mainArea = $$.main\n      .selectAll('.' + CLASS.areas)\n      .selectAll('.' + CLASS.area)\n      .data($$.lineData.bind($$))\n    var mainAreaEnter = mainArea\n      .enter()\n      .append('path')\n      .attr('class', $$.classArea.bind($$))\n      .style('fill', $$.color)\n      .style('opacity', function () {\n        $$.orgAreaOpacity = +d3.select(this).style('opacity')\n        return 0\n      })\n    $$.mainArea = mainAreaEnter.merge(mainArea).style('opacity', $$.orgAreaOpacity)\n    mainArea\n      .exit()\n      .transition()\n      .duration(durationForExit)\n      .style('opacity', 0)\n  }\n\n  ChartInternal.prototype.redrawArea = function (drawArea, withTransition, transition) {\n    return [\n      (withTransition ? this.mainArea.transition(transition) : this.mainArea)\n        .attr('d', drawArea)\n        .style('fill', this.color)\n        .style('opacity', this.orgAreaOpacity)\n    ]\n  }\n\n  ChartInternal.prototype.generateDrawArea = function (areaIndices, isSub) {\n    var $$ = this,\n      config = $$.config,\n      area = $$.d3.area(),\n      getPoints = $$.generateGetAreaPoints(areaIndices, isSub),\n      yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,\n      xValue = function xValue (d) {\n        return (isSub ? $$.subxx : $$.xx).call($$, d)\n      },\n      value0 = function value0 (d, i) {\n        return config.data_groups.length > 0\n          ? getPoints(d, i)[0][1]\n          : yScaleGetter.call($$, d.id)($$.getAreaBaseValue(d.id))\n      },\n      value1 = function value1 (d, i) {\n        return config.data_groups.length > 0 ? getPoints(d, i)[1][1] : yScaleGetter.call($$, d.id)(d.value)\n      }\n\n    area = config.axis_rotated\n      ? area\n          .x0(value0)\n          .x1(value1)\n          .y(xValue)\n      : area\n          .x(xValue)\n          .y0(config.area_above ? 0 : value0)\n          .y1(value1)\n\n    if (!config.line_connectNull) {\n      area = area.defined(function (d) {\n        return d.value !== null\n      })\n    }\n\n    return function (d) {\n      var values = config.line_connectNull ? $$.filterRemoveNull(d.values) : d.values,\n        x0 = 0,\n        y0 = 0,\n        path\n\n      if ($$.isAreaType(d)) {\n        if ($$.isStepType(d)) {\n          values = $$.convertValuesToStep(values)\n        }\n\n        path = area.curve($$.getInterpolate(d))(values)\n      } else {\n        if (values[0]) {\n          x0 = $$.x(values[0].x)\n          y0 = $$.getYScale(d.id)(values[0].value)\n        }\n\n        path = config.axis_rotated ? 'M ' + y0 + ' ' + x0 : 'M ' + x0 + ' ' + y0\n      }\n\n      return path ? path : 'M 0 0'\n    }\n  }\n\n  ChartInternal.prototype.getAreaBaseValue = function () {\n    return 0\n  }\n\n  ChartInternal.prototype.generateGetAreaPoints = function (areaIndices, isSub) {\n    // partial duplication of generateGetBarPoints\n    var $$ = this,\n      config = $$.config,\n      areaTargetsNum = areaIndices.__max__ + 1,\n      x = $$.getShapeX(0, areaTargetsNum, areaIndices, !!isSub),\n      y = $$.getShapeY(!!isSub),\n      areaOffset = $$.getShapeOffset($$.isAreaType, areaIndices, !!isSub),\n      yScale = isSub ? $$.getSubYScale : $$.getYScale\n    return function (d, i) {\n      var y0 = yScale.call($$, d.id)(0),\n        offset = areaOffset(d, i) || y0,\n        // offset is for stacked area chart\n        posX = x(d),\n        posY = y(d) // fix posY not to overflow opposite quadrant\n\n      if (config.axis_rotated) {\n        if ((0 < d.value && posY < y0) || (d.value < 0 && y0 < posY)) {\n          posY = y0\n        }\n      } // 1 point that marks the area position\n\n      return [\n        [posX, offset],\n        [posX, posY - (y0 - offset)],\n        [posX, posY - (y0 - offset)], // needed for compatibility\n        [posX, offset] // needed for compatibility\n      ]\n    }\n  }\n\n  ChartInternal.prototype.updateCircle = function (cx, cy) {\n    var $$ = this\n    var mainCircle = $$.main\n      .selectAll('.' + CLASS.circles)\n      .selectAll('.' + CLASS.circle)\n      .data($$.lineOrScatterData.bind($$))\n    var mainCircleEnter = mainCircle\n      .enter()\n      .append('circle')\n      .attr('class', $$.classCircle.bind($$))\n      .attr('cx', cx)\n      .attr('cy', cy)\n      .attr('r', $$.pointR.bind($$))\n      .style('fill', $$.color)\n    $$.mainCircle = mainCircleEnter.merge(mainCircle).style('opacity', $$.initialOpacityForCircle.bind($$))\n    mainCircle.exit().style('opacity', 0)\n  }\n\n  ChartInternal.prototype.redrawCircle = function (cx, cy, withTransition, transition) {\n    var $$ = this,\n      selectedCircles = $$.main.selectAll('.' + CLASS.selectedCircle)\n    return [\n      (withTransition ? $$.mainCircle.transition(transition) : $$.mainCircle)\n        .style('opacity', this.opacityForCircle.bind($$))\n        .style('fill', $$.color)\n        .attr('cx', cx)\n        .attr('cy', cy),\n      (withTransition ? selectedCircles.transition(transition) : selectedCircles).attr('cx', cx).attr('cy', cy)\n    ]\n  }\n\n  ChartInternal.prototype.circleX = function (d) {\n    return d.x || d.x === 0 ? this.x(d.x) : null\n  }\n\n  ChartInternal.prototype.updateCircleY = function () {\n    var $$ = this,\n      lineIndices,\n      getPoints\n\n    if ($$.config.data_groups.length > 0) {\n      ;(lineIndices = $$.getShapeIndices($$.isLineType)), (getPoints = $$.generateGetLinePoints(lineIndices))\n\n      $$.circleY = function (d, i) {\n        return getPoints(d, i)[0][1]\n      }\n    } else {\n      $$.circleY = function (d) {\n        return $$.getYScale(d.id)(d.value)\n      }\n    }\n  }\n\n  ChartInternal.prototype.getCircles = function (i, id) {\n    var $$ = this\n    return (id ? $$.main.selectAll('.' + CLASS.circles + $$.getTargetSelectorSuffix(id)) : $$.main).selectAll(\n      '.' + CLASS.circle + (isValue(i) ? '-' + i : '')\n    )\n  }\n\n  ChartInternal.prototype.expandCircles = function (i, id, reset) {\n    var $$ = this,\n      r = $$.pointExpandedR.bind($$)\n\n    if (reset) {\n      $$.unexpandCircles()\n    }\n\n    $$.getCircles(i, id)\n      .classed(CLASS.EXPANDED, true)\n      .attr('r', r)\n  }\n\n  ChartInternal.prototype.unexpandCircles = function (i) {\n    var $$ = this,\n      r = $$.pointR.bind($$)\n    $$.getCircles(i)\n      .filter(function () {\n        return $$.d3.select(this).classed(CLASS.EXPANDED)\n      })\n      .classed(CLASS.EXPANDED, false)\n      .attr('r', r)\n  }\n\n  ChartInternal.prototype.pointR = function (d) {\n    var $$ = this,\n      config = $$.config\n    return $$.isStepType(d) ? 0 : isFunction(config.point_r) ? config.point_r(d) : config.point_r\n  }\n\n  ChartInternal.prototype.pointExpandedR = function (d) {\n    var $$ = this,\n      config = $$.config\n\n    if (config.point_focus_expand_enabled) {\n      return isFunction(config.point_focus_expand_r)\n        ? config.point_focus_expand_r(d)\n        : config.point_focus_expand_r\n        ? config.point_focus_expand_r\n        : $$.pointR(d) * 1.75\n    } else {\n      return $$.pointR(d)\n    }\n  }\n\n  ChartInternal.prototype.pointSelectR = function (d) {\n    var $$ = this,\n      config = $$.config\n    return isFunction(config.point_select_r)\n      ? config.point_select_r(d)\n      : config.point_select_r\n      ? config.point_select_r\n      : $$.pointR(d) * 4\n  }\n\n  ChartInternal.prototype.isWithinCircle = function (that, r) {\n    var d3 = this.d3,\n      mouse = d3.mouse(that),\n      d3_this = d3.select(that),\n      cx = +d3_this.attr('cx'),\n      cy = +d3_this.attr('cy')\n    return Math.sqrt(Math.pow(cx - mouse[0], 2) + Math.pow(cy - mouse[1], 2)) < r\n  }\n\n  ChartInternal.prototype.isWithinStep = function (that, y) {\n    return Math.abs(y - this.d3.mouse(that)[1]) < 30\n  }\n\n  ChartInternal.prototype.getCurrentWidth = function () {\n    var $$ = this,\n      config = $$.config\n    return config.size_width ? config.size_width : $$.getParentWidth()\n  }\n\n  ChartInternal.prototype.getCurrentHeight = function () {\n    var $$ = this,\n      config = $$.config,\n      h = config.size_height ? config.size_height : $$.getParentHeight()\n    return h > 0 ? h : 320 / ($$.hasType('gauge') && !config.gauge_fullCircle ? 2 : 1)\n  }\n\n  ChartInternal.prototype.getCurrentPaddingTop = function () {\n    var $$ = this,\n      config = $$.config,\n      padding = isValue(config.padding_top) ? config.padding_top : 0\n\n    if ($$.title && $$.title.node()) {\n      padding += $$.getTitlePadding()\n    }\n\n    return padding\n  }\n\n  ChartInternal.prototype.getCurrentPaddingBottom = function () {\n    var config = this.config\n    return isValue(config.padding_bottom) ? config.padding_bottom : 0\n  }\n\n  ChartInternal.prototype.getCurrentPaddingLeft = function (withoutRecompute) {\n    var $$ = this,\n      config = $$.config\n\n    if (isValue(config.padding_left)) {\n      return config.padding_left\n    } else if (config.axis_rotated) {\n      return !config.axis_x_show || config.axis_x_inner\n        ? 1\n        : Math.max(ceil10($$.getAxisWidthByAxisId('x', withoutRecompute)), 40)\n    } else if (!config.axis_y_show || config.axis_y_inner) {\n      // && !config.axis_rotated\n      return $$.axis.getYAxisLabelPosition().isOuter ? 30 : 1\n    } else {\n      return ceil10($$.getAxisWidthByAxisId('y', withoutRecompute))\n    }\n  }\n\n  ChartInternal.prototype.getCurrentPaddingRight = function () {\n    var $$ = this,\n      config = $$.config,\n      defaultPadding = 10,\n      legendWidthOnRight = $$.isLegendRight ? $$.getLegendWidth() + 20 : 0\n\n    if (isValue(config.padding_right)) {\n      return config.padding_right + 1 // 1 is needed not to hide tick line\n    } else if (config.axis_rotated) {\n      return defaultPadding + legendWidthOnRight\n    } else if (!config.axis_y2_show || config.axis_y2_inner) {\n      // && !config.axis_rotated\n      return 2 + legendWidthOnRight + ($$.axis.getY2AxisLabelPosition().isOuter ? 20 : 0)\n    } else {\n      return ceil10($$.getAxisWidthByAxisId('y2')) + legendWidthOnRight\n    }\n  }\n\n  ChartInternal.prototype.getParentRectValue = function (key) {\n    var parent = this.selectChart.node(),\n      v\n\n    while (parent && parent.tagName !== 'BODY') {\n      try {\n        v = parent.getBoundingClientRect()[key]\n      } catch (e) {\n        if (key === 'width') {\n          // In IE in certain cases getBoundingClientRect\n          // will cause an \"unspecified error\"\n          v = parent.offsetWidth\n        }\n      }\n\n      if (v) {\n        break\n      }\n\n      parent = parent.parentNode\n    }\n\n    return v\n  }\n\n  ChartInternal.prototype.getParentWidth = function () {\n    return this.getParentRectValue('width')\n  }\n\n  ChartInternal.prototype.getParentHeight = function () {\n    return this.getParentRectValue('height')\n  }\n\n  ChartInternal.prototype.getSvgLeft = function (withoutRecompute) {\n    var $$ = this,\n      config = $$.config,\n      hasLeftAxisRect = config.axis_rotated || (!config.axis_rotated && !config.axis_y_inner),\n      leftAxisClass = config.axis_rotated ? CLASS.axisX : CLASS.axisY,\n      leftAxis = $$.main.select('.' + leftAxisClass).node(),\n      svgRect =\n        leftAxis && hasLeftAxisRect\n          ? leftAxis.getBoundingClientRect()\n          : {\n              right: 0\n            },\n      chartRect = $$.selectChart.node().getBoundingClientRect(),\n      hasArc = $$.hasArcType(),\n      svgLeft = svgRect.right - chartRect.left - (hasArc ? 0 : $$.getCurrentPaddingLeft(withoutRecompute))\n    return svgLeft > 0 ? svgLeft : 0\n  }\n\n  ChartInternal.prototype.getAxisWidthByAxisId = function (id, withoutRecompute) {\n    var $$ = this,\n      position = $$.axis.getLabelPositionById(id)\n    return $$.axis.getMaxTickWidth(id, withoutRecompute) + (position.isInner ? 20 : 40)\n  }\n\n  ChartInternal.prototype.getHorizontalAxisHeight = function (axisId) {\n    var $$ = this,\n      config = $$.config,\n      h = 30\n\n    if (axisId === 'x' && !config.axis_x_show) {\n      return 8\n    }\n\n    if (axisId === 'x' && config.axis_x_height) {\n      return config.axis_x_height\n    }\n\n    if (axisId === 'y' && !config.axis_y_show) {\n      return config.legend_show && !$$.isLegendRight && !$$.isLegendInset ? 10 : 1\n    }\n\n    if (axisId === 'y2' && !config.axis_y2_show) {\n      return $$.rotated_padding_top\n    } // Calculate x axis height when tick rotated\n\n    if (axisId === 'x' && !config.axis_rotated && config.axis_x_tick_rotate) {\n      h = 30 + $$.axis.getMaxTickWidth(axisId) * Math.cos((Math.PI * (90 - Math.abs(config.axis_x_tick_rotate))) / 180)\n    } // Calculate y axis height when tick rotated\n\n    if (axisId === 'y' && config.axis_rotated && config.axis_y_tick_rotate) {\n      h = 30 + $$.axis.getMaxTickWidth(axisId) * Math.cos((Math.PI * (90 - Math.abs(config.axis_y_tick_rotate))) / 180)\n    }\n\n    return h + ($$.axis.getLabelPositionById(axisId).isInner ? 0 : 10) + (axisId === 'y2' ? -10 : 0)\n  }\n\n  ChartInternal.prototype.initBrush = function (scale) {\n    var $$ = this,\n      d3 = $$.d3 // TODO: dynamically change brushY/brushX according to axis_rotated.\n\n    $$.brush = ($$.config.axis_rotated ? d3.brushY() : d3.brushX())\n      .on('brush', function () {\n        var event = d3.event.sourceEvent\n\n        if (event && event.type === 'zoom') {\n          return\n        }\n\n        $$.redrawForBrush()\n      })\n      .on('end', function () {\n        var event = d3.event.sourceEvent\n\n        if (event && event.type === 'zoom') {\n          return\n        }\n\n        if ($$.brush.empty() && event && event.type !== 'end') {\n          $$.brush.clear()\n        }\n      })\n\n    $$.brush.updateExtent = function () {\n      var range = this.scale.range(),\n        extent\n\n      if ($$.config.axis_rotated) {\n        extent = [[0, range[0]], [$$.width2, range[1]]]\n      } else {\n        extent = [[range[0], 0], [range[1], $$.height2]]\n      }\n\n      this.extent(extent)\n      return this\n    }\n\n    $$.brush.updateScale = function (scale) {\n      this.scale = scale\n      return this\n    }\n\n    $$.brush.update = function (scale) {\n      this.updateScale(scale || $$.subX).updateExtent()\n      $$.context.select('.' + CLASS.brush).call(this)\n    }\n\n    $$.brush.clear = function () {\n      $$.context.select('.' + CLASS.brush).call($$.brush.move, null)\n    }\n\n    $$.brush.selection = function () {\n      return d3.brushSelection($$.context.select('.' + CLASS.brush).node())\n    }\n\n    $$.brush.selectionAsValue = function (selectionAsValue, withTransition) {\n      var selection, brush\n\n      if (selectionAsValue) {\n        if ($$.context) {\n          selection = [this.scale(selectionAsValue[0]), this.scale(selectionAsValue[1])]\n          brush = $$.context.select('.' + CLASS.brush)\n\n          if (withTransition) {\n            brush = brush.transition()\n          }\n\n          $$.brush.move(brush, selection)\n        }\n\n        return []\n      }\n\n      selection = $$.brush.selection() || [0, 0]\n      return [this.scale.invert(selection[0]), this.scale.invert(selection[1])]\n    }\n\n    $$.brush.empty = function () {\n      var selection = $$.brush.selection()\n      return !selection || selection[0] === selection[1]\n    }\n\n    return $$.brush.updateScale(scale)\n  }\n\n  ChartInternal.prototype.initSubchart = function () {\n    var $$ = this,\n      config = $$.config,\n      context = ($$.context = $$.svg.append('g').attr('transform', $$.getTranslate('context'))),\n      visibility = config.subchart_show ? 'visible' : 'hidden' // set style\n\n    context.style('visibility', visibility) // Define g for chart area\n\n    context\n      .append('g')\n      .attr('clip-path', $$.clipPathForSubchart)\n      .attr('class', CLASS.chart) // Define g for bar chart area\n\n    context\n      .select('.' + CLASS.chart)\n      .append('g')\n      .attr('class', CLASS.chartBars) // Define g for line chart area\n\n    context\n      .select('.' + CLASS.chart)\n      .append('g')\n      .attr('class', CLASS.chartLines) // Add extent rect for Brush\n\n    context\n      .append('g')\n      .attr('clip-path', $$.clipPath)\n      .attr('class', CLASS.brush) // ATTENTION: This must be called AFTER chart added\n    // Add Axis\n\n    $$.axes.subx = context\n      .append('g')\n      .attr('class', CLASS.axisX)\n      .attr('transform', $$.getTranslate('subx'))\n      .attr('clip-path', config.axis_rotated ? '' : $$.clipPathForXAxis)\n  }\n\n  ChartInternal.prototype.initSubchartBrush = function () {\n    var $$ = this // Add extent rect for Brush\n\n    $$.initBrush($$.subX).updateExtent()\n    $$.context.select('.' + CLASS.brush).call($$.brush)\n  }\n\n  ChartInternal.prototype.updateTargetsForSubchart = function (targets) {\n    var $$ = this,\n      context = $$.context,\n      config = $$.config,\n      contextLineEnter,\n      contextLine,\n      contextBarEnter,\n      contextBar,\n      classChartBar = $$.classChartBar.bind($$),\n      classBars = $$.classBars.bind($$),\n      classChartLine = $$.classChartLine.bind($$),\n      classLines = $$.classLines.bind($$),\n      classAreas = $$.classAreas.bind($$)\n\n    if (config.subchart_show) {\n      //-- Bar --//\n      contextBar = context\n        .select('.' + CLASS.chartBars)\n        .selectAll('.' + CLASS.chartBar)\n        .data(targets)\n      contextBarEnter = contextBar\n        .enter()\n        .append('g')\n        .style('opacity', 0)\n      contextBarEnter.merge(contextBar).attr('class', classChartBar) // Bars for each data\n\n      contextBarEnter.append('g').attr('class', classBars) //-- Line --//\n\n      contextLine = context\n        .select('.' + CLASS.chartLines)\n        .selectAll('.' + CLASS.chartLine)\n        .data(targets)\n      contextLineEnter = contextLine\n        .enter()\n        .append('g')\n        .style('opacity', 0)\n      contextLineEnter.merge(contextLine).attr('class', classChartLine) // Lines for each data\n\n      contextLineEnter.append('g').attr('class', classLines) // Area\n\n      contextLineEnter.append('g').attr('class', classAreas) //-- Brush --//\n\n      context\n        .selectAll('.' + CLASS.brush + ' rect')\n        .attr(config.axis_rotated ? 'width' : 'height', config.axis_rotated ? $$.width2 : $$.height2)\n    }\n  }\n\n  ChartInternal.prototype.updateBarForSubchart = function (durationForExit) {\n    var $$ = this\n    var contextBar = $$.context\n      .selectAll('.' + CLASS.bars)\n      .selectAll('.' + CLASS.bar)\n      .data($$.barData.bind($$))\n    var contextBarEnter = contextBar\n      .enter()\n      .append('path')\n      .attr('class', $$.classBar.bind($$))\n      .style('stroke', 'none')\n      .style('fill', $$.color)\n    contextBar\n      .exit()\n      .transition()\n      .duration(durationForExit)\n      .style('opacity', 0)\n      .remove()\n    $$.contextBar = contextBarEnter.merge(contextBar).style('opacity', $$.initialOpacity.bind($$))\n  }\n\n  ChartInternal.prototype.redrawBarForSubchart = function (drawBarOnSub, withTransition, duration) {\n    ;(withTransition ? this.contextBar.transition(Math.random().toString()).duration(duration) : this.contextBar)\n      .attr('d', drawBarOnSub)\n      .style('opacity', 1)\n  }\n\n  ChartInternal.prototype.updateLineForSubchart = function (durationForExit) {\n    var $$ = this\n    var contextLine = $$.context\n      .selectAll('.' + CLASS.lines)\n      .selectAll('.' + CLASS.line)\n      .data($$.lineData.bind($$))\n    var contextLineEnter = contextLine\n      .enter()\n      .append('path')\n      .attr('class', $$.classLine.bind($$))\n      .style('stroke', $$.color)\n    contextLine\n      .exit()\n      .transition()\n      .duration(durationForExit)\n      .style('opacity', 0)\n      .remove()\n    $$.contextLine = contextLineEnter.merge(contextLine).style('opacity', $$.initialOpacity.bind($$))\n  }\n\n  ChartInternal.prototype.redrawLineForSubchart = function (drawLineOnSub, withTransition, duration) {\n    ;(withTransition ? this.contextLine.transition(Math.random().toString()).duration(duration) : this.contextLine)\n      .attr('d', drawLineOnSub)\n      .style('opacity', 1)\n  }\n\n  ChartInternal.prototype.updateAreaForSubchart = function (durationForExit) {\n    var $$ = this,\n      d3 = $$.d3\n    var contextArea = $$.context\n      .selectAll('.' + CLASS.areas)\n      .selectAll('.' + CLASS.area)\n      .data($$.lineData.bind($$))\n    var contextAreaEnter = contextArea\n      .enter()\n      .append('path')\n      .attr('class', $$.classArea.bind($$))\n      .style('fill', $$.color)\n      .style('opacity', function () {\n        $$.orgAreaOpacity = +d3.select(this).style('opacity')\n        return 0\n      })\n    contextArea\n      .exit()\n      .transition()\n      .duration(durationForExit)\n      .style('opacity', 0)\n      .remove()\n    $$.contextArea = contextAreaEnter.merge(contextArea).style('opacity', 0)\n  }\n\n  ChartInternal.prototype.redrawAreaForSubchart = function (drawAreaOnSub, withTransition, duration) {\n    ;(withTransition ? this.contextArea.transition(Math.random().toString()).duration(duration) : this.contextArea)\n      .attr('d', drawAreaOnSub)\n      .style('fill', this.color)\n      .style('opacity', this.orgAreaOpacity)\n  }\n\n  ChartInternal.prototype.redrawSubchart = function (\n    withSubchart,\n    transitions,\n    duration,\n    durationForExit,\n    areaIndices,\n    barIndices,\n    lineIndices\n  ) {\n    var $$ = this,\n      d3 = $$.d3,\n      config = $$.config,\n      drawAreaOnSub,\n      drawBarOnSub,\n      drawLineOnSub\n    $$.context.style('visibility', config.subchart_show ? 'visible' : 'hidden') // subchart\n\n    if (config.subchart_show) {\n      // reflect main chart to extent on subchart if zoomed\n      if (d3.event && d3.event.type === 'zoom') {\n        $$.brush.selectionAsValue($$.x.orgDomain())\n      } // update subchart elements if needed\n\n      if (withSubchart) {\n        // extent rect\n        if (!$$.brush.empty()) {\n          $$.brush.selectionAsValue($$.x.orgDomain())\n        } // setup drawer - MEMO: this must be called after axis updated\n\n        drawAreaOnSub = $$.generateDrawArea(areaIndices, true)\n        drawBarOnSub = $$.generateDrawBar(barIndices, true)\n        drawLineOnSub = $$.generateDrawLine(lineIndices, true)\n        $$.updateBarForSubchart(duration)\n        $$.updateLineForSubchart(duration)\n        $$.updateAreaForSubchart(duration)\n        $$.redrawBarForSubchart(drawBarOnSub, duration, duration)\n        $$.redrawLineForSubchart(drawLineOnSub, duration, duration)\n        $$.redrawAreaForSubchart(drawAreaOnSub, duration, duration)\n      }\n    }\n  }\n\n  ChartInternal.prototype.redrawForBrush = function () {\n    var $$ = this,\n      x = $$.x,\n      d3 = $$.d3,\n      s\n    $$.redraw({\n      withTransition: false,\n      withY: $$.config.zoom_rescale,\n      withSubchart: false,\n      withUpdateXDomain: true,\n      withEventRect: false,\n      withDimension: false\n    }) // update zoom transation binded to event rect\n\n    s = d3.event.selection || $$.brush.scale.range()\n    $$.main\n      .select('.' + CLASS.eventRect)\n      .call($$.zoom.transform, d3.zoomIdentity.scale($$.width / (s[1] - s[0])).translate(-s[0], 0))\n    $$.config.subchart_onbrush.call($$.api, x.orgDomain())\n  }\n\n  ChartInternal.prototype.transformContext = function (withTransition, transitions) {\n    var $$ = this,\n      subXAxis\n\n    if (transitions && transitions.axisSubX) {\n      subXAxis = transitions.axisSubX\n    } else {\n      subXAxis = $$.context.select('.' + CLASS.axisX)\n\n      if (withTransition) {\n        subXAxis = subXAxis.transition()\n      }\n    }\n\n    $$.context.attr('transform', $$.getTranslate('context'))\n    subXAxis.attr('transform', $$.getTranslate('subx'))\n  }\n\n  ChartInternal.prototype.getDefaultSelection = function () {\n    var $$ = this,\n      config = $$.config,\n      selection = isFunction(config.axis_x_selection)\n        ? config.axis_x_selection($$.getXDomain($$.data.targets))\n        : config.axis_x_selection\n\n    if ($$.isTimeSeries()) {\n      selection = [$$.parseDate(selection[0]), $$.parseDate(selection[1])]\n    }\n\n    return selection\n  }\n\n  ChartInternal.prototype.initText = function () {\n    var $$ = this\n    $$.main\n      .select('.' + CLASS.chart)\n      .append('g')\n      .attr('class', CLASS.chartTexts)\n    $$.mainText = $$.d3.selectAll([])\n  }\n\n  ChartInternal.prototype.updateTargetsForText = function (targets) {\n    var $$ = this,\n      classChartText = $$.classChartText.bind($$),\n      classTexts = $$.classTexts.bind($$),\n      classFocus = $$.classFocus.bind($$)\n    var mainText = $$.main\n      .select('.' + CLASS.chartTexts)\n      .selectAll('.' + CLASS.chartText)\n      .data(targets)\n    var mainTextEnter = mainText\n      .enter()\n      .append('g')\n      .attr('class', classChartText)\n      .style('opacity', 0)\n      .style('pointer-events', 'none')\n    mainTextEnter.append('g').attr('class', classTexts)\n    mainTextEnter.merge(mainText).attr('class', function (d) {\n      return classChartText(d) + classFocus(d)\n    })\n  }\n\n  ChartInternal.prototype.updateText = function (xForText, yForText, durationForExit) {\n    var $$ = this,\n      config = $$.config,\n      barOrLineData = $$.barOrLineData.bind($$),\n      classText = $$.classText.bind($$)\n    var mainText = $$.main\n      .selectAll('.' + CLASS.texts)\n      .selectAll('.' + CLASS.text)\n      .data(barOrLineData)\n    var mainTextEnter = mainText\n      .enter()\n      .append('text')\n      .attr('class', classText)\n      .attr('text-anchor', function (d) {\n        return config.axis_rotated ? (d.value < 0 ? 'end' : 'start') : 'middle'\n      })\n      .style('stroke', 'none')\n      .attr('x', xForText)\n      .attr('y', yForText)\n      .style('fill', function (d) {\n        return $$.color(d)\n      })\n      .style('fill-opacity', 0)\n    $$.mainText = mainTextEnter.merge(mainText).text(function (d, i, j) {\n      return $$.dataLabelFormat(d.id)(d.value, d.id, i, j)\n    })\n    mainText\n      .exit()\n      .transition()\n      .duration(durationForExit)\n      .style('fill-opacity', 0)\n      .remove()\n  }\n\n  ChartInternal.prototype.redrawText = function (xForText, yForText, forFlow, withTransition, transition) {\n    return [\n      (withTransition ? this.mainText.transition(transition) : this.mainText)\n        .attr('x', xForText)\n        .attr('y', yForText)\n        .style('fill', this.color)\n        .style('fill-opacity', forFlow ? 0 : this.opacityForText.bind(this))\n    ]\n  }\n\n  ChartInternal.prototype.getTextRect = function (text, cls, element) {\n    var dummy = this.d3\n        .select('body')\n        .append('div')\n        .classed('c3', true),\n      svg = dummy\n        .append('svg')\n        .style('visibility', 'hidden')\n        .style('position', 'fixed')\n        .style('top', 0)\n        .style('left', 0),\n      font = this.d3.select(element).style('font'),\n      rect\n    svg\n      .selectAll('.dummy')\n      .data([text])\n      .enter()\n      .append('text')\n      .classed(cls ? cls : '', true)\n      .style('font', font)\n      .text(text)\n      .each(function () {\n        rect = this.getBoundingClientRect()\n      })\n    dummy.remove()\n    return rect\n  }\n\n  ChartInternal.prototype.generateXYForText = function (areaIndices, barIndices, lineIndices, forX) {\n    var $$ = this,\n      getAreaPoints = $$.generateGetAreaPoints(areaIndices, false),\n      getBarPoints = $$.generateGetBarPoints(barIndices, false),\n      getLinePoints = $$.generateGetLinePoints(lineIndices, false),\n      getter = forX ? $$.getXForText : $$.getYForText\n    return function (d, i) {\n      var getPoints = $$.isAreaType(d) ? getAreaPoints : $$.isBarType(d) ? getBarPoints : getLinePoints\n      return getter.call($$, getPoints(d, i), d, this)\n    }\n  }\n\n  ChartInternal.prototype.getXForText = function (points, d, textElement) {\n    var $$ = this,\n      box = textElement.getBoundingClientRect(),\n      xPos,\n      padding\n\n    if ($$.config.axis_rotated) {\n      padding = $$.isBarType(d) ? 4 : 6\n      xPos = points[2][1] + padding * (d.value < 0 ? -1 : 1)\n    } else {\n      xPos = $$.hasType('bar') ? (points[2][0] + points[0][0]) / 2 : points[0][0]\n    } // show labels regardless of the domain if value is null\n\n    if (d.value === null) {\n      if (xPos > $$.width) {\n        xPos = $$.width - box.width\n      } else if (xPos < 0) {\n        xPos = 4\n      }\n    }\n\n    return xPos\n  }\n\n  ChartInternal.prototype.getYForText = function (points, d, textElement) {\n    var $$ = this,\n      box = textElement.getBoundingClientRect(),\n      yPos\n\n    if ($$.config.axis_rotated) {\n      yPos = (points[0][0] + points[2][0] + box.height * 0.6) / 2\n    } else {\n      yPos = points[2][1]\n\n      if (d.value < 0 || (d.value === 0 && !$$.hasPositiveValue)) {\n        yPos += box.height\n\n        if ($$.isBarType(d) && $$.isSafari()) {\n          yPos -= 3\n        } else if (!$$.isBarType(d) && $$.isChrome()) {\n          yPos += 3\n        }\n      } else {\n        yPos += $$.isBarType(d) ? -3 : -6\n      }\n    } // show labels regardless of the domain if value is null\n\n    if (d.value === null && !$$.config.axis_rotated) {\n      if (yPos < box.height) {\n        yPos = box.height\n      } else if (yPos > this.height) {\n        yPos = this.height - 4\n      }\n    }\n\n    return yPos\n  }\n\n  ChartInternal.prototype.initTitle = function () {\n    var $$ = this\n    $$.title = $$.svg\n      .append('text')\n      .text($$.config.title_text)\n      .attr('class', $$.CLASS.title)\n  }\n\n  ChartInternal.prototype.redrawTitle = function () {\n    var $$ = this\n    $$.title.attr('x', $$.xForTitle.bind($$)).attr('y', $$.yForTitle.bind($$))\n  }\n\n  ChartInternal.prototype.xForTitle = function () {\n    var $$ = this,\n      config = $$.config,\n      position = config.title_position || 'left',\n      x\n\n    if (position.indexOf('right') >= 0) {\n      x =\n        $$.currentWidth -\n        $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node()).width -\n        config.title_padding.right\n    } else if (position.indexOf('center') >= 0) {\n      x = ($$.currentWidth - $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node()).width) / 2\n    } else {\n      // left\n      x = config.title_padding.left\n    }\n\n    return x\n  }\n\n  ChartInternal.prototype.yForTitle = function () {\n    var $$ = this\n    return (\n      $$.config.title_padding.top + $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node()).height\n    )\n  }\n\n  ChartInternal.prototype.getTitlePadding = function () {\n    var $$ = this\n    return $$.yForTitle() + $$.config.title_padding.bottom\n  }\n\n  ChartInternal.prototype.initTooltip = function () {\n    var $$ = this,\n      config = $$.config,\n      i\n    $$.tooltip = $$.selectChart\n      .style('position', 'relative')\n      .append('div')\n      .attr('class', CLASS.tooltipContainer)\n      .style('position', 'absolute')\n      .style('pointer-events', 'none')\n      .style('display', 'none') // Show tooltip if needed\n\n    if (config.tooltip_init_show) {\n      if ($$.isTimeSeries() && isString(config.tooltip_init_x)) {\n        config.tooltip_init_x = $$.parseDate(config.tooltip_init_x)\n\n        for (i = 0; i < $$.data.targets[0].values.length; i++) {\n          if ($$.data.targets[0].values[i].x - config.tooltip_init_x === 0) {\n            break\n          }\n        }\n\n        config.tooltip_init_x = i\n      }\n\n      $$.tooltip.html(\n        config.tooltip_contents.call(\n          $$,\n          $$.data.targets.map(function (d) {\n            return $$.addName(d.values[config.tooltip_init_x])\n          }),\n          $$.axis.getXAxisTickFormat(),\n          $$.getYFormat($$.hasArcType()),\n          $$.color\n        )\n      )\n      $$.tooltip\n        .style('top', config.tooltip_init_position.top)\n        .style('left', config.tooltip_init_position.left)\n        .style('display', 'block')\n    }\n  }\n\n  ChartInternal.prototype.getTooltipSortFunction = function () {\n    var $$ = this,\n      config = $$.config\n\n    if (config.data_groups.length === 0 || config.tooltip_order !== undefined) {\n      // if data are not grouped or if an order is specified\n      // for the tooltip values we sort them by their values\n      var order = config.tooltip_order\n\n      if (order === undefined) {\n        order = config.data_order\n      }\n\n      var valueOf = function valueOf (obj) {\n        return obj ? obj.value : null\n      } // if data are not grouped, we sort them by their value\n\n      if (isString(order) && order.toLowerCase() === 'asc') {\n        return function (a, b) {\n          return valueOf(a) - valueOf(b)\n        }\n      } else if (isString(order) && order.toLowerCase() === 'desc') {\n        return function (a, b) {\n          return valueOf(b) - valueOf(a)\n        }\n      } else if (isFunction(order)) {\n        // if the function is from data_order we need\n        // to wrap the returned function in order to format\n        // the sorted value to the expected format\n        var sortFunction = order\n\n        if (config.tooltip_order === undefined) {\n          sortFunction = function sortFunction (a, b) {\n            return order(\n              a\n                ? {\n                    id: a.id,\n                    values: [a]\n                  }\n                : null,\n              b\n                ? {\n                    id: b.id,\n                    values: [b]\n                  }\n                : null\n            )\n          }\n        }\n\n        return sortFunction\n      } else if (isArray(order)) {\n        return function (a, b) {\n          return order.indexOf(a.id) - order.indexOf(b.id)\n        }\n      }\n    } else {\n      // if data are grouped, we follow the order of grouped targets\n      var ids = $$.orderTargets($$.data.targets).map(function (i) {\n        return i.id\n      }) // if it was either asc or desc we need to invert the order\n      // returned by orderTargets\n\n      if ($$.isOrderAsc() || $$.isOrderDesc()) {\n        ids = ids.reverse()\n      }\n\n      return function (a, b) {\n        return ids.indexOf(a.id) - ids.indexOf(b.id)\n      }\n    }\n  }\n\n  ChartInternal.prototype.getTooltipContent = function (d, defaultTitleFormat, defaultValueFormat, color) {\n    var $$ = this,\n      config = $$.config,\n      titleFormat = config.tooltip_format_title || defaultTitleFormat,\n      nameFormat =\n        config.tooltip_format_name ||\n        function (name) {\n          return name\n        },\n      valueFormat = config.tooltip_format_value || defaultValueFormat,\n      text,\n      i,\n      title,\n      value,\n      name,\n      bgcolor\n\n    var tooltipSortFunction = this.getTooltipSortFunction()\n\n    if (tooltipSortFunction) {\n      d.sort(tooltipSortFunction)\n    }\n\n    for (i = 0; i < d.length; i++) {\n      if (!(d[i] && (d[i].value || d[i].value === 0))) {\n        continue\n      }\n\n      if (!text) {\n        title = sanitise(titleFormat ? titleFormat(d[i].x, d[i].index) : d[i].x)\n        text =\n          \"<table class='\" +\n          $$.CLASS.tooltip +\n          \"'>\" +\n          (title || title === 0 ? \"<tr><th colspan='2'>\" + title + '</th></tr>' : '')\n      }\n\n      value = sanitise(valueFormat(d[i].value, d[i].ratio, d[i].id, d[i].index, d))\n\n      if (value !== undefined) {\n        // Skip elements when their name is set to null\n        if (d[i].name === null) {\n          continue\n        }\n\n        name = sanitise(nameFormat(d[i].name, d[i].ratio, d[i].id, d[i].index))\n        bgcolor = $$.levelColor ? $$.levelColor(d[i].value) : color(d[i].id)\n        text += \"<tr class='\" + $$.CLASS.tooltipName + '-' + $$.getTargetSelectorSuffix(d[i].id) + \"'>\"\n        text += \"<td class='name'><span style='background-color:\" + bgcolor + \"'></span>\" + name + '</td>'\n        text += \"<td class='value'>\" + value + '</td>'\n        text += '</tr>'\n      }\n    }\n\n    return text + '</table>'\n  }\n\n  ChartInternal.prototype.tooltipPosition = function (dataToShow, tWidth, tHeight, element) {\n    var $$ = this,\n      config = $$.config,\n      d3 = $$.d3\n    var svgLeft, tooltipLeft, tooltipRight, tooltipTop, chartRight\n    var forArc = $$.hasArcType(),\n      mouse = d3.mouse(element) // Determin tooltip position\n\n    if (forArc) {\n      tooltipLeft = ($$.width - ($$.isLegendRight ? $$.getLegendWidth() : 0)) / 2 + mouse[0]\n      tooltipTop = ($$.hasType('gauge') ? $$.height : $$.height / 2) + mouse[1] + 20\n    } else {\n      svgLeft = $$.getSvgLeft(true)\n\n      if (config.axis_rotated) {\n        tooltipLeft = svgLeft + mouse[0] + 100\n        tooltipRight = tooltipLeft + tWidth\n        chartRight = $$.currentWidth - $$.getCurrentPaddingRight()\n        tooltipTop = $$.x(dataToShow[0].x) + 20\n      } else {\n        tooltipLeft = svgLeft + $$.getCurrentPaddingLeft(true) + $$.x(dataToShow[0].x) + 20\n        tooltipRight = tooltipLeft + tWidth\n        chartRight = svgLeft + $$.currentWidth - $$.getCurrentPaddingRight()\n        tooltipTop = mouse[1] + 15\n      }\n\n      if (tooltipRight > chartRight) {\n        // 20 is needed for Firefox to keep tooltip width\n        tooltipLeft -= tooltipRight - chartRight + 20\n      }\n\n      if (tooltipTop + tHeight > $$.currentHeight) {\n        tooltipTop -= tHeight + 30\n      }\n    }\n\n    if (tooltipTop < 0) {\n      tooltipTop = 0\n    }\n\n    return {\n      top: tooltipTop,\n      left: tooltipLeft\n    }\n  }\n\n  ChartInternal.prototype.showTooltip = function (selectedData, element) {\n    var $$ = this,\n      config = $$.config\n    var tWidth, tHeight, position\n    var forArc = $$.hasArcType(),\n      dataToShow = selectedData.filter(function (d) {\n        return d && isValue(d.value)\n      }),\n      positionFunction = config.tooltip_position || ChartInternal.prototype.tooltipPosition\n\n    if (dataToShow.length === 0 || !config.tooltip_show) {\n      return\n    }\n\n    $$.tooltip\n      .html(\n        config.tooltip_contents.call($$, selectedData, $$.axis.getXAxisTickFormat(), $$.getYFormat(forArc), $$.color)\n      )\n      .style('display', 'block') // Get tooltip dimensions\n\n    tWidth = $$.tooltip.property('offsetWidth')\n    tHeight = $$.tooltip.property('offsetHeight')\n    position = positionFunction.call(this, dataToShow, tWidth, tHeight, element) // Set tooltip\n\n    $$.tooltip.style('top', position.top + 'px').style('left', position.left + 'px')\n  }\n\n  ChartInternal.prototype.hideTooltip = function () {\n    this.tooltip.style('display', 'none')\n  }\n\n  ChartInternal.prototype.setTargetType = function (targetIds, type) {\n    var $$ = this,\n      config = $$.config\n    $$.mapToTargetIds(targetIds).forEach(function (id) {\n      $$.withoutFadeIn[id] = type === config.data_types[id]\n      config.data_types[id] = type\n    })\n\n    if (!targetIds) {\n      config.data_type = type\n    }\n  }\n\n  ChartInternal.prototype.hasType = function (type, targets) {\n    var $$ = this,\n      types = $$.config.data_types,\n      has = false\n    targets = targets || $$.data.targets\n\n    if (targets && targets.length) {\n      targets.forEach(function (target) {\n        var t = types[target.id]\n\n        if ((t && t.indexOf(type) >= 0) || (!t && type === 'line')) {\n          has = true\n        }\n      })\n    } else if (Object.keys(types).length) {\n      Object.keys(types).forEach(function (id) {\n        if (types[id] === type) {\n          has = true\n        }\n      })\n    } else {\n      has = $$.config.data_type === type\n    }\n\n    return has\n  }\n\n  ChartInternal.prototype.hasArcType = function (targets) {\n    return this.hasType('pie', targets) || this.hasType('donut', targets) || this.hasType('gauge', targets)\n  }\n\n  ChartInternal.prototype.isLineType = function (d) {\n    var config = this.config,\n      id = isString(d) ? d : d.id\n    return (\n      !config.data_types[id] ||\n      ['line', 'spline', 'area', 'area-spline', 'step', 'area-step'].indexOf(config.data_types[id]) >= 0\n    )\n  }\n\n  ChartInternal.prototype.isStepType = function (d) {\n    var id = isString(d) ? d : d.id\n    return ['step', 'area-step'].indexOf(this.config.data_types[id]) >= 0\n  }\n\n  ChartInternal.prototype.isSplineType = function (d) {\n    var id = isString(d) ? d : d.id\n    return ['spline', 'area-spline'].indexOf(this.config.data_types[id]) >= 0\n  }\n\n  ChartInternal.prototype.isAreaType = function (d) {\n    var id = isString(d) ? d : d.id\n    return ['area', 'area-spline', 'area-step'].indexOf(this.config.data_types[id]) >= 0\n  }\n\n  ChartInternal.prototype.isBarType = function (d) {\n    var id = isString(d) ? d : d.id\n    return this.config.data_types[id] === 'bar'\n  }\n\n  ChartInternal.prototype.isScatterType = function (d) {\n    var id = isString(d) ? d : d.id\n    return this.config.data_types[id] === 'scatter'\n  }\n\n  ChartInternal.prototype.isPieType = function (d) {\n    var id = isString(d) ? d : d.id\n    return this.config.data_types[id] === 'pie'\n  }\n\n  ChartInternal.prototype.isGaugeType = function (d) {\n    var id = isString(d) ? d : d.id\n    return this.config.data_types[id] === 'gauge'\n  }\n\n  ChartInternal.prototype.isDonutType = function (d) {\n    var id = isString(d) ? d : d.id\n    return this.config.data_types[id] === 'donut'\n  }\n\n  ChartInternal.prototype.isArcType = function (d) {\n    return this.isPieType(d) || this.isDonutType(d) || this.isGaugeType(d)\n  }\n\n  ChartInternal.prototype.lineData = function (d) {\n    return this.isLineType(d) ? [d] : []\n  }\n\n  ChartInternal.prototype.arcData = function (d) {\n    return this.isArcType(d.data) ? [d] : []\n  }\n  /* not used\n   function scatterData(d) {\n   return isScatterType(d) ? d.values : [];\n   }\n   */\n\n  ChartInternal.prototype.barData = function (d) {\n    return this.isBarType(d) ? d.values : []\n  }\n\n  ChartInternal.prototype.lineOrScatterData = function (d) {\n    return this.isLineType(d) || this.isScatterType(d) ? d.values : []\n  }\n\n  ChartInternal.prototype.barOrLineData = function (d) {\n    return this.isBarType(d) || this.isLineType(d) ? d.values : []\n  }\n\n  ChartInternal.prototype.isSafari = function () {\n    var ua = window.navigator.userAgent\n    return ua.indexOf('Safari') >= 0 && ua.indexOf('Chrome') < 0\n  }\n\n  ChartInternal.prototype.isChrome = function () {\n    var ua = window.navigator.userAgent\n    return ua.indexOf('Chrome') >= 0\n  }\n\n  ChartInternal.prototype.initZoom = function () {\n    var $$ = this,\n      d3 = $$.d3,\n      config = $$.config,\n      startEvent\n    $$.zoom = d3\n      .zoom()\n      .on('start', function () {\n        if (config.zoom_type !== 'scroll') {\n          return\n        }\n\n        var e = d3.event.sourceEvent\n\n        if (e && e.type === 'brush') {\n          return\n        }\n\n        startEvent = e\n        config.zoom_onzoomstart.call($$.api, e)\n      })\n      .on('zoom', function () {\n        if (config.zoom_type !== 'scroll') {\n          return\n        }\n\n        var e = d3.event.sourceEvent\n\n        if (e && e.type === 'brush') {\n          return\n        }\n\n        $$.redrawForZoom()\n        config.zoom_onzoom.call($$.api, $$.x.orgDomain())\n      })\n      .on('end', function () {\n        if (config.zoom_type !== 'scroll') {\n          return\n        }\n\n        var e = d3.event.sourceEvent\n\n        if (e && e.type === 'brush') {\n          return\n        } // if click, do nothing. otherwise, click interaction will be canceled.\n\n        if (e && startEvent.clientX === e.clientX && startEvent.clientY === e.clientY) {\n          return\n        }\n\n        config.zoom_onzoomend.call($$.api, $$.x.orgDomain())\n      })\n\n    $$.zoom.updateDomain = function () {\n      if (d3.event && d3.event.transform) {\n        $$.x.domain(d3.event.transform.rescaleX($$.subX).domain())\n      }\n\n      return this\n    }\n\n    $$.zoom.updateExtent = function () {\n      this.scaleExtent([1, Infinity])\n        .translateExtent([[0, 0], [$$.width, $$.height]])\n        .extent([[0, 0], [$$.width, $$.height]])\n      return this\n    }\n\n    $$.zoom.update = function () {\n      return this.updateExtent().updateDomain()\n    }\n\n    return $$.zoom.updateExtent()\n  }\n\n  ChartInternal.prototype.zoomTransform = function (range) {\n    var $$ = this,\n      s = [$$.x(range[0]), $$.x(range[1])]\n    return $$.d3.zoomIdentity.scale($$.width / (s[1] - s[0])).translate(-s[0], 0)\n  }\n\n  ChartInternal.prototype.initDragZoom = function () {\n    var $$ = this\n    var d3 = $$.d3\n    var config = $$.config\n    var context = ($$.context = $$.svg)\n    var brushXPos = $$.margin.left + 20.5\n    var brushYPos = $$.margin.top + 0.5\n\n    if (!(config.zoom_type === 'drag' && config.zoom_enabled)) {\n      return\n    }\n\n    var getZoomedDomain = function getZoomedDomain (selection) {\n      return (\n        selection &&\n        selection.map(function (x) {\n          return $$.x.invert(x)\n        })\n      )\n    }\n\n    var brush = ($$.dragZoomBrush = d3\n      .brushX()\n      .on('start', function () {\n        $$.api.unzoom()\n        $$.svg.select('.' + CLASS.dragZoom).classed('disabled', false)\n        config.zoom_onzoomstart.call($$.api, d3.event.sourceEvent)\n      })\n      .on('brush', function () {\n        config.zoom_onzoom.call($$.api, getZoomedDomain(d3.event.selection))\n      })\n      .on('end', function () {\n        if (d3.event.selection == null) {\n          return\n        }\n\n        var zoomedDomain = getZoomedDomain(d3.event.selection)\n\n        if (!config.zoom_disableDefaultBehavior) {\n          $$.api.zoom(zoomedDomain)\n        }\n\n        $$.svg.select('.' + CLASS.dragZoom).classed('disabled', true)\n        config.zoom_onzoomend.call($$.api, zoomedDomain)\n      }))\n    context\n      .append('g')\n      .classed(CLASS.dragZoom, true)\n      .attr('clip-path', $$.clipPath)\n      .attr('transform', 'translate(' + brushXPos + ',' + brushYPos + ')')\n      .call(brush)\n  }\n\n  ChartInternal.prototype.getZoomDomain = function () {\n    var $$ = this,\n      config = $$.config,\n      d3 = $$.d3,\n      min = d3.min([$$.orgXDomain[0], config.zoom_x_min]),\n      max = d3.max([$$.orgXDomain[1], config.zoom_x_max])\n    return [min, max]\n  }\n\n  ChartInternal.prototype.redrawForZoom = function () {\n    var $$ = this,\n      d3 = $$.d3,\n      config = $$.config,\n      zoom = $$.zoom,\n      x = $$.x\n\n    if (!config.zoom_enabled) {\n      return\n    }\n\n    if ($$.filterTargetsToShow($$.data.targets).length === 0) {\n      return\n    }\n\n    zoom.update()\n\n    if (config.zoom_disableDefaultBehavior) {\n      return\n    }\n\n    if ($$.isCategorized() && x.orgDomain()[0] === $$.orgXDomain[0]) {\n      x.domain([$$.orgXDomain[0] - 1e-10, x.orgDomain()[1]])\n    }\n\n    $$.redraw({\n      withTransition: false,\n      withY: config.zoom_rescale,\n      withSubchart: false,\n      withEventRect: false,\n      withDimension: false\n    })\n\n    if (d3.event.sourceEvent && d3.event.sourceEvent.type === 'mousemove') {\n      $$.cancelClick = true\n    }\n  }\n\n  return c3\n})\n\n\n//# sourceURL=webpack:///./src/public/js/vendor/c3/c3.js?");

/***/ }),

/***/ "./src/public/js/vendor/d3/d3.min.js":
/*!*******************************************!*\
  !*** ./src/public/js/vendor/d3/d3.min.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// https://d3js.org v5.9.0 Copyright 2019 Mike Bostock\n!(function (t, n) {\n   true\n    ? n(exports)\n    : undefined\n})(this, function (t) {\n  'use strict'\n  function n (t, n) {\n    return t < n ? -1 : t > n ? 1 : t >= n ? 0 : NaN\n  }\n  function e (t) {\n    var e\n    return (\n      1 === t.length &&\n        ((e = t),\n        (t = function (t, r) {\n          return n(e(t), r)\n        })),\n      {\n        left: function (n, e, r, i) {\n          for (null == r && (r = 0), null == i && (i = n.length); r < i; ) {\n            var o = (r + i) >>> 1\n            t(n[o], e) < 0 ? (r = o + 1) : (i = o)\n          }\n          return r\n        },\n        right: function (n, e, r, i) {\n          for (null == r && (r = 0), null == i && (i = n.length); r < i; ) {\n            var o = (r + i) >>> 1\n            t(n[o], e) > 0 ? (i = o) : (r = o + 1)\n          }\n          return r\n        }\n      }\n    )\n  }\n  var r = e(n),\n    i = r.right,\n    o = r.left\n  function a (t, n) {\n    return [t, n]\n  }\n  function u (t) {\n    return null === t ? NaN : +t\n  }\n  function c (t, n) {\n    var e,\n      r,\n      i = t.length,\n      o = 0,\n      a = -1,\n      c = 0,\n      f = 0\n    if (null == n) for (; ++a < i; ) isNaN((e = u(t[a]))) || (f += (r = e - c) * (e - (c += r / ++o)))\n    else for (; ++a < i; ) isNaN((e = u(n(t[a], a, t)))) || (f += (r = e - c) * (e - (c += r / ++o)))\n    if (o > 1) return f / (o - 1)\n  }\n  function f (t, n) {\n    var e = c(t, n)\n    return e ? Math.sqrt(e) : e\n  }\n  function s (t, n) {\n    var e,\n      r,\n      i,\n      o = t.length,\n      a = -1\n    if (null == n) {\n      for (; ++a < o; )\n        if (null != (e = t[a]) && e >= e)\n          for (r = i = e; ++a < o; ) null != (e = t[a]) && (r > e && (r = e), i < e && (i = e))\n    } else for (; ++a < o; ) if (null != (e = n(t[a], a, t)) && e >= e) for (r = i = e; ++a < o; ) null != (e = n(t[a], a, t)) && (r > e && (r = e), i < e && (i = e))\n    return [r, i]\n  }\n  var l = Array.prototype,\n    h = l.slice,\n    d = l.map\n  function p (t) {\n    return function () {\n      return t\n    }\n  }\n  function v (t) {\n    return t\n  }\n  function g (t, n, e) {\n    ;(t = +t), (n = +n), (e = (i = arguments.length) < 2 ? ((n = t), (t = 0), 1) : i < 3 ? 1 : +e)\n    for (var r = -1, i = 0 | Math.max(0, Math.ceil((n - t) / e)), o = new Array(i); ++r < i; ) o[r] = t + r * e\n    return o\n  }\n  var y = Math.sqrt(50),\n    _ = Math.sqrt(10),\n    b = Math.sqrt(2)\n  function m (t, n, e) {\n    var r,\n      i,\n      o,\n      a,\n      u = -1\n    if (((e = +e), (t = +t) === (n = +n) && e > 0)) return [t]\n    if (((r = n < t) && ((i = t), (t = n), (n = i)), 0 === (a = x(t, n, e)) || !isFinite(a))) return []\n    if (a > 0)\n      for (t = Math.ceil(t / a), n = Math.floor(n / a), o = new Array((i = Math.ceil(n - t + 1))); ++u < i; )\n        o[u] = (t + u) * a\n    else\n      for (t = Math.floor(t * a), n = Math.ceil(n * a), o = new Array((i = Math.ceil(t - n + 1))); ++u < i; )\n        o[u] = (t - u) / a\n    return r && o.reverse(), o\n  }\n  function x (t, n, e) {\n    var r = (n - t) / Math.max(0, e),\n      i = Math.floor(Math.log(r) / Math.LN10),\n      o = r / Math.pow(10, i)\n    return i >= 0\n      ? (o >= y ? 10 : o >= _ ? 5 : o >= b ? 2 : 1) * Math.pow(10, i)\n      : -Math.pow(10, -i) / (o >= y ? 10 : o >= _ ? 5 : o >= b ? 2 : 1)\n  }\n  function w (t, n, e) {\n    var r = Math.abs(n - t) / Math.max(0, e),\n      i = Math.pow(10, Math.floor(Math.log(r) / Math.LN10)),\n      o = r / i\n    return o >= y ? (i *= 10) : o >= _ ? (i *= 5) : o >= b && (i *= 2), n < t ? -i : i\n  }\n  function M (t) {\n    return Math.ceil(Math.log(t.length) / Math.LN2) + 1\n  }\n  function N (t, n, e) {\n    if ((null == e && (e = u), (r = t.length))) {\n      if ((n = +n) <= 0 || r < 2) return +e(t[0], 0, t)\n      if (n >= 1) return +e(t[r - 1], r - 1, t)\n      var r,\n        i = (r - 1) * n,\n        o = Math.floor(i),\n        a = +e(t[o], o, t)\n      return a + (+e(t[o + 1], o + 1, t) - a) * (i - o)\n    }\n  }\n  function A (t, n) {\n    var e,\n      r,\n      i = t.length,\n      o = -1\n    if (null == n) {\n      for (; ++o < i; ) if (null != (e = t[o]) && e >= e) for (r = e; ++o < i; ) null != (e = t[o]) && e > r && (r = e)\n    } else for (; ++o < i; ) if (null != (e = n(t[o], o, t)) && e >= e) for (r = e; ++o < i; ) null != (e = n(t[o], o, t)) && e > r && (r = e)\n    return r\n  }\n  function S (t) {\n    for (var n, e, r, i = t.length, o = -1, a = 0; ++o < i; ) a += t[o].length\n    for (e = new Array(a); --i >= 0; ) for (n = (r = t[i]).length; --n >= 0; ) e[--a] = r[n]\n    return e\n  }\n  function k (t, n) {\n    var e,\n      r,\n      i = t.length,\n      o = -1\n    if (null == n) {\n      for (; ++o < i; ) if (null != (e = t[o]) && e >= e) for (r = e; ++o < i; ) null != (e = t[o]) && r > e && (r = e)\n    } else for (; ++o < i; ) if (null != (e = n(t[o], o, t)) && e >= e) for (r = e; ++o < i; ) null != (e = n(t[o], o, t)) && r > e && (r = e)\n    return r\n  }\n  function T (t) {\n    if (!(i = t.length)) return []\n    for (var n = -1, e = k(t, E), r = new Array(e); ++n < e; )\n      for (var i, o = -1, a = (r[n] = new Array(i)); ++o < i; ) a[o] = t[o][n]\n    return r\n  }\n  function E (t) {\n    return t.length\n  }\n  var C = Array.prototype.slice\n  function P (t) {\n    return t\n  }\n  var z = 1,\n    R = 2,\n    D = 3,\n    q = 4,\n    L = 1e-6\n  function U (t) {\n    return 'translate(' + (t + 0.5) + ',0)'\n  }\n  function O (t) {\n    return 'translate(0,' + (t + 0.5) + ')'\n  }\n  function B () {\n    return !this.__axis\n  }\n  function Y (t, n) {\n    var e = [],\n      r = null,\n      i = null,\n      o = 6,\n      a = 6,\n      u = 3,\n      c = t === z || t === q ? -1 : 1,\n      f = t === q || t === R ? 'x' : 'y',\n      s = t === z || t === D ? U : O\n    function l (l) {\n      var h = null == r ? (n.ticks ? n.ticks.apply(n, e) : n.domain()) : r,\n        d = null == i ? (n.tickFormat ? n.tickFormat.apply(n, e) : P) : i,\n        p = Math.max(o, 0) + u,\n        v = n.range(),\n        g = +v[0] + 0.5,\n        y = +v[v.length - 1] + 0.5,\n        _ = (n.bandwidth\n          ? function (t) {\n              var n = Math.max(0, t.bandwidth() - 1) / 2\n              return (\n                t.round() && (n = Math.round(n)),\n                function (e) {\n                  return +t(e) + n\n                }\n              )\n            }\n          : function (t) {\n              return function (n) {\n                return +t(n)\n              }\n            })(n.copy()),\n        b = l.selection ? l.selection() : l,\n        m = b.selectAll('.domain').data([null]),\n        x = b\n          .selectAll('.tick')\n          .data(h, n)\n          .order(),\n        w = x.exit(),\n        M = x\n          .enter()\n          .append('g')\n          .attr('class', 'tick'),\n        N = x.select('line'),\n        A = x.select('text')\n      ;(m = m.merge(\n        m\n          .enter()\n          .insert('path', '.tick')\n          .attr('class', 'domain')\n          .attr('stroke', 'currentColor')\n      )),\n        (x = x.merge(M)),\n        (N = N.merge(\n          M.append('line')\n            .attr('stroke', 'currentColor')\n            .attr(f + '2', c * o)\n        )),\n        (A = A.merge(\n          M.append('text')\n            .attr('fill', 'currentColor')\n            .attr(f, c * p)\n            .attr('dy', t === z ? '0em' : t === D ? '0.71em' : '0.32em')\n        )),\n        l !== b &&\n          ((m = m.transition(l)),\n          (x = x.transition(l)),\n          (N = N.transition(l)),\n          (A = A.transition(l)),\n          (w = w\n            .transition(l)\n            .attr('opacity', L)\n            .attr('transform', function (t) {\n              return isFinite((t = _(t))) ? s(t) : this.getAttribute('transform')\n            })),\n          M.attr('opacity', L).attr('transform', function (t) {\n            var n = this.parentNode.__axis\n            return s(n && isFinite((n = n(t))) ? n : _(t))\n          })),\n        w.remove(),\n        m.attr(\n          'd',\n          t === q || t == R\n            ? a\n              ? 'M' + c * a + ',' + g + 'H0.5V' + y + 'H' + c * a\n              : 'M0.5,' + g + 'V' + y\n            : a\n            ? 'M' + g + ',' + c * a + 'V0.5H' + y + 'V' + c * a\n            : 'M' + g + ',0.5H' + y\n        ),\n        x.attr('opacity', 1).attr('transform', function (t) {\n          return s(_(t))\n        }),\n        N.attr(f + '2', c * o),\n        A.attr(f, c * p).text(d),\n        b\n          .filter(B)\n          .attr('fill', 'none')\n          .attr('font-size', 10)\n          .attr('font-family', 'sans-serif')\n          .attr('text-anchor', t === R ? 'start' : t === q ? 'end' : 'middle'),\n        b.each(function () {\n          this.__axis = _\n        })\n    }\n    return (\n      (l.scale = function (t) {\n        return arguments.length ? ((n = t), l) : n\n      }),\n      (l.ticks = function () {\n        return (e = C.call(arguments)), l\n      }),\n      (l.tickArguments = function (t) {\n        return arguments.length ? ((e = null == t ? [] : C.call(t)), l) : e.slice()\n      }),\n      (l.tickValues = function (t) {\n        return arguments.length ? ((r = null == t ? null : C.call(t)), l) : r && r.slice()\n      }),\n      (l.tickFormat = function (t) {\n        return arguments.length ? ((i = t), l) : i\n      }),\n      (l.tickSize = function (t) {\n        return arguments.length ? ((o = a = +t), l) : o\n      }),\n      (l.tickSizeInner = function (t) {\n        return arguments.length ? ((o = +t), l) : o\n      }),\n      (l.tickSizeOuter = function (t) {\n        return arguments.length ? ((a = +t), l) : a\n      }),\n      (l.tickPadding = function (t) {\n        return arguments.length ? ((u = +t), l) : u\n      }),\n      l\n    )\n  }\n  var F = { value: function () {} }\n  function I () {\n    for (var t, n = 0, e = arguments.length, r = {}; n < e; ++n) {\n      if (!(t = arguments[n] + '') || t in r) throw new Error('illegal type: ' + t)\n      r[t] = []\n    }\n    return new j(r)\n  }\n  function j (t) {\n    this._ = t\n  }\n  function H (t, n) {\n    for (var e, r = 0, i = t.length; r < i; ++r) if ((e = t[r]).name === n) return e.value\n  }\n  function X (t, n, e) {\n    for (var r = 0, i = t.length; r < i; ++r)\n      if (t[r].name === n) {\n        ;(t[r] = F), (t = t.slice(0, r).concat(t.slice(r + 1)))\n        break\n      }\n    return null != e && t.push({ name: n, value: e }), t\n  }\n  j.prototype = I.prototype = {\n    constructor: j,\n    on: function (t, n) {\n      var e,\n        r,\n        i = this._,\n        o = ((r = i),\n        (t + '')\n          .trim()\n          .split(/^|\\s+/)\n          .map(function (t) {\n            var n = '',\n              e = t.indexOf('.')\n            if ((e >= 0 && ((n = t.slice(e + 1)), (t = t.slice(0, e))), t && !r.hasOwnProperty(t)))\n              throw new Error('unknown type: ' + t)\n            return { type: t, name: n }\n          })),\n        a = -1,\n        u = o.length\n      if (!(arguments.length < 2)) {\n        if (null != n && 'function' != typeof n) throw new Error('invalid callback: ' + n)\n        for (; ++a < u; )\n          if ((e = (t = o[a]).type)) i[e] = X(i[e], t.name, n)\n          else if (null == n) for (e in i) i[e] = X(i[e], t.name, null)\n        return this\n      }\n      for (; ++a < u; ) if ((e = (t = o[a]).type) && (e = H(i[e], t.name))) return e\n    },\n    copy: function () {\n      var t = {},\n        n = this._\n      for (var e in n) t[e] = n[e].slice()\n      return new j(t)\n    },\n    call: function (t, n) {\n      if ((e = arguments.length - 2) > 0) for (var e, r, i = new Array(e), o = 0; o < e; ++o) i[o] = arguments[o + 2]\n      if (!this._.hasOwnProperty(t)) throw new Error('unknown type: ' + t)\n      for (o = 0, e = (r = this._[t]).length; o < e; ++o) r[o].value.apply(n, i)\n    },\n    apply: function (t, n, e) {\n      if (!this._.hasOwnProperty(t)) throw new Error('unknown type: ' + t)\n      for (var r = this._[t], i = 0, o = r.length; i < o; ++i) r[i].value.apply(n, e)\n    }\n  }\n  var G = 'http://www.w3.org/1999/xhtml',\n    V = {\n      svg: 'http://www.w3.org/2000/svg',\n      xhtml: G,\n      xlink: 'http://www.w3.org/1999/xlink',\n      xml: 'http://www.w3.org/XML/1998/namespace',\n      xmlns: 'http://www.w3.org/2000/xmlns/'\n    }\n  function $ (t) {\n    var n = (t += ''),\n      e = n.indexOf(':')\n    return (\n      e >= 0 && 'xmlns' !== (n = t.slice(0, e)) && (t = t.slice(e + 1)),\n      V.hasOwnProperty(n) ? { space: V[n], local: t } : t\n    )\n  }\n  function W (t) {\n    var n = $(t)\n    return (n.local\n      ? function (t) {\n          return function () {\n            return this.ownerDocument.createElementNS(t.space, t.local)\n          }\n        }\n      : function (t) {\n          return function () {\n            var n = this.ownerDocument,\n              e = this.namespaceURI\n            return e === G && n.documentElement.namespaceURI === G ? n.createElement(t) : n.createElementNS(e, t)\n          }\n        })(n)\n  }\n  function Z () {}\n  function Q (t) {\n    return null == t\n      ? Z\n      : function () {\n          return this.querySelector(t)\n        }\n  }\n  function J () {\n    return []\n  }\n  function K (t) {\n    return null == t\n      ? J\n      : function () {\n          return this.querySelectorAll(t)\n        }\n  }\n  function tt (t) {\n    return function () {\n      return this.matches(t)\n    }\n  }\n  function nt (t) {\n    return new Array(t.length)\n  }\n  function et (t, n) {\n    ;(this.ownerDocument = t.ownerDocument),\n      (this.namespaceURI = t.namespaceURI),\n      (this._next = null),\n      (this._parent = t),\n      (this.__data__ = n)\n  }\n  et.prototype = {\n    constructor: et,\n    appendChild: function (t) {\n      return this._parent.insertBefore(t, this._next)\n    },\n    insertBefore: function (t, n) {\n      return this._parent.insertBefore(t, n)\n    },\n    querySelector: function (t) {\n      return this._parent.querySelector(t)\n    },\n    querySelectorAll: function (t) {\n      return this._parent.querySelectorAll(t)\n    }\n  }\n  var rt = '$'\n  function it (t, n, e, r, i, o) {\n    for (var a, u = 0, c = n.length, f = o.length; u < f; ++u)\n      (a = n[u]) ? ((a.__data__ = o[u]), (r[u] = a)) : (e[u] = new et(t, o[u]))\n    for (; u < c; ++u) (a = n[u]) && (i[u] = a)\n  }\n  function ot (t, n, e, r, i, o, a) {\n    var u,\n      c,\n      f,\n      s = {},\n      l = n.length,\n      h = o.length,\n      d = new Array(l)\n    for (u = 0; u < l; ++u)\n      (c = n[u]) && ((d[u] = f = rt + a.call(c, c.__data__, u, n)), f in s ? (i[u] = c) : (s[f] = c))\n    for (u = 0; u < h; ++u)\n      (c = s[(f = rt + a.call(t, o[u], u, o))])\n        ? ((r[u] = c), (c.__data__ = o[u]), (s[f] = null))\n        : (e[u] = new et(t, o[u]))\n    for (u = 0; u < l; ++u) (c = n[u]) && s[d[u]] === c && (i[u] = c)\n  }\n  function at (t, n) {\n    return t < n ? -1 : t > n ? 1 : t >= n ? 0 : NaN\n  }\n  function ut (t) {\n    return (t.ownerDocument && t.ownerDocument.defaultView) || (t.document && t) || t.defaultView\n  }\n  function ct (t, n) {\n    return (\n      t.style.getPropertyValue(n) ||\n      ut(t)\n        .getComputedStyle(t, null)\n        .getPropertyValue(n)\n    )\n  }\n  function ft (t) {\n    return t.trim().split(/^|\\s+/)\n  }\n  function st (t) {\n    return t.classList || new lt(t)\n  }\n  function lt (t) {\n    ;(this._node = t), (this._names = ft(t.getAttribute('class') || ''))\n  }\n  function ht (t, n) {\n    for (var e = st(t), r = -1, i = n.length; ++r < i; ) e.add(n[r])\n  }\n  function dt (t, n) {\n    for (var e = st(t), r = -1, i = n.length; ++r < i; ) e.remove(n[r])\n  }\n  function pt () {\n    this.textContent = ''\n  }\n  function vt () {\n    this.innerHTML = ''\n  }\n  function gt () {\n    this.nextSibling && this.parentNode.appendChild(this)\n  }\n  function yt () {\n    this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild)\n  }\n  function _t () {\n    return null\n  }\n  function bt () {\n    var t = this.parentNode\n    t && t.removeChild(this)\n  }\n  function mt () {\n    return this.parentNode.insertBefore(this.cloneNode(!1), this.nextSibling)\n  }\n  function xt () {\n    return this.parentNode.insertBefore(this.cloneNode(!0), this.nextSibling)\n  }\n  lt.prototype = {\n    add: function (t) {\n      this._names.indexOf(t) < 0 && (this._names.push(t), this._node.setAttribute('class', this._names.join(' ')))\n    },\n    remove: function (t) {\n      var n = this._names.indexOf(t)\n      n >= 0 && (this._names.splice(n, 1), this._node.setAttribute('class', this._names.join(' ')))\n    },\n    contains: function (t) {\n      return this._names.indexOf(t) >= 0\n    }\n  }\n  var wt = {}\n  ;((t.event = null), 'undefined' != typeof document) &&\n    ('onmouseenter' in document.documentElement || (wt = { mouseenter: 'mouseover', mouseleave: 'mouseout' }))\n  function Mt (t, n, e) {\n    return (\n      (t = Nt(t, n, e)),\n      function (n) {\n        var e = n.relatedTarget\n        ;(e && (e === this || 8 & e.compareDocumentPosition(this))) || t.call(this, n)\n      }\n    )\n  }\n  function Nt (n, e, r) {\n    return function (i) {\n      var o = t.event\n      t.event = i\n      try {\n        n.call(this, this.__data__, e, r)\n      } finally {\n        t.event = o\n      }\n    }\n  }\n  function At (t) {\n    return function () {\n      var n = this.__on\n      if (n) {\n        for (var e, r = 0, i = -1, o = n.length; r < o; ++r)\n          (e = n[r]),\n            (t.type && e.type !== t.type) || e.name !== t.name\n              ? (n[++i] = e)\n              : this.removeEventListener(e.type, e.listener, e.capture)\n        ++i ? (n.length = i) : delete this.__on\n      }\n    }\n  }\n  function St (t, n, e) {\n    var r = wt.hasOwnProperty(t.type) ? Mt : Nt\n    return function (i, o, a) {\n      var u,\n        c = this.__on,\n        f = r(n, o, a)\n      if (c)\n        for (var s = 0, l = c.length; s < l; ++s)\n          if ((u = c[s]).type === t.type && u.name === t.name)\n            return (\n              this.removeEventListener(u.type, u.listener, u.capture),\n              this.addEventListener(u.type, (u.listener = f), (u.capture = e)),\n              void (u.value = n)\n            )\n      this.addEventListener(t.type, f, e),\n        (u = { type: t.type, name: t.name, value: n, listener: f, capture: e }),\n        c ? c.push(u) : (this.__on = [u])\n    }\n  }\n  function kt (n, e, r, i) {\n    var o = t.event\n    ;(n.sourceEvent = t.event), (t.event = n)\n    try {\n      return e.apply(r, i)\n    } finally {\n      t.event = o\n    }\n  }\n  function Tt (t, n, e) {\n    var r = ut(t),\n      i = r.CustomEvent\n    'function' == typeof i\n      ? (i = new i(n, e))\n      : ((i = r.document.createEvent('Event')),\n        e ? (i.initEvent(n, e.bubbles, e.cancelable), (i.detail = e.detail)) : i.initEvent(n, !1, !1)),\n      t.dispatchEvent(i)\n  }\n  var Et = [null]\n  function Ct (t, n) {\n    ;(this._groups = t), (this._parents = n)\n  }\n  function Pt () {\n    return new Ct([[document.documentElement]], Et)\n  }\n  function zt (t) {\n    return 'string' == typeof t ? new Ct([[document.querySelector(t)]], [document.documentElement]) : new Ct([[t]], Et)\n  }\n  Ct.prototype = Pt.prototype = {\n    constructor: Ct,\n    select: function (t) {\n      'function' != typeof t && (t = Q(t))\n      for (var n = this._groups, e = n.length, r = new Array(e), i = 0; i < e; ++i)\n        for (var o, a, u = n[i], c = u.length, f = (r[i] = new Array(c)), s = 0; s < c; ++s)\n          (o = u[s]) && (a = t.call(o, o.__data__, s, u)) && ('__data__' in o && (a.__data__ = o.__data__), (f[s] = a))\n      return new Ct(r, this._parents)\n    },\n    selectAll: function (t) {\n      'function' != typeof t && (t = K(t))\n      for (var n = this._groups, e = n.length, r = [], i = [], o = 0; o < e; ++o)\n        for (var a, u = n[o], c = u.length, f = 0; f < c; ++f)\n          (a = u[f]) && (r.push(t.call(a, a.__data__, f, u)), i.push(a))\n      return new Ct(r, i)\n    },\n    filter: function (t) {\n      'function' != typeof t && (t = tt(t))\n      for (var n = this._groups, e = n.length, r = new Array(e), i = 0; i < e; ++i)\n        for (var o, a = n[i], u = a.length, c = (r[i] = []), f = 0; f < u; ++f)\n          (o = a[f]) && t.call(o, o.__data__, f, a) && c.push(o)\n      return new Ct(r, this._parents)\n    },\n    data: function (t, n) {\n      if (!t)\n        return (\n          (p = new Array(this.size())),\n          (s = -1),\n          this.each(function (t) {\n            p[++s] = t\n          }),\n          p\n        )\n      var e,\n        r = n ? ot : it,\n        i = this._parents,\n        o = this._groups\n      'function' != typeof t &&\n        ((e = t),\n        (t = function () {\n          return e\n        }))\n      for (var a = o.length, u = new Array(a), c = new Array(a), f = new Array(a), s = 0; s < a; ++s) {\n        var l = i[s],\n          h = o[s],\n          d = h.length,\n          p = t.call(l, l && l.__data__, s, i),\n          v = p.length,\n          g = (c[s] = new Array(v)),\n          y = (u[s] = new Array(v))\n        r(l, h, g, y, (f[s] = new Array(d)), p, n)\n        for (var _, b, m = 0, x = 0; m < v; ++m)\n          if ((_ = g[m])) {\n            for (m >= x && (x = m + 1); !(b = y[x]) && ++x < v; );\n            _._next = b || null\n          }\n      }\n      return ((u = new Ct(u, i))._enter = c), (u._exit = f), u\n    },\n    enter: function () {\n      return new Ct(this._enter || this._groups.map(nt), this._parents)\n    },\n    exit: function () {\n      return new Ct(this._exit || this._groups.map(nt), this._parents)\n    },\n    join: function (t, n, e) {\n      var r = this.enter(),\n        i = this,\n        o = this.exit()\n      return (\n        (r = 'function' == typeof t ? t(r) : r.append(t + '')),\n        null != n && (i = n(i)),\n        null == e ? o.remove() : e(o),\n        r && i ? r.merge(i).order() : i\n      )\n    },\n    merge: function (t) {\n      for (\n        var n = this._groups, e = t._groups, r = n.length, i = e.length, o = Math.min(r, i), a = new Array(r), u = 0;\n        u < o;\n        ++u\n      )\n        for (var c, f = n[u], s = e[u], l = f.length, h = (a[u] = new Array(l)), d = 0; d < l; ++d)\n          (c = f[d] || s[d]) && (h[d] = c)\n      for (; u < r; ++u) a[u] = n[u]\n      return new Ct(a, this._parents)\n    },\n    order: function () {\n      for (var t = this._groups, n = -1, e = t.length; ++n < e; )\n        for (var r, i = t[n], o = i.length - 1, a = i[o]; --o >= 0; )\n          (r = i[o]) && (a && 4 ^ r.compareDocumentPosition(a) && a.parentNode.insertBefore(r, a), (a = r))\n      return this\n    },\n    sort: function (t) {\n      function n (n, e) {\n        return n && e ? t(n.__data__, e.__data__) : !n - !e\n      }\n      t || (t = at)\n      for (var e = this._groups, r = e.length, i = new Array(r), o = 0; o < r; ++o) {\n        for (var a, u = e[o], c = u.length, f = (i[o] = new Array(c)), s = 0; s < c; ++s) (a = u[s]) && (f[s] = a)\n        f.sort(n)\n      }\n      return new Ct(i, this._parents).order()\n    },\n    call: function () {\n      var t = arguments[0]\n      return (arguments[0] = this), t.apply(null, arguments), this\n    },\n    nodes: function () {\n      var t = new Array(this.size()),\n        n = -1\n      return (\n        this.each(function () {\n          t[++n] = this\n        }),\n        t\n      )\n    },\n    node: function () {\n      for (var t = this._groups, n = 0, e = t.length; n < e; ++n)\n        for (var r = t[n], i = 0, o = r.length; i < o; ++i) {\n          var a = r[i]\n          if (a) return a\n        }\n      return null\n    },\n    size: function () {\n      var t = 0\n      return (\n        this.each(function () {\n          ++t\n        }),\n        t\n      )\n    },\n    empty: function () {\n      return !this.node()\n    },\n    each: function (t) {\n      for (var n = this._groups, e = 0, r = n.length; e < r; ++e)\n        for (var i, o = n[e], a = 0, u = o.length; a < u; ++a) (i = o[a]) && t.call(i, i.__data__, a, o)\n      return this\n    },\n    attr: function (t, n) {\n      var e = $(t)\n      if (arguments.length < 2) {\n        var r = this.node()\n        return e.local ? r.getAttributeNS(e.space, e.local) : r.getAttribute(e)\n      }\n      return this.each(\n        (null == n\n          ? e.local\n            ? function (t) {\n                return function () {\n                  this.removeAttributeNS(t.space, t.local)\n                }\n              }\n            : function (t) {\n                return function () {\n                  this.removeAttribute(t)\n                }\n              }\n          : 'function' == typeof n\n          ? e.local\n            ? function (t, n) {\n                return function () {\n                  var e = n.apply(this, arguments)\n                  null == e ? this.removeAttributeNS(t.space, t.local) : this.setAttributeNS(t.space, t.local, e)\n                }\n              }\n            : function (t, n) {\n                return function () {\n                  var e = n.apply(this, arguments)\n                  null == e ? this.removeAttribute(t) : this.setAttribute(t, e)\n                }\n              }\n          : e.local\n          ? function (t, n) {\n              return function () {\n                this.setAttributeNS(t.space, t.local, n)\n              }\n            }\n          : function (t, n) {\n              return function () {\n                this.setAttribute(t, n)\n              }\n            })(e, n)\n      )\n    },\n    style: function (t, n, e) {\n      return arguments.length > 1\n        ? this.each(\n            (null == n\n              ? function (t) {\n                  return function () {\n                    this.style.removeProperty(t)\n                  }\n                }\n              : 'function' == typeof n\n              ? function (t, n, e) {\n                  return function () {\n                    var r = n.apply(this, arguments)\n                    null == r ? this.style.removeProperty(t) : this.style.setProperty(t, r, e)\n                  }\n                }\n              : function (t, n, e) {\n                  return function () {\n                    this.style.setProperty(t, n, e)\n                  }\n                })(t, n, null == e ? '' : e)\n          )\n        : ct(this.node(), t)\n    },\n    property: function (t, n) {\n      return arguments.length > 1\n        ? this.each(\n            (null == n\n              ? function (t) {\n                  return function () {\n                    delete this[t]\n                  }\n                }\n              : 'function' == typeof n\n              ? function (t, n) {\n                  return function () {\n                    var e = n.apply(this, arguments)\n                    null == e ? delete this[t] : (this[t] = e)\n                  }\n                }\n              : function (t, n) {\n                  return function () {\n                    this[t] = n\n                  }\n                })(t, n)\n          )\n        : this.node()[t]\n    },\n    classed: function (t, n) {\n      var e = ft(t + '')\n      if (arguments.length < 2) {\n        for (var r = st(this.node()), i = -1, o = e.length; ++i < o; ) if (!r.contains(e[i])) return !1\n        return !0\n      }\n      return this.each(\n        ('function' == typeof n\n          ? function (t, n) {\n              return function () {\n                ;(n.apply(this, arguments) ? ht : dt)(this, t)\n              }\n            }\n          : n\n          ? function (t) {\n              return function () {\n                ht(this, t)\n              }\n            }\n          : function (t) {\n              return function () {\n                dt(this, t)\n              }\n            })(e, n)\n      )\n    },\n    text: function (t) {\n      return arguments.length\n        ? this.each(\n            null == t\n              ? pt\n              : ('function' == typeof t\n                  ? function (t) {\n                      return function () {\n                        var n = t.apply(this, arguments)\n                        this.textContent = null == n ? '' : n\n                      }\n                    }\n                  : function (t) {\n                      return function () {\n                        this.textContent = t\n                      }\n                    })(t)\n          )\n        : this.node().textContent\n    },\n    html: function (t) {\n      return arguments.length\n        ? this.each(\n            null == t\n              ? vt\n              : ('function' == typeof t\n                  ? function (t) {\n                      return function () {\n                        var n = t.apply(this, arguments)\n                        this.innerHTML = null == n ? '' : n\n                      }\n                    }\n                  : function (t) {\n                      return function () {\n                        this.innerHTML = t\n                      }\n                    })(t)\n          )\n        : this.node().innerHTML\n    },\n    raise: function () {\n      return this.each(gt)\n    },\n    lower: function () {\n      return this.each(yt)\n    },\n    append: function (t) {\n      var n = 'function' == typeof t ? t : W(t)\n      return this.select(function () {\n        return this.appendChild(n.apply(this, arguments))\n      })\n    },\n    insert: function (t, n) {\n      var e = 'function' == typeof t ? t : W(t),\n        r = null == n ? _t : 'function' == typeof n ? n : Q(n)\n      return this.select(function () {\n        return this.insertBefore(e.apply(this, arguments), r.apply(this, arguments) || null)\n      })\n    },\n    remove: function () {\n      return this.each(bt)\n    },\n    clone: function (t) {\n      return this.select(t ? xt : mt)\n    },\n    datum: function (t) {\n      return arguments.length ? this.property('__data__', t) : this.node().__data__\n    },\n    on: function (t, n, e) {\n      var r,\n        i,\n        o = (function (t) {\n          return t\n            .trim()\n            .split(/^|\\s+/)\n            .map(function (t) {\n              var n = '',\n                e = t.indexOf('.')\n              return e >= 0 && ((n = t.slice(e + 1)), (t = t.slice(0, e))), { type: t, name: n }\n            })\n        })(t + ''),\n        a = o.length\n      if (!(arguments.length < 2)) {\n        for (u = n ? St : At, null == e && (e = !1), r = 0; r < a; ++r) this.each(u(o[r], n, e))\n        return this\n      }\n      var u = this.node().__on\n      if (u)\n        for (var c, f = 0, s = u.length; f < s; ++f)\n          for (r = 0, c = u[f]; r < a; ++r) if ((i = o[r]).type === c.type && i.name === c.name) return c.value\n    },\n    dispatch: function (t, n) {\n      return this.each(\n        ('function' == typeof n\n          ? function (t, n) {\n              return function () {\n                return Tt(this, t, n.apply(this, arguments))\n              }\n            }\n          : function (t, n) {\n              return function () {\n                return Tt(this, t, n)\n              }\n            })(t, n)\n      )\n    }\n  }\n  var Rt = 0\n  function Dt () {\n    return new qt()\n  }\n  function qt () {\n    this._ = '@' + (++Rt).toString(36)\n  }\n  function Lt () {\n    for (var n, e = t.event; (n = e.sourceEvent); ) e = n\n    return e\n  }\n  function Ut (t, n) {\n    var e = t.ownerSVGElement || t\n    if (e.createSVGPoint) {\n      var r = e.createSVGPoint()\n      return (r.x = n.clientX), (r.y = n.clientY), [(r = r.matrixTransform(t.getScreenCTM().inverse())).x, r.y]\n    }\n    var i = t.getBoundingClientRect()\n    return [n.clientX - i.left - t.clientLeft, n.clientY - i.top - t.clientTop]\n  }\n  function Ot (t) {\n    var n = Lt()\n    return n.changedTouches && (n = n.changedTouches[0]), Ut(t, n)\n  }\n  function Bt (t, n, e) {\n    arguments.length < 3 && ((e = n), (n = Lt().changedTouches))\n    for (var r, i = 0, o = n ? n.length : 0; i < o; ++i) if ((r = n[i]).identifier === e) return Ut(t, r)\n    return null\n  }\n  function Yt () {\n    t.event.stopImmediatePropagation()\n  }\n  function Ft () {\n    t.event.preventDefault(), t.event.stopImmediatePropagation()\n  }\n  function It (t) {\n    var n = t.document.documentElement,\n      e = zt(t).on('dragstart.drag', Ft, !0)\n    'onselectstart' in n\n      ? e.on('selectstart.drag', Ft, !0)\n      : ((n.__noselect = n.style.MozUserSelect), (n.style.MozUserSelect = 'none'))\n  }\n  function jt (t, n) {\n    var e = t.document.documentElement,\n      r = zt(t).on('dragstart.drag', null)\n    n &&\n      (r.on('click.drag', Ft, !0),\n      setTimeout(function () {\n        r.on('click.drag', null)\n      }, 0)),\n      'onselectstart' in e\n        ? r.on('selectstart.drag', null)\n        : ((e.style.MozUserSelect = e.__noselect), delete e.__noselect)\n  }\n  function Ht (t) {\n    return function () {\n      return t\n    }\n  }\n  function Xt (t, n, e, r, i, o, a, u, c, f) {\n    ;(this.target = t),\n      (this.type = n),\n      (this.subject = e),\n      (this.identifier = r),\n      (this.active = i),\n      (this.x = o),\n      (this.y = a),\n      (this.dx = u),\n      (this.dy = c),\n      (this._ = f)\n  }\n  function Gt () {\n    return !t.event.button\n  }\n  function Vt () {\n    return this.parentNode\n  }\n  function $t (n) {\n    return null == n ? { x: t.event.x, y: t.event.y } : n\n  }\n  function Wt () {\n    return 'ontouchstart' in this\n  }\n  function Zt (t, n, e) {\n    ;(t.prototype = n.prototype = e), (e.constructor = t)\n  }\n  function Qt (t, n) {\n    var e = Object.create(t.prototype)\n    for (var r in n) e[r] = n[r]\n    return e\n  }\n  function Jt () {}\n  ;(qt.prototype = Dt.prototype = {\n    constructor: qt,\n    get: function (t) {\n      for (var n = this._; !(n in t); ) if (!(t = t.parentNode)) return\n      return t[n]\n    },\n    set: function (t, n) {\n      return (t[this._] = n)\n    },\n    remove: function (t) {\n      return this._ in t && delete t[this._]\n    },\n    toString: function () {\n      return this._\n    }\n  }),\n    (Xt.prototype.on = function () {\n      var t = this._.on.apply(this._, arguments)\n      return t === this._ ? this : t\n    })\n  var Kt = '\\\\s*([+-]?\\\\d+)\\\\s*',\n    tn = '\\\\s*([+-]?\\\\d*\\\\.?\\\\d+(?:[eE][+-]?\\\\d+)?)\\\\s*',\n    nn = '\\\\s*([+-]?\\\\d*\\\\.?\\\\d+(?:[eE][+-]?\\\\d+)?)%\\\\s*',\n    en = /^#([0-9a-f]{3})$/,\n    rn = /^#([0-9a-f]{6})$/,\n    on = new RegExp('^rgb\\\\(' + [Kt, Kt, Kt] + '\\\\)$'),\n    an = new RegExp('^rgb\\\\(' + [nn, nn, nn] + '\\\\)$'),\n    un = new RegExp('^rgba\\\\(' + [Kt, Kt, Kt, tn] + '\\\\)$'),\n    cn = new RegExp('^rgba\\\\(' + [nn, nn, nn, tn] + '\\\\)$'),\n    fn = new RegExp('^hsl\\\\(' + [tn, nn, nn] + '\\\\)$'),\n    sn = new RegExp('^hsla\\\\(' + [tn, nn, nn, tn] + '\\\\)$'),\n    ln = {\n      aliceblue: 15792383,\n      antiquewhite: 16444375,\n      aqua: 65535,\n      aquamarine: 8388564,\n      azure: 15794175,\n      beige: 16119260,\n      bisque: 16770244,\n      black: 0,\n      blanchedalmond: 16772045,\n      blue: 255,\n      blueviolet: 9055202,\n      brown: 10824234,\n      burlywood: 14596231,\n      cadetblue: 6266528,\n      chartreuse: 8388352,\n      chocolate: 13789470,\n      coral: 16744272,\n      cornflowerblue: 6591981,\n      cornsilk: 16775388,\n      crimson: 14423100,\n      cyan: 65535,\n      darkblue: 139,\n      darkcyan: 35723,\n      darkgoldenrod: 12092939,\n      darkgray: 11119017,\n      darkgreen: 25600,\n      darkgrey: 11119017,\n      darkkhaki: 12433259,\n      darkmagenta: 9109643,\n      darkolivegreen: 5597999,\n      darkorange: 16747520,\n      darkorchid: 10040012,\n      darkred: 9109504,\n      darksalmon: 15308410,\n      darkseagreen: 9419919,\n      darkslateblue: 4734347,\n      darkslategray: 3100495,\n      darkslategrey: 3100495,\n      darkturquoise: 52945,\n      darkviolet: 9699539,\n      deeppink: 16716947,\n      deepskyblue: 49151,\n      dimgray: 6908265,\n      dimgrey: 6908265,\n      dodgerblue: 2003199,\n      firebrick: 11674146,\n      floralwhite: 16775920,\n      forestgreen: 2263842,\n      fuchsia: 16711935,\n      gainsboro: 14474460,\n      ghostwhite: 16316671,\n      gold: 16766720,\n      goldenrod: 14329120,\n      gray: 8421504,\n      green: 32768,\n      greenyellow: 11403055,\n      grey: 8421504,\n      honeydew: 15794160,\n      hotpink: 16738740,\n      indianred: 13458524,\n      indigo: 4915330,\n      ivory: 16777200,\n      khaki: 15787660,\n      lavender: 15132410,\n      lavenderblush: 16773365,\n      lawngreen: 8190976,\n      lemonchiffon: 16775885,\n      lightblue: 11393254,\n      lightcoral: 15761536,\n      lightcyan: 14745599,\n      lightgoldenrodyellow: 16448210,\n      lightgray: 13882323,\n      lightgreen: 9498256,\n      lightgrey: 13882323,\n      lightpink: 16758465,\n      lightsalmon: 16752762,\n      lightseagreen: 2142890,\n      lightskyblue: 8900346,\n      lightslategray: 7833753,\n      lightslategrey: 7833753,\n      lightsteelblue: 11584734,\n      lightyellow: 16777184,\n      lime: 65280,\n      limegreen: 3329330,\n      linen: 16445670,\n      magenta: 16711935,\n      maroon: 8388608,\n      mediumaquamarine: 6737322,\n      mediumblue: 205,\n      mediumorchid: 12211667,\n      mediumpurple: 9662683,\n      mediumseagreen: 3978097,\n      mediumslateblue: 8087790,\n      mediumspringgreen: 64154,\n      mediumturquoise: 4772300,\n      mediumvioletred: 13047173,\n      midnightblue: 1644912,\n      mintcream: 16121850,\n      mistyrose: 16770273,\n      moccasin: 16770229,\n      navajowhite: 16768685,\n      navy: 128,\n      oldlace: 16643558,\n      olive: 8421376,\n      olivedrab: 7048739,\n      orange: 16753920,\n      orangered: 16729344,\n      orchid: 14315734,\n      palegoldenrod: 15657130,\n      palegreen: 10025880,\n      paleturquoise: 11529966,\n      palevioletred: 14381203,\n      papayawhip: 16773077,\n      peachpuff: 16767673,\n      peru: 13468991,\n      pink: 16761035,\n      plum: 14524637,\n      powderblue: 11591910,\n      purple: 8388736,\n      rebeccapurple: 6697881,\n      red: 16711680,\n      rosybrown: 12357519,\n      royalblue: 4286945,\n      saddlebrown: 9127187,\n      salmon: 16416882,\n      sandybrown: 16032864,\n      seagreen: 3050327,\n      seashell: 16774638,\n      sienna: 10506797,\n      silver: 12632256,\n      skyblue: 8900331,\n      slateblue: 6970061,\n      slategray: 7372944,\n      slategrey: 7372944,\n      snow: 16775930,\n      springgreen: 65407,\n      steelblue: 4620980,\n      tan: 13808780,\n      teal: 32896,\n      thistle: 14204888,\n      tomato: 16737095,\n      turquoise: 4251856,\n      violet: 15631086,\n      wheat: 16113331,\n      white: 16777215,\n      whitesmoke: 16119285,\n      yellow: 16776960,\n      yellowgreen: 10145074\n    }\n  function hn (t) {\n    var n\n    return (\n      (t = (t + '').trim().toLowerCase()),\n      (n = en.exec(t))\n        ? new yn(\n            (((n = parseInt(n[1], 16)) >> 8) & 15) | ((n >> 4) & 240),\n            ((n >> 4) & 15) | (240 & n),\n            ((15 & n) << 4) | (15 & n),\n            1\n          )\n        : (n = rn.exec(t))\n        ? dn(parseInt(n[1], 16))\n        : (n = on.exec(t))\n        ? new yn(n[1], n[2], n[3], 1)\n        : (n = an.exec(t))\n        ? new yn((255 * n[1]) / 100, (255 * n[2]) / 100, (255 * n[3]) / 100, 1)\n        : (n = un.exec(t))\n        ? pn(n[1], n[2], n[3], n[4])\n        : (n = cn.exec(t))\n        ? pn((255 * n[1]) / 100, (255 * n[2]) / 100, (255 * n[3]) / 100, n[4])\n        : (n = fn.exec(t))\n        ? bn(n[1], n[2] / 100, n[3] / 100, 1)\n        : (n = sn.exec(t))\n        ? bn(n[1], n[2] / 100, n[3] / 100, n[4])\n        : ln.hasOwnProperty(t)\n        ? dn(ln[t])\n        : 'transparent' === t\n        ? new yn(NaN, NaN, NaN, 0)\n        : null\n    )\n  }\n  function dn (t) {\n    return new yn((t >> 16) & 255, (t >> 8) & 255, 255 & t, 1)\n  }\n  function pn (t, n, e, r) {\n    return r <= 0 && (t = n = e = NaN), new yn(t, n, e, r)\n  }\n  function vn (t) {\n    return t instanceof Jt || (t = hn(t)), t ? new yn((t = t.rgb()).r, t.g, t.b, t.opacity) : new yn()\n  }\n  function gn (t, n, e, r) {\n    return 1 === arguments.length ? vn(t) : new yn(t, n, e, null == r ? 1 : r)\n  }\n  function yn (t, n, e, r) {\n    ;(this.r = +t), (this.g = +n), (this.b = +e), (this.opacity = +r)\n  }\n  function _n (t) {\n    return ((t = Math.max(0, Math.min(255, Math.round(t) || 0))) < 16 ? '0' : '') + t.toString(16)\n  }\n  function bn (t, n, e, r) {\n    return r <= 0 ? (t = n = e = NaN) : e <= 0 || e >= 1 ? (t = n = NaN) : n <= 0 && (t = NaN), new xn(t, n, e, r)\n  }\n  function mn (t, n, e, r) {\n    return 1 === arguments.length\n      ? (function (t) {\n          if (t instanceof xn) return new xn(t.h, t.s, t.l, t.opacity)\n          if ((t instanceof Jt || (t = hn(t)), !t)) return new xn()\n          if (t instanceof xn) return t\n          var n = (t = t.rgb()).r / 255,\n            e = t.g / 255,\n            r = t.b / 255,\n            i = Math.min(n, e, r),\n            o = Math.max(n, e, r),\n            a = NaN,\n            u = o - i,\n            c = (o + i) / 2\n          return (\n            u\n              ? ((a = n === o ? (e - r) / u + 6 * (e < r) : e === o ? (r - n) / u + 2 : (n - e) / u + 4),\n                (u /= c < 0.5 ? o + i : 2 - o - i),\n                (a *= 60))\n              : (u = c > 0 && c < 1 ? 0 : a),\n            new xn(a, u, c, t.opacity)\n          )\n        })(t)\n      : new xn(t, n, e, null == r ? 1 : r)\n  }\n  function xn (t, n, e, r) {\n    ;(this.h = +t), (this.s = +n), (this.l = +e), (this.opacity = +r)\n  }\n  function wn (t, n, e) {\n    return 255 * (t < 60 ? n + ((e - n) * t) / 60 : t < 180 ? e : t < 240 ? n + ((e - n) * (240 - t)) / 60 : n)\n  }\n  Zt(Jt, hn, {\n    displayable: function () {\n      return this.rgb().displayable()\n    },\n    hex: function () {\n      return this.rgb().hex()\n    },\n    toString: function () {\n      return this.rgb() + ''\n    }\n  }),\n    Zt(\n      yn,\n      gn,\n      Qt(Jt, {\n        brighter: function (t) {\n          return (\n            (t = null == t ? 1 / 0.7 : Math.pow(1 / 0.7, t)), new yn(this.r * t, this.g * t, this.b * t, this.opacity)\n          )\n        },\n        darker: function (t) {\n          return (t = null == t ? 0.7 : Math.pow(0.7, t)), new yn(this.r * t, this.g * t, this.b * t, this.opacity)\n        },\n        rgb: function () {\n          return this\n        },\n        displayable: function () {\n          return (\n            0 <= this.r &&\n            this.r <= 255 &&\n            0 <= this.g &&\n            this.g <= 255 &&\n            0 <= this.b &&\n            this.b <= 255 &&\n            0 <= this.opacity &&\n            this.opacity <= 1\n          )\n        },\n        hex: function () {\n          return '#' + _n(this.r) + _n(this.g) + _n(this.b)\n        },\n        toString: function () {\n          var t = this.opacity\n          return (\n            (1 === (t = isNaN(t) ? 1 : Math.max(0, Math.min(1, t))) ? 'rgb(' : 'rgba(') +\n            Math.max(0, Math.min(255, Math.round(this.r) || 0)) +\n            ', ' +\n            Math.max(0, Math.min(255, Math.round(this.g) || 0)) +\n            ', ' +\n            Math.max(0, Math.min(255, Math.round(this.b) || 0)) +\n            (1 === t ? ')' : ', ' + t + ')')\n          )\n        }\n      })\n    ),\n    Zt(\n      xn,\n      mn,\n      Qt(Jt, {\n        brighter: function (t) {\n          return (t = null == t ? 1 / 0.7 : Math.pow(1 / 0.7, t)), new xn(this.h, this.s, this.l * t, this.opacity)\n        },\n        darker: function (t) {\n          return (t = null == t ? 0.7 : Math.pow(0.7, t)), new xn(this.h, this.s, this.l * t, this.opacity)\n        },\n        rgb: function () {\n          var t = (this.h % 360) + 360 * (this.h < 0),\n            n = isNaN(t) || isNaN(this.s) ? 0 : this.s,\n            e = this.l,\n            r = e + (e < 0.5 ? e : 1 - e) * n,\n            i = 2 * e - r\n          return new yn(\n            wn(t >= 240 ? t - 240 : t + 120, i, r),\n            wn(t, i, r),\n            wn(t < 120 ? t + 240 : t - 120, i, r),\n            this.opacity\n          )\n        },\n        displayable: function () {\n          return (\n            ((0 <= this.s && this.s <= 1) || isNaN(this.s)) &&\n            0 <= this.l &&\n            this.l <= 1 &&\n            0 <= this.opacity &&\n            this.opacity <= 1\n          )\n        }\n      })\n    )\n  var Mn = Math.PI / 180,\n    Nn = 180 / Math.PI,\n    An = 0.96422,\n    Sn = 1,\n    kn = 0.82521,\n    Tn = 4 / 29,\n    En = 6 / 29,\n    Cn = 3 * En * En,\n    Pn = En * En * En\n  function zn (t) {\n    if (t instanceof Dn) return new Dn(t.l, t.a, t.b, t.opacity)\n    if (t instanceof Fn) {\n      if (isNaN(t.h)) return new Dn(t.l, 0, 0, t.opacity)\n      var n = t.h * Mn\n      return new Dn(t.l, Math.cos(n) * t.c, Math.sin(n) * t.c, t.opacity)\n    }\n    t instanceof yn || (t = vn(t))\n    var e,\n      r,\n      i = On(t.r),\n      o = On(t.g),\n      a = On(t.b),\n      u = qn((0.2225045 * i + 0.7168786 * o + 0.0606169 * a) / Sn)\n    return (\n      i === o && o === a\n        ? (e = r = u)\n        : ((e = qn((0.4360747 * i + 0.3850649 * o + 0.1430804 * a) / An)),\n          (r = qn((0.0139322 * i + 0.0971045 * o + 0.7141733 * a) / kn))),\n      new Dn(116 * u - 16, 500 * (e - u), 200 * (u - r), t.opacity)\n    )\n  }\n  function Rn (t, n, e, r) {\n    return 1 === arguments.length ? zn(t) : new Dn(t, n, e, null == r ? 1 : r)\n  }\n  function Dn (t, n, e, r) {\n    ;(this.l = +t), (this.a = +n), (this.b = +e), (this.opacity = +r)\n  }\n  function qn (t) {\n    return t > Pn ? Math.pow(t, 1 / 3) : t / Cn + Tn\n  }\n  function Ln (t) {\n    return t > En ? t * t * t : Cn * (t - Tn)\n  }\n  function Un (t) {\n    return 255 * (t <= 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 1 / 2.4) - 0.055)\n  }\n  function On (t) {\n    return (t /= 255) <= 0.04045 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4)\n  }\n  function Bn (t) {\n    if (t instanceof Fn) return new Fn(t.h, t.c, t.l, t.opacity)\n    if ((t instanceof Dn || (t = zn(t)), 0 === t.a && 0 === t.b)) return new Fn(NaN, 0, t.l, t.opacity)\n    var n = Math.atan2(t.b, t.a) * Nn\n    return new Fn(n < 0 ? n + 360 : n, Math.sqrt(t.a * t.a + t.b * t.b), t.l, t.opacity)\n  }\n  function Yn (t, n, e, r) {\n    return 1 === arguments.length ? Bn(t) : new Fn(t, n, e, null == r ? 1 : r)\n  }\n  function Fn (t, n, e, r) {\n    ;(this.h = +t), (this.c = +n), (this.l = +e), (this.opacity = +r)\n  }\n  Zt(\n    Dn,\n    Rn,\n    Qt(Jt, {\n      brighter: function (t) {\n        return new Dn(this.l + 18 * (null == t ? 1 : t), this.a, this.b, this.opacity)\n      },\n      darker: function (t) {\n        return new Dn(this.l - 18 * (null == t ? 1 : t), this.a, this.b, this.opacity)\n      },\n      rgb: function () {\n        var t = (this.l + 16) / 116,\n          n = isNaN(this.a) ? t : t + this.a / 500,\n          e = isNaN(this.b) ? t : t - this.b / 200\n        return new yn(\n          Un(3.1338561 * (n = An * Ln(n)) - 1.6168667 * (t = Sn * Ln(t)) - 0.4906146 * (e = kn * Ln(e))),\n          Un(-0.9787684 * n + 1.9161415 * t + 0.033454 * e),\n          Un(0.0719453 * n - 0.2289914 * t + 1.4052427 * e),\n          this.opacity\n        )\n      }\n    })\n  ),\n    Zt(\n      Fn,\n      Yn,\n      Qt(Jt, {\n        brighter: function (t) {\n          return new Fn(this.h, this.c, this.l + 18 * (null == t ? 1 : t), this.opacity)\n        },\n        darker: function (t) {\n          return new Fn(this.h, this.c, this.l - 18 * (null == t ? 1 : t), this.opacity)\n        },\n        rgb: function () {\n          return zn(this).rgb()\n        }\n      })\n    )\n  var In = -0.14861,\n    jn = 1.78277,\n    Hn = -0.29227,\n    Xn = -0.90649,\n    Gn = 1.97294,\n    Vn = Gn * Xn,\n    $n = Gn * jn,\n    Wn = jn * Hn - Xn * In\n  function Zn (t, n, e, r) {\n    return 1 === arguments.length\n      ? (function (t) {\n          if (t instanceof Qn) return new Qn(t.h, t.s, t.l, t.opacity)\n          t instanceof yn || (t = vn(t))\n          var n = t.r / 255,\n            e = t.g / 255,\n            r = t.b / 255,\n            i = (Wn * r + Vn * n - $n * e) / (Wn + Vn - $n),\n            o = r - i,\n            a = (Gn * (e - i) - Hn * o) / Xn,\n            u = Math.sqrt(a * a + o * o) / (Gn * i * (1 - i)),\n            c = u ? Math.atan2(a, o) * Nn - 120 : NaN\n          return new Qn(c < 0 ? c + 360 : c, u, i, t.opacity)\n        })(t)\n      : new Qn(t, n, e, null == r ? 1 : r)\n  }\n  function Qn (t, n, e, r) {\n    ;(this.h = +t), (this.s = +n), (this.l = +e), (this.opacity = +r)\n  }\n  function Jn (t, n, e, r, i) {\n    var o = t * t,\n      a = o * t\n    return ((1 - 3 * t + 3 * o - a) * n + (4 - 6 * o + 3 * a) * e + (1 + 3 * t + 3 * o - 3 * a) * r + a * i) / 6\n  }\n  function Kn (t) {\n    var n = t.length - 1\n    return function (e) {\n      var r = e <= 0 ? (e = 0) : e >= 1 ? ((e = 1), n - 1) : Math.floor(e * n),\n        i = t[r],\n        o = t[r + 1],\n        a = r > 0 ? t[r - 1] : 2 * i - o,\n        u = r < n - 1 ? t[r + 2] : 2 * o - i\n      return Jn((e - r / n) * n, a, i, o, u)\n    }\n  }\n  function te (t) {\n    var n = t.length\n    return function (e) {\n      var r = Math.floor(((e %= 1) < 0 ? ++e : e) * n),\n        i = t[(r + n - 1) % n],\n        o = t[r % n],\n        a = t[(r + 1) % n],\n        u = t[(r + 2) % n]\n      return Jn((e - r / n) * n, i, o, a, u)\n    }\n  }\n  function ne (t) {\n    return function () {\n      return t\n    }\n  }\n  function ee (t, n) {\n    return function (e) {\n      return t + e * n\n    }\n  }\n  function re (t, n) {\n    var e = n - t\n    return e ? ee(t, e > 180 || e < -180 ? e - 360 * Math.round(e / 360) : e) : ne(isNaN(t) ? n : t)\n  }\n  function ie (t) {\n    return 1 == (t = +t)\n      ? oe\n      : function (n, e) {\n          return e - n\n            ? (function (t, n, e) {\n                return (\n                  (t = Math.pow(t, e)),\n                  (n = Math.pow(n, e) - t),\n                  (e = 1 / e),\n                  function (r) {\n                    return Math.pow(t + r * n, e)\n                  }\n                )\n              })(n, e, t)\n            : ne(isNaN(n) ? e : n)\n        }\n  }\n  function oe (t, n) {\n    var e = n - t\n    return e ? ee(t, e) : ne(isNaN(t) ? n : t)\n  }\n  Zt(\n    Qn,\n    Zn,\n    Qt(Jt, {\n      brighter: function (t) {\n        return (t = null == t ? 1 / 0.7 : Math.pow(1 / 0.7, t)), new Qn(this.h, this.s, this.l * t, this.opacity)\n      },\n      darker: function (t) {\n        return (t = null == t ? 0.7 : Math.pow(0.7, t)), new Qn(this.h, this.s, this.l * t, this.opacity)\n      },\n      rgb: function () {\n        var t = isNaN(this.h) ? 0 : (this.h + 120) * Mn,\n          n = +this.l,\n          e = isNaN(this.s) ? 0 : this.s * n * (1 - n),\n          r = Math.cos(t),\n          i = Math.sin(t)\n        return new yn(\n          255 * (n + e * (In * r + jn * i)),\n          255 * (n + e * (Hn * r + Xn * i)),\n          255 * (n + e * (Gn * r)),\n          this.opacity\n        )\n      }\n    })\n  )\n  var ae = (function t (n) {\n    var e = ie(n)\n    function r (t, n) {\n      var r = e((t = gn(t)).r, (n = gn(n)).r),\n        i = e(t.g, n.g),\n        o = e(t.b, n.b),\n        a = oe(t.opacity, n.opacity)\n      return function (n) {\n        return (t.r = r(n)), (t.g = i(n)), (t.b = o(n)), (t.opacity = a(n)), t + ''\n      }\n    }\n    return (r.gamma = t), r\n  })(1)\n  function ue (t) {\n    return function (n) {\n      var e,\n        r,\n        i = n.length,\n        o = new Array(i),\n        a = new Array(i),\n        u = new Array(i)\n      for (e = 0; e < i; ++e) (r = gn(n[e])), (o[e] = r.r || 0), (a[e] = r.g || 0), (u[e] = r.b || 0)\n      return (\n        (o = t(o)),\n        (a = t(a)),\n        (u = t(u)),\n        (r.opacity = 1),\n        function (t) {\n          return (r.r = o(t)), (r.g = a(t)), (r.b = u(t)), r + ''\n        }\n      )\n    }\n  }\n  var ce = ue(Kn),\n    fe = ue(te)\n  function se (t, n) {\n    var e,\n      r = n ? n.length : 0,\n      i = t ? Math.min(r, t.length) : 0,\n      o = new Array(i),\n      a = new Array(r)\n    for (e = 0; e < i; ++e) o[e] = ye(t[e], n[e])\n    for (; e < r; ++e) a[e] = n[e]\n    return function (t) {\n      for (e = 0; e < i; ++e) a[e] = o[e](t)\n      return a\n    }\n  }\n  function le (t, n) {\n    var e = new Date()\n    return (\n      (n -= t = +t),\n      function (r) {\n        return e.setTime(t + n * r), e\n      }\n    )\n  }\n  function he (t, n) {\n    return (\n      (n -= t = +t),\n      function (e) {\n        return t + n * e\n      }\n    )\n  }\n  function de (t, n) {\n    var e,\n      r = {},\n      i = {}\n    for (e in ((null !== t && 'object' == typeof t) || (t = {}), (null !== n && 'object' == typeof n) || (n = {}), n))\n      e in t ? (r[e] = ye(t[e], n[e])) : (i[e] = n[e])\n    return function (t) {\n      for (e in r) i[e] = r[e](t)\n      return i\n    }\n  }\n  var pe = /[-+]?(?:\\d+\\.?\\d*|\\.?\\d+)(?:[eE][-+]?\\d+)?/g,\n    ve = new RegExp(pe.source, 'g')\n  function ge (t, n) {\n    var e,\n      r,\n      i,\n      o = (pe.lastIndex = ve.lastIndex = 0),\n      a = -1,\n      u = [],\n      c = []\n    for (t += '', n += ''; (e = pe.exec(t)) && (r = ve.exec(n)); )\n      (i = r.index) > o && ((i = n.slice(o, i)), u[a] ? (u[a] += i) : (u[++a] = i)),\n        (e = e[0]) === (r = r[0])\n          ? u[a]\n            ? (u[a] += r)\n            : (u[++a] = r)\n          : ((u[++a] = null), c.push({ i: a, x: he(e, r) })),\n        (o = ve.lastIndex)\n    return (\n      o < n.length && ((i = n.slice(o)), u[a] ? (u[a] += i) : (u[++a] = i)),\n      u.length < 2\n        ? c[0]\n          ? (function (t) {\n              return function (n) {\n                return t(n) + ''\n              }\n            })(c[0].x)\n          : (function (t) {\n              return function () {\n                return t\n              }\n            })(n)\n        : ((n = c.length),\n          function (t) {\n            for (var e, r = 0; r < n; ++r) u[(e = c[r]).i] = e.x(t)\n            return u.join('')\n          })\n    )\n  }\n  function ye (t, n) {\n    var e,\n      r = typeof n\n    return null == n || 'boolean' === r\n      ? ne(n)\n      : ('number' === r\n          ? he\n          : 'string' === r\n          ? (e = hn(n))\n            ? ((n = e), ae)\n            : ge\n          : n instanceof hn\n          ? ae\n          : n instanceof Date\n          ? le\n          : Array.isArray(n)\n          ? se\n          : ('function' != typeof n.valueOf && 'function' != typeof n.toString) || isNaN(n)\n          ? de\n          : he)(t, n)\n  }\n  function _e (t, n) {\n    return (\n      (n -= t = +t),\n      function (e) {\n        return Math.round(t + n * e)\n      }\n    )\n  }\n  var be,\n    me,\n    xe,\n    we,\n    Me = 180 / Math.PI,\n    Ne = { translateX: 0, translateY: 0, rotate: 0, skewX: 0, scaleX: 1, scaleY: 1 }\n  function Ae (t, n, e, r, i, o) {\n    var a, u, c\n    return (\n      (a = Math.sqrt(t * t + n * n)) && ((t /= a), (n /= a)),\n      (c = t * e + n * r) && ((e -= t * c), (r -= n * c)),\n      (u = Math.sqrt(e * e + r * r)) && ((e /= u), (r /= u), (c /= u)),\n      t * r < n * e && ((t = -t), (n = -n), (c = -c), (a = -a)),\n      { translateX: i, translateY: o, rotate: Math.atan2(n, t) * Me, skewX: Math.atan(c) * Me, scaleX: a, scaleY: u }\n    )\n  }\n  function Se (t, n, e, r) {\n    function i (t) {\n      return t.length ? t.pop() + ' ' : ''\n    }\n    return function (o, a) {\n      var u = [],\n        c = []\n      return (\n        (o = t(o)),\n        (a = t(a)),\n        (function (t, r, i, o, a, u) {\n          if (t !== i || r !== o) {\n            var c = a.push('translate(', null, n, null, e)\n            u.push({ i: c - 4, x: he(t, i) }, { i: c - 2, x: he(r, o) })\n          } else (i || o) && a.push('translate(' + i + n + o + e)\n        })(o.translateX, o.translateY, a.translateX, a.translateY, u, c),\n        (function (t, n, e, o) {\n          t !== n\n            ? (t - n > 180 ? (n += 360) : n - t > 180 && (t += 360),\n              o.push({ i: e.push(i(e) + 'rotate(', null, r) - 2, x: he(t, n) }))\n            : n && e.push(i(e) + 'rotate(' + n + r)\n        })(o.rotate, a.rotate, u, c),\n        (function (t, n, e, o) {\n          t !== n\n            ? o.push({ i: e.push(i(e) + 'skewX(', null, r) - 2, x: he(t, n) })\n            : n && e.push(i(e) + 'skewX(' + n + r)\n        })(o.skewX, a.skewX, u, c),\n        (function (t, n, e, r, o, a) {\n          if (t !== e || n !== r) {\n            var u = o.push(i(o) + 'scale(', null, ',', null, ')')\n            a.push({ i: u - 4, x: he(t, e) }, { i: u - 2, x: he(n, r) })\n          } else (1 === e && 1 === r) || o.push(i(o) + 'scale(' + e + ',' + r + ')')\n        })(o.scaleX, o.scaleY, a.scaleX, a.scaleY, u, c),\n        (o = a = null),\n        function (t) {\n          for (var n, e = -1, r = c.length; ++e < r; ) u[(n = c[e]).i] = n.x(t)\n          return u.join('')\n        }\n      )\n    }\n  }\n  var ke = Se(\n      function (t) {\n        return 'none' === t\n          ? Ne\n          : (be || ((be = document.createElement('DIV')), (me = document.documentElement), (xe = document.defaultView)),\n            (be.style.transform = t),\n            (t = xe.getComputedStyle(me.appendChild(be), null).getPropertyValue('transform')),\n            me.removeChild(be),\n            Ae(+(t = t.slice(7, -1).split(','))[0], +t[1], +t[2], +t[3], +t[4], +t[5]))\n      },\n      'px, ',\n      'px)',\n      'deg)'\n    ),\n    Te = Se(\n      function (t) {\n        return null == t\n          ? Ne\n          : (we || (we = document.createElementNS('http://www.w3.org/2000/svg', 'g')),\n            we.setAttribute('transform', t),\n            (t = we.transform.baseVal.consolidate()) ? Ae((t = t.matrix).a, t.b, t.c, t.d, t.e, t.f) : Ne)\n      },\n      ', ',\n      ')',\n      ')'\n    ),\n    Ee = Math.SQRT2,\n    Ce = 2,\n    Pe = 4,\n    ze = 1e-12\n  function Re (t) {\n    return ((t = Math.exp(t)) + 1 / t) / 2\n  }\n  function De (t, n) {\n    var e,\n      r,\n      i = t[0],\n      o = t[1],\n      a = t[2],\n      u = n[0],\n      c = n[1],\n      f = n[2],\n      s = u - i,\n      l = c - o,\n      h = s * s + l * l\n    if (h < ze)\n      (r = Math.log(f / a) / Ee),\n        (e = function (t) {\n          return [i + t * s, o + t * l, a * Math.exp(Ee * t * r)]\n        })\n    else {\n      var d = Math.sqrt(h),\n        p = (f * f - a * a + Pe * h) / (2 * a * Ce * d),\n        v = (f * f - a * a - Pe * h) / (2 * f * Ce * d),\n        g = Math.log(Math.sqrt(p * p + 1) - p),\n        y = Math.log(Math.sqrt(v * v + 1) - v)\n      ;(r = (y - g) / Ee),\n        (e = function (t) {\n          var n,\n            e = t * r,\n            u = Re(g),\n            c =\n              (a / (Ce * d)) *\n              (u * ((n = Ee * e + g), ((n = Math.exp(2 * n)) - 1) / (n + 1)) -\n                (function (t) {\n                  return ((t = Math.exp(t)) - 1 / t) / 2\n                })(g))\n          return [i + c * s, o + c * l, (a * u) / Re(Ee * e + g)]\n        })\n    }\n    return (e.duration = 1e3 * r), e\n  }\n  function qe (t) {\n    return function (n, e) {\n      var r = t((n = mn(n)).h, (e = mn(e)).h),\n        i = oe(n.s, e.s),\n        o = oe(n.l, e.l),\n        a = oe(n.opacity, e.opacity)\n      return function (t) {\n        return (n.h = r(t)), (n.s = i(t)), (n.l = o(t)), (n.opacity = a(t)), n + ''\n      }\n    }\n  }\n  var Le = qe(re),\n    Ue = qe(oe)\n  function Oe (t) {\n    return function (n, e) {\n      var r = t((n = Yn(n)).h, (e = Yn(e)).h),\n        i = oe(n.c, e.c),\n        o = oe(n.l, e.l),\n        a = oe(n.opacity, e.opacity)\n      return function (t) {\n        return (n.h = r(t)), (n.c = i(t)), (n.l = o(t)), (n.opacity = a(t)), n + ''\n      }\n    }\n  }\n  var Be = Oe(re),\n    Ye = Oe(oe)\n  function Fe (t) {\n    return (function n (e) {\n      function r (n, r) {\n        var i = t((n = Zn(n)).h, (r = Zn(r)).h),\n          o = oe(n.s, r.s),\n          a = oe(n.l, r.l),\n          u = oe(n.opacity, r.opacity)\n        return function (t) {\n          return (n.h = i(t)), (n.s = o(t)), (n.l = a(Math.pow(t, e))), (n.opacity = u(t)), n + ''\n        }\n      }\n      return (e = +e), (r.gamma = n), r\n    })(1)\n  }\n  var Ie = Fe(re),\n    je = Fe(oe)\n  var He,\n    Xe,\n    Ge = 0,\n    Ve = 0,\n    $e = 0,\n    We = 1e3,\n    Ze = 0,\n    Qe = 0,\n    Je = 0,\n    Ke = 'object' == typeof performance && performance.now ? performance : Date,\n    tr =\n      'object' == typeof window && window.requestAnimationFrame\n        ? window.requestAnimationFrame.bind(window)\n        : function (t) {\n            setTimeout(t, 17)\n          }\n  function nr () {\n    return Qe || (tr(er), (Qe = Ke.now() + Je))\n  }\n  function er () {\n    Qe = 0\n  }\n  function rr () {\n    this._call = this._time = this._next = null\n  }\n  function ir (t, n, e) {\n    var r = new rr()\n    return r.restart(t, n, e), r\n  }\n  function or () {\n    nr(), ++Ge\n    for (var t, n = He; n; ) (t = Qe - n._time) >= 0 && n._call.call(null, t), (n = n._next)\n    --Ge\n  }\n  function ar () {\n    ;(Qe = (Ze = Ke.now()) + Je), (Ge = Ve = 0)\n    try {\n      or()\n    } finally {\n      ;(Ge = 0),\n        (function () {\n          var t,\n            n,\n            e = He,\n            r = 1 / 0\n          for (; e; )\n            e._call\n              ? (r > e._time && (r = e._time), (t = e), (e = e._next))\n              : ((n = e._next), (e._next = null), (e = t ? (t._next = n) : (He = n)))\n          ;(Xe = t), cr(r)\n        })(),\n        (Qe = 0)\n    }\n  }\n  function ur () {\n    var t = Ke.now(),\n      n = t - Ze\n    n > We && ((Je -= n), (Ze = t))\n  }\n  function cr (t) {\n    Ge ||\n      (Ve && (Ve = clearTimeout(Ve)),\n      t - Qe > 24\n        ? (t < 1 / 0 && (Ve = setTimeout(ar, t - Ke.now() - Je)), $e && ($e = clearInterval($e)))\n        : ($e || ((Ze = Ke.now()), ($e = setInterval(ur, We))), (Ge = 1), tr(ar)))\n  }\n  function fr (t, n, e) {\n    var r = new rr()\n    return (\n      (n = null == n ? 0 : +n),\n      r.restart(\n        function (e) {\n          r.stop(), t(e + n)\n        },\n        n,\n        e\n      ),\n      r\n    )\n  }\n  rr.prototype = ir.prototype = {\n    constructor: rr,\n    restart: function (t, n, e) {\n      if ('function' != typeof t) throw new TypeError('callback is not a function')\n      ;(e = (null == e ? nr() : +e) + (null == n ? 0 : +n)),\n        this._next || Xe === this || (Xe ? (Xe._next = this) : (He = this), (Xe = this)),\n        (this._call = t),\n        (this._time = e),\n        cr()\n    },\n    stop: function () {\n      this._call && ((this._call = null), (this._time = 1 / 0), cr())\n    }\n  }\n  var sr = I('start', 'end', 'cancel', 'interrupt'),\n    lr = [],\n    hr = 0,\n    dr = 1,\n    pr = 2,\n    vr = 3,\n    gr = 4,\n    yr = 5,\n    _r = 6\n  function br (t, n, e, r, i, o) {\n    var a = t.__transition\n    if (a) {\n      if (e in a) return\n    } else t.__transition = {}\n    !(function (t, n, e) {\n      var r,\n        i = t.__transition\n      function o (c) {\n        var f, s, l, h\n        if (e.state !== dr) return u()\n        for (f in i)\n          if ((h = i[f]).name === e.name) {\n            if (h.state === vr) return fr(o)\n            h.state === gr\n              ? ((h.state = _r), h.timer.stop(), h.on.call('interrupt', t, t.__data__, h.index, h.group), delete i[f])\n              : +f < n &&\n                ((h.state = _r), h.timer.stop(), h.on.call('cancel', t, t.__data__, h.index, h.group), delete i[f])\n          }\n        if (\n          (fr(function () {\n            e.state === vr && ((e.state = gr), e.timer.restart(a, e.delay, e.time), a(c))\n          }),\n          (e.state = pr),\n          e.on.call('start', t, t.__data__, e.index, e.group),\n          e.state === pr)\n        ) {\n          for (e.state = vr, r = new Array((l = e.tween.length)), f = 0, s = -1; f < l; ++f)\n            (h = e.tween[f].value.call(t, t.__data__, e.index, e.group)) && (r[++s] = h)\n          r.length = s + 1\n        }\n      }\n      function a (n) {\n        for (\n          var i = n < e.duration ? e.ease.call(null, n / e.duration) : (e.timer.restart(u), (e.state = yr), 1),\n            o = -1,\n            a = r.length;\n          ++o < a;\n\n        )\n          r[o].call(t, i)\n        e.state === yr && (e.on.call('end', t, t.__data__, e.index, e.group), u())\n      }\n      function u () {\n        for (var r in ((e.state = _r), e.timer.stop(), delete i[n], i)) return\n        delete t.__transition\n      }\n      ;(i[n] = e),\n        (e.timer = ir(\n          function (t) {\n            ;(e.state = dr), e.timer.restart(o, e.delay, e.time), e.delay <= t && o(t - e.delay)\n          },\n          0,\n          e.time\n        ))\n    })(t, e, {\n      name: n,\n      index: r,\n      group: i,\n      on: sr,\n      tween: lr,\n      time: o.time,\n      delay: o.delay,\n      duration: o.duration,\n      ease: o.ease,\n      timer: null,\n      state: hr\n    })\n  }\n  function mr (t, n) {\n    var e = wr(t, n)\n    if (e.state > hr) throw new Error('too late; already scheduled')\n    return e\n  }\n  function xr (t, n) {\n    var e = wr(t, n)\n    if (e.state > vr) throw new Error('too late; already running')\n    return e\n  }\n  function wr (t, n) {\n    var e = t.__transition\n    if (!e || !(e = e[n])) throw new Error('transition not found')\n    return e\n  }\n  function Mr (t, n) {\n    var e,\n      r,\n      i,\n      o = t.__transition,\n      a = !0\n    if (o) {\n      for (i in ((n = null == n ? null : n + ''), o))\n        (e = o[i]).name === n\n          ? ((r = e.state > pr && e.state < yr),\n            (e.state = _r),\n            e.timer.stop(),\n            e.on.call(r ? 'interrupt' : 'cancel', t, t.__data__, e.index, e.group),\n            delete o[i])\n          : (a = !1)\n      a && delete t.__transition\n    }\n  }\n  function Nr (t, n, e) {\n    var r = t._id\n    return (\n      t.each(function () {\n        var t = xr(this, r)\n        ;(t.value || (t.value = {}))[n] = e.apply(this, arguments)\n      }),\n      function (t) {\n        return wr(t, r).value[n]\n      }\n    )\n  }\n  function Ar (t, n) {\n    var e\n    return ('number' == typeof n ? he : n instanceof hn ? ae : (e = hn(n)) ? ((n = e), ae) : ge)(t, n)\n  }\n  var Sr = Pt.prototype.constructor\n  function kr (t) {\n    return function () {\n      this.style.removeProperty(t)\n    }\n  }\n  var Tr = 0\n  function Er (t, n, e, r) {\n    ;(this._groups = t), (this._parents = n), (this._name = e), (this._id = r)\n  }\n  function Cr (t) {\n    return Pt().transition(t)\n  }\n  function Pr () {\n    return ++Tr\n  }\n  var zr = Pt.prototype\n  function Rr (t) {\n    return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2\n  }\n  function Dr (t) {\n    return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2\n  }\n  Er.prototype = Cr.prototype = {\n    constructor: Er,\n    select: function (t) {\n      var n = this._name,\n        e = this._id\n      'function' != typeof t && (t = Q(t))\n      for (var r = this._groups, i = r.length, o = new Array(i), a = 0; a < i; ++a)\n        for (var u, c, f = r[a], s = f.length, l = (o[a] = new Array(s)), h = 0; h < s; ++h)\n          (u = f[h]) &&\n            (c = t.call(u, u.__data__, h, f)) &&\n            ('__data__' in u && (c.__data__ = u.__data__), (l[h] = c), br(l[h], n, e, h, l, wr(u, e)))\n      return new Er(o, this._parents, n, e)\n    },\n    selectAll: function (t) {\n      var n = this._name,\n        e = this._id\n      'function' != typeof t && (t = K(t))\n      for (var r = this._groups, i = r.length, o = [], a = [], u = 0; u < i; ++u)\n        for (var c, f = r[u], s = f.length, l = 0; l < s; ++l)\n          if ((c = f[l])) {\n            for (var h, d = t.call(c, c.__data__, l, f), p = wr(c, e), v = 0, g = d.length; v < g; ++v)\n              (h = d[v]) && br(h, n, e, v, d, p)\n            o.push(d), a.push(c)\n          }\n      return new Er(o, a, n, e)\n    },\n    filter: function (t) {\n      'function' != typeof t && (t = tt(t))\n      for (var n = this._groups, e = n.length, r = new Array(e), i = 0; i < e; ++i)\n        for (var o, a = n[i], u = a.length, c = (r[i] = []), f = 0; f < u; ++f)\n          (o = a[f]) && t.call(o, o.__data__, f, a) && c.push(o)\n      return new Er(r, this._parents, this._name, this._id)\n    },\n    merge: function (t) {\n      if (t._id !== this._id) throw new Error()\n      for (\n        var n = this._groups, e = t._groups, r = n.length, i = e.length, o = Math.min(r, i), a = new Array(r), u = 0;\n        u < o;\n        ++u\n      )\n        for (var c, f = n[u], s = e[u], l = f.length, h = (a[u] = new Array(l)), d = 0; d < l; ++d)\n          (c = f[d] || s[d]) && (h[d] = c)\n      for (; u < r; ++u) a[u] = n[u]\n      return new Er(a, this._parents, this._name, this._id)\n    },\n    selection: function () {\n      return new Sr(this._groups, this._parents)\n    },\n    transition: function () {\n      for (var t = this._name, n = this._id, e = Pr(), r = this._groups, i = r.length, o = 0; o < i; ++o)\n        for (var a, u = r[o], c = u.length, f = 0; f < c; ++f)\n          if ((a = u[f])) {\n            var s = wr(a, n)\n            br(a, t, e, f, u, { time: s.time + s.delay + s.duration, delay: 0, duration: s.duration, ease: s.ease })\n          }\n      return new Er(r, this._parents, t, e)\n    },\n    call: zr.call,\n    nodes: zr.nodes,\n    node: zr.node,\n    size: zr.size,\n    empty: zr.empty,\n    each: zr.each,\n    on: function (t, n) {\n      var e = this._id\n      return arguments.length < 2\n        ? wr(this.node(), e).on.on(t)\n        : this.each(\n            (function (t, n, e) {\n              var r,\n                i,\n                o = (function (t) {\n                  return (t + '')\n                    .trim()\n                    .split(/^|\\s+/)\n                    .every(function (t) {\n                      var n = t.indexOf('.')\n                      return n >= 0 && (t = t.slice(0, n)), !t || 'start' === t\n                    })\n                })(n)\n                  ? mr\n                  : xr\n              return function () {\n                var a = o(this, t),\n                  u = a.on\n                u !== r && (i = (r = u).copy()).on(n, e), (a.on = i)\n              }\n            })(e, t, n)\n          )\n    },\n    attr: function (t, n) {\n      var e = $(t),\n        r = 'transform' === e ? Te : Ar\n      return this.attrTween(\n        t,\n        'function' == typeof n\n          ? (e.local\n              ? function (t, n, e) {\n                  var r, i, o\n                  return function () {\n                    var a,\n                      u,\n                      c = e(this)\n                    if (null != c)\n                      return (a = this.getAttributeNS(t.space, t.local)) === (u = c + '')\n                        ? null\n                        : a === r && u === i\n                        ? o\n                        : ((i = u), (o = n((r = a), c)))\n                    this.removeAttributeNS(t.space, t.local)\n                  }\n                }\n              : function (t, n, e) {\n                  var r, i, o\n                  return function () {\n                    var a,\n                      u,\n                      c = e(this)\n                    if (null != c)\n                      return (a = this.getAttribute(t)) === (u = c + '')\n                        ? null\n                        : a === r && u === i\n                        ? o\n                        : ((i = u), (o = n((r = a), c)))\n                    this.removeAttribute(t)\n                  }\n                })(e, r, Nr(this, 'attr.' + t, n))\n          : null == n\n          ? (e.local\n              ? function (t) {\n                  return function () {\n                    this.removeAttributeNS(t.space, t.local)\n                  }\n                }\n              : function (t) {\n                  return function () {\n                    this.removeAttribute(t)\n                  }\n                })(e)\n          : (e.local\n              ? function (t, n, e) {\n                  var r,\n                    i,\n                    o = e + ''\n                  return function () {\n                    var a = this.getAttributeNS(t.space, t.local)\n                    return a === o ? null : a === r ? i : (i = n((r = a), e))\n                  }\n                }\n              : function (t, n, e) {\n                  var r,\n                    i,\n                    o = e + ''\n                  return function () {\n                    var a = this.getAttribute(t)\n                    return a === o ? null : a === r ? i : (i = n((r = a), e))\n                  }\n                })(e, r, n)\n      )\n    },\n    attrTween: function (t, n) {\n      var e = 'attr.' + t\n      if (arguments.length < 2) return (e = this.tween(e)) && e._value\n      if (null == n) return this.tween(e, null)\n      if ('function' != typeof n) throw new Error()\n      var r = $(t)\n      return this.tween(\n        e,\n        (r.local\n          ? function (t, n) {\n              var e, r\n              function i () {\n                var i = n.apply(this, arguments)\n                return (\n                  i !== r &&\n                    (e =\n                      (r = i) &&\n                      (function (t, n) {\n                        return function (e) {\n                          this.setAttributeNS(t.space, t.local, n(e))\n                        }\n                      })(t, i)),\n                  e\n                )\n              }\n              return (i._value = n), i\n            }\n          : function (t, n) {\n              var e, r\n              function i () {\n                var i = n.apply(this, arguments)\n                return (\n                  i !== r &&\n                    (e =\n                      (r = i) &&\n                      (function (t, n) {\n                        return function (e) {\n                          this.setAttribute(t, n(e))\n                        }\n                      })(t, i)),\n                  e\n                )\n              }\n              return (i._value = n), i\n            })(r, n)\n      )\n    },\n    style: function (t, n, e) {\n      var r = 'transform' == (t += '') ? ke : Ar\n      return null == n\n        ? this.styleTween(\n            t,\n            (function (t, n) {\n              var e, r, i\n              return function () {\n                var o = ct(this, t),\n                  a = (this.style.removeProperty(t), ct(this, t))\n                return o === a ? null : o === e && a === r ? i : (i = n((e = o), (r = a)))\n              }\n            })(t, r)\n          ).on('end.style.' + t, kr(t))\n        : 'function' == typeof n\n        ? this.styleTween(\n            t,\n            (function (t, n, e) {\n              var r, i, o\n              return function () {\n                var a = ct(this, t),\n                  u = e(this),\n                  c = u + ''\n                return (\n                  null == u && (this.style.removeProperty(t), (c = u = ct(this, t))),\n                  a === c ? null : a === r && c === i ? o : ((i = c), (o = n((r = a), u)))\n                )\n              }\n            })(t, r, Nr(this, 'style.' + t, n))\n          ).each(\n            (function (t, n) {\n              var e,\n                r,\n                i,\n                o,\n                a = 'style.' + n,\n                u = 'end.' + a\n              return function () {\n                var c = xr(this, t),\n                  f = c.on,\n                  s = null == c.value[a] ? o || (o = kr(n)) : void 0\n                ;(f === e && i === s) || (r = (e = f).copy()).on(u, (i = s)), (c.on = r)\n              }\n            })(this._id, t)\n          )\n        : this.styleTween(\n            t,\n            (function (t, n, e) {\n              var r,\n                i,\n                o = e + ''\n              return function () {\n                var a = ct(this, t)\n                return a === o ? null : a === r ? i : (i = n((r = a), e))\n              }\n            })(t, r, n),\n            e\n          ).on('end.style.' + t, null)\n    },\n    styleTween: function (t, n, e) {\n      var r = 'style.' + (t += '')\n      if (arguments.length < 2) return (r = this.tween(r)) && r._value\n      if (null == n) return this.tween(r, null)\n      if ('function' != typeof n) throw new Error()\n      return this.tween(\n        r,\n        (function (t, n, e) {\n          var r, i\n          function o () {\n            var o = n.apply(this, arguments)\n            return (\n              o !== i &&\n                (r =\n                  (i = o) &&\n                  (function (t, n, e) {\n                    return function (r) {\n                      this.style.setProperty(t, n(r), e)\n                    }\n                  })(t, o, e)),\n              r\n            )\n          }\n          return (o._value = n), o\n        })(t, n, null == e ? '' : e)\n      )\n    },\n    text: function (t) {\n      return this.tween(\n        'text',\n        'function' == typeof t\n          ? (function (t) {\n              return function () {\n                var n = t(this)\n                this.textContent = null == n ? '' : n\n              }\n            })(Nr(this, 'text', t))\n          : (function (t) {\n              return function () {\n                this.textContent = t\n              }\n            })(null == t ? '' : t + '')\n      )\n    },\n    remove: function () {\n      return this.on(\n        'end.remove',\n        ((t = this._id),\n        function () {\n          var n = this.parentNode\n          for (var e in this.__transition) if (+e !== t) return\n          n && n.removeChild(this)\n        })\n      )\n      var t\n    },\n    tween: function (t, n) {\n      var e = this._id\n      if (((t += ''), arguments.length < 2)) {\n        for (var r, i = wr(this.node(), e).tween, o = 0, a = i.length; o < a; ++o)\n          if ((r = i[o]).name === t) return r.value\n        return null\n      }\n      return this.each(\n        (null == n\n          ? function (t, n) {\n              var e, r\n              return function () {\n                var i = xr(this, t),\n                  o = i.tween\n                if (o !== e)\n                  for (var a = 0, u = (r = e = o).length; a < u; ++a)\n                    if (r[a].name === n) {\n                      ;(r = r.slice()).splice(a, 1)\n                      break\n                    }\n                i.tween = r\n              }\n            }\n          : function (t, n, e) {\n              var r, i\n              if ('function' != typeof e) throw new Error()\n              return function () {\n                var o = xr(this, t),\n                  a = o.tween\n                if (a !== r) {\n                  i = (r = a).slice()\n                  for (var u = { name: n, value: e }, c = 0, f = i.length; c < f; ++c)\n                    if (i[c].name === n) {\n                      i[c] = u\n                      break\n                    }\n                  c === f && i.push(u)\n                }\n                o.tween = i\n              }\n            })(e, t, n)\n      )\n    },\n    delay: function (t) {\n      var n = this._id\n      return arguments.length\n        ? this.each(\n            ('function' == typeof t\n              ? function (t, n) {\n                  return function () {\n                    mr(this, t).delay = +n.apply(this, arguments)\n                  }\n                }\n              : function (t, n) {\n                  return (\n                    (n = +n),\n                    function () {\n                      mr(this, t).delay = n\n                    }\n                  )\n                })(n, t)\n          )\n        : wr(this.node(), n).delay\n    },\n    duration: function (t) {\n      var n = this._id\n      return arguments.length\n        ? this.each(\n            ('function' == typeof t\n              ? function (t, n) {\n                  return function () {\n                    xr(this, t).duration = +n.apply(this, arguments)\n                  }\n                }\n              : function (t, n) {\n                  return (\n                    (n = +n),\n                    function () {\n                      xr(this, t).duration = n\n                    }\n                  )\n                })(n, t)\n          )\n        : wr(this.node(), n).duration\n    },\n    ease: function (t) {\n      var n = this._id\n      return arguments.length\n        ? this.each(\n            (function (t, n) {\n              if ('function' != typeof n) throw new Error()\n              return function () {\n                xr(this, t).ease = n\n              }\n            })(n, t)\n          )\n        : wr(this.node(), n).ease\n    },\n    end: function () {\n      var t,\n        n,\n        e = this,\n        r = e._id,\n        i = e.size()\n      return new Promise(function (o, a) {\n        var u = { value: a },\n          c = {\n            value: function () {\n              0 == --i && o()\n            }\n          }\n        e.each(function () {\n          var e = xr(this, r),\n            i = e.on\n          i !== t && ((n = (t = i).copy())._.cancel.push(u), n._.interrupt.push(u), n._.end.push(c)), (e.on = n)\n        })\n      })\n    }\n  }\n  var qr = (function t (n) {\n      function e (t) {\n        return Math.pow(t, n)\n      }\n      return (n = +n), (e.exponent = t), e\n    })(3),\n    Lr = (function t (n) {\n      function e (t) {\n        return 1 - Math.pow(1 - t, n)\n      }\n      return (n = +n), (e.exponent = t), e\n    })(3),\n    Ur = (function t (n) {\n      function e (t) {\n        return ((t *= 2) <= 1 ? Math.pow(t, n) : 2 - Math.pow(2 - t, n)) / 2\n      }\n      return (n = +n), (e.exponent = t), e\n    })(3),\n    Or = Math.PI,\n    Br = Or / 2\n  function Yr (t) {\n    return (1 - Math.cos(Or * t)) / 2\n  }\n  function Fr (t) {\n    return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2\n  }\n  function Ir (t) {\n    return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2\n  }\n  var jr = 4 / 11,\n    Hr = 6 / 11,\n    Xr = 8 / 11,\n    Gr = 0.75,\n    Vr = 9 / 11,\n    $r = 10 / 11,\n    Wr = 0.9375,\n    Zr = 21 / 22,\n    Qr = 63 / 64,\n    Jr = 1 / jr / jr\n  function Kr (t) {\n    return (t = +t) < jr\n      ? Jr * t * t\n      : t < Xr\n      ? Jr * (t -= Hr) * t + Gr\n      : t < $r\n      ? Jr * (t -= Vr) * t + Wr\n      : Jr * (t -= Zr) * t + Qr\n  }\n  var ti = (function t (n) {\n      function e (t) {\n        return t * t * ((n + 1) * t - n)\n      }\n      return (n = +n), (e.overshoot = t), e\n    })(1.70158),\n    ni = (function t (n) {\n      function e (t) {\n        return --t * t * ((n + 1) * t + n) + 1\n      }\n      return (n = +n), (e.overshoot = t), e\n    })(1.70158),\n    ei = (function t (n) {\n      function e (t) {\n        return ((t *= 2) < 1 ? t * t * ((n + 1) * t - n) : (t -= 2) * t * ((n + 1) * t + n) + 2) / 2\n      }\n      return (n = +n), (e.overshoot = t), e\n    })(1.70158),\n    ri = 2 * Math.PI,\n    ii = (function t (n, e) {\n      var r = Math.asin(1 / (n = Math.max(1, n))) * (e /= ri)\n      function i (t) {\n        return n * Math.pow(2, 10 * --t) * Math.sin((r - t) / e)\n      }\n      return (\n        (i.amplitude = function (n) {\n          return t(n, e * ri)\n        }),\n        (i.period = function (e) {\n          return t(n, e)\n        }),\n        i\n      )\n    })(1, 0.3),\n    oi = (function t (n, e) {\n      var r = Math.asin(1 / (n = Math.max(1, n))) * (e /= ri)\n      function i (t) {\n        return 1 - n * Math.pow(2, -10 * (t = +t)) * Math.sin((t + r) / e)\n      }\n      return (\n        (i.amplitude = function (n) {\n          return t(n, e * ri)\n        }),\n        (i.period = function (e) {\n          return t(n, e)\n        }),\n        i\n      )\n    })(1, 0.3),\n    ai = (function t (n, e) {\n      var r = Math.asin(1 / (n = Math.max(1, n))) * (e /= ri)\n      function i (t) {\n        return (\n          ((t = 2 * t - 1) < 0\n            ? n * Math.pow(2, 10 * t) * Math.sin((r - t) / e)\n            : 2 - n * Math.pow(2, -10 * t) * Math.sin((r + t) / e)) / 2\n        )\n      }\n      return (\n        (i.amplitude = function (n) {\n          return t(n, e * ri)\n        }),\n        (i.period = function (e) {\n          return t(n, e)\n        }),\n        i\n      )\n    })(1, 0.3),\n    ui = { time: null, delay: 0, duration: 250, ease: Dr }\n  function ci (t, n) {\n    for (var e; !(e = t.__transition) || !(e = e[n]); ) if (!(t = t.parentNode)) return (ui.time = nr()), ui\n    return e\n  }\n  ;(Pt.prototype.interrupt = function (t) {\n    return this.each(function () {\n      Mr(this, t)\n    })\n  }),\n    (Pt.prototype.transition = function (t) {\n      var n, e\n      t instanceof Er\n        ? ((n = t._id), (t = t._name))\n        : ((n = Pr()), ((e = ui).time = nr()), (t = null == t ? null : t + ''))\n      for (var r = this._groups, i = r.length, o = 0; o < i; ++o)\n        for (var a, u = r[o], c = u.length, f = 0; f < c; ++f) (a = u[f]) && br(a, t, n, f, u, e || ci(a, n))\n      return new Er(r, this._parents, t, n)\n    })\n  var fi = [null]\n  function si (t) {\n    return function () {\n      return t\n    }\n  }\n  function li (t, n, e) {\n    ;(this.target = t), (this.type = n), (this.selection = e)\n  }\n  function hi () {\n    t.event.stopImmediatePropagation()\n  }\n  function di () {\n    t.event.preventDefault(), t.event.stopImmediatePropagation()\n  }\n  var pi = { name: 'drag' },\n    vi = { name: 'space' },\n    gi = { name: 'handle' },\n    yi = { name: 'center' },\n    _i = {\n      name: 'x',\n      handles: ['e', 'w'].map(Si),\n      input: function (t, n) {\n        return t && [[t[0], n[0][1]], [t[1], n[1][1]]]\n      },\n      output: function (t) {\n        return t && [t[0][0], t[1][0]]\n      }\n    },\n    bi = {\n      name: 'y',\n      handles: ['n', 's'].map(Si),\n      input: function (t, n) {\n        return t && [[n[0][0], t[0]], [n[1][0], t[1]]]\n      },\n      output: function (t) {\n        return t && [t[0][1], t[1][1]]\n      }\n    },\n    mi = {\n      name: 'xy',\n      handles: ['n', 'e', 's', 'w', 'nw', 'ne', 'se', 'sw'].map(Si),\n      input: function (t) {\n        return t\n      },\n      output: function (t) {\n        return t\n      }\n    },\n    xi = {\n      overlay: 'crosshair',\n      selection: 'move',\n      n: 'ns-resize',\n      e: 'ew-resize',\n      s: 'ns-resize',\n      w: 'ew-resize',\n      nw: 'nwse-resize',\n      ne: 'nesw-resize',\n      se: 'nwse-resize',\n      sw: 'nesw-resize'\n    },\n    wi = { e: 'w', w: 'e', nw: 'ne', ne: 'nw', se: 'sw', sw: 'se' },\n    Mi = { n: 's', s: 'n', nw: 'sw', ne: 'se', se: 'ne', sw: 'nw' },\n    Ni = { overlay: 1, selection: 1, n: null, e: 1, s: null, w: -1, nw: -1, ne: 1, se: 1, sw: -1 },\n    Ai = { overlay: 1, selection: 1, n: -1, e: null, s: 1, w: null, nw: -1, ne: -1, se: 1, sw: 1 }\n  function Si (t) {\n    return { type: t }\n  }\n  function ki () {\n    return !t.event.button\n  }\n  function Ti () {\n    var t = this.ownerSVGElement || this\n    return [[0, 0], [t.width.baseVal.value, t.height.baseVal.value]]\n  }\n  function Ei (t) {\n    for (; !t.__brush; ) if (!(t = t.parentNode)) return\n    return t.__brush\n  }\n  function Ci (t) {\n    return t[0][0] === t[1][0] || t[0][1] === t[1][1]\n  }\n  function Pi (n) {\n    var e,\n      r = Ti,\n      i = ki,\n      o = I(u, 'start', 'brush', 'end'),\n      a = 6\n    function u (t) {\n      var e = t\n        .property('__brush', h)\n        .selectAll('.overlay')\n        .data([Si('overlay')])\n      e\n        .enter()\n        .append('rect')\n        .attr('class', 'overlay')\n        .attr('pointer-events', 'all')\n        .attr('cursor', xi.overlay)\n        .merge(e)\n        .each(function () {\n          var t = Ei(this).extent\n          zt(this)\n            .attr('x', t[0][0])\n            .attr('y', t[0][1])\n            .attr('width', t[1][0] - t[0][0])\n            .attr('height', t[1][1] - t[0][1])\n        }),\n        t\n          .selectAll('.selection')\n          .data([Si('selection')])\n          .enter()\n          .append('rect')\n          .attr('class', 'selection')\n          .attr('cursor', xi.selection)\n          .attr('fill', '#777')\n          .attr('fill-opacity', 0.3)\n          .attr('stroke', '#fff')\n          .attr('shape-rendering', 'crispEdges')\n      var r = t.selectAll('.handle').data(n.handles, function (t) {\n        return t.type\n      })\n      r.exit().remove(),\n        r\n          .enter()\n          .append('rect')\n          .attr('class', function (t) {\n            return 'handle handle--' + t.type\n          })\n          .attr('cursor', function (t) {\n            return xi[t.type]\n          }),\n        t\n          .each(c)\n          .attr('fill', 'none')\n          .attr('pointer-events', 'all')\n          .style('-webkit-tap-highlight-color', 'rgba(0,0,0,0)')\n          .on('mousedown.brush touchstart.brush', l)\n    }\n    function c () {\n      var t = zt(this),\n        n = Ei(this).selection\n      n\n        ? (t\n            .selectAll('.selection')\n            .style('display', null)\n            .attr('x', n[0][0])\n            .attr('y', n[0][1])\n            .attr('width', n[1][0] - n[0][0])\n            .attr('height', n[1][1] - n[0][1]),\n          t\n            .selectAll('.handle')\n            .style('display', null)\n            .attr('x', function (t) {\n              return 'e' === t.type[t.type.length - 1] ? n[1][0] - a / 2 : n[0][0] - a / 2\n            })\n            .attr('y', function (t) {\n              return 's' === t.type[0] ? n[1][1] - a / 2 : n[0][1] - a / 2\n            })\n            .attr('width', function (t) {\n              return 'n' === t.type || 's' === t.type ? n[1][0] - n[0][0] + a : a\n            })\n            .attr('height', function (t) {\n              return 'e' === t.type || 'w' === t.type ? n[1][1] - n[0][1] + a : a\n            }))\n        : t\n            .selectAll('.selection,.handle')\n            .style('display', 'none')\n            .attr('x', null)\n            .attr('y', null)\n            .attr('width', null)\n            .attr('height', null)\n    }\n    function f (t, n) {\n      return t.__brush.emitter || new s(t, n)\n    }\n    function s (t, n) {\n      ;(this.that = t), (this.args = n), (this.state = t.__brush), (this.active = 0)\n    }\n    function l () {\n      if (t.event.touches) {\n        if (t.event.changedTouches.length < t.event.touches.length) return di()\n      } else if (e) return\n      if (i.apply(this, arguments)) {\n        var r,\n          o,\n          a,\n          u,\n          s,\n          l,\n          h,\n          d,\n          p,\n          v,\n          g,\n          y,\n          _,\n          b = this,\n          m = t.event.target.__data__.type,\n          x = 'selection' === (t.event.metaKey ? (m = 'overlay') : m) ? pi : t.event.altKey ? yi : gi,\n          w = n === bi ? null : Ni[m],\n          M = n === _i ? null : Ai[m],\n          N = Ei(b),\n          A = N.extent,\n          S = N.selection,\n          k = A[0][0],\n          T = A[0][1],\n          E = A[1][0],\n          C = A[1][1],\n          P = w && M && t.event.shiftKey,\n          z = Ot(b),\n          R = z,\n          D = f(b, arguments).beforestart()\n        'overlay' === m\n          ? (N.selection = S = [\n              [(r = n === bi ? k : z[0]), (a = n === _i ? T : z[1])],\n              [(s = n === bi ? E : r), (h = n === _i ? C : a)]\n            ])\n          : ((r = S[0][0]), (a = S[0][1]), (s = S[1][0]), (h = S[1][1])),\n          (o = r),\n          (u = a),\n          (l = s),\n          (d = h)\n        var q = zt(b).attr('pointer-events', 'none'),\n          L = q.selectAll('.overlay').attr('cursor', xi[m])\n        if (t.event.touches) q.on('touchmove.brush', O, !0).on('touchend.brush touchcancel.brush', Y, !0)\n        else {\n          var U = zt(t.event.view)\n            .on(\n              'keydown.brush',\n              function () {\n                switch (t.event.keyCode) {\n                  case 16:\n                    P = w && M\n                    break\n                  case 18:\n                    x === gi &&\n                      (w && ((s = l - p * w), (r = o + p * w)), M && ((h = d - v * M), (a = u + v * M)), (x = yi), B())\n                    break\n                  case 32:\n                    ;(x !== gi && x !== yi) ||\n                      (w < 0 ? (s = l - p) : w > 0 && (r = o - p),\n                      M < 0 ? (h = d - v) : M > 0 && (a = u - v),\n                      (x = vi),\n                      L.attr('cursor', xi.selection),\n                      B())\n                    break\n                  default:\n                    return\n                }\n                di()\n              },\n              !0\n            )\n            .on(\n              'keyup.brush',\n              function () {\n                switch (t.event.keyCode) {\n                  case 16:\n                    P && ((y = _ = P = !1), B())\n                    break\n                  case 18:\n                    x === yi && (w < 0 ? (s = l) : w > 0 && (r = o), M < 0 ? (h = d) : M > 0 && (a = u), (x = gi), B())\n                    break\n                  case 32:\n                    x === vi &&\n                      (t.event.altKey\n                        ? (w && ((s = l - p * w), (r = o + p * w)), M && ((h = d - v * M), (a = u + v * M)), (x = yi))\n                        : (w < 0 ? (s = l) : w > 0 && (r = o), M < 0 ? (h = d) : M > 0 && (a = u), (x = gi)),\n                      L.attr('cursor', xi[m]),\n                      B())\n                    break\n                  default:\n                    return\n                }\n                di()\n              },\n              !0\n            )\n            .on('mousemove.brush', O, !0)\n            .on('mouseup.brush', Y, !0)\n          It(t.event.view)\n        }\n        hi(), Mr(b), c.call(b), D.start()\n      }\n      function O () {\n        var t = Ot(b)\n        !P || y || _ || (Math.abs(t[0] - R[0]) > Math.abs(t[1] - R[1]) ? (_ = !0) : (y = !0)),\n          (R = t),\n          (g = !0),\n          di(),\n          B()\n      }\n      function B () {\n        var t\n        switch (((p = R[0] - z[0]), (v = R[1] - z[1]), x)) {\n          case vi:\n          case pi:\n            w && ((p = Math.max(k - r, Math.min(E - s, p))), (o = r + p), (l = s + p)),\n              M && ((v = Math.max(T - a, Math.min(C - h, v))), (u = a + v), (d = h + v))\n            break\n          case gi:\n            w < 0\n              ? ((p = Math.max(k - r, Math.min(E - r, p))), (o = r + p), (l = s))\n              : w > 0 && ((p = Math.max(k - s, Math.min(E - s, p))), (o = r), (l = s + p)),\n              M < 0\n                ? ((v = Math.max(T - a, Math.min(C - a, v))), (u = a + v), (d = h))\n                : M > 0 && ((v = Math.max(T - h, Math.min(C - h, v))), (u = a), (d = h + v))\n            break\n          case yi:\n            w && ((o = Math.max(k, Math.min(E, r - p * w))), (l = Math.max(k, Math.min(E, s + p * w)))),\n              M && ((u = Math.max(T, Math.min(C, a - v * M))), (d = Math.max(T, Math.min(C, h + v * M))))\n        }\n        l < o &&\n          ((w *= -1),\n          (t = r),\n          (r = s),\n          (s = t),\n          (t = o),\n          (o = l),\n          (l = t),\n          m in wi && L.attr('cursor', xi[(m = wi[m])])),\n          d < u &&\n            ((M *= -1),\n            (t = a),\n            (a = h),\n            (h = t),\n            (t = u),\n            (u = d),\n            (d = t),\n            m in Mi && L.attr('cursor', xi[(m = Mi[m])])),\n          N.selection && (S = N.selection),\n          y && ((o = S[0][0]), (l = S[1][0])),\n          _ && ((u = S[0][1]), (d = S[1][1])),\n          (S[0][0] === o && S[0][1] === u && S[1][0] === l && S[1][1] === d) ||\n            ((N.selection = [[o, u], [l, d]]), c.call(b), D.brush())\n      }\n      function Y () {\n        if ((hi(), t.event.touches)) {\n          if (t.event.touches.length) return\n          e && clearTimeout(e),\n            (e = setTimeout(function () {\n              e = null\n            }, 500)),\n            q.on('touchmove.brush touchend.brush touchcancel.brush', null)\n        } else jt(t.event.view, g), U.on('keydown.brush keyup.brush mousemove.brush mouseup.brush', null)\n        q.attr('pointer-events', 'all'),\n          L.attr('cursor', xi.overlay),\n          N.selection && (S = N.selection),\n          Ci(S) && ((N.selection = null), c.call(b)),\n          D.end()\n      }\n    }\n    function h () {\n      var t = this.__brush || { selection: null }\n      return (t.extent = r.apply(this, arguments)), (t.dim = n), t\n    }\n    return (\n      (u.move = function (t, e) {\n        t.selection\n          ? t\n              .on('start.brush', function () {\n                f(this, arguments)\n                  .beforestart()\n                  .start()\n              })\n              .on('interrupt.brush end.brush', function () {\n                f(this, arguments).end()\n              })\n              .tween('brush', function () {\n                var t = this,\n                  r = t.__brush,\n                  i = f(t, arguments),\n                  o = r.selection,\n                  a = n.input('function' == typeof e ? e.apply(this, arguments) : e, r.extent),\n                  u = ye(o, a)\n                function s (n) {\n                  ;(r.selection = 1 === n && Ci(a) ? null : u(n)), c.call(t), i.brush()\n                }\n                return o && a ? s : s(1)\n              })\n          : t.each(function () {\n              var t = arguments,\n                r = this.__brush,\n                i = n.input('function' == typeof e ? e.apply(this, t) : e, r.extent),\n                o = f(this, t).beforestart()\n              Mr(this),\n                (r.selection = null == i || Ci(i) ? null : i),\n                c.call(this),\n                o\n                  .start()\n                  .brush()\n                  .end()\n            })\n      }),\n      (s.prototype = {\n        beforestart: function () {\n          return 1 == ++this.active && ((this.state.emitter = this), (this.starting = !0)), this\n        },\n        start: function () {\n          return this.starting && ((this.starting = !1), this.emit('start')), this\n        },\n        brush: function () {\n          return this.emit('brush'), this\n        },\n        end: function () {\n          return 0 == --this.active && (delete this.state.emitter, this.emit('end')), this\n        },\n        emit: function (t) {\n          kt(new li(u, t, n.output(this.state.selection)), o.apply, o, [t, this.that, this.args])\n        }\n      }),\n      (u.extent = function (t) {\n        return arguments.length\n          ? ((r = 'function' == typeof t ? t : si([[+t[0][0], +t[0][1]], [+t[1][0], +t[1][1]]])), u)\n          : r\n      }),\n      (u.filter = function (t) {\n        return arguments.length ? ((i = 'function' == typeof t ? t : si(!!t)), u) : i\n      }),\n      (u.handleSize = function (t) {\n        return arguments.length ? ((a = +t), u) : a\n      }),\n      (u.on = function () {\n        var t = o.on.apply(o, arguments)\n        return t === o ? u : t\n      }),\n      u\n    )\n  }\n  var zi = Math.cos,\n    Ri = Math.sin,\n    Di = Math.PI,\n    qi = Di / 2,\n    Li = 2 * Di,\n    Ui = Math.max\n  var Oi = Array.prototype.slice\n  function Bi (t) {\n    return function () {\n      return t\n    }\n  }\n  var Yi = Math.PI,\n    Fi = 2 * Yi,\n    Ii = Fi - 1e-6\n  function ji () {\n    ;(this._x0 = this._y0 = this._x1 = this._y1 = null), (this._ = '')\n  }\n  function Hi () {\n    return new ji()\n  }\n  function Xi (t) {\n    return t.source\n  }\n  function Gi (t) {\n    return t.target\n  }\n  function Vi (t) {\n    return t.radius\n  }\n  function $i (t) {\n    return t.startAngle\n  }\n  function Wi (t) {\n    return t.endAngle\n  }\n  ji.prototype = Hi.prototype = {\n    constructor: ji,\n    moveTo: function (t, n) {\n      this._ += 'M' + (this._x0 = this._x1 = +t) + ',' + (this._y0 = this._y1 = +n)\n    },\n    closePath: function () {\n      null !== this._x1 && ((this._x1 = this._x0), (this._y1 = this._y0), (this._ += 'Z'))\n    },\n    lineTo: function (t, n) {\n      this._ += 'L' + (this._x1 = +t) + ',' + (this._y1 = +n)\n    },\n    quadraticCurveTo: function (t, n, e, r) {\n      this._ += 'Q' + +t + ',' + +n + ',' + (this._x1 = +e) + ',' + (this._y1 = +r)\n    },\n    bezierCurveTo: function (t, n, e, r, i, o) {\n      this._ += 'C' + +t + ',' + +n + ',' + +e + ',' + +r + ',' + (this._x1 = +i) + ',' + (this._y1 = +o)\n    },\n    arcTo: function (t, n, e, r, i) {\n      ;(t = +t), (n = +n), (e = +e), (r = +r), (i = +i)\n      var o = this._x1,\n        a = this._y1,\n        u = e - t,\n        c = r - n,\n        f = o - t,\n        s = a - n,\n        l = f * f + s * s\n      if (i < 0) throw new Error('negative radius: ' + i)\n      if (null === this._x1) this._ += 'M' + (this._x1 = t) + ',' + (this._y1 = n)\n      else if (l > 1e-6)\n        if (Math.abs(s * u - c * f) > 1e-6 && i) {\n          var h = e - o,\n            d = r - a,\n            p = u * u + c * c,\n            v = h * h + d * d,\n            g = Math.sqrt(p),\n            y = Math.sqrt(l),\n            _ = i * Math.tan((Yi - Math.acos((p + l - v) / (2 * g * y))) / 2),\n            b = _ / y,\n            m = _ / g\n          Math.abs(b - 1) > 1e-6 && (this._ += 'L' + (t + b * f) + ',' + (n + b * s)),\n            (this._ +=\n              'A' +\n              i +\n              ',' +\n              i +\n              ',0,0,' +\n              +(s * h > f * d) +\n              ',' +\n              (this._x1 = t + m * u) +\n              ',' +\n              (this._y1 = n + m * c))\n        } else this._ += 'L' + (this._x1 = t) + ',' + (this._y1 = n)\n      else;\n    },\n    arc: function (t, n, e, r, i, o) {\n      ;(t = +t), (n = +n)\n      var a = (e = +e) * Math.cos(r),\n        u = e * Math.sin(r),\n        c = t + a,\n        f = n + u,\n        s = 1 ^ o,\n        l = o ? r - i : i - r\n      if (e < 0) throw new Error('negative radius: ' + e)\n      null === this._x1\n        ? (this._ += 'M' + c + ',' + f)\n        : (Math.abs(this._x1 - c) > 1e-6 || Math.abs(this._y1 - f) > 1e-6) && (this._ += 'L' + c + ',' + f),\n        e &&\n          (l < 0 && (l = (l % Fi) + Fi),\n          l > Ii\n            ? (this._ +=\n                'A' +\n                e +\n                ',' +\n                e +\n                ',0,1,' +\n                s +\n                ',' +\n                (t - a) +\n                ',' +\n                (n - u) +\n                'A' +\n                e +\n                ',' +\n                e +\n                ',0,1,' +\n                s +\n                ',' +\n                (this._x1 = c) +\n                ',' +\n                (this._y1 = f))\n            : l > 1e-6 &&\n              (this._ +=\n                'A' +\n                e +\n                ',' +\n                e +\n                ',0,' +\n                +(l >= Yi) +\n                ',' +\n                s +\n                ',' +\n                (this._x1 = t + e * Math.cos(i)) +\n                ',' +\n                (this._y1 = n + e * Math.sin(i))))\n    },\n    rect: function (t, n, e, r) {\n      this._ +=\n        'M' + (this._x0 = this._x1 = +t) + ',' + (this._y0 = this._y1 = +n) + 'h' + +e + 'v' + +r + 'h' + -e + 'Z'\n    },\n    toString: function () {\n      return this._\n    }\n  }\n  function Zi () {}\n  function Qi (t, n) {\n    var e = new Zi()\n    if (t instanceof Zi)\n      t.each(function (t, n) {\n        e.set(n, t)\n      })\n    else if (Array.isArray(t)) {\n      var r,\n        i = -1,\n        o = t.length\n      if (null == n) for (; ++i < o; ) e.set(i, t[i])\n      else for (; ++i < o; ) e.set(n((r = t[i]), i, t), r)\n    } else if (t) for (var a in t) e.set(a, t[a])\n    return e\n  }\n  function Ji () {\n    return {}\n  }\n  function Ki (t, n, e) {\n    t[n] = e\n  }\n  function to () {\n    return Qi()\n  }\n  function no (t, n, e) {\n    t.set(n, e)\n  }\n  function eo () {}\n  Zi.prototype = Qi.prototype = {\n    constructor: Zi,\n    has: function (t) {\n      return '$' + t in this\n    },\n    get: function (t) {\n      return this['$' + t]\n    },\n    set: function (t, n) {\n      return (this['$' + t] = n), this\n    },\n    remove: function (t) {\n      var n = '$' + t\n      return n in this && delete this[n]\n    },\n    clear: function () {\n      for (var t in this) '$' === t[0] && delete this[t]\n    },\n    keys: function () {\n      var t = []\n      for (var n in this) '$' === n[0] && t.push(n.slice(1))\n      return t\n    },\n    values: function () {\n      var t = []\n      for (var n in this) '$' === n[0] && t.push(this[n])\n      return t\n    },\n    entries: function () {\n      var t = []\n      for (var n in this) '$' === n[0] && t.push({ key: n.slice(1), value: this[n] })\n      return t\n    },\n    size: function () {\n      var t = 0\n      for (var n in this) '$' === n[0] && ++t\n      return t\n    },\n    empty: function () {\n      for (var t in this) if ('$' === t[0]) return !1\n      return !0\n    },\n    each: function (t) {\n      for (var n in this) '$' === n[0] && t(this[n], n.slice(1), this)\n    }\n  }\n  var ro = Qi.prototype\n  function io (t, n) {\n    var e = new eo()\n    if (t instanceof eo)\n      t.each(function (t) {\n        e.add(t)\n      })\n    else if (t) {\n      var r = -1,\n        i = t.length\n      if (null == n) for (; ++r < i; ) e.add(t[r])\n      else for (; ++r < i; ) e.add(n(t[r], r, t))\n    }\n    return e\n  }\n  eo.prototype = io.prototype = {\n    constructor: eo,\n    has: ro.has,\n    add: function (t) {\n      return (this['$' + (t += '')] = t), this\n    },\n    remove: ro.remove,\n    clear: ro.clear,\n    values: ro.keys,\n    size: ro.size,\n    empty: ro.empty,\n    each: ro.each\n  }\n  var oo = Array.prototype.slice\n  function ao (t, n) {\n    return t - n\n  }\n  function uo (t) {\n    return function () {\n      return t\n    }\n  }\n  function co (t, n) {\n    for (var e, r = -1, i = n.length; ++r < i; ) if ((e = fo(t, n[r]))) return e\n    return 0\n  }\n  function fo (t, n) {\n    for (var e = n[0], r = n[1], i = -1, o = 0, a = t.length, u = a - 1; o < a; u = o++) {\n      var c = t[o],\n        f = c[0],\n        s = c[1],\n        l = t[u],\n        h = l[0],\n        d = l[1]\n      if (so(c, l, n)) return 0\n      s > r != d > r && e < ((h - f) * (r - s)) / (d - s) + f && (i = -i)\n    }\n    return i\n  }\n  function so (t, n, e) {\n    var r, i, o, a\n    return (\n      (function (t, n, e) {\n        return (n[0] - t[0]) * (e[1] - t[1]) == (e[0] - t[0]) * (n[1] - t[1])\n      })(t, n, e) && ((i = t[(r = +(t[0] === n[0]))]), (o = e[r]), (a = n[r]), (i <= o && o <= a) || (a <= o && o <= i))\n    )\n  }\n  function lo () {}\n  var ho = [\n    [],\n    [[[1, 1.5], [0.5, 1]]],\n    [[[1.5, 1], [1, 1.5]]],\n    [[[1.5, 1], [0.5, 1]]],\n    [[[1, 0.5], [1.5, 1]]],\n    [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]],\n    [[[1, 0.5], [1, 1.5]]],\n    [[[1, 0.5], [0.5, 1]]],\n    [[[0.5, 1], [1, 0.5]]],\n    [[[1, 1.5], [1, 0.5]]],\n    [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]],\n    [[[1.5, 1], [1, 0.5]]],\n    [[[0.5, 1], [1.5, 1]]],\n    [[[1, 1.5], [1.5, 1]]],\n    [[[0.5, 1], [1, 1.5]]],\n    []\n  ]\n  function po () {\n    var t = 1,\n      n = 1,\n      e = M,\n      r = u\n    function i (t) {\n      var n = e(t)\n      if (Array.isArray(n)) n = n.slice().sort(ao)\n      else {\n        var r = s(t),\n          i = r[0],\n          a = r[1]\n        ;(n = w(i, a, n)), (n = g(Math.floor(i / n) * n, Math.floor(a / n) * n, n))\n      }\n      return n.map(function (n) {\n        return o(t, n)\n      })\n    }\n    function o (e, i) {\n      var o = [],\n        u = []\n      return (\n        (function (e, r, i) {\n          var o,\n            u,\n            c,\n            f,\n            s,\n            l,\n            h = new Array(),\n            d = new Array()\n          ;(o = u = -1), (f = e[0] >= r), ho[f << 1].forEach(p)\n          for (; ++o < t - 1; ) (c = f), (f = e[o + 1] >= r), ho[c | (f << 1)].forEach(p)\n          ho[f << 0].forEach(p)\n          for (; ++u < n - 1; ) {\n            for (o = -1, f = e[u * t + t] >= r, s = e[u * t] >= r, ho[(f << 1) | (s << 2)].forEach(p); ++o < t - 1; )\n              (c = f),\n                (f = e[u * t + t + o + 1] >= r),\n                (l = s),\n                (s = e[u * t + o + 1] >= r),\n                ho[c | (f << 1) | (s << 2) | (l << 3)].forEach(p)\n            ho[f | (s << 3)].forEach(p)\n          }\n          ;(o = -1), (s = e[u * t] >= r), ho[s << 2].forEach(p)\n          for (; ++o < t - 1; ) (l = s), (s = e[u * t + o + 1] >= r), ho[(s << 2) | (l << 3)].forEach(p)\n          function p (t) {\n            var n,\n              e,\n              r = [t[0][0] + o, t[0][1] + u],\n              c = [t[1][0] + o, t[1][1] + u],\n              f = a(r),\n              s = a(c)\n            ;(n = d[f])\n              ? (e = h[s])\n                ? (delete d[n.end],\n                  delete h[e.start],\n                  n === e\n                    ? (n.ring.push(c), i(n.ring))\n                    : (h[n.start] = d[e.end] = { start: n.start, end: e.end, ring: n.ring.concat(e.ring) }))\n                : (delete d[n.end], n.ring.push(c), (d[(n.end = s)] = n))\n              : (n = h[s])\n              ? (e = d[f])\n                ? (delete h[n.start],\n                  delete d[e.end],\n                  n === e\n                    ? (n.ring.push(c), i(n.ring))\n                    : (h[e.start] = d[n.end] = { start: e.start, end: n.end, ring: e.ring.concat(n.ring) }))\n                : (delete h[n.start], n.ring.unshift(r), (h[(n.start = f)] = n))\n              : (h[f] = d[s] = { start: f, end: s, ring: [r, c] })\n          }\n          ho[s << 3].forEach(p)\n        })(e, i, function (t) {\n          r(t, e, i),\n            (function (t) {\n              for (var n = 0, e = t.length, r = t[e - 1][1] * t[0][0] - t[e - 1][0] * t[0][1]; ++n < e; )\n                r += t[n - 1][1] * t[n][0] - t[n - 1][0] * t[n][1]\n              return r\n            })(t) > 0\n              ? o.push([t])\n              : u.push(t)\n        }),\n        u.forEach(function (t) {\n          for (var n, e = 0, r = o.length; e < r; ++e) if (-1 !== co((n = o[e])[0], t)) return void n.push(t)\n        }),\n        { type: 'MultiPolygon', value: i, coordinates: o }\n      )\n    }\n    function a (n) {\n      return 2 * n[0] + n[1] * (t + 1) * 4\n    }\n    function u (e, r, i) {\n      e.forEach(function (e) {\n        var o,\n          a = e[0],\n          u = e[1],\n          c = 0 | a,\n          f = 0 | u,\n          s = r[f * t + c]\n        a > 0 && a < t && c === a && ((o = r[f * t + c - 1]), (e[0] = a + (i - o) / (s - o) - 0.5)),\n          u > 0 && u < n && f === u && ((o = r[(f - 1) * t + c]), (e[1] = u + (i - o) / (s - o) - 0.5))\n      })\n    }\n    return (\n      (i.contour = o),\n      (i.size = function (e) {\n        if (!arguments.length) return [t, n]\n        var r = Math.ceil(e[0]),\n          o = Math.ceil(e[1])\n        if (!(r > 0 && o > 0)) throw new Error('invalid size')\n        return (t = r), (n = o), i\n      }),\n      (i.thresholds = function (t) {\n        return arguments.length ? ((e = 'function' == typeof t ? t : Array.isArray(t) ? uo(oo.call(t)) : uo(t)), i) : e\n      }),\n      (i.smooth = function (t) {\n        return arguments.length ? ((r = t ? u : lo), i) : r === u\n      }),\n      i\n    )\n  }\n  function vo (t, n, e) {\n    for (var r = t.width, i = t.height, o = 1 + (e << 1), a = 0; a < i; ++a)\n      for (var u = 0, c = 0; u < r + e; ++u)\n        u < r && (c += t.data[u + a * r]),\n          u >= e &&\n            (u >= o && (c -= t.data[u - o + a * r]), (n.data[u - e + a * r] = c / Math.min(u + 1, r - 1 + o - u, o)))\n  }\n  function go (t, n, e) {\n    for (var r = t.width, i = t.height, o = 1 + (e << 1), a = 0; a < r; ++a)\n      for (var u = 0, c = 0; u < i + e; ++u)\n        u < i && (c += t.data[a + u * r]),\n          u >= e &&\n            (u >= o && (c -= t.data[a + (u - o) * r]),\n            (n.data[a + (u - e) * r] = c / Math.min(u + 1, i - 1 + o - u, o)))\n  }\n  function yo (t) {\n    return t[0]\n  }\n  function _o (t) {\n    return t[1]\n  }\n  function bo () {\n    return 1\n  }\n  var mo = {},\n    xo = {},\n    wo = 34,\n    Mo = 10,\n    No = 13\n  function Ao (t) {\n    return new Function(\n      'd',\n      'return {' +\n        t\n          .map(function (t, n) {\n            return JSON.stringify(t) + ': d[' + n + ']'\n          })\n          .join(',') +\n        '}'\n    )\n  }\n  function So (t) {\n    var n = Object.create(null),\n      e = []\n    return (\n      t.forEach(function (t) {\n        for (var r in t) r in n || e.push((n[r] = r))\n      }),\n      e\n    )\n  }\n  function ko (t) {\n    var n = new RegExp('[\"' + t + '\\n\\r]'),\n      e = t.charCodeAt(0)\n    function r (t, n) {\n      var r,\n        i = [],\n        o = t.length,\n        a = 0,\n        u = 0,\n        c = o <= 0,\n        f = !1\n      function s () {\n        if (c) return xo\n        if (f) return (f = !1), mo\n        var n,\n          r,\n          i = a\n        if (t.charCodeAt(i) === wo) {\n          for (; (a++ < o && t.charCodeAt(a) !== wo) || t.charCodeAt(++a) === wo; );\n          return (\n            (n = a) >= o\n              ? (c = !0)\n              : (r = t.charCodeAt(a++)) === Mo\n              ? (f = !0)\n              : r === No && ((f = !0), t.charCodeAt(a) === Mo && ++a),\n            t.slice(i + 1, n - 1).replace(/\"\"/g, '\"')\n          )\n        }\n        for (; a < o; ) {\n          if ((r = t.charCodeAt((n = a++))) === Mo) f = !0\n          else if (r === No) (f = !0), t.charCodeAt(a) === Mo && ++a\n          else if (r !== e) continue\n          return t.slice(i, n)\n        }\n        return (c = !0), t.slice(i, o)\n      }\n      for (t.charCodeAt(o - 1) === Mo && --o, t.charCodeAt(o - 1) === No && --o; (r = s()) !== xo; ) {\n        for (var l = []; r !== mo && r !== xo; ) l.push(r), (r = s())\n        ;(n && null == (l = n(l, u++))) || i.push(l)\n      }\n      return i\n    }\n    function i (n, e) {\n      return n.map(function (n) {\n        return e\n          .map(function (t) {\n            return a(n[t])\n          })\n          .join(t)\n      })\n    }\n    function o (n) {\n      return n.map(a).join(t)\n    }\n    function a (t) {\n      return null == t\n        ? ''\n        : t instanceof Date\n        ? t.toISOString()\n        : n.test((t += ''))\n        ? '\"' + t.replace(/\"/g, '\"\"') + '\"'\n        : t\n    }\n    return {\n      parse: function (t, n) {\n        var e,\n          i,\n          o = r(t, function (t, r) {\n            if (e) return e(t, r - 1)\n            ;(i = t),\n              (e = n\n                ? (function (t, n) {\n                    var e = Ao(t)\n                    return function (r, i) {\n                      return n(e(r), i, t)\n                    }\n                  })(t, n)\n                : Ao(t))\n          })\n        return (o.columns = i || []), o\n      },\n      parseRows: r,\n      format: function (n, e) {\n        return null == e && (e = So(n)), [e.map(a).join(t)].concat(i(n, e)).join('\\n')\n      },\n      formatBody: function (t, n) {\n        return null == n && (n = So(t)), i(t, n).join('\\n')\n      },\n      formatRows: function (t) {\n        return t.map(o).join('\\n')\n      }\n    }\n  }\n  var To = ko(','),\n    Eo = To.parse,\n    Co = To.parseRows,\n    Po = To.format,\n    zo = To.formatBody,\n    Ro = To.formatRows,\n    Do = ko('\\t'),\n    qo = Do.parse,\n    Lo = Do.parseRows,\n    Uo = Do.format,\n    Oo = Do.formatBody,\n    Bo = Do.formatRows\n  function Yo (t) {\n    if (!t.ok) throw new Error(t.status + ' ' + t.statusText)\n    return t.blob()\n  }\n  function Fo (t) {\n    if (!t.ok) throw new Error(t.status + ' ' + t.statusText)\n    return t.arrayBuffer()\n  }\n  function Io (t) {\n    if (!t.ok) throw new Error(t.status + ' ' + t.statusText)\n    return t.text()\n  }\n  function jo (t, n) {\n    return fetch(t, n).then(Io)\n  }\n  function Ho (t) {\n    return function (n, e, r) {\n      return (\n        2 === arguments.length && 'function' == typeof e && ((r = e), (e = void 0)),\n        jo(n, e).then(function (n) {\n          return t(n, r)\n        })\n      )\n    }\n  }\n  var Xo = Ho(Eo),\n    Go = Ho(qo)\n  function Vo (t) {\n    if (!t.ok) throw new Error(t.status + ' ' + t.statusText)\n    return t.json()\n  }\n  function $o (t) {\n    return function (n, e) {\n      return jo(n, e).then(function (n) {\n        return new DOMParser().parseFromString(n, t)\n      })\n    }\n  }\n  var Wo = $o('application/xml'),\n    Zo = $o('text/html'),\n    Qo = $o('image/svg+xml')\n  function Jo (t) {\n    return function () {\n      return t\n    }\n  }\n  function Ko () {\n    return 1e-6 * (Math.random() - 0.5)\n  }\n  function ta (t, n, e, r) {\n    if (isNaN(n) || isNaN(e)) return t\n    var i,\n      o,\n      a,\n      u,\n      c,\n      f,\n      s,\n      l,\n      h,\n      d = t._root,\n      p = { data: r },\n      v = t._x0,\n      g = t._y0,\n      y = t._x1,\n      _ = t._y1\n    if (!d) return (t._root = p), t\n    for (; d.length; )\n      if (\n        ((f = n >= (o = (v + y) / 2)) ? (v = o) : (y = o),\n        (s = e >= (a = (g + _) / 2)) ? (g = a) : (_ = a),\n        (i = d),\n        !(d = d[(l = (s << 1) | f)]))\n      )\n        return (i[l] = p), t\n    if (((u = +t._x.call(null, d.data)), (c = +t._y.call(null, d.data)), n === u && e === c))\n      return (p.next = d), i ? (i[l] = p) : (t._root = p), t\n    do {\n      ;(i = i ? (i[l] = new Array(4)) : (t._root = new Array(4))),\n        (f = n >= (o = (v + y) / 2)) ? (v = o) : (y = o),\n        (s = e >= (a = (g + _) / 2)) ? (g = a) : (_ = a)\n    } while ((l = (s << 1) | f) == (h = ((c >= a) << 1) | (u >= o)))\n    return (i[h] = d), (i[l] = p), t\n  }\n  function na (t, n, e, r, i) {\n    ;(this.node = t), (this.x0 = n), (this.y0 = e), (this.x1 = r), (this.y1 = i)\n  }\n  function ea (t) {\n    return t[0]\n  }\n  function ra (t) {\n    return t[1]\n  }\n  function ia (t, n, e) {\n    var r = new oa(null == n ? ea : n, null == e ? ra : e, NaN, NaN, NaN, NaN)\n    return null == t ? r : r.addAll(t)\n  }\n  function oa (t, n, e, r, i, o) {\n    ;(this._x = t), (this._y = n), (this._x0 = e), (this._y0 = r), (this._x1 = i), (this._y1 = o), (this._root = void 0)\n  }\n  function aa (t) {\n    for (var n = { data: t.data }, e = n; (t = t.next); ) e = e.next = { data: t.data }\n    return n\n  }\n  var ua = (ia.prototype = oa.prototype)\n  function ca (t) {\n    return t.x + t.vx\n  }\n  function fa (t) {\n    return t.y + t.vy\n  }\n  function sa (t) {\n    return t.index\n  }\n  function la (t, n) {\n    var e = t.get(n)\n    if (!e) throw new Error('missing: ' + n)\n    return e\n  }\n  function ha (t) {\n    return t.x\n  }\n  function da (t) {\n    return t.y\n  }\n  ;(ua.copy = function () {\n    var t,\n      n,\n      e = new oa(this._x, this._y, this._x0, this._y0, this._x1, this._y1),\n      r = this._root\n    if (!r) return e\n    if (!r.length) return (e._root = aa(r)), e\n    for (t = [{ source: r, target: (e._root = new Array(4)) }]; (r = t.pop()); )\n      for (var i = 0; i < 4; ++i)\n        (n = r.source[i]) &&\n          (n.length ? t.push({ source: n, target: (r.target[i] = new Array(4)) }) : (r.target[i] = aa(n)))\n    return e\n  }),\n    (ua.add = function (t) {\n      var n = +this._x.call(null, t),\n        e = +this._y.call(null, t)\n      return ta(this.cover(n, e), n, e, t)\n    }),\n    (ua.addAll = function (t) {\n      var n,\n        e,\n        r,\n        i,\n        o = t.length,\n        a = new Array(o),\n        u = new Array(o),\n        c = 1 / 0,\n        f = 1 / 0,\n        s = -1 / 0,\n        l = -1 / 0\n      for (e = 0; e < o; ++e)\n        isNaN((r = +this._x.call(null, (n = t[e])))) ||\n          isNaN((i = +this._y.call(null, n))) ||\n          ((a[e] = r), (u[e] = i), r < c && (c = r), r > s && (s = r), i < f && (f = i), i > l && (l = i))\n      for (\n        s < c && ((c = this._x0), (s = this._x1)),\n          l < f && ((f = this._y0), (l = this._y1)),\n          this.cover(c, f).cover(s, l),\n          e = 0;\n        e < o;\n        ++e\n      )\n        ta(this, a[e], u[e], t[e])\n      return this\n    }),\n    (ua.cover = function (t, n) {\n      if (isNaN((t = +t)) || isNaN((n = +n))) return this\n      var e = this._x0,\n        r = this._y0,\n        i = this._x1,\n        o = this._y1\n      if (isNaN(e)) (i = (e = Math.floor(t)) + 1), (o = (r = Math.floor(n)) + 1)\n      else {\n        if (!(e > t || t > i || r > n || n > o)) return this\n        var a,\n          u,\n          c = i - e,\n          f = this._root\n        switch ((u = ((n < (r + o) / 2) << 1) | (t < (e + i) / 2))) {\n          case 0:\n            do {\n              ;((a = new Array(4))[u] = f), (f = a)\n            } while (((o = r + (c *= 2)), t > (i = e + c) || n > o))\n            break\n          case 1:\n            do {\n              ;((a = new Array(4))[u] = f), (f = a)\n            } while (((o = r + (c *= 2)), (e = i - c) > t || n > o))\n            break\n          case 2:\n            do {\n              ;((a = new Array(4))[u] = f), (f = a)\n            } while (((r = o - (c *= 2)), t > (i = e + c) || r > n))\n            break\n          case 3:\n            do {\n              ;((a = new Array(4))[u] = f), (f = a)\n            } while (((r = o - (c *= 2)), (e = i - c) > t || r > n))\n        }\n        this._root && this._root.length && (this._root = f)\n      }\n      return (this._x0 = e), (this._y0 = r), (this._x1 = i), (this._y1 = o), this\n    }),\n    (ua.data = function () {\n      var t = []\n      return (\n        this.visit(function (n) {\n          if (!n.length)\n            do {\n              t.push(n.data)\n            } while ((n = n.next))\n        }),\n        t\n      )\n    }),\n    (ua.extent = function (t) {\n      return arguments.length\n        ? this.cover(+t[0][0], +t[0][1]).cover(+t[1][0], +t[1][1])\n        : isNaN(this._x0)\n        ? void 0\n        : [[this._x0, this._y0], [this._x1, this._y1]]\n    }),\n    (ua.find = function (t, n, e) {\n      var r,\n        i,\n        o,\n        a,\n        u,\n        c,\n        f,\n        s = this._x0,\n        l = this._y0,\n        h = this._x1,\n        d = this._y1,\n        p = [],\n        v = this._root\n      for (\n        v && p.push(new na(v, s, l, h, d)),\n          null == e ? (e = 1 / 0) : ((s = t - e), (l = n - e), (h = t + e), (d = n + e), (e *= e));\n        (c = p.pop());\n\n      )\n        if (!(!(v = c.node) || (i = c.x0) > h || (o = c.y0) > d || (a = c.x1) < s || (u = c.y1) < l))\n          if (v.length) {\n            var g = (i + a) / 2,\n              y = (o + u) / 2\n            p.push(\n              new na(v[3], g, y, a, u),\n              new na(v[2], i, y, g, u),\n              new na(v[1], g, o, a, y),\n              new na(v[0], i, o, g, y)\n            ),\n              (f = ((n >= y) << 1) | (t >= g)) &&\n                ((c = p[p.length - 1]), (p[p.length - 1] = p[p.length - 1 - f]), (p[p.length - 1 - f] = c))\n          } else {\n            var _ = t - +this._x.call(null, v.data),\n              b = n - +this._y.call(null, v.data),\n              m = _ * _ + b * b\n            if (m < e) {\n              var x = Math.sqrt((e = m))\n              ;(s = t - x), (l = n - x), (h = t + x), (d = n + x), (r = v.data)\n            }\n          }\n      return r\n    }),\n    (ua.remove = function (t) {\n      if (isNaN((o = +this._x.call(null, t))) || isNaN((a = +this._y.call(null, t)))) return this\n      var n,\n        e,\n        r,\n        i,\n        o,\n        a,\n        u,\n        c,\n        f,\n        s,\n        l,\n        h,\n        d = this._root,\n        p = this._x0,\n        v = this._y0,\n        g = this._x1,\n        y = this._y1\n      if (!d) return this\n      if (d.length)\n        for (;;) {\n          if (\n            ((f = o >= (u = (p + g) / 2)) ? (p = u) : (g = u),\n            (s = a >= (c = (v + y) / 2)) ? (v = c) : (y = c),\n            (n = d),\n            !(d = d[(l = (s << 1) | f)]))\n          )\n            return this\n          if (!d.length) break\n          ;(n[(l + 1) & 3] || n[(l + 2) & 3] || n[(l + 3) & 3]) && ((e = n), (h = l))\n        }\n      for (; d.data !== t; ) if (((r = d), !(d = d.next))) return this\n      return (\n        (i = d.next) && delete d.next,\n        r\n          ? (i ? (r.next = i) : delete r.next, this)\n          : n\n          ? (i ? (n[l] = i) : delete n[l],\n            (d = n[0] || n[1] || n[2] || n[3]) &&\n              d === (n[3] || n[2] || n[1] || n[0]) &&\n              !d.length &&\n              (e ? (e[h] = d) : (this._root = d)),\n            this)\n          : ((this._root = i), this)\n      )\n    }),\n    (ua.removeAll = function (t) {\n      for (var n = 0, e = t.length; n < e; ++n) this.remove(t[n])\n      return this\n    }),\n    (ua.root = function () {\n      return this._root\n    }),\n    (ua.size = function () {\n      var t = 0\n      return (\n        this.visit(function (n) {\n          if (!n.length)\n            do {\n              ++t\n            } while ((n = n.next))\n        }),\n        t\n      )\n    }),\n    (ua.visit = function (t) {\n      var n,\n        e,\n        r,\n        i,\n        o,\n        a,\n        u = [],\n        c = this._root\n      for (c && u.push(new na(c, this._x0, this._y0, this._x1, this._y1)); (n = u.pop()); )\n        if (!t((c = n.node), (r = n.x0), (i = n.y0), (o = n.x1), (a = n.y1)) && c.length) {\n          var f = (r + o) / 2,\n            s = (i + a) / 2\n          ;(e = c[3]) && u.push(new na(e, f, s, o, a)),\n            (e = c[2]) && u.push(new na(e, r, s, f, a)),\n            (e = c[1]) && u.push(new na(e, f, i, o, s)),\n            (e = c[0]) && u.push(new na(e, r, i, f, s))\n        }\n      return this\n    }),\n    (ua.visitAfter = function (t) {\n      var n,\n        e = [],\n        r = []\n      for (this._root && e.push(new na(this._root, this._x0, this._y0, this._x1, this._y1)); (n = e.pop()); ) {\n        var i = n.node\n        if (i.length) {\n          var o,\n            a = n.x0,\n            u = n.y0,\n            c = n.x1,\n            f = n.y1,\n            s = (a + c) / 2,\n            l = (u + f) / 2\n          ;(o = i[0]) && e.push(new na(o, a, u, s, l)),\n            (o = i[1]) && e.push(new na(o, s, u, c, l)),\n            (o = i[2]) && e.push(new na(o, a, l, s, f)),\n            (o = i[3]) && e.push(new na(o, s, l, c, f))\n        }\n        r.push(n)\n      }\n      for (; (n = r.pop()); ) t(n.node, n.x0, n.y0, n.x1, n.y1)\n      return this\n    }),\n    (ua.x = function (t) {\n      return arguments.length ? ((this._x = t), this) : this._x\n    }),\n    (ua.y = function (t) {\n      return arguments.length ? ((this._y = t), this) : this._y\n    })\n  var pa = 10,\n    va = Math.PI * (3 - Math.sqrt(5))\n  function ga (t, n) {\n    if ((e = (t = n ? t.toExponential(n - 1) : t.toExponential()).indexOf('e')) < 0) return null\n    var e,\n      r = t.slice(0, e)\n    return [r.length > 1 ? r[0] + r.slice(2) : r, +t.slice(e + 1)]\n  }\n  function ya (t) {\n    return (t = ga(Math.abs(t))) ? t[1] : NaN\n  }\n  var _a,\n    ba = /^(?:(.)?([<>=^]))?([+\\-( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?(~)?([a-z%])?$/i\n  function ma (t) {\n    return new xa(t)\n  }\n  function xa (t) {\n    if (!(n = ba.exec(t))) throw new Error('invalid format: ' + t)\n    var n\n    ;(this.fill = n[1] || ' '),\n      (this.align = n[2] || '>'),\n      (this.sign = n[3] || '-'),\n      (this.symbol = n[4] || ''),\n      (this.zero = !!n[5]),\n      (this.width = n[6] && +n[6]),\n      (this.comma = !!n[7]),\n      (this.precision = n[8] && +n[8].slice(1)),\n      (this.trim = !!n[9]),\n      (this.type = n[10] || '')\n  }\n  function wa (t, n) {\n    var e = ga(t, n)\n    if (!e) return t + ''\n    var r = e[0],\n      i = e[1]\n    return i < 0\n      ? '0.' + new Array(-i).join('0') + r\n      : r.length > i + 1\n      ? r.slice(0, i + 1) + '.' + r.slice(i + 1)\n      : r + new Array(i - r.length + 2).join('0')\n  }\n  ;(ma.prototype = xa.prototype),\n    (xa.prototype.toString = function () {\n      return (\n        this.fill +\n        this.align +\n        this.sign +\n        this.symbol +\n        (this.zero ? '0' : '') +\n        (null == this.width ? '' : Math.max(1, 0 | this.width)) +\n        (this.comma ? ',' : '') +\n        (null == this.precision ? '' : '.' + Math.max(0, 0 | this.precision)) +\n        (this.trim ? '~' : '') +\n        this.type\n      )\n    })\n  var Ma = {\n    '%': function (t, n) {\n      return (100 * t).toFixed(n)\n    },\n    b: function (t) {\n      return Math.round(t).toString(2)\n    },\n    c: function (t) {\n      return t + ''\n    },\n    d: function (t) {\n      return Math.round(t).toString(10)\n    },\n    e: function (t, n) {\n      return t.toExponential(n)\n    },\n    f: function (t, n) {\n      return t.toFixed(n)\n    },\n    g: function (t, n) {\n      return t.toPrecision(n)\n    },\n    o: function (t) {\n      return Math.round(t).toString(8)\n    },\n    p: function (t, n) {\n      return wa(100 * t, n)\n    },\n    r: wa,\n    s: function (t, n) {\n      var e = ga(t, n)\n      if (!e) return t + ''\n      var r = e[0],\n        i = e[1],\n        o = i - (_a = 3 * Math.max(-8, Math.min(8, Math.floor(i / 3)))) + 1,\n        a = r.length\n      return o === a\n        ? r\n        : o > a\n        ? r + new Array(o - a + 1).join('0')\n        : o > 0\n        ? r.slice(0, o) + '.' + r.slice(o)\n        : '0.' + new Array(1 - o).join('0') + ga(t, Math.max(0, n + o - 1))[0]\n    },\n    X: function (t) {\n      return Math.round(t)\n        .toString(16)\n        .toUpperCase()\n    },\n    x: function (t) {\n      return Math.round(t).toString(16)\n    }\n  }\n  function Na (t) {\n    return t\n  }\n  var Aa,\n    Sa = ['y', 'z', 'a', 'f', 'p', 'n', 'µ', 'm', '', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y']\n  function ka (t) {\n    var n,\n      e,\n      r =\n        t.grouping && t.thousands\n          ? ((n = t.grouping),\n            (e = t.thousands),\n            function (t, r) {\n              for (\n                var i = t.length, o = [], a = 0, u = n[0], c = 0;\n                i > 0 &&\n                u > 0 &&\n                (c + u + 1 > r && (u = Math.max(1, r - c)), o.push(t.substring((i -= u), i + u)), !((c += u + 1) > r));\n\n              )\n                u = n[(a = (a + 1) % n.length)]\n              return o.reverse().join(e)\n            })\n          : Na,\n      i = t.currency,\n      o = t.decimal,\n      a = t.numerals\n        ? (function (t) {\n            return function (n) {\n              return n.replace(/[0-9]/g, function (n) {\n                return t[+n]\n              })\n            }\n          })(t.numerals)\n        : Na,\n      u = t.percent || '%'\n    function c (t) {\n      var n = (t = ma(t)).fill,\n        e = t.align,\n        c = t.sign,\n        f = t.symbol,\n        s = t.zero,\n        l = t.width,\n        h = t.comma,\n        d = t.precision,\n        p = t.trim,\n        v = t.type\n      'n' === v ? ((h = !0), (v = 'g')) : Ma[v] || (null == d && (d = 12), (p = !0), (v = 'g')),\n        (s || ('0' === n && '=' === e)) && ((s = !0), (n = '0'), (e = '='))\n      var g = '$' === f ? i[0] : '#' === f && /[boxX]/.test(v) ? '0' + v.toLowerCase() : '',\n        y = '$' === f ? i[1] : /[%p]/.test(v) ? u : '',\n        _ = Ma[v],\n        b = /[defgprs%]/.test(v)\n      function m (t) {\n        var i,\n          u,\n          f,\n          m = g,\n          x = y\n        if ('c' === v) (x = _(t) + x), (t = '')\n        else {\n          var w = (t = +t) < 0\n          if (\n            ((t = _(Math.abs(t), d)),\n            p &&\n              (t = (function (t) {\n                t: for (var n, e = t.length, r = 1, i = -1; r < e; ++r)\n                  switch (t[r]) {\n                    case '.':\n                      i = n = r\n                      break\n                    case '0':\n                      0 === i && (i = r), (n = r)\n                      break\n                    default:\n                      if (i > 0) {\n                        if (!+t[r]) break t\n                        i = 0\n                      }\n                  }\n                return i > 0 ? t.slice(0, i) + t.slice(n + 1) : t\n              })(t)),\n            w && 0 == +t && (w = !1),\n            (m = (w ? ('(' === c ? c : '-') : '-' === c || '(' === c ? '' : c) + m),\n            (x = ('s' === v ? Sa[8 + _a / 3] : '') + x + (w && '(' === c ? ')' : '')),\n            b)\n          )\n            for (i = -1, u = t.length; ++i < u; )\n              if (48 > (f = t.charCodeAt(i)) || f > 57) {\n                ;(x = (46 === f ? o + t.slice(i + 1) : t.slice(i)) + x), (t = t.slice(0, i))\n                break\n              }\n        }\n        h && !s && (t = r(t, 1 / 0))\n        var M = m.length + t.length + x.length,\n          N = M < l ? new Array(l - M + 1).join(n) : ''\n        switch ((h && s && ((t = r(N + t, N.length ? l - x.length : 1 / 0)), (N = '')), e)) {\n          case '<':\n            t = m + t + x + N\n            break\n          case '=':\n            t = m + N + t + x\n            break\n          case '^':\n            t = N.slice(0, (M = N.length >> 1)) + m + t + x + N.slice(M)\n            break\n          default:\n            t = N + m + t + x\n        }\n        return a(t)\n      }\n      return (\n        (d = null == d ? 6 : /[gprs]/.test(v) ? Math.max(1, Math.min(21, d)) : Math.max(0, Math.min(20, d))),\n        (m.toString = function () {\n          return t + ''\n        }),\n        m\n      )\n    }\n    return {\n      format: c,\n      formatPrefix: function (t, n) {\n        var e = c((((t = ma(t)).type = 'f'), t)),\n          r = 3 * Math.max(-8, Math.min(8, Math.floor(ya(n) / 3))),\n          i = Math.pow(10, -r),\n          o = Sa[8 + r / 3]\n        return function (t) {\n          return e(i * t) + o\n        }\n      }\n    }\n  }\n  function Ta (n) {\n    return (Aa = ka(n)), (t.format = Aa.format), (t.formatPrefix = Aa.formatPrefix), Aa\n  }\n  function Ea (t) {\n    return Math.max(0, -ya(Math.abs(t)))\n  }\n  function Ca (t, n) {\n    return Math.max(0, 3 * Math.max(-8, Math.min(8, Math.floor(ya(n) / 3))) - ya(Math.abs(t)))\n  }\n  function Pa (t, n) {\n    return (t = Math.abs(t)), (n = Math.abs(n) - t), Math.max(0, ya(n) - ya(t)) + 1\n  }\n  function za () {\n    return new Ra()\n  }\n  function Ra () {\n    this.reset()\n  }\n  Ta({ decimal: '.', thousands: ',', grouping: [3], currency: ['$', ''] }),\n    (Ra.prototype = {\n      constructor: Ra,\n      reset: function () {\n        this.s = this.t = 0\n      },\n      add: function (t) {\n        qa(Da, t, this.t), qa(this, Da.s, this.s), this.s ? (this.t += Da.t) : (this.s = Da.t)\n      },\n      valueOf: function () {\n        return this.s\n      }\n    })\n  var Da = new Ra()\n  function qa (t, n, e) {\n    var r = (t.s = n + e),\n      i = r - n,\n      o = r - i\n    t.t = n - o + (e - i)\n  }\n  var La = 1e-6,\n    Ua = 1e-12,\n    Oa = Math.PI,\n    Ba = Oa / 2,\n    Ya = Oa / 4,\n    Fa = 2 * Oa,\n    Ia = 180 / Oa,\n    ja = Oa / 180,\n    Ha = Math.abs,\n    Xa = Math.atan,\n    Ga = Math.atan2,\n    Va = Math.cos,\n    $a = Math.ceil,\n    Wa = Math.exp,\n    Za = Math.log,\n    Qa = Math.pow,\n    Ja = Math.sin,\n    Ka =\n      Math.sign ||\n      function (t) {\n        return t > 0 ? 1 : t < 0 ? -1 : 0\n      },\n    tu = Math.sqrt,\n    nu = Math.tan\n  function eu (t) {\n    return t > 1 ? 0 : t < -1 ? Oa : Math.acos(t)\n  }\n  function ru (t) {\n    return t > 1 ? Ba : t < -1 ? -Ba : Math.asin(t)\n  }\n  function iu (t) {\n    return (t = Ja(t / 2)) * t\n  }\n  function ou () {}\n  function au (t, n) {\n    t && cu.hasOwnProperty(t.type) && cu[t.type](t, n)\n  }\n  var uu = {\n      Feature: function (t, n) {\n        au(t.geometry, n)\n      },\n      FeatureCollection: function (t, n) {\n        for (var e = t.features, r = -1, i = e.length; ++r < i; ) au(e[r].geometry, n)\n      }\n    },\n    cu = {\n      Sphere: function (t, n) {\n        n.sphere()\n      },\n      Point: function (t, n) {\n        ;(t = t.coordinates), n.point(t[0], t[1], t[2])\n      },\n      MultiPoint: function (t, n) {\n        for (var e = t.coordinates, r = -1, i = e.length; ++r < i; ) (t = e[r]), n.point(t[0], t[1], t[2])\n      },\n      LineString: function (t, n) {\n        fu(t.coordinates, n, 0)\n      },\n      MultiLineString: function (t, n) {\n        for (var e = t.coordinates, r = -1, i = e.length; ++r < i; ) fu(e[r], n, 0)\n      },\n      Polygon: function (t, n) {\n        su(t.coordinates, n)\n      },\n      MultiPolygon: function (t, n) {\n        for (var e = t.coordinates, r = -1, i = e.length; ++r < i; ) su(e[r], n)\n      },\n      GeometryCollection: function (t, n) {\n        for (var e = t.geometries, r = -1, i = e.length; ++r < i; ) au(e[r], n)\n      }\n    }\n  function fu (t, n, e) {\n    var r,\n      i = -1,\n      o = t.length - e\n    for (n.lineStart(); ++i < o; ) (r = t[i]), n.point(r[0], r[1], r[2])\n    n.lineEnd()\n  }\n  function su (t, n) {\n    var e = -1,\n      r = t.length\n    for (n.polygonStart(); ++e < r; ) fu(t[e], n, 1)\n    n.polygonEnd()\n  }\n  function lu (t, n) {\n    t && uu.hasOwnProperty(t.type) ? uu[t.type](t, n) : au(t, n)\n  }\n  var hu,\n    du,\n    pu,\n    vu,\n    gu,\n    yu = za(),\n    _u = za(),\n    bu = {\n      point: ou,\n      lineStart: ou,\n      lineEnd: ou,\n      polygonStart: function () {\n        yu.reset(), (bu.lineStart = mu), (bu.lineEnd = xu)\n      },\n      polygonEnd: function () {\n        var t = +yu\n        _u.add(t < 0 ? Fa + t : t), (this.lineStart = this.lineEnd = this.point = ou)\n      },\n      sphere: function () {\n        _u.add(Fa)\n      }\n    }\n  function mu () {\n    bu.point = wu\n  }\n  function xu () {\n    Mu(hu, du)\n  }\n  function wu (t, n) {\n    ;(bu.point = Mu), (hu = t), (du = n), (pu = t *= ja), (vu = Va((n = (n *= ja) / 2 + Ya))), (gu = Ja(n))\n  }\n  function Mu (t, n) {\n    var e = (t *= ja) - pu,\n      r = e >= 0 ? 1 : -1,\n      i = r * e,\n      o = Va((n = (n *= ja) / 2 + Ya)),\n      a = Ja(n),\n      u = gu * a,\n      c = vu * o + u * Va(i),\n      f = u * r * Ja(i)\n    yu.add(Ga(f, c)), (pu = t), (vu = o), (gu = a)\n  }\n  function Nu (t) {\n    return [Ga(t[1], t[0]), ru(t[2])]\n  }\n  function Au (t) {\n    var n = t[0],\n      e = t[1],\n      r = Va(e)\n    return [r * Va(n), r * Ja(n), Ja(e)]\n  }\n  function Su (t, n) {\n    return t[0] * n[0] + t[1] * n[1] + t[2] * n[2]\n  }\n  function ku (t, n) {\n    return [t[1] * n[2] - t[2] * n[1], t[2] * n[0] - t[0] * n[2], t[0] * n[1] - t[1] * n[0]]\n  }\n  function Tu (t, n) {\n    ;(t[0] += n[0]), (t[1] += n[1]), (t[2] += n[2])\n  }\n  function Eu (t, n) {\n    return [t[0] * n, t[1] * n, t[2] * n]\n  }\n  function Cu (t) {\n    var n = tu(t[0] * t[0] + t[1] * t[1] + t[2] * t[2])\n    ;(t[0] /= n), (t[1] /= n), (t[2] /= n)\n  }\n  var Pu,\n    zu,\n    Ru,\n    Du,\n    qu,\n    Lu,\n    Uu,\n    Ou,\n    Bu,\n    Yu,\n    Fu,\n    Iu,\n    ju,\n    Hu,\n    Xu,\n    Gu,\n    Vu,\n    $u,\n    Wu,\n    Zu,\n    Qu,\n    Ju,\n    Ku,\n    tc,\n    nc,\n    ec,\n    rc = za(),\n    ic = {\n      point: oc,\n      lineStart: uc,\n      lineEnd: cc,\n      polygonStart: function () {\n        ;(ic.point = fc), (ic.lineStart = sc), (ic.lineEnd = lc), rc.reset(), bu.polygonStart()\n      },\n      polygonEnd: function () {\n        bu.polygonEnd(),\n          (ic.point = oc),\n          (ic.lineStart = uc),\n          (ic.lineEnd = cc),\n          yu < 0 ? ((Pu = -(Ru = 180)), (zu = -(Du = 90))) : rc > La ? (Du = 90) : rc < -La && (zu = -90),\n          (Yu[0] = Pu),\n          (Yu[1] = Ru)\n      }\n    }\n  function oc (t, n) {\n    Bu.push((Yu = [(Pu = t), (Ru = t)])), n < zu && (zu = n), n > Du && (Du = n)\n  }\n  function ac (t, n) {\n    var e = Au([t * ja, n * ja])\n    if (Ou) {\n      var r = ku(Ou, e),\n        i = ku([r[1], -r[0], 0], r)\n      Cu(i), (i = Nu(i))\n      var o,\n        a = t - qu,\n        u = a > 0 ? 1 : -1,\n        c = i[0] * Ia * u,\n        f = Ha(a) > 180\n      f ^ (u * qu < c && c < u * t)\n        ? (o = i[1] * Ia) > Du && (Du = o)\n        : f ^ (u * qu < (c = ((c + 360) % 360) - 180) && c < u * t)\n        ? (o = -i[1] * Ia) < zu && (zu = o)\n        : (n < zu && (zu = n), n > Du && (Du = n)),\n        f\n          ? t < qu\n            ? hc(Pu, t) > hc(Pu, Ru) && (Ru = t)\n            : hc(t, Ru) > hc(Pu, Ru) && (Pu = t)\n          : Ru >= Pu\n          ? (t < Pu && (Pu = t), t > Ru && (Ru = t))\n          : t > qu\n          ? hc(Pu, t) > hc(Pu, Ru) && (Ru = t)\n          : hc(t, Ru) > hc(Pu, Ru) && (Pu = t)\n    } else Bu.push((Yu = [(Pu = t), (Ru = t)]))\n    n < zu && (zu = n), n > Du && (Du = n), (Ou = e), (qu = t)\n  }\n  function uc () {\n    ic.point = ac\n  }\n  function cc () {\n    ;(Yu[0] = Pu), (Yu[1] = Ru), (ic.point = oc), (Ou = null)\n  }\n  function fc (t, n) {\n    if (Ou) {\n      var e = t - qu\n      rc.add(Ha(e) > 180 ? e + (e > 0 ? 360 : -360) : e)\n    } else (Lu = t), (Uu = n)\n    bu.point(t, n), ac(t, n)\n  }\n  function sc () {\n    bu.lineStart()\n  }\n  function lc () {\n    fc(Lu, Uu), bu.lineEnd(), Ha(rc) > La && (Pu = -(Ru = 180)), (Yu[0] = Pu), (Yu[1] = Ru), (Ou = null)\n  }\n  function hc (t, n) {\n    return (n -= t) < 0 ? n + 360 : n\n  }\n  function dc (t, n) {\n    return t[0] - n[0]\n  }\n  function pc (t, n) {\n    return t[0] <= t[1] ? t[0] <= n && n <= t[1] : n < t[0] || t[1] < n\n  }\n  var vc = {\n    sphere: ou,\n    point: gc,\n    lineStart: _c,\n    lineEnd: xc,\n    polygonStart: function () {\n      ;(vc.lineStart = wc), (vc.lineEnd = Mc)\n    },\n    polygonEnd: function () {\n      ;(vc.lineStart = _c), (vc.lineEnd = xc)\n    }\n  }\n  function gc (t, n) {\n    t *= ja\n    var e = Va((n *= ja))\n    yc(e * Va(t), e * Ja(t), Ja(n))\n  }\n  function yc (t, n, e) {\n    ;(ju += (t - ju) / ++Fu), (Hu += (n - Hu) / Fu), (Xu += (e - Xu) / Fu)\n  }\n  function _c () {\n    vc.point = bc\n  }\n  function bc (t, n) {\n    t *= ja\n    var e = Va((n *= ja))\n    ;(tc = e * Va(t)), (nc = e * Ja(t)), (ec = Ja(n)), (vc.point = mc), yc(tc, nc, ec)\n  }\n  function mc (t, n) {\n    t *= ja\n    var e = Va((n *= ja)),\n      r = e * Va(t),\n      i = e * Ja(t),\n      o = Ja(n),\n      a = Ga(\n        tu((a = nc * o - ec * i) * a + (a = ec * r - tc * o) * a + (a = tc * i - nc * r) * a),\n        tc * r + nc * i + ec * o\n      )\n    ;(Iu += a), (Gu += a * (tc + (tc = r))), (Vu += a * (nc + (nc = i))), ($u += a * (ec + (ec = o))), yc(tc, nc, ec)\n  }\n  function xc () {\n    vc.point = gc\n  }\n  function wc () {\n    vc.point = Nc\n  }\n  function Mc () {\n    Ac(Ju, Ku), (vc.point = gc)\n  }\n  function Nc (t, n) {\n    ;(Ju = t), (Ku = n), (t *= ja), (n *= ja), (vc.point = Ac)\n    var e = Va(n)\n    ;(tc = e * Va(t)), (nc = e * Ja(t)), (ec = Ja(n)), yc(tc, nc, ec)\n  }\n  function Ac (t, n) {\n    t *= ja\n    var e = Va((n *= ja)),\n      r = e * Va(t),\n      i = e * Ja(t),\n      o = Ja(n),\n      a = nc * o - ec * i,\n      u = ec * r - tc * o,\n      c = tc * i - nc * r,\n      f = tu(a * a + u * u + c * c),\n      s = ru(f),\n      l = f && -s / f\n    ;(Wu += l * a),\n      (Zu += l * u),\n      (Qu += l * c),\n      (Iu += s),\n      (Gu += s * (tc + (tc = r))),\n      (Vu += s * (nc + (nc = i))),\n      ($u += s * (ec + (ec = o))),\n      yc(tc, nc, ec)\n  }\n  function Sc (t) {\n    return function () {\n      return t\n    }\n  }\n  function kc (t, n) {\n    function e (e, r) {\n      return (e = t(e, r)), n(e[0], e[1])\n    }\n    return (\n      t.invert &&\n        n.invert &&\n        (e.invert = function (e, r) {\n          return (e = n.invert(e, r)) && t.invert(e[0], e[1])\n        }),\n      e\n    )\n  }\n  function Tc (t, n) {\n    return [Ha(t) > Oa ? t + Math.round(-t / Fa) * Fa : t, n]\n  }\n  function Ec (t, n, e) {\n    return (t %= Fa) ? (n || e ? kc(Pc(t), zc(n, e)) : Pc(t)) : n || e ? zc(n, e) : Tc\n  }\n  function Cc (t) {\n    return function (n, e) {\n      return [(n += t) > Oa ? n - Fa : n < -Oa ? n + Fa : n, e]\n    }\n  }\n  function Pc (t) {\n    var n = Cc(t)\n    return (n.invert = Cc(-t)), n\n  }\n  function zc (t, n) {\n    var e = Va(t),\n      r = Ja(t),\n      i = Va(n),\n      o = Ja(n)\n    function a (t, n) {\n      var a = Va(n),\n        u = Va(t) * a,\n        c = Ja(t) * a,\n        f = Ja(n),\n        s = f * e + u * r\n      return [Ga(c * i - s * o, u * e - f * r), ru(s * i + c * o)]\n    }\n    return (\n      (a.invert = function (t, n) {\n        var a = Va(n),\n          u = Va(t) * a,\n          c = Ja(t) * a,\n          f = Ja(n),\n          s = f * i - c * o\n        return [Ga(c * i + f * o, u * e + s * r), ru(s * e - u * r)]\n      }),\n      a\n    )\n  }\n  function Rc (t) {\n    function n (n) {\n      return ((n = t(n[0] * ja, n[1] * ja))[0] *= Ia), (n[1] *= Ia), n\n    }\n    return (\n      (t = Ec(t[0] * ja, t[1] * ja, t.length > 2 ? t[2] * ja : 0)),\n      (n.invert = function (n) {\n        return ((n = t.invert(n[0] * ja, n[1] * ja))[0] *= Ia), (n[1] *= Ia), n\n      }),\n      n\n    )\n  }\n  function Dc (t, n, e, r, i, o) {\n    if (e) {\n      var a = Va(n),\n        u = Ja(n),\n        c = r * e\n      null == i\n        ? ((i = n + r * Fa), (o = n - c / 2))\n        : ((i = qc(a, i)), (o = qc(a, o)), (r > 0 ? i < o : i > o) && (i += r * Fa))\n      for (var f, s = i; r > 0 ? s > o : s < o; s -= c) (f = Nu([a, -u * Va(s), -u * Ja(s)])), t.point(f[0], f[1])\n    }\n  }\n  function qc (t, n) {\n    ;((n = Au(n))[0] -= t), Cu(n)\n    var e = eu(-n[1])\n    return ((-n[2] < 0 ? -e : e) + Fa - La) % Fa\n  }\n  function Lc () {\n    var t,\n      n = []\n    return {\n      point: function (n, e) {\n        t.push([n, e])\n      },\n      lineStart: function () {\n        n.push((t = []))\n      },\n      lineEnd: ou,\n      rejoin: function () {\n        n.length > 1 && n.push(n.pop().concat(n.shift()))\n      },\n      result: function () {\n        var e = n\n        return (n = []), (t = null), e\n      }\n    }\n  }\n  function Uc (t, n) {\n    return Ha(t[0] - n[0]) < La && Ha(t[1] - n[1]) < La\n  }\n  function Oc (t, n, e, r) {\n    ;(this.x = t), (this.z = n), (this.o = e), (this.e = r), (this.v = !1), (this.n = this.p = null)\n  }\n  function Bc (t, n, e, r, i) {\n    var o,\n      a,\n      u = [],\n      c = []\n    if (\n      (t.forEach(function (t) {\n        if (!((n = t.length - 1) <= 0)) {\n          var n,\n            e,\n            r = t[0],\n            a = t[n]\n          if (Uc(r, a)) {\n            for (i.lineStart(), o = 0; o < n; ++o) i.point((r = t[o])[0], r[1])\n            i.lineEnd()\n          } else\n            u.push((e = new Oc(r, t, null, !0))),\n              c.push((e.o = new Oc(r, null, e, !1))),\n              u.push((e = new Oc(a, t, null, !1))),\n              c.push((e.o = new Oc(a, null, e, !0)))\n        }\n      }),\n      u.length)\n    ) {\n      for (c.sort(n), Yc(u), Yc(c), o = 0, a = c.length; o < a; ++o) c[o].e = e = !e\n      for (var f, s, l = u[0]; ; ) {\n        for (var h = l, d = !0; h.v; ) if ((h = h.n) === l) return\n        ;(f = h.z), i.lineStart()\n        do {\n          if (((h.v = h.o.v = !0), h.e)) {\n            if (d) for (o = 0, a = f.length; o < a; ++o) i.point((s = f[o])[0], s[1])\n            else r(h.x, h.n.x, 1, i)\n            h = h.n\n          } else {\n            if (d) for (f = h.p.z, o = f.length - 1; o >= 0; --o) i.point((s = f[o])[0], s[1])\n            else r(h.x, h.p.x, -1, i)\n            h = h.p\n          }\n          ;(f = (h = h.o).z), (d = !d)\n        } while (!h.v)\n        i.lineEnd()\n      }\n    }\n  }\n  function Yc (t) {\n    if ((n = t.length)) {\n      for (var n, e, r = 0, i = t[0]; ++r < n; ) (i.n = e = t[r]), (e.p = i), (i = e)\n      ;(i.n = e = t[0]), (e.p = i)\n    }\n  }\n  Tc.invert = Tc\n  var Fc = za()\n  function Ic (t, n) {\n    var e = n[0],\n      r = n[1],\n      i = Ja(r),\n      o = [Ja(e), -Va(e), 0],\n      a = 0,\n      u = 0\n    Fc.reset(), 1 === i ? (r = Ba + La) : -1 === i && (r = -Ba - La)\n    for (var c = 0, f = t.length; c < f; ++c)\n      if ((l = (s = t[c]).length))\n        for (\n          var s, l, h = s[l - 1], d = h[0], p = h[1] / 2 + Ya, v = Ja(p), g = Va(p), y = 0;\n          y < l;\n          ++y, d = b, v = x, g = w, h = _\n        ) {\n          var _ = s[y],\n            b = _[0],\n            m = _[1] / 2 + Ya,\n            x = Ja(m),\n            w = Va(m),\n            M = b - d,\n            N = M >= 0 ? 1 : -1,\n            A = N * M,\n            S = A > Oa,\n            k = v * x\n          if ((Fc.add(Ga(k * N * Ja(A), g * w + k * Va(A))), (a += S ? M + N * Fa : M), S ^ (d >= e) ^ (b >= e))) {\n            var T = ku(Au(h), Au(_))\n            Cu(T)\n            var E = ku(o, T)\n            Cu(E)\n            var C = (S ^ (M >= 0) ? -1 : 1) * ru(E[2])\n            ;(r > C || (r === C && (T[0] || T[1]))) && (u += S ^ (M >= 0) ? 1 : -1)\n          }\n        }\n    return (a < -La || (a < La && Fc < -La)) ^ (1 & u)\n  }\n  function jc (t, n, e, r) {\n    return function (i) {\n      var o,\n        a,\n        u,\n        c = n(i),\n        f = Lc(),\n        s = n(f),\n        l = !1,\n        h = {\n          point: d,\n          lineStart: v,\n          lineEnd: g,\n          polygonStart: function () {\n            ;(h.point = y), (h.lineStart = _), (h.lineEnd = b), (a = []), (o = [])\n          },\n          polygonEnd: function () {\n            ;(h.point = d), (h.lineStart = v), (h.lineEnd = g), (a = S(a))\n            var t = Ic(o, r)\n            a.length\n              ? (l || (i.polygonStart(), (l = !0)), Bc(a, Xc, t, e, i))\n              : t && (l || (i.polygonStart(), (l = !0)), i.lineStart(), e(null, null, 1, i), i.lineEnd()),\n              l && (i.polygonEnd(), (l = !1)),\n              (a = o = null)\n          },\n          sphere: function () {\n            i.polygonStart(), i.lineStart(), e(null, null, 1, i), i.lineEnd(), i.polygonEnd()\n          }\n        }\n      function d (n, e) {\n        t(n, e) && i.point(n, e)\n      }\n      function p (t, n) {\n        c.point(t, n)\n      }\n      function v () {\n        ;(h.point = p), c.lineStart()\n      }\n      function g () {\n        ;(h.point = d), c.lineEnd()\n      }\n      function y (t, n) {\n        u.push([t, n]), s.point(t, n)\n      }\n      function _ () {\n        s.lineStart(), (u = [])\n      }\n      function b () {\n        y(u[0][0], u[0][1]), s.lineEnd()\n        var t,\n          n,\n          e,\n          r,\n          c = s.clean(),\n          h = f.result(),\n          d = h.length\n        if ((u.pop(), o.push(u), (u = null), d))\n          if (1 & c) {\n            if ((n = (e = h[0]).length - 1) > 0) {\n              for (l || (i.polygonStart(), (l = !0)), i.lineStart(), t = 0; t < n; ++t) i.point((r = e[t])[0], r[1])\n              i.lineEnd()\n            }\n          } else d > 1 && 2 & c && h.push(h.pop().concat(h.shift())), a.push(h.filter(Hc))\n      }\n      return h\n    }\n  }\n  function Hc (t) {\n    return t.length > 1\n  }\n  function Xc (t, n) {\n    return ((t = t.x)[0] < 0 ? t[1] - Ba - La : Ba - t[1]) - ((n = n.x)[0] < 0 ? n[1] - Ba - La : Ba - n[1])\n  }\n  var Gc = jc(\n    function () {\n      return !0\n    },\n    function (t) {\n      var n,\n        e = NaN,\n        r = NaN,\n        i = NaN\n      return {\n        lineStart: function () {\n          t.lineStart(), (n = 1)\n        },\n        point: function (o, a) {\n          var u = o > 0 ? Oa : -Oa,\n            c = Ha(o - e)\n          Ha(c - Oa) < La\n            ? (t.point(e, (r = (r + a) / 2 > 0 ? Ba : -Ba)),\n              t.point(i, r),\n              t.lineEnd(),\n              t.lineStart(),\n              t.point(u, r),\n              t.point(o, r),\n              (n = 0))\n            : i !== u &&\n              c >= Oa &&\n              (Ha(e - i) < La && (e -= i * La),\n              Ha(o - u) < La && (o -= u * La),\n              (r = (function (t, n, e, r) {\n                var i,\n                  o,\n                  a = Ja(t - e)\n                return Ha(a) > La\n                  ? Xa((Ja(n) * (o = Va(r)) * Ja(e) - Ja(r) * (i = Va(n)) * Ja(t)) / (i * o * a))\n                  : (n + r) / 2\n              })(e, r, o, a)),\n              t.point(i, r),\n              t.lineEnd(),\n              t.lineStart(),\n              t.point(u, r),\n              (n = 0)),\n            t.point((e = o), (r = a)),\n            (i = u)\n        },\n        lineEnd: function () {\n          t.lineEnd(), (e = r = NaN)\n        },\n        clean: function () {\n          return 2 - n\n        }\n      }\n    },\n    function (t, n, e, r) {\n      var i\n      if (null == t)\n        (i = e * Ba),\n          r.point(-Oa, i),\n          r.point(0, i),\n          r.point(Oa, i),\n          r.point(Oa, 0),\n          r.point(Oa, -i),\n          r.point(0, -i),\n          r.point(-Oa, -i),\n          r.point(-Oa, 0),\n          r.point(-Oa, i)\n      else if (Ha(t[0] - n[0]) > La) {\n        var o = t[0] < n[0] ? Oa : -Oa\n        ;(i = (e * o) / 2), r.point(-o, i), r.point(0, i), r.point(o, i)\n      } else r.point(n[0], n[1])\n    },\n    [-Oa, -Ba]\n  )\n  function Vc (t) {\n    var n = Va(t),\n      e = 6 * ja,\n      r = n > 0,\n      i = Ha(n) > La\n    function o (t, e) {\n      return Va(t) * Va(e) > n\n    }\n    function a (t, e, r) {\n      var i = [1, 0, 0],\n        o = ku(Au(t), Au(e)),\n        a = Su(o, o),\n        u = o[0],\n        c = a - u * u\n      if (!c) return !r && t\n      var f = (n * a) / c,\n        s = (-n * u) / c,\n        l = ku(i, o),\n        h = Eu(i, f)\n      Tu(h, Eu(o, s))\n      var d = l,\n        p = Su(h, d),\n        v = Su(d, d),\n        g = p * p - v * (Su(h, h) - 1)\n      if (!(g < 0)) {\n        var y = tu(g),\n          _ = Eu(d, (-p - y) / v)\n        if ((Tu(_, h), (_ = Nu(_)), !r)) return _\n        var b,\n          m = t[0],\n          x = e[0],\n          w = t[1],\n          M = e[1]\n        x < m && ((b = m), (m = x), (x = b))\n        var N = x - m,\n          A = Ha(N - Oa) < La\n        if (\n          (!A && M < w && ((b = w), (w = M), (M = b)),\n          A || N < La\n            ? A\n              ? (w + M > 0) ^ (_[1] < (Ha(_[0] - m) < La ? w : M))\n              : w <= _[1] && _[1] <= M\n            : (N > Oa) ^ (m <= _[0] && _[0] <= x))\n        ) {\n          var S = Eu(d, (-p + y) / v)\n          return Tu(S, h), [_, Nu(S)]\n        }\n      }\n    }\n    function u (n, e) {\n      var i = r ? t : Oa - t,\n        o = 0\n      return n < -i ? (o |= 1) : n > i && (o |= 2), e < -i ? (o |= 4) : e > i && (o |= 8), o\n    }\n    return jc(\n      o,\n      function (t) {\n        var n, e, c, f, s\n        return {\n          lineStart: function () {\n            ;(f = c = !1), (s = 1)\n          },\n          point: function (l, h) {\n            var d,\n              p = [l, h],\n              v = o(l, h),\n              g = r ? (v ? 0 : u(l, h)) : v ? u(l + (l < 0 ? Oa : -Oa), h) : 0\n            if (\n              (!n && (f = c = v) && t.lineStart(),\n              v !== c && (!(d = a(n, p)) || Uc(n, d) || Uc(p, d)) && ((p[0] += La), (p[1] += La), (v = o(p[0], p[1]))),\n              v !== c)\n            )\n              (s = 0),\n                v\n                  ? (t.lineStart(), (d = a(p, n)), t.point(d[0], d[1]))\n                  : ((d = a(n, p)), t.point(d[0], d[1]), t.lineEnd()),\n                (n = d)\n            else if (i && n && r ^ v) {\n              var y\n              g & e ||\n                !(y = a(p, n, !0)) ||\n                ((s = 0),\n                r\n                  ? (t.lineStart(), t.point(y[0][0], y[0][1]), t.point(y[1][0], y[1][1]), t.lineEnd())\n                  : (t.point(y[1][0], y[1][1]), t.lineEnd(), t.lineStart(), t.point(y[0][0], y[0][1])))\n            }\n            !v || (n && Uc(n, p)) || t.point(p[0], p[1]), (n = p), (c = v), (e = g)\n          },\n          lineEnd: function () {\n            c && t.lineEnd(), (n = null)\n          },\n          clean: function () {\n            return s | ((f && c) << 1)\n          }\n        }\n      },\n      function (n, r, i, o) {\n        Dc(o, t, e, i, n, r)\n      },\n      r ? [0, -t] : [-Oa, t - Oa]\n    )\n  }\n  var $c = 1e9,\n    Wc = -$c\n  function Zc (t, n, e, r) {\n    function i (i, o) {\n      return t <= i && i <= e && n <= o && o <= r\n    }\n    function o (i, o, u, f) {\n      var s = 0,\n        l = 0\n      if (null == i || (s = a(i, u)) !== (l = a(o, u)) || (c(i, o) < 0) ^ (u > 0))\n        do {\n          f.point(0 === s || 3 === s ? t : e, s > 1 ? r : n)\n        } while ((s = (s + u + 4) % 4) !== l)\n      else f.point(o[0], o[1])\n    }\n    function a (r, i) {\n      return Ha(r[0] - t) < La\n        ? i > 0\n          ? 0\n          : 3\n        : Ha(r[0] - e) < La\n        ? i > 0\n          ? 2\n          : 1\n        : Ha(r[1] - n) < La\n        ? i > 0\n          ? 1\n          : 0\n        : i > 0\n        ? 3\n        : 2\n    }\n    function u (t, n) {\n      return c(t.x, n.x)\n    }\n    function c (t, n) {\n      var e = a(t, 1),\n        r = a(n, 1)\n      return e !== r ? e - r : 0 === e ? n[1] - t[1] : 1 === e ? t[0] - n[0] : 2 === e ? t[1] - n[1] : n[0] - t[0]\n    }\n    return function (a) {\n      var c,\n        f,\n        s,\n        l,\n        h,\n        d,\n        p,\n        v,\n        g,\n        y,\n        _,\n        b = a,\n        m = Lc(),\n        x = {\n          point: w,\n          lineStart: function () {\n            ;(x.point = M), f && f.push((s = []))\n            ;(y = !0), (g = !1), (p = v = NaN)\n          },\n          lineEnd: function () {\n            c && (M(l, h), d && g && m.rejoin(), c.push(m.result()))\n            ;(x.point = w), g && b.lineEnd()\n          },\n          polygonStart: function () {\n            ;(b = m), (c = []), (f = []), (_ = !0)\n          },\n          polygonEnd: function () {\n            var n = (function () {\n                for (var n = 0, e = 0, i = f.length; e < i; ++e)\n                  for (var o, a, u = f[e], c = 1, s = u.length, l = u[0], h = l[0], d = l[1]; c < s; ++c)\n                    (o = h),\n                      (a = d),\n                      (l = u[c]),\n                      (h = l[0]),\n                      (d = l[1]),\n                      a <= r\n                        ? d > r && (h - o) * (r - a) > (d - a) * (t - o) && ++n\n                        : d <= r && (h - o) * (r - a) < (d - a) * (t - o) && --n\n                return n\n              })(),\n              e = _ && n,\n              i = (c = S(c)).length\n            ;(e || i) &&\n              (a.polygonStart(),\n              e && (a.lineStart(), o(null, null, 1, a), a.lineEnd()),\n              i && Bc(c, u, n, o, a),\n              a.polygonEnd())\n            ;(b = a), (c = f = s = null)\n          }\n        }\n      function w (t, n) {\n        i(t, n) && b.point(t, n)\n      }\n      function M (o, a) {\n        var u = i(o, a)\n        if ((f && s.push([o, a]), y)) (l = o), (h = a), (d = u), (y = !1), u && (b.lineStart(), b.point(o, a))\n        else if (u && g) b.point(o, a)\n        else {\n          var c = [(p = Math.max(Wc, Math.min($c, p))), (v = Math.max(Wc, Math.min($c, v)))],\n            m = [(o = Math.max(Wc, Math.min($c, o))), (a = Math.max(Wc, Math.min($c, a)))]\n          !(function (t, n, e, r, i, o) {\n            var a,\n              u = t[0],\n              c = t[1],\n              f = 0,\n              s = 1,\n              l = n[0] - u,\n              h = n[1] - c\n            if (((a = e - u), l || !(a > 0))) {\n              if (((a /= l), l < 0)) {\n                if (a < f) return\n                a < s && (s = a)\n              } else if (l > 0) {\n                if (a > s) return\n                a > f && (f = a)\n              }\n              if (((a = i - u), l || !(a < 0))) {\n                if (((a /= l), l < 0)) {\n                  if (a > s) return\n                  a > f && (f = a)\n                } else if (l > 0) {\n                  if (a < f) return\n                  a < s && (s = a)\n                }\n                if (((a = r - c), h || !(a > 0))) {\n                  if (((a /= h), h < 0)) {\n                    if (a < f) return\n                    a < s && (s = a)\n                  } else if (h > 0) {\n                    if (a > s) return\n                    a > f && (f = a)\n                  }\n                  if (((a = o - c), h || !(a < 0))) {\n                    if (((a /= h), h < 0)) {\n                      if (a > s) return\n                      a > f && (f = a)\n                    } else if (h > 0) {\n                      if (a < f) return\n                      a < s && (s = a)\n                    }\n                    return (\n                      f > 0 && ((t[0] = u + f * l), (t[1] = c + f * h)),\n                      s < 1 && ((n[0] = u + s * l), (n[1] = c + s * h)),\n                      !0\n                    )\n                  }\n                }\n              }\n            }\n          })(c, m, t, n, e, r)\n            ? u && (b.lineStart(), b.point(o, a), (_ = !1))\n            : (g || (b.lineStart(), b.point(c[0], c[1])), b.point(m[0], m[1]), u || b.lineEnd(), (_ = !1))\n        }\n        ;(p = o), (v = a), (g = u)\n      }\n      return x\n    }\n  }\n  var Qc,\n    Jc,\n    Kc,\n    tf = za(),\n    nf = {\n      sphere: ou,\n      point: ou,\n      lineStart: function () {\n        ;(nf.point = rf), (nf.lineEnd = ef)\n      },\n      lineEnd: ou,\n      polygonStart: ou,\n      polygonEnd: ou\n    }\n  function ef () {\n    nf.point = nf.lineEnd = ou\n  }\n  function rf (t, n) {\n    ;(Qc = t *= ja), (Jc = Ja((n *= ja))), (Kc = Va(n)), (nf.point = of)\n  }\n  function of (t, n) {\n    t *= ja\n    var e = Ja((n *= ja)),\n      r = Va(n),\n      i = Ha(t - Qc),\n      o = Va(i),\n      a = r * Ja(i),\n      u = Kc * e - Jc * r * o,\n      c = Jc * e + Kc * r * o\n    tf.add(Ga(tu(a * a + u * u), c)), (Qc = t), (Jc = e), (Kc = r)\n  }\n  function af (t) {\n    return tf.reset(), lu(t, nf), +tf\n  }\n  var uf = [null, null],\n    cf = { type: 'LineString', coordinates: uf }\n  function ff (t, n) {\n    return (uf[0] = t), (uf[1] = n), af(cf)\n  }\n  var sf = {\n      Feature: function (t, n) {\n        return hf(t.geometry, n)\n      },\n      FeatureCollection: function (t, n) {\n        for (var e = t.features, r = -1, i = e.length; ++r < i; ) if (hf(e[r].geometry, n)) return !0\n        return !1\n      }\n    },\n    lf = {\n      Sphere: function () {\n        return !0\n      },\n      Point: function (t, n) {\n        return df(t.coordinates, n)\n      },\n      MultiPoint: function (t, n) {\n        for (var e = t.coordinates, r = -1, i = e.length; ++r < i; ) if (df(e[r], n)) return !0\n        return !1\n      },\n      LineString: function (t, n) {\n        return pf(t.coordinates, n)\n      },\n      MultiLineString: function (t, n) {\n        for (var e = t.coordinates, r = -1, i = e.length; ++r < i; ) if (pf(e[r], n)) return !0\n        return !1\n      },\n      Polygon: function (t, n) {\n        return vf(t.coordinates, n)\n      },\n      MultiPolygon: function (t, n) {\n        for (var e = t.coordinates, r = -1, i = e.length; ++r < i; ) if (vf(e[r], n)) return !0\n        return !1\n      },\n      GeometryCollection: function (t, n) {\n        for (var e = t.geometries, r = -1, i = e.length; ++r < i; ) if (hf(e[r], n)) return !0\n        return !1\n      }\n    }\n  function hf (t, n) {\n    return !(!t || !lf.hasOwnProperty(t.type)) && lf[t.type](t, n)\n  }\n  function df (t, n) {\n    return 0 === ff(t, n)\n  }\n  function pf (t, n) {\n    var e = ff(t[0], t[1])\n    return ff(t[0], n) + ff(n, t[1]) <= e + La\n  }\n  function vf (t, n) {\n    return !!Ic(t.map(gf), yf(n))\n  }\n  function gf (t) {\n    return (t = t.map(yf)).pop(), t\n  }\n  function yf (t) {\n    return [t[0] * ja, t[1] * ja]\n  }\n  function _f (t, n, e) {\n    var r = g(t, n - La, e).concat(n)\n    return function (t) {\n      return r.map(function (n) {\n        return [t, n]\n      })\n    }\n  }\n  function bf (t, n, e) {\n    var r = g(t, n - La, e).concat(n)\n    return function (t) {\n      return r.map(function (n) {\n        return [n, t]\n      })\n    }\n  }\n  function mf () {\n    var t,\n      n,\n      e,\n      r,\n      i,\n      o,\n      a,\n      u,\n      c,\n      f,\n      s,\n      l,\n      h = 10,\n      d = h,\n      p = 90,\n      v = 360,\n      y = 2.5\n    function _ () {\n      return { type: 'MultiLineString', coordinates: b() }\n    }\n    function b () {\n      return g($a(r / p) * p, e, p)\n        .map(s)\n        .concat(g($a(u / v) * v, a, v).map(l))\n        .concat(\n          g($a(n / h) * h, t, h)\n            .filter(function (t) {\n              return Ha(t % p) > La\n            })\n            .map(c)\n        )\n        .concat(\n          g($a(o / d) * d, i, d)\n            .filter(function (t) {\n              return Ha(t % v) > La\n            })\n            .map(f)\n        )\n    }\n    return (\n      (_.lines = function () {\n        return b().map(function (t) {\n          return { type: 'LineString', coordinates: t }\n        })\n      }),\n      (_.outline = function () {\n        return {\n          type: 'Polygon',\n          coordinates: [\n            s(r).concat(\n              l(a).slice(1),\n              s(e)\n                .reverse()\n                .slice(1),\n              l(u)\n                .reverse()\n                .slice(1)\n            )\n          ]\n        }\n      }),\n      (_.extent = function (t) {\n        return arguments.length ? _.extentMajor(t).extentMinor(t) : _.extentMinor()\n      }),\n      (_.extentMajor = function (t) {\n        return arguments.length\n          ? ((r = +t[0][0]),\n            (e = +t[1][0]),\n            (u = +t[0][1]),\n            (a = +t[1][1]),\n            r > e && ((t = r), (r = e), (e = t)),\n            u > a && ((t = u), (u = a), (a = t)),\n            _.precision(y))\n          : [[r, u], [e, a]]\n      }),\n      (_.extentMinor = function (e) {\n        return arguments.length\n          ? ((n = +e[0][0]),\n            (t = +e[1][0]),\n            (o = +e[0][1]),\n            (i = +e[1][1]),\n            n > t && ((e = n), (n = t), (t = e)),\n            o > i && ((e = o), (o = i), (i = e)),\n            _.precision(y))\n          : [[n, o], [t, i]]\n      }),\n      (_.step = function (t) {\n        return arguments.length ? _.stepMajor(t).stepMinor(t) : _.stepMinor()\n      }),\n      (_.stepMajor = function (t) {\n        return arguments.length ? ((p = +t[0]), (v = +t[1]), _) : [p, v]\n      }),\n      (_.stepMinor = function (t) {\n        return arguments.length ? ((h = +t[0]), (d = +t[1]), _) : [h, d]\n      }),\n      (_.precision = function (h) {\n        return arguments.length\n          ? ((y = +h), (c = _f(o, i, 90)), (f = bf(n, t, y)), (s = _f(u, a, 90)), (l = bf(r, e, y)), _)\n          : y\n      }),\n      _.extentMajor([[-180, -90 + La], [180, 90 - La]]).extentMinor([[-180, -80 - La], [180, 80 + La]])\n    )\n  }\n  function xf (t) {\n    return t\n  }\n  var wf,\n    Mf,\n    Nf,\n    Af,\n    Sf = za(),\n    kf = za(),\n    Tf = {\n      point: ou,\n      lineStart: ou,\n      lineEnd: ou,\n      polygonStart: function () {\n        ;(Tf.lineStart = Ef), (Tf.lineEnd = zf)\n      },\n      polygonEnd: function () {\n        ;(Tf.lineStart = Tf.lineEnd = Tf.point = ou), Sf.add(Ha(kf)), kf.reset()\n      },\n      result: function () {\n        var t = Sf / 2\n        return Sf.reset(), t\n      }\n    }\n  function Ef () {\n    Tf.point = Cf\n  }\n  function Cf (t, n) {\n    ;(Tf.point = Pf), (wf = Nf = t), (Mf = Af = n)\n  }\n  function Pf (t, n) {\n    kf.add(Af * t - Nf * n), (Nf = t), (Af = n)\n  }\n  function zf () {\n    Pf(wf, Mf)\n  }\n  var Rf = 1 / 0,\n    Df = Rf,\n    qf = -Rf,\n    Lf = qf,\n    Uf = {\n      point: function (t, n) {\n        t < Rf && (Rf = t)\n        t > qf && (qf = t)\n        n < Df && (Df = n)\n        n > Lf && (Lf = n)\n      },\n      lineStart: ou,\n      lineEnd: ou,\n      polygonStart: ou,\n      polygonEnd: ou,\n      result: function () {\n        var t = [[Rf, Df], [qf, Lf]]\n        return (qf = Lf = -(Df = Rf = 1 / 0)), t\n      }\n    }\n  var Of,\n    Bf,\n    Yf,\n    Ff,\n    If = 0,\n    jf = 0,\n    Hf = 0,\n    Xf = 0,\n    Gf = 0,\n    Vf = 0,\n    $f = 0,\n    Wf = 0,\n    Zf = 0,\n    Qf = {\n      point: Jf,\n      lineStart: Kf,\n      lineEnd: es,\n      polygonStart: function () {\n        ;(Qf.lineStart = rs), (Qf.lineEnd = is)\n      },\n      polygonEnd: function () {\n        ;(Qf.point = Jf), (Qf.lineStart = Kf), (Qf.lineEnd = es)\n      },\n      result: function () {\n        var t = Zf ? [$f / Zf, Wf / Zf] : Vf ? [Xf / Vf, Gf / Vf] : Hf ? [If / Hf, jf / Hf] : [NaN, NaN]\n        return (If = jf = Hf = Xf = Gf = Vf = $f = Wf = Zf = 0), t\n      }\n    }\n  function Jf (t, n) {\n    ;(If += t), (jf += n), ++Hf\n  }\n  function Kf () {\n    Qf.point = ts\n  }\n  function ts (t, n) {\n    ;(Qf.point = ns), Jf((Yf = t), (Ff = n))\n  }\n  function ns (t, n) {\n    var e = t - Yf,\n      r = n - Ff,\n      i = tu(e * e + r * r)\n    ;(Xf += (i * (Yf + t)) / 2), (Gf += (i * (Ff + n)) / 2), (Vf += i), Jf((Yf = t), (Ff = n))\n  }\n  function es () {\n    Qf.point = Jf\n  }\n  function rs () {\n    Qf.point = os\n  }\n  function is () {\n    as(Of, Bf)\n  }\n  function os (t, n) {\n    ;(Qf.point = as), Jf((Of = Yf = t), (Bf = Ff = n))\n  }\n  function as (t, n) {\n    var e = t - Yf,\n      r = n - Ff,\n      i = tu(e * e + r * r)\n    ;(Xf += (i * (Yf + t)) / 2),\n      (Gf += (i * (Ff + n)) / 2),\n      (Vf += i),\n      ($f += (i = Ff * t - Yf * n) * (Yf + t)),\n      (Wf += i * (Ff + n)),\n      (Zf += 3 * i),\n      Jf((Yf = t), (Ff = n))\n  }\n  function us (t) {\n    this._context = t\n  }\n  us.prototype = {\n    _radius: 4.5,\n    pointRadius: function (t) {\n      return (this._radius = t), this\n    },\n    polygonStart: function () {\n      this._line = 0\n    },\n    polygonEnd: function () {\n      this._line = NaN\n    },\n    lineStart: function () {\n      this._point = 0\n    },\n    lineEnd: function () {\n      0 === this._line && this._context.closePath(), (this._point = NaN)\n    },\n    point: function (t, n) {\n      switch (this._point) {\n        case 0:\n          this._context.moveTo(t, n), (this._point = 1)\n          break\n        case 1:\n          this._context.lineTo(t, n)\n          break\n        default:\n          this._context.moveTo(t + this._radius, n), this._context.arc(t, n, this._radius, 0, Fa)\n      }\n    },\n    result: ou\n  }\n  var cs,\n    fs,\n    ss,\n    ls,\n    hs,\n    ds = za(),\n    ps = {\n      point: ou,\n      lineStart: function () {\n        ps.point = vs\n      },\n      lineEnd: function () {\n        cs && gs(fs, ss), (ps.point = ou)\n      },\n      polygonStart: function () {\n        cs = !0\n      },\n      polygonEnd: function () {\n        cs = null\n      },\n      result: function () {\n        var t = +ds\n        return ds.reset(), t\n      }\n    }\n  function vs (t, n) {\n    ;(ps.point = gs), (fs = ls = t), (ss = hs = n)\n  }\n  function gs (t, n) {\n    ;(ls -= t), (hs -= n), ds.add(tu(ls * ls + hs * hs)), (ls = t), (hs = n)\n  }\n  function ys () {\n    this._string = []\n  }\n  function _s (t) {\n    return 'm0,' + t + 'a' + t + ',' + t + ' 0 1,1 0,' + -2 * t + 'a' + t + ',' + t + ' 0 1,1 0,' + 2 * t + 'z'\n  }\n  function bs (t) {\n    return function (n) {\n      var e = new ms()\n      for (var r in t) e[r] = t[r]\n      return (e.stream = n), e\n    }\n  }\n  function ms () {}\n  function xs (t, n, e) {\n    var r = t.clipExtent && t.clipExtent()\n    return (\n      t.scale(150).translate([0, 0]),\n      null != r && t.clipExtent(null),\n      lu(e, t.stream(Uf)),\n      n(Uf.result()),\n      null != r && t.clipExtent(r),\n      t\n    )\n  }\n  function ws (t, n, e) {\n    return xs(\n      t,\n      function (e) {\n        var r = n[1][0] - n[0][0],\n          i = n[1][1] - n[0][1],\n          o = Math.min(r / (e[1][0] - e[0][0]), i / (e[1][1] - e[0][1])),\n          a = +n[0][0] + (r - o * (e[1][0] + e[0][0])) / 2,\n          u = +n[0][1] + (i - o * (e[1][1] + e[0][1])) / 2\n        t.scale(150 * o).translate([a, u])\n      },\n      e\n    )\n  }\n  function Ms (t, n, e) {\n    return ws(t, [[0, 0], n], e)\n  }\n  function Ns (t, n, e) {\n    return xs(\n      t,\n      function (e) {\n        var r = +n,\n          i = r / (e[1][0] - e[0][0]),\n          o = (r - i * (e[1][0] + e[0][0])) / 2,\n          a = -i * e[0][1]\n        t.scale(150 * i).translate([o, a])\n      },\n      e\n    )\n  }\n  function As (t, n, e) {\n    return xs(\n      t,\n      function (e) {\n        var r = +n,\n          i = r / (e[1][1] - e[0][1]),\n          o = -i * e[0][0],\n          a = (r - i * (e[1][1] + e[0][1])) / 2\n        t.scale(150 * i).translate([o, a])\n      },\n      e\n    )\n  }\n  ;(ys.prototype = {\n    _radius: 4.5,\n    _circle: _s(4.5),\n    pointRadius: function (t) {\n      return (t = +t) !== this._radius && ((this._radius = t), (this._circle = null)), this\n    },\n    polygonStart: function () {\n      this._line = 0\n    },\n    polygonEnd: function () {\n      this._line = NaN\n    },\n    lineStart: function () {\n      this._point = 0\n    },\n    lineEnd: function () {\n      0 === this._line && this._string.push('Z'), (this._point = NaN)\n    },\n    point: function (t, n) {\n      switch (this._point) {\n        case 0:\n          this._string.push('M', t, ',', n), (this._point = 1)\n          break\n        case 1:\n          this._string.push('L', t, ',', n)\n          break\n        default:\n          null == this._circle && (this._circle = _s(this._radius)), this._string.push('M', t, ',', n, this._circle)\n      }\n    },\n    result: function () {\n      if (this._string.length) {\n        var t = this._string.join('')\n        return (this._string = []), t\n      }\n      return null\n    }\n  }),\n    (ms.prototype = {\n      constructor: ms,\n      point: function (t, n) {\n        this.stream.point(t, n)\n      },\n      sphere: function () {\n        this.stream.sphere()\n      },\n      lineStart: function () {\n        this.stream.lineStart()\n      },\n      lineEnd: function () {\n        this.stream.lineEnd()\n      },\n      polygonStart: function () {\n        this.stream.polygonStart()\n      },\n      polygonEnd: function () {\n        this.stream.polygonEnd()\n      }\n    })\n  var Ss = 16,\n    ks = Va(30 * ja)\n  function Ts (t, n) {\n    return +n\n      ? (function (t, n) {\n          function e (r, i, o, a, u, c, f, s, l, h, d, p, v, g) {\n            var y = f - r,\n              _ = s - i,\n              b = y * y + _ * _\n            if (b > 4 * n && v--) {\n              var m = a + h,\n                x = u + d,\n                w = c + p,\n                M = tu(m * m + x * x + w * w),\n                N = ru((w /= M)),\n                A = Ha(Ha(w) - 1) < La || Ha(o - l) < La ? (o + l) / 2 : Ga(x, m),\n                S = t(A, N),\n                k = S[0],\n                T = S[1],\n                E = k - r,\n                C = T - i,\n                P = _ * E - y * C\n              ;((P * P) / b > n || Ha((y * E + _ * C) / b - 0.5) > 0.3 || a * h + u * d + c * p < ks) &&\n                (e(r, i, o, a, u, c, k, T, A, (m /= M), (x /= M), w, v, g),\n                g.point(k, T),\n                e(k, T, A, m, x, w, f, s, l, h, d, p, v, g))\n            }\n          }\n          return function (n) {\n            var r,\n              i,\n              o,\n              a,\n              u,\n              c,\n              f,\n              s,\n              l,\n              h,\n              d,\n              p,\n              v = {\n                point: g,\n                lineStart: y,\n                lineEnd: b,\n                polygonStart: function () {\n                  n.polygonStart(), (v.lineStart = m)\n                },\n                polygonEnd: function () {\n                  n.polygonEnd(), (v.lineStart = y)\n                }\n              }\n            function g (e, r) {\n              ;(e = t(e, r)), n.point(e[0], e[1])\n            }\n            function y () {\n              ;(s = NaN), (v.point = _), n.lineStart()\n            }\n            function _ (r, i) {\n              var o = Au([r, i]),\n                a = t(r, i)\n              e(s, l, f, h, d, p, (s = a[0]), (l = a[1]), (f = r), (h = o[0]), (d = o[1]), (p = o[2]), Ss, n),\n                n.point(s, l)\n            }\n            function b () {\n              ;(v.point = g), n.lineEnd()\n            }\n            function m () {\n              y(), (v.point = x), (v.lineEnd = w)\n            }\n            function x (t, n) {\n              _((r = t), n), (i = s), (o = l), (a = h), (u = d), (c = p), (v.point = _)\n            }\n            function w () {\n              e(s, l, f, h, d, p, i, o, r, a, u, c, Ss, n), (v.lineEnd = b), b()\n            }\n            return v\n          }\n        })(t, n)\n      : (function (t) {\n          return bs({\n            point: function (n, e) {\n              ;(n = t(n, e)), this.stream.point(n[0], n[1])\n            }\n          })\n        })(t)\n  }\n  var Es = bs({\n    point: function (t, n) {\n      this.stream.point(t * ja, n * ja)\n    }\n  })\n  function Cs (t, n, e, r) {\n    var i = Va(r),\n      o = Ja(r),\n      a = i * t,\n      u = o * t,\n      c = i / t,\n      f = o / t,\n      s = (o * e - i * n) / t,\n      l = (o * n + i * e) / t\n    function h (t, r) {\n      return [a * t - u * r + n, e - u * t - a * r]\n    }\n    return (\n      (h.invert = function (t, n) {\n        return [c * t - f * n + s, l - f * t - c * n]\n      }),\n      h\n    )\n  }\n  function Ps (t) {\n    return zs(function () {\n      return t\n    })()\n  }\n  function zs (t) {\n    var n,\n      e,\n      r,\n      i,\n      o,\n      a,\n      u,\n      c,\n      f,\n      s,\n      l = 150,\n      h = 480,\n      d = 250,\n      p = 0,\n      v = 0,\n      g = 0,\n      y = 0,\n      _ = 0,\n      b = 0,\n      m = null,\n      x = Gc,\n      w = null,\n      M = xf,\n      N = 0.5\n    function A (t) {\n      return c(t[0] * ja, t[1] * ja)\n    }\n    function S (t) {\n      return (t = c.invert(t[0], t[1])) && [t[0] * Ia, t[1] * Ia]\n    }\n    function k () {\n      var t = Cs(l, 0, 0, b).apply(null, n(p, v)),\n        r = (b\n          ? Cs\n          : function (t, n, e) {\n              function r (r, i) {\n                return [n + t * r, e - t * i]\n              }\n              return (\n                (r.invert = function (r, i) {\n                  return [(r - n) / t, (e - i) / t]\n                }),\n                r\n              )\n            })(l, h - t[0], d - t[1], b)\n      return (e = Ec(g, y, _)), (u = kc(n, r)), (c = kc(e, u)), (a = Ts(u, N)), T()\n    }\n    function T () {\n      return (f = s = null), A\n    }\n    return (\n      (A.stream = function (t) {\n        return f && s === t\n          ? f\n          : (f = Es(\n              (function (t) {\n                return bs({\n                  point: function (n, e) {\n                    var r = t(n, e)\n                    return this.stream.point(r[0], r[1])\n                  }\n                })\n              })(e)(x(a(M((s = t)))))\n            ))\n      }),\n      (A.preclip = function (t) {\n        return arguments.length ? ((x = t), (m = void 0), T()) : x\n      }),\n      (A.postclip = function (t) {\n        return arguments.length ? ((M = t), (w = r = i = o = null), T()) : M\n      }),\n      (A.clipAngle = function (t) {\n        return arguments.length ? ((x = +t ? Vc((m = t * ja)) : ((m = null), Gc)), T()) : m * Ia\n      }),\n      (A.clipExtent = function (t) {\n        return arguments.length\n          ? ((M =\n              null == t\n                ? ((w = r = i = o = null), xf)\n                : Zc((w = +t[0][0]), (r = +t[0][1]), (i = +t[1][0]), (o = +t[1][1]))),\n            T())\n          : null == w\n          ? null\n          : [[w, r], [i, o]]\n      }),\n      (A.scale = function (t) {\n        return arguments.length ? ((l = +t), k()) : l\n      }),\n      (A.translate = function (t) {\n        return arguments.length ? ((h = +t[0]), (d = +t[1]), k()) : [h, d]\n      }),\n      (A.center = function (t) {\n        return arguments.length ? ((p = (t[0] % 360) * ja), (v = (t[1] % 360) * ja), k()) : [p * Ia, v * Ia]\n      }),\n      (A.rotate = function (t) {\n        return arguments.length\n          ? ((g = (t[0] % 360) * ja), (y = (t[1] % 360) * ja), (_ = t.length > 2 ? (t[2] % 360) * ja : 0), k())\n          : [g * Ia, y * Ia, _ * Ia]\n      }),\n      (A.angle = function (t) {\n        return arguments.length ? ((b = (t % 360) * ja), k()) : b * Ia\n      }),\n      (A.precision = function (t) {\n        return arguments.length ? ((a = Ts(u, (N = t * t))), T()) : tu(N)\n      }),\n      (A.fitExtent = function (t, n) {\n        return ws(A, t, n)\n      }),\n      (A.fitSize = function (t, n) {\n        return Ms(A, t, n)\n      }),\n      (A.fitWidth = function (t, n) {\n        return Ns(A, t, n)\n      }),\n      (A.fitHeight = function (t, n) {\n        return As(A, t, n)\n      }),\n      function () {\n        return (n = t.apply(this, arguments)), (A.invert = n.invert && S), k()\n      }\n    )\n  }\n  function Rs (t) {\n    var n = 0,\n      e = Oa / 3,\n      r = zs(t),\n      i = r(n, e)\n    return (\n      (i.parallels = function (t) {\n        return arguments.length ? r((n = t[0] * ja), (e = t[1] * ja)) : [n * Ia, e * Ia]\n      }),\n      i\n    )\n  }\n  function Ds (t, n) {\n    var e = Ja(t),\n      r = (e + Ja(n)) / 2\n    if (Ha(r) < La)\n      return (function (t) {\n        var n = Va(t)\n        function e (t, e) {\n          return [t * n, Ja(e) / n]\n        }\n        return (\n          (e.invert = function (t, e) {\n            return [t / n, ru(e * n)]\n          }),\n          e\n        )\n      })(t)\n    var i = 1 + e * (2 * r - e),\n      o = tu(i) / r\n    function a (t, n) {\n      var e = tu(i - 2 * r * Ja(n)) / r\n      return [e * Ja((t *= r)), o - e * Va(t)]\n    }\n    return (\n      (a.invert = function (t, n) {\n        var e = o - n\n        return [(Ga(t, Ha(e)) / r) * Ka(e), ru((i - (t * t + e * e) * r * r) / (2 * r))]\n      }),\n      a\n    )\n  }\n  function qs () {\n    return Rs(Ds)\n      .scale(155.424)\n      .center([0, 33.6442])\n  }\n  function Ls () {\n    return qs()\n      .parallels([29.5, 45.5])\n      .scale(1070)\n      .translate([480, 250])\n      .rotate([96, 0])\n      .center([-0.6, 38.7])\n  }\n  function Us (t) {\n    return function (n, e) {\n      var r = Va(n),\n        i = Va(e),\n        o = t(r * i)\n      return [o * i * Ja(n), o * Ja(e)]\n    }\n  }\n  function Os (t) {\n    return function (n, e) {\n      var r = tu(n * n + e * e),\n        i = t(r),\n        o = Ja(i),\n        a = Va(i)\n      return [Ga(n * o, r * a), ru(r && (e * o) / r)]\n    }\n  }\n  var Bs = Us(function (t) {\n    return tu(2 / (1 + t))\n  })\n  Bs.invert = Os(function (t) {\n    return 2 * ru(t / 2)\n  })\n  var Ys = Us(function (t) {\n    return (t = eu(t)) && t / Ja(t)\n  })\n  function Fs (t, n) {\n    return [t, Za(nu((Ba + n) / 2))]\n  }\n  function Is (t) {\n    var n,\n      e,\n      r,\n      i = Ps(t),\n      o = i.center,\n      a = i.scale,\n      u = i.translate,\n      c = i.clipExtent,\n      f = null\n    function s () {\n      var o = Oa * a(),\n        u = i(Rc(i.rotate()).invert([0, 0]))\n      return c(\n        null == f\n          ? [[u[0] - o, u[1] - o], [u[0] + o, u[1] + o]]\n          : t === Fs\n          ? [[Math.max(u[0] - o, f), n], [Math.min(u[0] + o, e), r]]\n          : [[f, Math.max(u[1] - o, n)], [e, Math.min(u[1] + o, r)]]\n      )\n    }\n    return (\n      (i.scale = function (t) {\n        return arguments.length ? (a(t), s()) : a()\n      }),\n      (i.translate = function (t) {\n        return arguments.length ? (u(t), s()) : u()\n      }),\n      (i.center = function (t) {\n        return arguments.length ? (o(t), s()) : o()\n      }),\n      (i.clipExtent = function (t) {\n        return arguments.length\n          ? (null == t ? (f = n = e = r = null) : ((f = +t[0][0]), (n = +t[0][1]), (e = +t[1][0]), (r = +t[1][1])), s())\n          : null == f\n          ? null\n          : [[f, n], [e, r]]\n      }),\n      s()\n    )\n  }\n  function js (t) {\n    return nu((Ba + t) / 2)\n  }\n  function Hs (t, n) {\n    var e = Va(t),\n      r = t === n ? Ja(t) : Za(e / Va(n)) / Za(js(n) / js(t)),\n      i = (e * Qa(js(t), r)) / r\n    if (!r) return Fs\n    function o (t, n) {\n      i > 0 ? n < -Ba + La && (n = -Ba + La) : n > Ba - La && (n = Ba - La)\n      var e = i / Qa(js(n), r)\n      return [e * Ja(r * t), i - e * Va(r * t)]\n    }\n    return (\n      (o.invert = function (t, n) {\n        var e = i - n,\n          o = Ka(r) * tu(t * t + e * e)\n        return [(Ga(t, Ha(e)) / r) * Ka(e), 2 * Xa(Qa(i / o, 1 / r)) - Ba]\n      }),\n      o\n    )\n  }\n  function Xs (t, n) {\n    return [t, n]\n  }\n  function Gs (t, n) {\n    var e = Va(t),\n      r = t === n ? Ja(t) : (e - Va(n)) / (n - t),\n      i = e / r + t\n    if (Ha(r) < La) return Xs\n    function o (t, n) {\n      var e = i - n,\n        o = r * t\n      return [e * Ja(o), i - e * Va(o)]\n    }\n    return (\n      (o.invert = function (t, n) {\n        var e = i - n\n        return [(Ga(t, Ha(e)) / r) * Ka(e), i - Ka(r) * tu(t * t + e * e)]\n      }),\n      o\n    )\n  }\n  ;(Ys.invert = Os(function (t) {\n    return t\n  })),\n    (Fs.invert = function (t, n) {\n      return [t, 2 * Xa(Wa(n)) - Ba]\n    }),\n    (Xs.invert = Xs)\n  var Vs = 1.340264,\n    $s = -0.081106,\n    Ws = 893e-6,\n    Zs = 0.003796,\n    Qs = tu(3) / 2\n  function Js (t, n) {\n    var e = ru(Qs * Ja(n)),\n      r = e * e,\n      i = r * r * r\n    return [(t * Va(e)) / (Qs * (Vs + 3 * $s * r + i * (7 * Ws + 9 * Zs * r))), e * (Vs + $s * r + i * (Ws + Zs * r))]\n  }\n  function Ks (t, n) {\n    var e = Va(n),\n      r = Va(t) * e\n    return [(e * Ja(t)) / r, Ja(n) / r]\n  }\n  function tl (t, n, e, r) {\n    return 1 === t && 1 === n && 0 === e && 0 === r\n      ? xf\n      : bs({\n          point: function (i, o) {\n            this.stream.point(i * t + e, o * n + r)\n          }\n        })\n  }\n  function nl (t, n) {\n    var e = n * n,\n      r = e * e\n    return [\n      t * (0.8707 - 0.131979 * e + r * (r * (0.003971 * e - 0.001529 * r) - 0.013791)),\n      n * (1.007226 + e * (0.015085 + r * (0.028874 * e - 0.044475 - 0.005916 * r)))\n    ]\n  }\n  function el (t, n) {\n    return [Va(n) * Ja(t), Ja(n)]\n  }\n  function rl (t, n) {\n    var e = Va(n),\n      r = 1 + Va(t) * e\n    return [(e * Ja(t)) / r, Ja(n) / r]\n  }\n  function il (t, n) {\n    return [Za(nu((Ba + n) / 2)), -t]\n  }\n  function ol (t, n) {\n    return t.parent === n.parent ? 1 : 2\n  }\n  function al (t, n) {\n    return t + n.x\n  }\n  function ul (t, n) {\n    return Math.max(t, n.y)\n  }\n  function cl (t) {\n    var n = 0,\n      e = t.children,\n      r = e && e.length\n    if (r) for (; --r >= 0; ) n += e[r].value\n    else n = 1\n    t.value = n\n  }\n  function fl (t, n) {\n    var e,\n      r,\n      i,\n      o,\n      a,\n      u = new dl(t),\n      c = +t.value && (u.value = t.value),\n      f = [u]\n    for (null == n && (n = sl); (e = f.pop()); )\n      if ((c && (e.value = +e.data.value), (i = n(e.data)) && (a = i.length)))\n        for (e.children = new Array(a), o = a - 1; o >= 0; --o)\n          f.push((r = e.children[o] = new dl(i[o]))), (r.parent = e), (r.depth = e.depth + 1)\n    return u.eachBefore(hl)\n  }\n  function sl (t) {\n    return t.children\n  }\n  function ll (t) {\n    t.data = t.data.data\n  }\n  function hl (t) {\n    var n = 0\n    do {\n      t.height = n\n    } while ((t = t.parent) && t.height < ++n)\n  }\n  function dl (t) {\n    ;(this.data = t), (this.depth = this.height = 0), (this.parent = null)\n  }\n  ;(Js.invert = function (t, n) {\n    for (\n      var e, r = n, i = r * r, o = i * i * i, a = 0;\n      a < 12 &&\n      ((o =\n        (i =\n          (r -= e = (r * (Vs + $s * i + o * (Ws + Zs * i)) - n) / (Vs + 3 * $s * i + o * (7 * Ws + 9 * Zs * i))) * r) *\n        i *\n        i),\n      !(Ha(e) < Ua));\n      ++a\n    );\n    return [(Qs * t * (Vs + 3 * $s * i + o * (7 * Ws + 9 * Zs * i))) / Va(r), ru(Ja(r) / Qs)]\n  }),\n    (Ks.invert = Os(Xa)),\n    (nl.invert = function (t, n) {\n      var e,\n        r = n,\n        i = 25\n      do {\n        var o = r * r,\n          a = o * o\n        r -= e =\n          (r * (1.007226 + o * (0.015085 + a * (0.028874 * o - 0.044475 - 0.005916 * a))) - n) /\n          (1.007226 + o * (0.045255 + a * (0.259866 * o - 0.311325 - 0.005916 * 11 * a)))\n      } while (Ha(e) > La && --i > 0)\n      return [t / (0.8707 + (o = r * r) * (o * (o * o * o * (0.003971 - 0.001529 * o) - 0.013791) - 0.131979)), r]\n    }),\n    (el.invert = Os(ru)),\n    (rl.invert = Os(function (t) {\n      return 2 * Xa(t)\n    })),\n    (il.invert = function (t, n) {\n      return [-n, 2 * Xa(Wa(t)) - Ba]\n    }),\n    (dl.prototype = fl.prototype = {\n      constructor: dl,\n      count: function () {\n        return this.eachAfter(cl)\n      },\n      each: function (t) {\n        var n,\n          e,\n          r,\n          i,\n          o = this,\n          a = [o]\n        do {\n          for (n = a.reverse(), a = []; (o = n.pop()); )\n            if ((t(o), (e = o.children))) for (r = 0, i = e.length; r < i; ++r) a.push(e[r])\n        } while (a.length)\n        return this\n      },\n      eachAfter: function (t) {\n        for (var n, e, r, i = this, o = [i], a = []; (i = o.pop()); )\n          if ((a.push(i), (n = i.children))) for (e = 0, r = n.length; e < r; ++e) o.push(n[e])\n        for (; (i = a.pop()); ) t(i)\n        return this\n      },\n      eachBefore: function (t) {\n        for (var n, e, r = this, i = [r]; (r = i.pop()); )\n          if ((t(r), (n = r.children))) for (e = n.length - 1; e >= 0; --e) i.push(n[e])\n        return this\n      },\n      sum: function (t) {\n        return this.eachAfter(function (n) {\n          for (var e = +t(n.data) || 0, r = n.children, i = r && r.length; --i >= 0; ) e += r[i].value\n          n.value = e\n        })\n      },\n      sort: function (t) {\n        return this.eachBefore(function (n) {\n          n.children && n.children.sort(t)\n        })\n      },\n      path: function (t) {\n        for (\n          var n = this,\n            e = (function (t, n) {\n              if (t === n) return t\n              var e = t.ancestors(),\n                r = n.ancestors(),\n                i = null\n              for (t = e.pop(), n = r.pop(); t === n; ) (i = t), (t = e.pop()), (n = r.pop())\n              return i\n            })(n, t),\n            r = [n];\n          n !== e;\n\n        )\n          (n = n.parent), r.push(n)\n        for (var i = r.length; t !== e; ) r.splice(i, 0, t), (t = t.parent)\n        return r\n      },\n      ancestors: function () {\n        for (var t = this, n = [t]; (t = t.parent); ) n.push(t)\n        return n\n      },\n      descendants: function () {\n        var t = []\n        return (\n          this.each(function (n) {\n            t.push(n)\n          }),\n          t\n        )\n      },\n      leaves: function () {\n        var t = []\n        return (\n          this.eachBefore(function (n) {\n            n.children || t.push(n)\n          }),\n          t\n        )\n      },\n      links: function () {\n        var t = this,\n          n = []\n        return (\n          t.each(function (e) {\n            e !== t && n.push({ source: e.parent, target: e })\n          }),\n          n\n        )\n      },\n      copy: function () {\n        return fl(this).eachBefore(ll)\n      }\n    })\n  var pl = Array.prototype.slice\n  function vl (t) {\n    for (\n      var n,\n        e,\n        r = 0,\n        i = (t = (function (t) {\n          for (var n, e, r = t.length; r; ) (e = (Math.random() * r--) | 0), (n = t[r]), (t[r] = t[e]), (t[e] = n)\n          return t\n        })(pl.call(t))).length,\n        o = [];\n      r < i;\n\n    )\n      (n = t[r]), e && _l(e, n) ? ++r : ((e = ml((o = gl(o, n)))), (r = 0))\n    return e\n  }\n  function gl (t, n) {\n    var e, r\n    if (bl(n, t)) return [n]\n    for (e = 0; e < t.length; ++e) if (yl(n, t[e]) && bl(xl(t[e], n), t)) return [t[e], n]\n    for (e = 0; e < t.length - 1; ++e)\n      for (r = e + 1; r < t.length; ++r)\n        if (yl(xl(t[e], t[r]), n) && yl(xl(t[e], n), t[r]) && yl(xl(t[r], n), t[e]) && bl(wl(t[e], t[r], n), t))\n          return [t[e], t[r], n]\n    throw new Error()\n  }\n  function yl (t, n) {\n    var e = t.r - n.r,\n      r = n.x - t.x,\n      i = n.y - t.y\n    return e < 0 || e * e < r * r + i * i\n  }\n  function _l (t, n) {\n    var e = t.r - n.r + 1e-6,\n      r = n.x - t.x,\n      i = n.y - t.y\n    return e > 0 && e * e > r * r + i * i\n  }\n  function bl (t, n) {\n    for (var e = 0; e < n.length; ++e) if (!_l(t, n[e])) return !1\n    return !0\n  }\n  function ml (t) {\n    switch (t.length) {\n      case 1:\n        return { x: (n = t[0]).x, y: n.y, r: n.r }\n      case 2:\n        return xl(t[0], t[1])\n      case 3:\n        return wl(t[0], t[1], t[2])\n    }\n    var n\n  }\n  function xl (t, n) {\n    var e = t.x,\n      r = t.y,\n      i = t.r,\n      o = n.x,\n      a = n.y,\n      u = n.r,\n      c = o - e,\n      f = a - r,\n      s = u - i,\n      l = Math.sqrt(c * c + f * f)\n    return { x: (e + o + (c / l) * s) / 2, y: (r + a + (f / l) * s) / 2, r: (l + i + u) / 2 }\n  }\n  function wl (t, n, e) {\n    var r = t.x,\n      i = t.y,\n      o = t.r,\n      a = n.x,\n      u = n.y,\n      c = n.r,\n      f = e.x,\n      s = e.y,\n      l = e.r,\n      h = r - a,\n      d = r - f,\n      p = i - u,\n      v = i - s,\n      g = c - o,\n      y = l - o,\n      _ = r * r + i * i - o * o,\n      b = _ - a * a - u * u + c * c,\n      m = _ - f * f - s * s + l * l,\n      x = d * p - h * v,\n      w = (p * m - v * b) / (2 * x) - r,\n      M = (v * g - p * y) / x,\n      N = (d * b - h * m) / (2 * x) - i,\n      A = (h * y - d * g) / x,\n      S = M * M + A * A - 1,\n      k = 2 * (o + w * M + N * A),\n      T = w * w + N * N - o * o,\n      E = -(S ? (k + Math.sqrt(k * k - 4 * S * T)) / (2 * S) : T / k)\n    return { x: r + w + M * E, y: i + N + A * E, r: E }\n  }\n  function Ml (t, n, e) {\n    var r,\n      i,\n      o,\n      a,\n      u = t.x - n.x,\n      c = t.y - n.y,\n      f = u * u + c * c\n    f\n      ? ((i = n.r + e.r),\n        (i *= i),\n        (a = t.r + e.r),\n        i > (a *= a)\n          ? ((r = (f + a - i) / (2 * f)),\n            (o = Math.sqrt(Math.max(0, a / f - r * r))),\n            (e.x = t.x - r * u - o * c),\n            (e.y = t.y - r * c + o * u))\n          : ((r = (f + i - a) / (2 * f)),\n            (o = Math.sqrt(Math.max(0, i / f - r * r))),\n            (e.x = n.x + r * u - o * c),\n            (e.y = n.y + r * c + o * u)))\n      : ((e.x = n.x + e.r), (e.y = n.y))\n  }\n  function Nl (t, n) {\n    var e = t.r + n.r - 1e-6,\n      r = n.x - t.x,\n      i = n.y - t.y\n    return e > 0 && e * e > r * r + i * i\n  }\n  function Al (t) {\n    var n = t._,\n      e = t.next._,\n      r = n.r + e.r,\n      i = (n.x * e.r + e.x * n.r) / r,\n      o = (n.y * e.r + e.y * n.r) / r\n    return i * i + o * o\n  }\n  function Sl (t) {\n    ;(this._ = t), (this.next = null), (this.previous = null)\n  }\n  function kl (t) {\n    if (!(i = t.length)) return 0\n    var n, e, r, i, o, a, u, c, f, s, l\n    if ((((n = t[0]).x = 0), (n.y = 0), !(i > 1))) return n.r\n    if (((e = t[1]), (n.x = -e.r), (e.x = n.r), (e.y = 0), !(i > 2))) return n.r + e.r\n    Ml(e, n, (r = t[2])),\n      (n = new Sl(n)),\n      (e = new Sl(e)),\n      (r = new Sl(r)),\n      (n.next = r.previous = e),\n      (e.next = n.previous = r),\n      (r.next = e.previous = n)\n    t: for (u = 3; u < i; ++u) {\n      Ml(n._, e._, (r = t[u])), (r = new Sl(r)), (c = e.next), (f = n.previous), (s = e._.r), (l = n._.r)\n      do {\n        if (s <= l) {\n          if (Nl(c._, r._)) {\n            ;(e = c), (n.next = e), (e.previous = n), --u\n            continue t\n          }\n          ;(s += c._.r), (c = c.next)\n        } else {\n          if (Nl(f._, r._)) {\n            ;((n = f).next = e), (e.previous = n), --u\n            continue t\n          }\n          ;(l += f._.r), (f = f.previous)\n        }\n      } while (c !== f.next)\n      for (r.previous = n, r.next = e, n.next = e.previous = e = r, o = Al(n); (r = r.next) !== e; )\n        (a = Al(r)) < o && ((n = r), (o = a))\n      e = n.next\n    }\n    for (n = [e._], r = e; (r = r.next) !== e; ) n.push(r._)\n    for (r = vl(n), u = 0; u < i; ++u) ((n = t[u]).x -= r.x), (n.y -= r.y)\n    return r.r\n  }\n  function Tl (t) {\n    if ('function' != typeof t) throw new Error()\n    return t\n  }\n  function El () {\n    return 0\n  }\n  function Cl (t) {\n    return function () {\n      return t\n    }\n  }\n  function Pl (t) {\n    return Math.sqrt(t.value)\n  }\n  function zl (t) {\n    return function (n) {\n      n.children || (n.r = Math.max(0, +t(n) || 0))\n    }\n  }\n  function Rl (t, n) {\n    return function (e) {\n      if ((r = e.children)) {\n        var r,\n          i,\n          o,\n          a = r.length,\n          u = t(e) * n || 0\n        if (u) for (i = 0; i < a; ++i) r[i].r += u\n        if (((o = kl(r)), u)) for (i = 0; i < a; ++i) r[i].r -= u\n        e.r = o + u\n      }\n    }\n  }\n  function Dl (t) {\n    return function (n) {\n      var e = n.parent\n      ;(n.r *= t), e && ((n.x = e.x + t * n.x), (n.y = e.y + t * n.y))\n    }\n  }\n  function ql (t) {\n    ;(t.x0 = Math.round(t.x0)), (t.y0 = Math.round(t.y0)), (t.x1 = Math.round(t.x1)), (t.y1 = Math.round(t.y1))\n  }\n  function Ll (t, n, e, r, i) {\n    for (var o, a = t.children, u = -1, c = a.length, f = t.value && (r - n) / t.value; ++u < c; )\n      ((o = a[u]).y0 = e), (o.y1 = i), (o.x0 = n), (o.x1 = n += o.value * f)\n  }\n  var Ul = '$',\n    Ol = { depth: -1 },\n    Bl = {}\n  function Yl (t) {\n    return t.id\n  }\n  function Fl (t) {\n    return t.parentId\n  }\n  function Il (t, n) {\n    return t.parent === n.parent ? 1 : 2\n  }\n  function jl (t) {\n    var n = t.children\n    return n ? n[0] : t.t\n  }\n  function Hl (t) {\n    var n = t.children\n    return n ? n[n.length - 1] : t.t\n  }\n  function Xl (t, n, e) {\n    var r = e / (n.i - t.i)\n    ;(n.c -= r), (n.s += e), (t.c += r), (n.z += e), (n.m += e)\n  }\n  function Gl (t, n, e) {\n    return t.a.parent === n.parent ? t.a : e\n  }\n  function Vl (t, n) {\n    ;(this._ = t),\n      (this.parent = null),\n      (this.children = null),\n      (this.A = null),\n      (this.a = this),\n      (this.z = 0),\n      (this.m = 0),\n      (this.c = 0),\n      (this.s = 0),\n      (this.t = null),\n      (this.i = n)\n  }\n  function $l (t, n, e, r, i) {\n    for (var o, a = t.children, u = -1, c = a.length, f = t.value && (i - e) / t.value; ++u < c; )\n      ((o = a[u]).x0 = n), (o.x1 = r), (o.y0 = e), (o.y1 = e += o.value * f)\n  }\n  Vl.prototype = Object.create(dl.prototype)\n  var Wl = (1 + Math.sqrt(5)) / 2\n  function Zl (t, n, e, r, i, o) {\n    for (\n      var a, u, c, f, s, l, h, d, p, v, g, y = [], _ = n.children, b = 0, m = 0, x = _.length, w = n.value;\n      b < x;\n\n    ) {\n      ;(c = i - e), (f = o - r)\n      do {\n        s = _[m++].value\n      } while (!s && m < x)\n      for (l = h = s, g = s * s * (v = Math.max(f / c, c / f) / (w * t)), p = Math.max(h / g, g / l); m < x; ++m) {\n        if (\n          ((s += u = _[m].value), u < l && (l = u), u > h && (h = u), (g = s * s * v), (d = Math.max(h / g, g / l)) > p)\n        ) {\n          s -= u\n          break\n        }\n        p = d\n      }\n      y.push((a = { value: s, dice: c < f, children: _.slice(b, m) })),\n        a.dice ? Ll(a, e, r, i, w ? (r += (f * s) / w) : o) : $l(a, e, r, w ? (e += (c * s) / w) : i, o),\n        (w -= s),\n        (b = m)\n    }\n    return y\n  }\n  var Ql = (function t (n) {\n    function e (t, e, r, i, o) {\n      Zl(n, t, e, r, i, o)\n    }\n    return (\n      (e.ratio = function (n) {\n        return t((n = +n) > 1 ? n : 1)\n      }),\n      e\n    )\n  })(Wl)\n  var Jl = (function t (n) {\n    function e (t, e, r, i, o) {\n      if ((a = t._squarify) && a.ratio === n)\n        for (var a, u, c, f, s, l = -1, h = a.length, d = t.value; ++l < h; ) {\n          for (c = (u = a[l]).children, f = u.value = 0, s = c.length; f < s; ++f) u.value += c[f].value\n          u.dice ? Ll(u, e, r, i, (r += ((o - r) * u.value) / d)) : $l(u, e, r, (e += ((i - e) * u.value) / d), o),\n            (d -= u.value)\n        }\n      else (t._squarify = a = Zl(n, t, e, r, i, o)), (a.ratio = n)\n    }\n    return (\n      (e.ratio = function (n) {\n        return t((n = +n) > 1 ? n : 1)\n      }),\n      e\n    )\n  })(Wl)\n  function Kl (t, n) {\n    return t[0] - n[0] || t[1] - n[1]\n  }\n  function th (t) {\n    for (var n, e, r, i = t.length, o = [0, 1], a = 2, u = 2; u < i; ++u) {\n      for (\n        ;\n        a > 1 &&\n        ((n = t[o[a - 2]]),\n        (e = t[o[a - 1]]),\n        (r = t[u]),\n        (e[0] - n[0]) * (r[1] - n[1]) - (e[1] - n[1]) * (r[0] - n[0]) <= 0);\n\n      )\n        --a\n      o[a++] = u\n    }\n    return o.slice(0, a)\n  }\n  function nh () {\n    return Math.random()\n  }\n  var eh = (function t (n) {\n      function e (t, e) {\n        return (\n          (t = null == t ? 0 : +t),\n          (e = null == e ? 1 : +e),\n          1 === arguments.length ? ((e = t), (t = 0)) : (e -= t),\n          function () {\n            return n() * e + t\n          }\n        )\n      }\n      return (e.source = t), e\n    })(nh),\n    rh = (function t (n) {\n      function e (t, e) {\n        var r, i\n        return (\n          (t = null == t ? 0 : +t),\n          (e = null == e ? 1 : +e),\n          function () {\n            var o\n            if (null != r) (o = r), (r = null)\n            else\n              do {\n                ;(r = 2 * n() - 1), (o = 2 * n() - 1), (i = r * r + o * o)\n              } while (!i || i > 1)\n            return t + e * o * Math.sqrt((-2 * Math.log(i)) / i)\n          }\n        )\n      }\n      return (e.source = t), e\n    })(nh),\n    ih = (function t (n) {\n      function e () {\n        var t = rh.source(n).apply(this, arguments)\n        return function () {\n          return Math.exp(t())\n        }\n      }\n      return (e.source = t), e\n    })(nh),\n    oh = (function t (n) {\n      function e (t) {\n        return function () {\n          for (var e = 0, r = 0; r < t; ++r) e += n()\n          return e\n        }\n      }\n      return (e.source = t), e\n    })(nh),\n    ah = (function t (n) {\n      function e (t) {\n        var e = oh.source(n)(t)\n        return function () {\n          return e() / t\n        }\n      }\n      return (e.source = t), e\n    })(nh),\n    uh = (function t (n) {\n      function e (t) {\n        return function () {\n          return -Math.log(1 - n()) / t\n        }\n      }\n      return (e.source = t), e\n    })(nh)\n  function ch (t, n) {\n    switch (arguments.length) {\n      case 0:\n        break\n      case 1:\n        this.range(t)\n        break\n      default:\n        this.range(n).domain(t)\n    }\n    return this\n  }\n  function fh (t, n) {\n    switch (arguments.length) {\n      case 0:\n        break\n      case 1:\n        this.interpolator(t)\n        break\n      default:\n        this.interpolator(n).domain(t)\n    }\n    return this\n  }\n  var sh = Array.prototype,\n    lh = sh.map,\n    hh = sh.slice,\n    dh = { name: 'implicit' }\n  function ph () {\n    var t = Qi(),\n      n = [],\n      e = [],\n      r = dh\n    function i (i) {\n      var o = i + '',\n        a = t.get(o)\n      if (!a) {\n        if (r !== dh) return r\n        t.set(o, (a = n.push(i)))\n      }\n      return e[(a - 1) % e.length]\n    }\n    return (\n      (i.domain = function (e) {\n        if (!arguments.length) return n.slice()\n        ;(n = []), (t = Qi())\n        for (var r, o, a = -1, u = e.length; ++a < u; ) t.has((o = (r = e[a]) + '')) || t.set(o, n.push(r))\n        return i\n      }),\n      (i.range = function (t) {\n        return arguments.length ? ((e = hh.call(t)), i) : e.slice()\n      }),\n      (i.unknown = function (t) {\n        return arguments.length ? ((r = t), i) : r\n      }),\n      (i.copy = function () {\n        return ph(n, e).unknown(r)\n      }),\n      ch.apply(i, arguments),\n      i\n    )\n  }\n  function vh () {\n    var t,\n      n,\n      e = ph().unknown(void 0),\n      r = e.domain,\n      i = e.range,\n      o = [0, 1],\n      a = !1,\n      u = 0,\n      c = 0,\n      f = 0.5\n    function s () {\n      var e = r().length,\n        s = o[1] < o[0],\n        l = o[s - 0],\n        h = o[1 - s]\n      ;(t = (h - l) / Math.max(1, e - u + 2 * c)),\n        a && (t = Math.floor(t)),\n        (l += (h - l - t * (e - u)) * f),\n        (n = t * (1 - u)),\n        a && ((l = Math.round(l)), (n = Math.round(n)))\n      var d = g(e).map(function (n) {\n        return l + t * n\n      })\n      return i(s ? d.reverse() : d)\n    }\n    return (\n      delete e.unknown,\n      (e.domain = function (t) {\n        return arguments.length ? (r(t), s()) : r()\n      }),\n      (e.range = function (t) {\n        return arguments.length ? ((o = [+t[0], +t[1]]), s()) : o.slice()\n      }),\n      (e.rangeRound = function (t) {\n        return (o = [+t[0], +t[1]]), (a = !0), s()\n      }),\n      (e.bandwidth = function () {\n        return n\n      }),\n      (e.step = function () {\n        return t\n      }),\n      (e.round = function (t) {\n        return arguments.length ? ((a = !!t), s()) : a\n      }),\n      (e.padding = function (t) {\n        return arguments.length ? ((u = Math.min(1, (c = +t))), s()) : u\n      }),\n      (e.paddingInner = function (t) {\n        return arguments.length ? ((u = Math.min(1, t)), s()) : u\n      }),\n      (e.paddingOuter = function (t) {\n        return arguments.length ? ((c = +t), s()) : c\n      }),\n      (e.align = function (t) {\n        return arguments.length ? ((f = Math.max(0, Math.min(1, t))), s()) : f\n      }),\n      (e.copy = function () {\n        return vh(r(), o)\n          .round(a)\n          .paddingInner(u)\n          .paddingOuter(c)\n          .align(f)\n      }),\n      ch.apply(s(), arguments)\n    )\n  }\n  function gh (t) {\n    return +t\n  }\n  var yh = [0, 1]\n  function _h (t) {\n    return t\n  }\n  function bh (t, n) {\n    return (n -= t = +t)\n      ? function (e) {\n          return (e - t) / n\n        }\n      : ((e = isNaN(n) ? NaN : 0.5),\n        function () {\n          return e\n        })\n    var e\n  }\n  function mh (t) {\n    var n,\n      e = t[0],\n      r = t[t.length - 1]\n    return (\n      e > r && ((n = e), (e = r), (r = n)),\n      function (t) {\n        return Math.max(e, Math.min(r, t))\n      }\n    )\n  }\n  function xh (t, n, e) {\n    var r = t[0],\n      i = t[1],\n      o = n[0],\n      a = n[1]\n    return (\n      i < r ? ((r = bh(i, r)), (o = e(a, o))) : ((r = bh(r, i)), (o = e(o, a))),\n      function (t) {\n        return o(r(t))\n      }\n    )\n  }\n  function wh (t, n, e) {\n    var r = Math.min(t.length, n.length) - 1,\n      o = new Array(r),\n      a = new Array(r),\n      u = -1\n    for (t[r] < t[0] && ((t = t.slice().reverse()), (n = n.slice().reverse())); ++u < r; )\n      (o[u] = bh(t[u], t[u + 1])), (a[u] = e(n[u], n[u + 1]))\n    return function (n) {\n      var e = i(t, n, 1, r) - 1\n      return a[e](o[e](n))\n    }\n  }\n  function Mh (t, n) {\n    return n\n      .domain(t.domain())\n      .range(t.range())\n      .interpolate(t.interpolate())\n      .clamp(t.clamp())\n      .unknown(t.unknown())\n  }\n  function Nh () {\n    var t,\n      n,\n      e,\n      r,\n      i,\n      o,\n      a = yh,\n      u = yh,\n      c = ye,\n      f = _h\n    function s () {\n      return (r = Math.min(a.length, u.length) > 2 ? wh : xh), (i = o = null), l\n    }\n    function l (n) {\n      return isNaN((n = +n)) ? e : (i || (i = r(a.map(t), u, c)))(t(f(n)))\n    }\n    return (\n      (l.invert = function (e) {\n        return f(n((o || (o = r(u, a.map(t), he)))(e)))\n      }),\n      (l.domain = function (t) {\n        return arguments.length ? ((a = lh.call(t, gh)), f === _h || (f = mh(a)), s()) : a.slice()\n      }),\n      (l.range = function (t) {\n        return arguments.length ? ((u = hh.call(t)), s()) : u.slice()\n      }),\n      (l.rangeRound = function (t) {\n        return (u = hh.call(t)), (c = _e), s()\n      }),\n      (l.clamp = function (t) {\n        return arguments.length ? ((f = t ? mh(a) : _h), l) : f !== _h\n      }),\n      (l.interpolate = function (t) {\n        return arguments.length ? ((c = t), s()) : c\n      }),\n      (l.unknown = function (t) {\n        return arguments.length ? ((e = t), l) : e\n      }),\n      function (e, r) {\n        return (t = e), (n = r), s()\n      }\n    )\n  }\n  function Ah (t, n) {\n    return Nh()(t, n)\n  }\n  function Sh (n, e, r, i) {\n    var o,\n      a = w(n, e, r)\n    switch ((i = ma(null == i ? ',f' : i)).type) {\n      case 's':\n        var u = Math.max(Math.abs(n), Math.abs(e))\n        return null != i.precision || isNaN((o = Ca(a, u))) || (i.precision = o), t.formatPrefix(i, u)\n      case '':\n      case 'e':\n      case 'g':\n      case 'p':\n      case 'r':\n        null != i.precision ||\n          isNaN((o = Pa(a, Math.max(Math.abs(n), Math.abs(e))))) ||\n          (i.precision = o - ('e' === i.type))\n        break\n      case 'f':\n      case '%':\n        null != i.precision || isNaN((o = Ea(a))) || (i.precision = o - 2 * ('%' === i.type))\n    }\n    return t.format(i)\n  }\n  function kh (t) {\n    var n = t.domain\n    return (\n      (t.ticks = function (t) {\n        var e = n()\n        return m(e[0], e[e.length - 1], null == t ? 10 : t)\n      }),\n      (t.tickFormat = function (t, e) {\n        var r = n()\n        return Sh(r[0], r[r.length - 1], null == t ? 10 : t, e)\n      }),\n      (t.nice = function (e) {\n        null == e && (e = 10)\n        var r,\n          i = n(),\n          o = 0,\n          a = i.length - 1,\n          u = i[o],\n          c = i[a]\n        return (\n          c < u && ((r = u), (u = c), (c = r), (r = o), (o = a), (a = r)),\n          (r = x(u, c, e)) > 0\n            ? (r = x((u = Math.floor(u / r) * r), (c = Math.ceil(c / r) * r), e))\n            : r < 0 && (r = x((u = Math.ceil(u * r) / r), (c = Math.floor(c * r) / r), e)),\n          r > 0\n            ? ((i[o] = Math.floor(u / r) * r), (i[a] = Math.ceil(c / r) * r), n(i))\n            : r < 0 && ((i[o] = Math.ceil(u * r) / r), (i[a] = Math.floor(c * r) / r), n(i)),\n          t\n        )\n      }),\n      t\n    )\n  }\n  function Th (t, n) {\n    var e,\n      r = 0,\n      i = (t = t.slice()).length - 1,\n      o = t[r],\n      a = t[i]\n    return a < o && ((e = r), (r = i), (i = e), (e = o), (o = a), (a = e)), (t[r] = n.floor(o)), (t[i] = n.ceil(a)), t\n  }\n  function Eh (t) {\n    return Math.log(t)\n  }\n  function Ch (t) {\n    return Math.exp(t)\n  }\n  function Ph (t) {\n    return -Math.log(-t)\n  }\n  function zh (t) {\n    return -Math.exp(-t)\n  }\n  function Rh (t) {\n    return isFinite(t) ? +('1e' + t) : t < 0 ? 0 : t\n  }\n  function Dh (t) {\n    return function (n) {\n      return -t(-n)\n    }\n  }\n  function qh (n) {\n    var e,\n      r,\n      i = n(Eh, Ch),\n      o = i.domain,\n      a = 10\n    function u () {\n      return (\n        (e = (function (t) {\n          return t === Math.E\n            ? Math.log\n            : (10 === t && Math.log10) ||\n                (2 === t && Math.log2) ||\n                ((t = Math.log(t)),\n                function (n) {\n                  return Math.log(n) / t\n                })\n        })(a)),\n        (r = (function (t) {\n          return 10 === t\n            ? Rh\n            : t === Math.E\n            ? Math.exp\n            : function (n) {\n                return Math.pow(t, n)\n              }\n        })(a)),\n        o()[0] < 0 ? ((e = Dh(e)), (r = Dh(r)), n(Ph, zh)) : n(Eh, Ch),\n        i\n      )\n    }\n    return (\n      (i.base = function (t) {\n        return arguments.length ? ((a = +t), u()) : a\n      }),\n      (i.domain = function (t) {\n        return arguments.length ? (o(t), u()) : o()\n      }),\n      (i.ticks = function (t) {\n        var n,\n          i = o(),\n          u = i[0],\n          c = i[i.length - 1]\n        ;(n = c < u) && ((h = u), (u = c), (c = h))\n        var f,\n          s,\n          l,\n          h = e(u),\n          d = e(c),\n          p = null == t ? 10 : +t,\n          v = []\n        if (!(a % 1) && d - h < p) {\n          if (((h = Math.round(h) - 1), (d = Math.round(d) + 1), u > 0)) {\n            for (; h < d; ++h)\n              for (s = 1, f = r(h); s < a; ++s)\n                if (!((l = f * s) < u)) {\n                  if (l > c) break\n                  v.push(l)\n                }\n          } else\n            for (; h < d; ++h)\n              for (s = a - 1, f = r(h); s >= 1; --s)\n                if (!((l = f * s) < u)) {\n                  if (l > c) break\n                  v.push(l)\n                }\n        } else v = m(h, d, Math.min(d - h, p)).map(r)\n        return n ? v.reverse() : v\n      }),\n      (i.tickFormat = function (n, o) {\n        if ((null == o && (o = 10 === a ? '.0e' : ','), 'function' != typeof o && (o = t.format(o)), n === 1 / 0))\n          return o\n        null == n && (n = 10)\n        var u = Math.max(1, (a * n) / i.ticks().length)\n        return function (t) {\n          var n = t / r(Math.round(e(t)))\n          return n * a < a - 0.5 && (n *= a), n <= u ? o(t) : ''\n        }\n      }),\n      (i.nice = function () {\n        return o(\n          Th(o(), {\n            floor: function (t) {\n              return r(Math.floor(e(t)))\n            },\n            ceil: function (t) {\n              return r(Math.ceil(e(t)))\n            }\n          })\n        )\n      }),\n      i\n    )\n  }\n  function Lh (t) {\n    return function (n) {\n      return Math.sign(n) * Math.log1p(Math.abs(n / t))\n    }\n  }\n  function Uh (t) {\n    return function (n) {\n      return Math.sign(n) * Math.expm1(Math.abs(n)) * t\n    }\n  }\n  function Oh (t) {\n    var n = 1,\n      e = t(Lh(n), Uh(n))\n    return (\n      (e.constant = function (e) {\n        return arguments.length ? t(Lh((n = +e)), Uh(n)) : n\n      }),\n      kh(e)\n    )\n  }\n  function Bh (t) {\n    return function (n) {\n      return n < 0 ? -Math.pow(-n, t) : Math.pow(n, t)\n    }\n  }\n  function Yh (t) {\n    return t < 0 ? -Math.sqrt(-t) : Math.sqrt(t)\n  }\n  function Fh (t) {\n    return t < 0 ? -t * t : t * t\n  }\n  function Ih (t) {\n    var n = t(_h, _h),\n      e = 1\n    return (\n      (n.exponent = function (n) {\n        return arguments.length ? (1 === (e = +n) ? t(_h, _h) : 0.5 === e ? t(Yh, Fh) : t(Bh(e), Bh(1 / e))) : e\n      }),\n      kh(n)\n    )\n  }\n  function jh () {\n    var t = Ih(Nh())\n    return (\n      (t.copy = function () {\n        return Mh(t, jh()).exponent(t.exponent())\n      }),\n      ch.apply(t, arguments),\n      t\n    )\n  }\n  var Hh = new Date(),\n    Xh = new Date()\n  function Gh (t, n, e, r) {\n    function i (n) {\n      return t((n = new Date(+n))), n\n    }\n    return (\n      (i.floor = i),\n      (i.ceil = function (e) {\n        return t((e = new Date(e - 1))), n(e, 1), t(e), e\n      }),\n      (i.round = function (t) {\n        var n = i(t),\n          e = i.ceil(t)\n        return t - n < e - t ? n : e\n      }),\n      (i.offset = function (t, e) {\n        return n((t = new Date(+t)), null == e ? 1 : Math.floor(e)), t\n      }),\n      (i.range = function (e, r, o) {\n        var a,\n          u = []\n        if (((e = i.ceil(e)), (o = null == o ? 1 : Math.floor(o)), !(e < r && o > 0))) return u\n        do {\n          u.push((a = new Date(+e))), n(e, o), t(e)\n        } while (a < e && e < r)\n        return u\n      }),\n      (i.filter = function (e) {\n        return Gh(\n          function (n) {\n            if (n >= n) for (; t(n), !e(n); ) n.setTime(n - 1)\n          },\n          function (t, r) {\n            if (t >= t)\n              if (r < 0) for (; ++r <= 0; ) for (; n(t, -1), !e(t); );\n              else for (; --r >= 0; ) for (; n(t, 1), !e(t); );\n          }\n        )\n      }),\n      e &&\n        ((i.count = function (n, r) {\n          return Hh.setTime(+n), Xh.setTime(+r), t(Hh), t(Xh), Math.floor(e(Hh, Xh))\n        }),\n        (i.every = function (t) {\n          return (\n            (t = Math.floor(t)),\n            isFinite(t) && t > 0\n              ? t > 1\n                ? i.filter(\n                    r\n                      ? function (n) {\n                          return r(n) % t == 0\n                        }\n                      : function (n) {\n                          return i.count(0, n) % t == 0\n                        }\n                  )\n                : i\n              : null\n          )\n        })),\n      i\n    )\n  }\n  var Vh = Gh(\n    function () {},\n    function (t, n) {\n      t.setTime(+t + n)\n    },\n    function (t, n) {\n      return n - t\n    }\n  )\n  Vh.every = function (t) {\n    return (\n      (t = Math.floor(t)),\n      isFinite(t) && t > 0\n        ? t > 1\n          ? Gh(\n              function (n) {\n                n.setTime(Math.floor(n / t) * t)\n              },\n              function (n, e) {\n                n.setTime(+n + e * t)\n              },\n              function (n, e) {\n                return (e - n) / t\n              }\n            )\n          : Vh\n        : null\n    )\n  }\n  var $h = Vh.range,\n    Wh = 6e4,\n    Zh = 6048e5,\n    Qh = Gh(\n      function (t) {\n        t.setTime(t - t.getMilliseconds())\n      },\n      function (t, n) {\n        t.setTime(+t + 1e3 * n)\n      },\n      function (t, n) {\n        return (n - t) / 1e3\n      },\n      function (t) {\n        return t.getUTCSeconds()\n      }\n    ),\n    Jh = Qh.range,\n    Kh = Gh(\n      function (t) {\n        t.setTime(t - t.getMilliseconds() - 1e3 * t.getSeconds())\n      },\n      function (t, n) {\n        t.setTime(+t + n * Wh)\n      },\n      function (t, n) {\n        return (n - t) / Wh\n      },\n      function (t) {\n        return t.getMinutes()\n      }\n    ),\n    td = Kh.range,\n    nd = Gh(\n      function (t) {\n        t.setTime(t - t.getMilliseconds() - 1e3 * t.getSeconds() - t.getMinutes() * Wh)\n      },\n      function (t, n) {\n        t.setTime(+t + 36e5 * n)\n      },\n      function (t, n) {\n        return (n - t) / 36e5\n      },\n      function (t) {\n        return t.getHours()\n      }\n    ),\n    ed = nd.range,\n    rd = Gh(\n      function (t) {\n        t.setHours(0, 0, 0, 0)\n      },\n      function (t, n) {\n        t.setDate(t.getDate() + n)\n      },\n      function (t, n) {\n        return (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Wh) / 864e5\n      },\n      function (t) {\n        return t.getDate() - 1\n      }\n    ),\n    id = rd.range\n  function od (t) {\n    return Gh(\n      function (n) {\n        n.setDate(n.getDate() - ((n.getDay() + 7 - t) % 7)), n.setHours(0, 0, 0, 0)\n      },\n      function (t, n) {\n        t.setDate(t.getDate() + 7 * n)\n      },\n      function (t, n) {\n        return (n - t - (n.getTimezoneOffset() - t.getTimezoneOffset()) * Wh) / Zh\n      }\n    )\n  }\n  var ad = od(0),\n    ud = od(1),\n    cd = od(2),\n    fd = od(3),\n    sd = od(4),\n    ld = od(5),\n    hd = od(6),\n    dd = ad.range,\n    pd = ud.range,\n    vd = cd.range,\n    gd = fd.range,\n    yd = sd.range,\n    _d = ld.range,\n    bd = hd.range,\n    md = Gh(\n      function (t) {\n        t.setDate(1), t.setHours(0, 0, 0, 0)\n      },\n      function (t, n) {\n        t.setMonth(t.getMonth() + n)\n      },\n      function (t, n) {\n        return n.getMonth() - t.getMonth() + 12 * (n.getFullYear() - t.getFullYear())\n      },\n      function (t) {\n        return t.getMonth()\n      }\n    ),\n    xd = md.range,\n    wd = Gh(\n      function (t) {\n        t.setMonth(0, 1), t.setHours(0, 0, 0, 0)\n      },\n      function (t, n) {\n        t.setFullYear(t.getFullYear() + n)\n      },\n      function (t, n) {\n        return n.getFullYear() - t.getFullYear()\n      },\n      function (t) {\n        return t.getFullYear()\n      }\n    )\n  wd.every = function (t) {\n    return isFinite((t = Math.floor(t))) && t > 0\n      ? Gh(\n          function (n) {\n            n.setFullYear(Math.floor(n.getFullYear() / t) * t), n.setMonth(0, 1), n.setHours(0, 0, 0, 0)\n          },\n          function (n, e) {\n            n.setFullYear(n.getFullYear() + e * t)\n          }\n        )\n      : null\n  }\n  var Md = wd.range,\n    Nd = Gh(\n      function (t) {\n        t.setUTCSeconds(0, 0)\n      },\n      function (t, n) {\n        t.setTime(+t + n * Wh)\n      },\n      function (t, n) {\n        return (n - t) / Wh\n      },\n      function (t) {\n        return t.getUTCMinutes()\n      }\n    ),\n    Ad = Nd.range,\n    Sd = Gh(\n      function (t) {\n        t.setUTCMinutes(0, 0, 0)\n      },\n      function (t, n) {\n        t.setTime(+t + 36e5 * n)\n      },\n      function (t, n) {\n        return (n - t) / 36e5\n      },\n      function (t) {\n        return t.getUTCHours()\n      }\n    ),\n    kd = Sd.range,\n    Td = Gh(\n      function (t) {\n        t.setUTCHours(0, 0, 0, 0)\n      },\n      function (t, n) {\n        t.setUTCDate(t.getUTCDate() + n)\n      },\n      function (t, n) {\n        return (n - t) / 864e5\n      },\n      function (t) {\n        return t.getUTCDate() - 1\n      }\n    ),\n    Ed = Td.range\n  function Cd (t) {\n    return Gh(\n      function (n) {\n        n.setUTCDate(n.getUTCDate() - ((n.getUTCDay() + 7 - t) % 7)), n.setUTCHours(0, 0, 0, 0)\n      },\n      function (t, n) {\n        t.setUTCDate(t.getUTCDate() + 7 * n)\n      },\n      function (t, n) {\n        return (n - t) / Zh\n      }\n    )\n  }\n  var Pd = Cd(0),\n    zd = Cd(1),\n    Rd = Cd(2),\n    Dd = Cd(3),\n    qd = Cd(4),\n    Ld = Cd(5),\n    Ud = Cd(6),\n    Od = Pd.range,\n    Bd = zd.range,\n    Yd = Rd.range,\n    Fd = Dd.range,\n    Id = qd.range,\n    jd = Ld.range,\n    Hd = Ud.range,\n    Xd = Gh(\n      function (t) {\n        t.setUTCDate(1), t.setUTCHours(0, 0, 0, 0)\n      },\n      function (t, n) {\n        t.setUTCMonth(t.getUTCMonth() + n)\n      },\n      function (t, n) {\n        return n.getUTCMonth() - t.getUTCMonth() + 12 * (n.getUTCFullYear() - t.getUTCFullYear())\n      },\n      function (t) {\n        return t.getUTCMonth()\n      }\n    ),\n    Gd = Xd.range,\n    Vd = Gh(\n      function (t) {\n        t.setUTCMonth(0, 1), t.setUTCHours(0, 0, 0, 0)\n      },\n      function (t, n) {\n        t.setUTCFullYear(t.getUTCFullYear() + n)\n      },\n      function (t, n) {\n        return n.getUTCFullYear() - t.getUTCFullYear()\n      },\n      function (t) {\n        return t.getUTCFullYear()\n      }\n    )\n  Vd.every = function (t) {\n    return isFinite((t = Math.floor(t))) && t > 0\n      ? Gh(\n          function (n) {\n            n.setUTCFullYear(Math.floor(n.getUTCFullYear() / t) * t), n.setUTCMonth(0, 1), n.setUTCHours(0, 0, 0, 0)\n          },\n          function (n, e) {\n            n.setUTCFullYear(n.getUTCFullYear() + e * t)\n          }\n        )\n      : null\n  }\n  var $d = Vd.range\n  function Wd (t) {\n    if (0 <= t.y && t.y < 100) {\n      var n = new Date(-1, t.m, t.d, t.H, t.M, t.S, t.L)\n      return n.setFullYear(t.y), n\n    }\n    return new Date(t.y, t.m, t.d, t.H, t.M, t.S, t.L)\n  }\n  function Zd (t) {\n    if (0 <= t.y && t.y < 100) {\n      var n = new Date(Date.UTC(-1, t.m, t.d, t.H, t.M, t.S, t.L))\n      return n.setUTCFullYear(t.y), n\n    }\n    return new Date(Date.UTC(t.y, t.m, t.d, t.H, t.M, t.S, t.L))\n  }\n  function Qd (t) {\n    return { y: t, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0 }\n  }\n  function Jd (t) {\n    var n = t.dateTime,\n      e = t.date,\n      r = t.time,\n      i = t.periods,\n      o = t.days,\n      a = t.shortDays,\n      u = t.months,\n      c = t.shortMonths,\n      f = ap(i),\n      s = up(i),\n      l = ap(o),\n      h = up(o),\n      d = ap(a),\n      p = up(a),\n      v = ap(u),\n      g = up(u),\n      y = ap(c),\n      _ = up(c),\n      b = {\n        a: function (t) {\n          return a[t.getDay()]\n        },\n        A: function (t) {\n          return o[t.getDay()]\n        },\n        b: function (t) {\n          return c[t.getMonth()]\n        },\n        B: function (t) {\n          return u[t.getMonth()]\n        },\n        c: null,\n        d: kp,\n        e: kp,\n        f: zp,\n        H: Tp,\n        I: Ep,\n        j: Cp,\n        L: Pp,\n        m: Rp,\n        M: Dp,\n        p: function (t) {\n          return i[+(t.getHours() >= 12)]\n        },\n        Q: cv,\n        s: fv,\n        S: qp,\n        u: Lp,\n        U: Up,\n        V: Op,\n        w: Bp,\n        W: Yp,\n        x: null,\n        X: null,\n        y: Fp,\n        Y: Ip,\n        Z: jp,\n        '%': uv\n      },\n      m = {\n        a: function (t) {\n          return a[t.getUTCDay()]\n        },\n        A: function (t) {\n          return o[t.getUTCDay()]\n        },\n        b: function (t) {\n          return c[t.getUTCMonth()]\n        },\n        B: function (t) {\n          return u[t.getUTCMonth()]\n        },\n        c: null,\n        d: Hp,\n        e: Hp,\n        f: Wp,\n        H: Xp,\n        I: Gp,\n        j: Vp,\n        L: $p,\n        m: Zp,\n        M: Qp,\n        p: function (t) {\n          return i[+(t.getUTCHours() >= 12)]\n        },\n        Q: cv,\n        s: fv,\n        S: Jp,\n        u: Kp,\n        U: tv,\n        V: nv,\n        w: ev,\n        W: rv,\n        x: null,\n        X: null,\n        y: iv,\n        Y: ov,\n        Z: av,\n        '%': uv\n      },\n      x = {\n        a: function (t, n, e) {\n          var r = d.exec(n.slice(e))\n          return r ? ((t.w = p[r[0].toLowerCase()]), e + r[0].length) : -1\n        },\n        A: function (t, n, e) {\n          var r = l.exec(n.slice(e))\n          return r ? ((t.w = h[r[0].toLowerCase()]), e + r[0].length) : -1\n        },\n        b: function (t, n, e) {\n          var r = y.exec(n.slice(e))\n          return r ? ((t.m = _[r[0].toLowerCase()]), e + r[0].length) : -1\n        },\n        B: function (t, n, e) {\n          var r = v.exec(n.slice(e))\n          return r ? ((t.m = g[r[0].toLowerCase()]), e + r[0].length) : -1\n        },\n        c: function (t, e, r) {\n          return N(t, n, e, r)\n        },\n        d: yp,\n        e: yp,\n        f: Mp,\n        H: bp,\n        I: bp,\n        j: _p,\n        L: wp,\n        m: gp,\n        M: mp,\n        p: function (t, n, e) {\n          var r = f.exec(n.slice(e))\n          return r ? ((t.p = s[r[0].toLowerCase()]), e + r[0].length) : -1\n        },\n        Q: Ap,\n        s: Sp,\n        S: xp,\n        u: fp,\n        U: sp,\n        V: lp,\n        w: cp,\n        W: hp,\n        x: function (t, n, r) {\n          return N(t, e, n, r)\n        },\n        X: function (t, n, e) {\n          return N(t, r, n, e)\n        },\n        y: pp,\n        Y: dp,\n        Z: vp,\n        '%': Np\n      }\n    function w (t, n) {\n      return function (e) {\n        var r,\n          i,\n          o,\n          a = [],\n          u = -1,\n          c = 0,\n          f = t.length\n        for (e instanceof Date || (e = new Date(+e)); ++u < f; )\n          37 === t.charCodeAt(u) &&\n            (a.push(t.slice(c, u)),\n            null != (i = tp[(r = t.charAt(++u))]) ? (r = t.charAt(++u)) : (i = 'e' === r ? ' ' : '0'),\n            (o = n[r]) && (r = o(e, i)),\n            a.push(r),\n            (c = u + 1))\n        return a.push(t.slice(c, u)), a.join('')\n      }\n    }\n    function M (t, n) {\n      return function (e) {\n        var r,\n          i,\n          o = Qd(1900)\n        if (N(o, t, (e += ''), 0) != e.length) return null\n        if ('Q' in o) return new Date(o.Q)\n        if (('p' in o && (o.H = (o.H % 12) + 12 * o.p), 'V' in o)) {\n          if (o.V < 1 || o.V > 53) return null\n          'w' in o || (o.w = 1),\n            'Z' in o\n              ? ((i = (r = Zd(Qd(o.y))).getUTCDay()),\n                (r = i > 4 || 0 === i ? zd.ceil(r) : zd(r)),\n                (r = Td.offset(r, 7 * (o.V - 1))),\n                (o.y = r.getUTCFullYear()),\n                (o.m = r.getUTCMonth()),\n                (o.d = r.getUTCDate() + ((o.w + 6) % 7)))\n              : ((i = (r = n(Qd(o.y))).getDay()),\n                (r = i > 4 || 0 === i ? ud.ceil(r) : ud(r)),\n                (r = rd.offset(r, 7 * (o.V - 1))),\n                (o.y = r.getFullYear()),\n                (o.m = r.getMonth()),\n                (o.d = r.getDate() + ((o.w + 6) % 7)))\n        } else ('W' in o || 'U' in o) && ('w' in o || (o.w = 'u' in o ? o.u % 7 : 'W' in o ? 1 : 0), (i = 'Z' in o ? Zd(Qd(o.y)).getUTCDay() : n(Qd(o.y)).getDay()), (o.m = 0), (o.d = 'W' in o ? ((o.w + 6) % 7) + 7 * o.W - ((i + 5) % 7) : o.w + 7 * o.U - ((i + 6) % 7)))\n        return 'Z' in o ? ((o.H += (o.Z / 100) | 0), (o.M += o.Z % 100), Zd(o)) : n(o)\n      }\n    }\n    function N (t, n, e, r) {\n      for (var i, o, a = 0, u = n.length, c = e.length; a < u; ) {\n        if (r >= c) return -1\n        if (37 === (i = n.charCodeAt(a++))) {\n          if (((i = n.charAt(a++)), !(o = x[i in tp ? n.charAt(a++) : i]) || (r = o(t, e, r)) < 0)) return -1\n        } else if (i != e.charCodeAt(r++)) return -1\n      }\n      return r\n    }\n    return (\n      (b.x = w(e, b)),\n      (b.X = w(r, b)),\n      (b.c = w(n, b)),\n      (m.x = w(e, m)),\n      (m.X = w(r, m)),\n      (m.c = w(n, m)),\n      {\n        format: function (t) {\n          var n = w((t += ''), b)\n          return (\n            (n.toString = function () {\n              return t\n            }),\n            n\n          )\n        },\n        parse: function (t) {\n          var n = M((t += ''), Wd)\n          return (\n            (n.toString = function () {\n              return t\n            }),\n            n\n          )\n        },\n        utcFormat: function (t) {\n          var n = w((t += ''), m)\n          return (\n            (n.toString = function () {\n              return t\n            }),\n            n\n          )\n        },\n        utcParse: function (t) {\n          var n = M(t, Zd)\n          return (\n            (n.toString = function () {\n              return t\n            }),\n            n\n          )\n        }\n      }\n    )\n  }\n  var Kd,\n    tp = { '-': '', _: ' ', 0: '0' },\n    np = /^\\s*\\d+/,\n    ep = /^%/,\n    rp = /[\\\\^$*+?|[\\]().{}]/g\n  function ip (t, n, e) {\n    var r = t < 0 ? '-' : '',\n      i = (r ? -t : t) + '',\n      o = i.length\n    return r + (o < e ? new Array(e - o + 1).join(n) + i : i)\n  }\n  function op (t) {\n    return t.replace(rp, '\\\\$&')\n  }\n  function ap (t) {\n    return new RegExp('^(?:' + t.map(op).join('|') + ')', 'i')\n  }\n  function up (t) {\n    for (var n = {}, e = -1, r = t.length; ++e < r; ) n[t[e].toLowerCase()] = e\n    return n\n  }\n  function cp (t, n, e) {\n    var r = np.exec(n.slice(e, e + 1))\n    return r ? ((t.w = +r[0]), e + r[0].length) : -1\n  }\n  function fp (t, n, e) {\n    var r = np.exec(n.slice(e, e + 1))\n    return r ? ((t.u = +r[0]), e + r[0].length) : -1\n  }\n  function sp (t, n, e) {\n    var r = np.exec(n.slice(e, e + 2))\n    return r ? ((t.U = +r[0]), e + r[0].length) : -1\n  }\n  function lp (t, n, e) {\n    var r = np.exec(n.slice(e, e + 2))\n    return r ? ((t.V = +r[0]), e + r[0].length) : -1\n  }\n  function hp (t, n, e) {\n    var r = np.exec(n.slice(e, e + 2))\n    return r ? ((t.W = +r[0]), e + r[0].length) : -1\n  }\n  function dp (t, n, e) {\n    var r = np.exec(n.slice(e, e + 4))\n    return r ? ((t.y = +r[0]), e + r[0].length) : -1\n  }\n  function pp (t, n, e) {\n    var r = np.exec(n.slice(e, e + 2))\n    return r ? ((t.y = +r[0] + (+r[0] > 68 ? 1900 : 2e3)), e + r[0].length) : -1\n  }\n  function vp (t, n, e) {\n    var r = /^(Z)|([+-]\\d\\d)(?::?(\\d\\d))?/.exec(n.slice(e, e + 6))\n    return r ? ((t.Z = r[1] ? 0 : -(r[2] + (r[3] || '00'))), e + r[0].length) : -1\n  }\n  function gp (t, n, e) {\n    var r = np.exec(n.slice(e, e + 2))\n    return r ? ((t.m = r[0] - 1), e + r[0].length) : -1\n  }\n  function yp (t, n, e) {\n    var r = np.exec(n.slice(e, e + 2))\n    return r ? ((t.d = +r[0]), e + r[0].length) : -1\n  }\n  function _p (t, n, e) {\n    var r = np.exec(n.slice(e, e + 3))\n    return r ? ((t.m = 0), (t.d = +r[0]), e + r[0].length) : -1\n  }\n  function bp (t, n, e) {\n    var r = np.exec(n.slice(e, e + 2))\n    return r ? ((t.H = +r[0]), e + r[0].length) : -1\n  }\n  function mp (t, n, e) {\n    var r = np.exec(n.slice(e, e + 2))\n    return r ? ((t.M = +r[0]), e + r[0].length) : -1\n  }\n  function xp (t, n, e) {\n    var r = np.exec(n.slice(e, e + 2))\n    return r ? ((t.S = +r[0]), e + r[0].length) : -1\n  }\n  function wp (t, n, e) {\n    var r = np.exec(n.slice(e, e + 3))\n    return r ? ((t.L = +r[0]), e + r[0].length) : -1\n  }\n  function Mp (t, n, e) {\n    var r = np.exec(n.slice(e, e + 6))\n    return r ? ((t.L = Math.floor(r[0] / 1e3)), e + r[0].length) : -1\n  }\n  function Np (t, n, e) {\n    var r = ep.exec(n.slice(e, e + 1))\n    return r ? e + r[0].length : -1\n  }\n  function Ap (t, n, e) {\n    var r = np.exec(n.slice(e))\n    return r ? ((t.Q = +r[0]), e + r[0].length) : -1\n  }\n  function Sp (t, n, e) {\n    var r = np.exec(n.slice(e))\n    return r ? ((t.Q = 1e3 * +r[0]), e + r[0].length) : -1\n  }\n  function kp (t, n) {\n    return ip(t.getDate(), n, 2)\n  }\n  function Tp (t, n) {\n    return ip(t.getHours(), n, 2)\n  }\n  function Ep (t, n) {\n    return ip(t.getHours() % 12 || 12, n, 2)\n  }\n  function Cp (t, n) {\n    return ip(1 + rd.count(wd(t), t), n, 3)\n  }\n  function Pp (t, n) {\n    return ip(t.getMilliseconds(), n, 3)\n  }\n  function zp (t, n) {\n    return Pp(t, n) + '000'\n  }\n  function Rp (t, n) {\n    return ip(t.getMonth() + 1, n, 2)\n  }\n  function Dp (t, n) {\n    return ip(t.getMinutes(), n, 2)\n  }\n  function qp (t, n) {\n    return ip(t.getSeconds(), n, 2)\n  }\n  function Lp (t) {\n    var n = t.getDay()\n    return 0 === n ? 7 : n\n  }\n  function Up (t, n) {\n    return ip(ad.count(wd(t), t), n, 2)\n  }\n  function Op (t, n) {\n    var e = t.getDay()\n    return (t = e >= 4 || 0 === e ? sd(t) : sd.ceil(t)), ip(sd.count(wd(t), t) + (4 === wd(t).getDay()), n, 2)\n  }\n  function Bp (t) {\n    return t.getDay()\n  }\n  function Yp (t, n) {\n    return ip(ud.count(wd(t), t), n, 2)\n  }\n  function Fp (t, n) {\n    return ip(t.getFullYear() % 100, n, 2)\n  }\n  function Ip (t, n) {\n    return ip(t.getFullYear() % 1e4, n, 4)\n  }\n  function jp (t) {\n    var n = t.getTimezoneOffset()\n    return (n > 0 ? '-' : ((n *= -1), '+')) + ip((n / 60) | 0, '0', 2) + ip(n % 60, '0', 2)\n  }\n  function Hp (t, n) {\n    return ip(t.getUTCDate(), n, 2)\n  }\n  function Xp (t, n) {\n    return ip(t.getUTCHours(), n, 2)\n  }\n  function Gp (t, n) {\n    return ip(t.getUTCHours() % 12 || 12, n, 2)\n  }\n  function Vp (t, n) {\n    return ip(1 + Td.count(Vd(t), t), n, 3)\n  }\n  function $p (t, n) {\n    return ip(t.getUTCMilliseconds(), n, 3)\n  }\n  function Wp (t, n) {\n    return $p(t, n) + '000'\n  }\n  function Zp (t, n) {\n    return ip(t.getUTCMonth() + 1, n, 2)\n  }\n  function Qp (t, n) {\n    return ip(t.getUTCMinutes(), n, 2)\n  }\n  function Jp (t, n) {\n    return ip(t.getUTCSeconds(), n, 2)\n  }\n  function Kp (t) {\n    var n = t.getUTCDay()\n    return 0 === n ? 7 : n\n  }\n  function tv (t, n) {\n    return ip(Pd.count(Vd(t), t), n, 2)\n  }\n  function nv (t, n) {\n    var e = t.getUTCDay()\n    return (t = e >= 4 || 0 === e ? qd(t) : qd.ceil(t)), ip(qd.count(Vd(t), t) + (4 === Vd(t).getUTCDay()), n, 2)\n  }\n  function ev (t) {\n    return t.getUTCDay()\n  }\n  function rv (t, n) {\n    return ip(zd.count(Vd(t), t), n, 2)\n  }\n  function iv (t, n) {\n    return ip(t.getUTCFullYear() % 100, n, 2)\n  }\n  function ov (t, n) {\n    return ip(t.getUTCFullYear() % 1e4, n, 4)\n  }\n  function av () {\n    return '+0000'\n  }\n  function uv () {\n    return '%'\n  }\n  function cv (t) {\n    return +t\n  }\n  function fv (t) {\n    return Math.floor(+t / 1e3)\n  }\n  function sv (n) {\n    return (\n      (Kd = Jd(n)),\n      (t.timeFormat = Kd.format),\n      (t.timeParse = Kd.parse),\n      (t.utcFormat = Kd.utcFormat),\n      (t.utcParse = Kd.utcParse),\n      Kd\n    )\n  }\n  sv({\n    dateTime: '%x, %X',\n    date: '%-m/%-d/%Y',\n    time: '%-I:%M:%S %p',\n    periods: ['AM', 'PM'],\n    days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n    shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n    months: [\n      'January',\n      'February',\n      'March',\n      'April',\n      'May',\n      'June',\n      'July',\n      'August',\n      'September',\n      'October',\n      'November',\n      'December'\n    ],\n    shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n  })\n  var lv = Date.prototype.toISOString\n    ? function (t) {\n        return t.toISOString()\n      }\n    : t.utcFormat('%Y-%m-%dT%H:%M:%S.%LZ')\n  var hv = +new Date('2000-01-01T00:00:00.000Z')\n      ? function (t) {\n          var n = new Date(t)\n          return isNaN(n) ? null : n\n        }\n      : t.utcParse('%Y-%m-%dT%H:%M:%S.%LZ'),\n    dv = 1e3,\n    pv = 60 * dv,\n    vv = 60 * pv,\n    gv = 24 * vv,\n    yv = 7 * gv,\n    _v = 30 * gv,\n    bv = 365 * gv\n  function mv (t) {\n    return new Date(t)\n  }\n  function xv (t) {\n    return t instanceof Date ? +t : +new Date(+t)\n  }\n  function wv (t, n, r, i, o, a, u, c, f) {\n    var s = Ah(_h, _h),\n      l = s.invert,\n      h = s.domain,\n      d = f('.%L'),\n      p = f(':%S'),\n      v = f('%I:%M'),\n      g = f('%I %p'),\n      y = f('%a %d'),\n      _ = f('%b %d'),\n      b = f('%B'),\n      m = f('%Y'),\n      x = [\n        [u, 1, dv],\n        [u, 5, 5 * dv],\n        [u, 15, 15 * dv],\n        [u, 30, 30 * dv],\n        [a, 1, pv],\n        [a, 5, 5 * pv],\n        [a, 15, 15 * pv],\n        [a, 30, 30 * pv],\n        [o, 1, vv],\n        [o, 3, 3 * vv],\n        [o, 6, 6 * vv],\n        [o, 12, 12 * vv],\n        [i, 1, gv],\n        [i, 2, 2 * gv],\n        [r, 1, yv],\n        [n, 1, _v],\n        [n, 3, 3 * _v],\n        [t, 1, bv]\n      ]\n    function M (e) {\n      return (u(e) < e\n        ? d\n        : a(e) < e\n        ? p\n        : o(e) < e\n        ? v\n        : i(e) < e\n        ? g\n        : n(e) < e\n        ? r(e) < e\n          ? y\n          : _\n        : t(e) < e\n        ? b\n        : m)(e)\n    }\n    function N (n, r, i, o) {\n      if ((null == n && (n = 10), 'number' == typeof n)) {\n        var a = Math.abs(i - r) / n,\n          u = e(function (t) {\n            return t[2]\n          }).right(x, a)\n        u === x.length\n          ? ((o = w(r / bv, i / bv, n)), (n = t))\n          : u\n          ? ((o = (u = x[a / x[u - 1][2] < x[u][2] / a ? u - 1 : u])[1]), (n = u[0]))\n          : ((o = Math.max(w(r, i, n), 1)), (n = c))\n      }\n      return null == o ? n : n.every(o)\n    }\n    return (\n      (s.invert = function (t) {\n        return new Date(l(t))\n      }),\n      (s.domain = function (t) {\n        return arguments.length ? h(lh.call(t, xv)) : h().map(mv)\n      }),\n      (s.ticks = function (t, n) {\n        var e,\n          r = h(),\n          i = r[0],\n          o = r[r.length - 1],\n          a = o < i\n        return a && ((e = i), (i = o), (o = e)), (e = (e = N(t, i, o, n)) ? e.range(i, o + 1) : []), a ? e.reverse() : e\n      }),\n      (s.tickFormat = function (t, n) {\n        return null == n ? M : f(n)\n      }),\n      (s.nice = function (t, n) {\n        var e = h()\n        return (t = N(t, e[0], e[e.length - 1], n)) ? h(Th(e, t)) : s\n      }),\n      (s.copy = function () {\n        return Mh(s, wv(t, n, r, i, o, a, u, c, f))\n      }),\n      s\n    )\n  }\n  function Mv () {\n    var t,\n      n,\n      e,\n      r,\n      i,\n      o = 0,\n      a = 1,\n      u = _h,\n      c = !1\n    function f (n) {\n      return isNaN((n = +n)) ? i : u(0 === e ? 0.5 : ((n = (r(n) - t) * e), c ? Math.max(0, Math.min(1, n)) : n))\n    }\n    return (\n      (f.domain = function (i) {\n        return arguments.length\n          ? ((t = r((o = +i[0]))), (n = r((a = +i[1]))), (e = t === n ? 0 : 1 / (n - t)), f)\n          : [o, a]\n      }),\n      (f.clamp = function (t) {\n        return arguments.length ? ((c = !!t), f) : c\n      }),\n      (f.interpolator = function (t) {\n        return arguments.length ? ((u = t), f) : u\n      }),\n      (f.unknown = function (t) {\n        return arguments.length ? ((i = t), f) : i\n      }),\n      function (i) {\n        return (r = i), (t = i(o)), (n = i(a)), (e = t === n ? 0 : 1 / (n - t)), f\n      }\n    )\n  }\n  function Nv (t, n) {\n    return n\n      .domain(t.domain())\n      .interpolator(t.interpolator())\n      .clamp(t.clamp())\n      .unknown(t.unknown())\n  }\n  function Av () {\n    var t = Ih(Mv())\n    return (\n      (t.copy = function () {\n        return Nv(t, Av()).exponent(t.exponent())\n      }),\n      fh.apply(t, arguments)\n    )\n  }\n  function Sv () {\n    var t,\n      n,\n      e,\n      r,\n      i,\n      o,\n      a,\n      u = 0,\n      c = 0.5,\n      f = 1,\n      s = _h,\n      l = !1\n    function h (t) {\n      return isNaN((t = +t))\n        ? a\n        : ((t = 0.5 + ((t = +o(t)) - n) * (t < n ? r : i)), s(l ? Math.max(0, Math.min(1, t)) : t))\n    }\n    return (\n      (h.domain = function (a) {\n        return arguments.length\n          ? ((t = o((u = +a[0]))),\n            (n = o((c = +a[1]))),\n            (e = o((f = +a[2]))),\n            (r = t === n ? 0 : 0.5 / (n - t)),\n            (i = n === e ? 0 : 0.5 / (e - n)),\n            h)\n          : [u, c, f]\n      }),\n      (h.clamp = function (t) {\n        return arguments.length ? ((l = !!t), h) : l\n      }),\n      (h.interpolator = function (t) {\n        return arguments.length ? ((s = t), h) : s\n      }),\n      (h.unknown = function (t) {\n        return arguments.length ? ((a = t), h) : a\n      }),\n      function (a) {\n        return (\n          (o = a),\n          (t = a(u)),\n          (n = a(c)),\n          (e = a(f)),\n          (r = t === n ? 0 : 0.5 / (n - t)),\n          (i = n === e ? 0 : 0.5 / (e - n)),\n          h\n        )\n      }\n    )\n  }\n  function kv () {\n    var t = Ih(Sv())\n    return (\n      (t.copy = function () {\n        return Nv(t, kv()).exponent(t.exponent())\n      }),\n      fh.apply(t, arguments)\n    )\n  }\n  function Tv (t) {\n    for (var n = (t.length / 6) | 0, e = new Array(n), r = 0; r < n; ) e[r] = '#' + t.slice(6 * r, 6 * ++r)\n    return e\n  }\n  var Ev = Tv('1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf'),\n    Cv = Tv('7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666'),\n    Pv = Tv('1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666'),\n    zv = Tv('a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928'),\n    Rv = Tv('fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2'),\n    Dv = Tv('b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc'),\n    qv = Tv('e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999'),\n    Lv = Tv('66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3'),\n    Uv = Tv('8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f')\n  function Ov (t) {\n    return ce(t[t.length - 1])\n  }\n  var Bv = new Array(3)\n      .concat(\n        'd8b365f5f5f55ab4ac',\n        'a6611adfc27d80cdc1018571',\n        'a6611adfc27df5f5f580cdc1018571',\n        '8c510ad8b365f6e8c3c7eae55ab4ac01665e',\n        '8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e',\n        '8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e',\n        '8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e',\n        '5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30',\n        '5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30'\n      )\n      .map(Tv),\n    Yv = Ov(Bv),\n    Fv = new Array(3)\n      .concat(\n        'af8dc3f7f7f77fbf7b',\n        '7b3294c2a5cfa6dba0008837',\n        '7b3294c2a5cff7f7f7a6dba0008837',\n        '762a83af8dc3e7d4e8d9f0d37fbf7b1b7837',\n        '762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837',\n        '762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837',\n        '762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837',\n        '40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b',\n        '40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b'\n      )\n      .map(Tv),\n    Iv = Ov(Fv),\n    jv = new Array(3)\n      .concat(\n        'e9a3c9f7f7f7a1d76a',\n        'd01c8bf1b6dab8e1864dac26',\n        'd01c8bf1b6daf7f7f7b8e1864dac26',\n        'c51b7de9a3c9fde0efe6f5d0a1d76a4d9221',\n        'c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221',\n        'c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221',\n        'c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221',\n        '8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419',\n        '8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419'\n      )\n      .map(Tv),\n    Hv = Ov(jv),\n    Xv = new Array(3)\n      .concat(\n        '998ec3f7f7f7f1a340',\n        '5e3c99b2abd2fdb863e66101',\n        '5e3c99b2abd2f7f7f7fdb863e66101',\n        '542788998ec3d8daebfee0b6f1a340b35806',\n        '542788998ec3d8daebf7f7f7fee0b6f1a340b35806',\n        '5427888073acb2abd2d8daebfee0b6fdb863e08214b35806',\n        '5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806',\n        '2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08',\n        '2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08'\n      )\n      .map(Tv),\n    Gv = Ov(Xv),\n    Vv = new Array(3)\n      .concat(\n        'ef8a62f7f7f767a9cf',\n        'ca0020f4a58292c5de0571b0',\n        'ca0020f4a582f7f7f792c5de0571b0',\n        'b2182bef8a62fddbc7d1e5f067a9cf2166ac',\n        'b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac',\n        'b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac',\n        'b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac',\n        '67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061',\n        '67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061'\n      )\n      .map(Tv),\n    $v = Ov(Vv),\n    Wv = new Array(3)\n      .concat(\n        'ef8a62ffffff999999',\n        'ca0020f4a582bababa404040',\n        'ca0020f4a582ffffffbababa404040',\n        'b2182bef8a62fddbc7e0e0e09999994d4d4d',\n        'b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d',\n        'b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d',\n        'b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d',\n        '67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a',\n        '67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a'\n      )\n      .map(Tv),\n    Zv = Ov(Wv),\n    Qv = new Array(3)\n      .concat(\n        'fc8d59ffffbf91bfdb',\n        'd7191cfdae61abd9e92c7bb6',\n        'd7191cfdae61ffffbfabd9e92c7bb6',\n        'd73027fc8d59fee090e0f3f891bfdb4575b4',\n        'd73027fc8d59fee090ffffbfe0f3f891bfdb4575b4',\n        'd73027f46d43fdae61fee090e0f3f8abd9e974add14575b4',\n        'd73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4',\n        'a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695',\n        'a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695'\n      )\n      .map(Tv),\n    Jv = Ov(Qv),\n    Kv = new Array(3)\n      .concat(\n        'fc8d59ffffbf91cf60',\n        'd7191cfdae61a6d96a1a9641',\n        'd7191cfdae61ffffbfa6d96a1a9641',\n        'd73027fc8d59fee08bd9ef8b91cf601a9850',\n        'd73027fc8d59fee08bffffbfd9ef8b91cf601a9850',\n        'd73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850',\n        'd73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850',\n        'a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837',\n        'a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837'\n      )\n      .map(Tv),\n    tg = Ov(Kv),\n    ng = new Array(3)\n      .concat(\n        'fc8d59ffffbf99d594',\n        'd7191cfdae61abdda42b83ba',\n        'd7191cfdae61ffffbfabdda42b83ba',\n        'd53e4ffc8d59fee08be6f59899d5943288bd',\n        'd53e4ffc8d59fee08bffffbfe6f59899d5943288bd',\n        'd53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd',\n        'd53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd',\n        '9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2',\n        '9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2'\n      )\n      .map(Tv),\n    eg = Ov(ng),\n    rg = new Array(3)\n      .concat(\n        'e5f5f999d8c92ca25f',\n        'edf8fbb2e2e266c2a4238b45',\n        'edf8fbb2e2e266c2a42ca25f006d2c',\n        'edf8fbccece699d8c966c2a42ca25f006d2c',\n        'edf8fbccece699d8c966c2a441ae76238b45005824',\n        'f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824',\n        'f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b'\n      )\n      .map(Tv),\n    ig = Ov(rg),\n    og = new Array(3)\n      .concat(\n        'e0ecf49ebcda8856a7',\n        'edf8fbb3cde38c96c688419d',\n        'edf8fbb3cde38c96c68856a7810f7c',\n        'edf8fbbfd3e69ebcda8c96c68856a7810f7c',\n        'edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b',\n        'f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b',\n        'f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b'\n      )\n      .map(Tv),\n    ag = Ov(og),\n    ug = new Array(3)\n      .concat(\n        'e0f3dba8ddb543a2ca',\n        'f0f9e8bae4bc7bccc42b8cbe',\n        'f0f9e8bae4bc7bccc443a2ca0868ac',\n        'f0f9e8ccebc5a8ddb57bccc443a2ca0868ac',\n        'f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e',\n        'f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e',\n        'f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081'\n      )\n      .map(Tv),\n    cg = Ov(ug),\n    fg = new Array(3)\n      .concat(\n        'fee8c8fdbb84e34a33',\n        'fef0d9fdcc8afc8d59d7301f',\n        'fef0d9fdcc8afc8d59e34a33b30000',\n        'fef0d9fdd49efdbb84fc8d59e34a33b30000',\n        'fef0d9fdd49efdbb84fc8d59ef6548d7301f990000',\n        'fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000',\n        'fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000'\n      )\n      .map(Tv),\n    sg = Ov(fg),\n    lg = new Array(3)\n      .concat(\n        'ece2f0a6bddb1c9099',\n        'f6eff7bdc9e167a9cf02818a',\n        'f6eff7bdc9e167a9cf1c9099016c59',\n        'f6eff7d0d1e6a6bddb67a9cf1c9099016c59',\n        'f6eff7d0d1e6a6bddb67a9cf3690c002818a016450',\n        'fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450',\n        'fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636'\n      )\n      .map(Tv),\n    hg = Ov(lg),\n    dg = new Array(3)\n      .concat(\n        'ece7f2a6bddb2b8cbe',\n        'f1eef6bdc9e174a9cf0570b0',\n        'f1eef6bdc9e174a9cf2b8cbe045a8d',\n        'f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d',\n        'f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b',\n        'fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b',\n        'fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858'\n      )\n      .map(Tv),\n    pg = Ov(dg),\n    vg = new Array(3)\n      .concat(\n        'e7e1efc994c7dd1c77',\n        'f1eef6d7b5d8df65b0ce1256',\n        'f1eef6d7b5d8df65b0dd1c77980043',\n        'f1eef6d4b9dac994c7df65b0dd1c77980043',\n        'f1eef6d4b9dac994c7df65b0e7298ace125691003f',\n        'f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f',\n        'f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f'\n      )\n      .map(Tv),\n    gg = Ov(vg),\n    yg = new Array(3)\n      .concat(\n        'fde0ddfa9fb5c51b8a',\n        'feebe2fbb4b9f768a1ae017e',\n        'feebe2fbb4b9f768a1c51b8a7a0177',\n        'feebe2fcc5c0fa9fb5f768a1c51b8a7a0177',\n        'feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177',\n        'fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177',\n        'fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a'\n      )\n      .map(Tv),\n    _g = Ov(yg),\n    bg = new Array(3)\n      .concat(\n        'edf8b17fcdbb2c7fb8',\n        'ffffcca1dab441b6c4225ea8',\n        'ffffcca1dab441b6c42c7fb8253494',\n        'ffffccc7e9b47fcdbb41b6c42c7fb8253494',\n        'ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84',\n        'ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84',\n        'ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58'\n      )\n      .map(Tv),\n    mg = Ov(bg),\n    xg = new Array(3)\n      .concat(\n        'f7fcb9addd8e31a354',\n        'ffffccc2e69978c679238443',\n        'ffffccc2e69978c67931a354006837',\n        'ffffccd9f0a3addd8e78c67931a354006837',\n        'ffffccd9f0a3addd8e78c67941ab5d238443005a32',\n        'ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32',\n        'ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529'\n      )\n      .map(Tv),\n    wg = Ov(xg),\n    Mg = new Array(3)\n      .concat(\n        'fff7bcfec44fd95f0e',\n        'ffffd4fed98efe9929cc4c02',\n        'ffffd4fed98efe9929d95f0e993404',\n        'ffffd4fee391fec44ffe9929d95f0e993404',\n        'ffffd4fee391fec44ffe9929ec7014cc4c028c2d04',\n        'ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04',\n        'ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506'\n      )\n      .map(Tv),\n    Ng = Ov(Mg),\n    Ag = new Array(3)\n      .concat(\n        'ffeda0feb24cf03b20',\n        'ffffb2fecc5cfd8d3ce31a1c',\n        'ffffb2fecc5cfd8d3cf03b20bd0026',\n        'ffffb2fed976feb24cfd8d3cf03b20bd0026',\n        'ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026',\n        'ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026',\n        'ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026'\n      )\n      .map(Tv),\n    Sg = Ov(Ag),\n    kg = new Array(3)\n      .concat(\n        'deebf79ecae13182bd',\n        'eff3ffbdd7e76baed62171b5',\n        'eff3ffbdd7e76baed63182bd08519c',\n        'eff3ffc6dbef9ecae16baed63182bd08519c',\n        'eff3ffc6dbef9ecae16baed64292c62171b5084594',\n        'f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594',\n        'f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b'\n      )\n      .map(Tv),\n    Tg = Ov(kg),\n    Eg = new Array(3)\n      .concat(\n        'e5f5e0a1d99b31a354',\n        'edf8e9bae4b374c476238b45',\n        'edf8e9bae4b374c47631a354006d2c',\n        'edf8e9c7e9c0a1d99b74c47631a354006d2c',\n        'edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32',\n        'f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32',\n        'f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b'\n      )\n      .map(Tv),\n    Cg = Ov(Eg),\n    Pg = new Array(3)\n      .concat(\n        'f0f0f0bdbdbd636363',\n        'f7f7f7cccccc969696525252',\n        'f7f7f7cccccc969696636363252525',\n        'f7f7f7d9d9d9bdbdbd969696636363252525',\n        'f7f7f7d9d9d9bdbdbd969696737373525252252525',\n        'fffffff0f0f0d9d9d9bdbdbd969696737373525252252525',\n        'fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000'\n      )\n      .map(Tv),\n    zg = Ov(Pg),\n    Rg = new Array(3)\n      .concat(\n        'efedf5bcbddc756bb1',\n        'f2f0f7cbc9e29e9ac86a51a3',\n        'f2f0f7cbc9e29e9ac8756bb154278f',\n        'f2f0f7dadaebbcbddc9e9ac8756bb154278f',\n        'f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486',\n        'fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486',\n        'fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d'\n      )\n      .map(Tv),\n    Dg = Ov(Rg),\n    qg = new Array(3)\n      .concat(\n        'fee0d2fc9272de2d26',\n        'fee5d9fcae91fb6a4acb181d',\n        'fee5d9fcae91fb6a4ade2d26a50f15',\n        'fee5d9fcbba1fc9272fb6a4ade2d26a50f15',\n        'fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d',\n        'fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d',\n        'fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d'\n      )\n      .map(Tv),\n    Lg = Ov(qg),\n    Ug = new Array(3)\n      .concat(\n        'fee6cefdae6be6550d',\n        'feeddefdbe85fd8d3cd94701',\n        'feeddefdbe85fd8d3ce6550da63603',\n        'feeddefdd0a2fdae6bfd8d3ce6550da63603',\n        'feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04',\n        'fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04',\n        'fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704'\n      )\n      .map(Tv),\n    Og = Ov(Ug),\n    Bg = je(Zn(300, 0.5, 0), Zn(-240, 0.5, 1)),\n    Yg = je(Zn(-100, 0.75, 0.35), Zn(80, 1.5, 0.8)),\n    Fg = je(Zn(260, 0.75, 0.35), Zn(80, 1.5, 0.8)),\n    Ig = Zn()\n  var jg = gn(),\n    Hg = Math.PI / 3,\n    Xg = (2 * Math.PI) / 3\n  function Gg (t) {\n    var n = t.length\n    return function (e) {\n      return t[Math.max(0, Math.min(n - 1, Math.floor(e * n)))]\n    }\n  }\n  var Vg = Gg(\n      Tv(\n        '44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725'\n      )\n    ),\n    $g = Gg(\n      Tv(\n        '00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf'\n      )\n    ),\n    Wg = Gg(\n      Tv(\n        '00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4'\n      )\n    ),\n    Zg = Gg(\n      Tv(\n        '0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921'\n      )\n    )\n  function Qg (t) {\n    return function () {\n      return t\n    }\n  }\n  var Jg = Math.abs,\n    Kg = Math.atan2,\n    ty = Math.cos,\n    ny = Math.max,\n    ey = Math.min,\n    ry = Math.sin,\n    iy = Math.sqrt,\n    oy = 1e-12,\n    ay = Math.PI,\n    uy = ay / 2,\n    cy = 2 * ay\n  function fy (t) {\n    return t >= 1 ? uy : t <= -1 ? -uy : Math.asin(t)\n  }\n  function sy (t) {\n    return t.innerRadius\n  }\n  function ly (t) {\n    return t.outerRadius\n  }\n  function hy (t) {\n    return t.startAngle\n  }\n  function dy (t) {\n    return t.endAngle\n  }\n  function py (t) {\n    return t && t.padAngle\n  }\n  function vy (t, n, e, r, i, o, a) {\n    var u = t - e,\n      c = n - r,\n      f = (a ? o : -o) / iy(u * u + c * c),\n      s = f * c,\n      l = -f * u,\n      h = t + s,\n      d = n + l,\n      p = e + s,\n      v = r + l,\n      g = (h + p) / 2,\n      y = (d + v) / 2,\n      _ = p - h,\n      b = v - d,\n      m = _ * _ + b * b,\n      x = i - o,\n      w = h * v - p * d,\n      M = (b < 0 ? -1 : 1) * iy(ny(0, x * x * m - w * w)),\n      N = (w * b - _ * M) / m,\n      A = (-w * _ - b * M) / m,\n      S = (w * b + _ * M) / m,\n      k = (-w * _ + b * M) / m,\n      T = N - g,\n      E = A - y,\n      C = S - g,\n      P = k - y\n    return (\n      T * T + E * E > C * C + P * P && ((N = S), (A = k)),\n      { cx: N, cy: A, x01: -s, y01: -l, x11: N * (i / x - 1), y11: A * (i / x - 1) }\n    )\n  }\n  function gy (t) {\n    this._context = t\n  }\n  function yy (t) {\n    return new gy(t)\n  }\n  function _y (t) {\n    return t[0]\n  }\n  function by (t) {\n    return t[1]\n  }\n  function my () {\n    var t = _y,\n      n = by,\n      e = Qg(!0),\n      r = null,\n      i = yy,\n      o = null\n    function a (a) {\n      var u,\n        c,\n        f,\n        s = a.length,\n        l = !1\n      for (null == r && (o = i((f = Hi()))), u = 0; u <= s; ++u)\n        !(u < s && e((c = a[u]), u, a)) === l && ((l = !l) ? o.lineStart() : o.lineEnd()),\n          l && o.point(+t(c, u, a), +n(c, u, a))\n      if (f) return (o = null), f + '' || null\n    }\n    return (\n      (a.x = function (n) {\n        return arguments.length ? ((t = 'function' == typeof n ? n : Qg(+n)), a) : t\n      }),\n      (a.y = function (t) {\n        return arguments.length ? ((n = 'function' == typeof t ? t : Qg(+t)), a) : n\n      }),\n      (a.defined = function (t) {\n        return arguments.length ? ((e = 'function' == typeof t ? t : Qg(!!t)), a) : e\n      }),\n      (a.curve = function (t) {\n        return arguments.length ? ((i = t), null != r && (o = i(r)), a) : i\n      }),\n      (a.context = function (t) {\n        return arguments.length ? (null == t ? (r = o = null) : (o = i((r = t))), a) : r\n      }),\n      a\n    )\n  }\n  function xy () {\n    var t = _y,\n      n = null,\n      e = Qg(0),\n      r = by,\n      i = Qg(!0),\n      o = null,\n      a = yy,\n      u = null\n    function c (c) {\n      var f,\n        s,\n        l,\n        h,\n        d,\n        p = c.length,\n        v = !1,\n        g = new Array(p),\n        y = new Array(p)\n      for (null == o && (u = a((d = Hi()))), f = 0; f <= p; ++f) {\n        if (!(f < p && i((h = c[f]), f, c)) === v)\n          if ((v = !v)) (s = f), u.areaStart(), u.lineStart()\n          else {\n            for (u.lineEnd(), u.lineStart(), l = f - 1; l >= s; --l) u.point(g[l], y[l])\n            u.lineEnd(), u.areaEnd()\n          }\n        v && ((g[f] = +t(h, f, c)), (y[f] = +e(h, f, c)), u.point(n ? +n(h, f, c) : g[f], r ? +r(h, f, c) : y[f]))\n      }\n      if (d) return (u = null), d + '' || null\n    }\n    function f () {\n      return my()\n        .defined(i)\n        .curve(a)\n        .context(o)\n    }\n    return (\n      (c.x = function (e) {\n        return arguments.length ? ((t = 'function' == typeof e ? e : Qg(+e)), (n = null), c) : t\n      }),\n      (c.x0 = function (n) {\n        return arguments.length ? ((t = 'function' == typeof n ? n : Qg(+n)), c) : t\n      }),\n      (c.x1 = function (t) {\n        return arguments.length ? ((n = null == t ? null : 'function' == typeof t ? t : Qg(+t)), c) : n\n      }),\n      (c.y = function (t) {\n        return arguments.length ? ((e = 'function' == typeof t ? t : Qg(+t)), (r = null), c) : e\n      }),\n      (c.y0 = function (t) {\n        return arguments.length ? ((e = 'function' == typeof t ? t : Qg(+t)), c) : e\n      }),\n      (c.y1 = function (t) {\n        return arguments.length ? ((r = null == t ? null : 'function' == typeof t ? t : Qg(+t)), c) : r\n      }),\n      (c.lineX0 = c.lineY0 = function () {\n        return f()\n          .x(t)\n          .y(e)\n      }),\n      (c.lineY1 = function () {\n        return f()\n          .x(t)\n          .y(r)\n      }),\n      (c.lineX1 = function () {\n        return f()\n          .x(n)\n          .y(e)\n      }),\n      (c.defined = function (t) {\n        return arguments.length ? ((i = 'function' == typeof t ? t : Qg(!!t)), c) : i\n      }),\n      (c.curve = function (t) {\n        return arguments.length ? ((a = t), null != o && (u = a(o)), c) : a\n      }),\n      (c.context = function (t) {\n        return arguments.length ? (null == t ? (o = u = null) : (u = a((o = t))), c) : o\n      }),\n      c\n    )\n  }\n  function wy (t, n) {\n    return n < t ? -1 : n > t ? 1 : n >= t ? 0 : NaN\n  }\n  function My (t) {\n    return t\n  }\n  gy.prototype = {\n    areaStart: function () {\n      this._line = 0\n    },\n    areaEnd: function () {\n      this._line = NaN\n    },\n    lineStart: function () {\n      this._point = 0\n    },\n    lineEnd: function () {\n      ;(this._line || (0 !== this._line && 1 === this._point)) && this._context.closePath(),\n        (this._line = 1 - this._line)\n    },\n    point: function (t, n) {\n      switch (((t = +t), (n = +n), this._point)) {\n        case 0:\n          ;(this._point = 1), this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n)\n          break\n        case 1:\n          this._point = 2\n        default:\n          this._context.lineTo(t, n)\n      }\n    }\n  }\n  var Ny = Sy(yy)\n  function Ay (t) {\n    this._curve = t\n  }\n  function Sy (t) {\n    function n (n) {\n      return new Ay(t(n))\n    }\n    return (n._curve = t), n\n  }\n  function ky (t) {\n    var n = t.curve\n    return (\n      (t.angle = t.x),\n      delete t.x,\n      (t.radius = t.y),\n      delete t.y,\n      (t.curve = function (t) {\n        return arguments.length ? n(Sy(t)) : n()._curve\n      }),\n      t\n    )\n  }\n  function Ty () {\n    return ky(my().curve(Ny))\n  }\n  function Ey () {\n    var t = xy().curve(Ny),\n      n = t.curve,\n      e = t.lineX0,\n      r = t.lineX1,\n      i = t.lineY0,\n      o = t.lineY1\n    return (\n      (t.angle = t.x),\n      delete t.x,\n      (t.startAngle = t.x0),\n      delete t.x0,\n      (t.endAngle = t.x1),\n      delete t.x1,\n      (t.radius = t.y),\n      delete t.y,\n      (t.innerRadius = t.y0),\n      delete t.y0,\n      (t.outerRadius = t.y1),\n      delete t.y1,\n      (t.lineStartAngle = function () {\n        return ky(e())\n      }),\n      delete t.lineX0,\n      (t.lineEndAngle = function () {\n        return ky(r())\n      }),\n      delete t.lineX1,\n      (t.lineInnerRadius = function () {\n        return ky(i())\n      }),\n      delete t.lineY0,\n      (t.lineOuterRadius = function () {\n        return ky(o())\n      }),\n      delete t.lineY1,\n      (t.curve = function (t) {\n        return arguments.length ? n(Sy(t)) : n()._curve\n      }),\n      t\n    )\n  }\n  function Cy (t, n) {\n    return [(n = +n) * Math.cos((t -= Math.PI / 2)), n * Math.sin(t)]\n  }\n  Ay.prototype = {\n    areaStart: function () {\n      this._curve.areaStart()\n    },\n    areaEnd: function () {\n      this._curve.areaEnd()\n    },\n    lineStart: function () {\n      this._curve.lineStart()\n    },\n    lineEnd: function () {\n      this._curve.lineEnd()\n    },\n    point: function (t, n) {\n      this._curve.point(n * Math.sin(t), n * -Math.cos(t))\n    }\n  }\n  var Py = Array.prototype.slice\n  function zy (t) {\n    return t.source\n  }\n  function Ry (t) {\n    return t.target\n  }\n  function Dy (t) {\n    var n = zy,\n      e = Ry,\n      r = _y,\n      i = by,\n      o = null\n    function a () {\n      var a,\n        u = Py.call(arguments),\n        c = n.apply(this, u),\n        f = e.apply(this, u)\n      if (\n        (o || (o = a = Hi()),\n        t(o, +r.apply(this, ((u[0] = c), u)), +i.apply(this, u), +r.apply(this, ((u[0] = f), u)), +i.apply(this, u)),\n        a)\n      )\n        return (o = null), a + '' || null\n    }\n    return (\n      (a.source = function (t) {\n        return arguments.length ? ((n = t), a) : n\n      }),\n      (a.target = function (t) {\n        return arguments.length ? ((e = t), a) : e\n      }),\n      (a.x = function (t) {\n        return arguments.length ? ((r = 'function' == typeof t ? t : Qg(+t)), a) : r\n      }),\n      (a.y = function (t) {\n        return arguments.length ? ((i = 'function' == typeof t ? t : Qg(+t)), a) : i\n      }),\n      (a.context = function (t) {\n        return arguments.length ? ((o = null == t ? null : t), a) : o\n      }),\n      a\n    )\n  }\n  function qy (t, n, e, r, i) {\n    t.moveTo(n, e), t.bezierCurveTo((n = (n + r) / 2), e, n, i, r, i)\n  }\n  function Ly (t, n, e, r, i) {\n    t.moveTo(n, e), t.bezierCurveTo(n, (e = (e + i) / 2), r, e, r, i)\n  }\n  function Uy (t, n, e, r, i) {\n    var o = Cy(n, e),\n      a = Cy(n, (e = (e + i) / 2)),\n      u = Cy(r, e),\n      c = Cy(r, i)\n    t.moveTo(o[0], o[1]), t.bezierCurveTo(a[0], a[1], u[0], u[1], c[0], c[1])\n  }\n  var Oy = {\n      draw: function (t, n) {\n        var e = Math.sqrt(n / ay)\n        t.moveTo(e, 0), t.arc(0, 0, e, 0, cy)\n      }\n    },\n    By = {\n      draw: function (t, n) {\n        var e = Math.sqrt(n / 5) / 2\n        t.moveTo(-3 * e, -e),\n          t.lineTo(-e, -e),\n          t.lineTo(-e, -3 * e),\n          t.lineTo(e, -3 * e),\n          t.lineTo(e, -e),\n          t.lineTo(3 * e, -e),\n          t.lineTo(3 * e, e),\n          t.lineTo(e, e),\n          t.lineTo(e, 3 * e),\n          t.lineTo(-e, 3 * e),\n          t.lineTo(-e, e),\n          t.lineTo(-3 * e, e),\n          t.closePath()\n      }\n    },\n    Yy = Math.sqrt(1 / 3),\n    Fy = 2 * Yy,\n    Iy = {\n      draw: function (t, n) {\n        var e = Math.sqrt(n / Fy),\n          r = e * Yy\n        t.moveTo(0, -e), t.lineTo(r, 0), t.lineTo(0, e), t.lineTo(-r, 0), t.closePath()\n      }\n    },\n    jy = Math.sin(ay / 10) / Math.sin((7 * ay) / 10),\n    Hy = Math.sin(cy / 10) * jy,\n    Xy = -Math.cos(cy / 10) * jy,\n    Gy = {\n      draw: function (t, n) {\n        var e = Math.sqrt(0.8908130915292852 * n),\n          r = Hy * e,\n          i = Xy * e\n        t.moveTo(0, -e), t.lineTo(r, i)\n        for (var o = 1; o < 5; ++o) {\n          var a = (cy * o) / 5,\n            u = Math.cos(a),\n            c = Math.sin(a)\n          t.lineTo(c * e, -u * e), t.lineTo(u * r - c * i, c * r + u * i)\n        }\n        t.closePath()\n      }\n    },\n    Vy = {\n      draw: function (t, n) {\n        var e = Math.sqrt(n),\n          r = -e / 2\n        t.rect(r, r, e, e)\n      }\n    },\n    $y = Math.sqrt(3),\n    Wy = {\n      draw: function (t, n) {\n        var e = -Math.sqrt(n / (3 * $y))\n        t.moveTo(0, 2 * e), t.lineTo(-$y * e, -e), t.lineTo($y * e, -e), t.closePath()\n      }\n    },\n    Zy = Math.sqrt(3) / 2,\n    Qy = 1 / Math.sqrt(12),\n    Jy = 3 * (Qy / 2 + 1),\n    Ky = {\n      draw: function (t, n) {\n        var e = Math.sqrt(n / Jy),\n          r = e / 2,\n          i = e * Qy,\n          o = r,\n          a = e * Qy + e,\n          u = -o,\n          c = a\n        t.moveTo(r, i),\n          t.lineTo(o, a),\n          t.lineTo(u, c),\n          t.lineTo(-0.5 * r - Zy * i, Zy * r + -0.5 * i),\n          t.lineTo(-0.5 * o - Zy * a, Zy * o + -0.5 * a),\n          t.lineTo(-0.5 * u - Zy * c, Zy * u + -0.5 * c),\n          t.lineTo(-0.5 * r + Zy * i, -0.5 * i - Zy * r),\n          t.lineTo(-0.5 * o + Zy * a, -0.5 * a - Zy * o),\n          t.lineTo(-0.5 * u + Zy * c, -0.5 * c - Zy * u),\n          t.closePath()\n      }\n    },\n    t_ = [Oy, By, Iy, Vy, Gy, Wy, Ky]\n  function n_ () {}\n  function e_ (t, n, e) {\n    t._context.bezierCurveTo(\n      (2 * t._x0 + t._x1) / 3,\n      (2 * t._y0 + t._y1) / 3,\n      (t._x0 + 2 * t._x1) / 3,\n      (t._y0 + 2 * t._y1) / 3,\n      (t._x0 + 4 * t._x1 + n) / 6,\n      (t._y0 + 4 * t._y1 + e) / 6\n    )\n  }\n  function r_ (t) {\n    this._context = t\n  }\n  function i_ (t) {\n    this._context = t\n  }\n  function o_ (t) {\n    this._context = t\n  }\n  function a_ (t, n) {\n    ;(this._basis = new r_(t)), (this._beta = n)\n  }\n  ;(r_.prototype = {\n    areaStart: function () {\n      this._line = 0\n    },\n    areaEnd: function () {\n      this._line = NaN\n    },\n    lineStart: function () {\n      ;(this._x0 = this._x1 = this._y0 = this._y1 = NaN), (this._point = 0)\n    },\n    lineEnd: function () {\n      switch (this._point) {\n        case 3:\n          e_(this, this._x1, this._y1)\n        case 2:\n          this._context.lineTo(this._x1, this._y1)\n      }\n      ;(this._line || (0 !== this._line && 1 === this._point)) && this._context.closePath(),\n        (this._line = 1 - this._line)\n    },\n    point: function (t, n) {\n      switch (((t = +t), (n = +n), this._point)) {\n        case 0:\n          ;(this._point = 1), this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n)\n          break\n        case 1:\n          this._point = 2\n          break\n        case 2:\n          ;(this._point = 3), this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6)\n        default:\n          e_(this, t, n)\n      }\n      ;(this._x0 = this._x1), (this._x1 = t), (this._y0 = this._y1), (this._y1 = n)\n    }\n  }),\n    (i_.prototype = {\n      areaStart: n_,\n      areaEnd: n_,\n      lineStart: function () {\n        ;(this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN),\n          (this._point = 0)\n      },\n      lineEnd: function () {\n        switch (this._point) {\n          case 1:\n            this._context.moveTo(this._x2, this._y2), this._context.closePath()\n            break\n          case 2:\n            this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3),\n              this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3),\n              this._context.closePath()\n            break\n          case 3:\n            this.point(this._x2, this._y2), this.point(this._x3, this._y3), this.point(this._x4, this._y4)\n        }\n      },\n      point: function (t, n) {\n        switch (((t = +t), (n = +n), this._point)) {\n          case 0:\n            ;(this._point = 1), (this._x2 = t), (this._y2 = n)\n            break\n          case 1:\n            ;(this._point = 2), (this._x3 = t), (this._y3 = n)\n            break\n          case 2:\n            ;(this._point = 3),\n              (this._x4 = t),\n              (this._y4 = n),\n              this._context.moveTo((this._x0 + 4 * this._x1 + t) / 6, (this._y0 + 4 * this._y1 + n) / 6)\n            break\n          default:\n            e_(this, t, n)\n        }\n        ;(this._x0 = this._x1), (this._x1 = t), (this._y0 = this._y1), (this._y1 = n)\n      }\n    }),\n    (o_.prototype = {\n      areaStart: function () {\n        this._line = 0\n      },\n      areaEnd: function () {\n        this._line = NaN\n      },\n      lineStart: function () {\n        ;(this._x0 = this._x1 = this._y0 = this._y1 = NaN), (this._point = 0)\n      },\n      lineEnd: function () {\n        ;(this._line || (0 !== this._line && 3 === this._point)) && this._context.closePath(),\n          (this._line = 1 - this._line)\n      },\n      point: function (t, n) {\n        switch (((t = +t), (n = +n), this._point)) {\n          case 0:\n            this._point = 1\n            break\n          case 1:\n            this._point = 2\n            break\n          case 2:\n            this._point = 3\n            var e = (this._x0 + 4 * this._x1 + t) / 6,\n              r = (this._y0 + 4 * this._y1 + n) / 6\n            this._line ? this._context.lineTo(e, r) : this._context.moveTo(e, r)\n            break\n          case 3:\n            this._point = 4\n          default:\n            e_(this, t, n)\n        }\n        ;(this._x0 = this._x1), (this._x1 = t), (this._y0 = this._y1), (this._y1 = n)\n      }\n    }),\n    (a_.prototype = {\n      lineStart: function () {\n        ;(this._x = []), (this._y = []), this._basis.lineStart()\n      },\n      lineEnd: function () {\n        var t = this._x,\n          n = this._y,\n          e = t.length - 1\n        if (e > 0)\n          for (var r, i = t[0], o = n[0], a = t[e] - i, u = n[e] - o, c = -1; ++c <= e; )\n            (r = c / e),\n              this._basis.point(\n                this._beta * t[c] + (1 - this._beta) * (i + r * a),\n                this._beta * n[c] + (1 - this._beta) * (o + r * u)\n              )\n        ;(this._x = this._y = null), this._basis.lineEnd()\n      },\n      point: function (t, n) {\n        this._x.push(+t), this._y.push(+n)\n      }\n    })\n  var u_ = (function t (n) {\n    function e (t) {\n      return 1 === n ? new r_(t) : new a_(t, n)\n    }\n    return (\n      (e.beta = function (n) {\n        return t(+n)\n      }),\n      e\n    )\n  })(0.85)\n  function c_ (t, n, e) {\n    t._context.bezierCurveTo(\n      t._x1 + t._k * (t._x2 - t._x0),\n      t._y1 + t._k * (t._y2 - t._y0),\n      t._x2 + t._k * (t._x1 - n),\n      t._y2 + t._k * (t._y1 - e),\n      t._x2,\n      t._y2\n    )\n  }\n  function f_ (t, n) {\n    ;(this._context = t), (this._k = (1 - n) / 6)\n  }\n  f_.prototype = {\n    areaStart: function () {\n      this._line = 0\n    },\n    areaEnd: function () {\n      this._line = NaN\n    },\n    lineStart: function () {\n      ;(this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN), (this._point = 0)\n    },\n    lineEnd: function () {\n      switch (this._point) {\n        case 2:\n          this._context.lineTo(this._x2, this._y2)\n          break\n        case 3:\n          c_(this, this._x1, this._y1)\n      }\n      ;(this._line || (0 !== this._line && 1 === this._point)) && this._context.closePath(),\n        (this._line = 1 - this._line)\n    },\n    point: function (t, n) {\n      switch (((t = +t), (n = +n), this._point)) {\n        case 0:\n          ;(this._point = 1), this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n)\n          break\n        case 1:\n          ;(this._point = 2), (this._x1 = t), (this._y1 = n)\n          break\n        case 2:\n          this._point = 3\n        default:\n          c_(this, t, n)\n      }\n      ;(this._x0 = this._x1),\n        (this._x1 = this._x2),\n        (this._x2 = t),\n        (this._y0 = this._y1),\n        (this._y1 = this._y2),\n        (this._y2 = n)\n    }\n  }\n  var s_ = (function t (n) {\n    function e (t) {\n      return new f_(t, n)\n    }\n    return (\n      (e.tension = function (n) {\n        return t(+n)\n      }),\n      e\n    )\n  })(0)\n  function l_ (t, n) {\n    ;(this._context = t), (this._k = (1 - n) / 6)\n  }\n  l_.prototype = {\n    areaStart: n_,\n    areaEnd: n_,\n    lineStart: function () {\n      ;(this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN),\n        (this._point = 0)\n    },\n    lineEnd: function () {\n      switch (this._point) {\n        case 1:\n          this._context.moveTo(this._x3, this._y3), this._context.closePath()\n          break\n        case 2:\n          this._context.lineTo(this._x3, this._y3), this._context.closePath()\n          break\n        case 3:\n          this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5)\n      }\n    },\n    point: function (t, n) {\n      switch (((t = +t), (n = +n), this._point)) {\n        case 0:\n          ;(this._point = 1), (this._x3 = t), (this._y3 = n)\n          break\n        case 1:\n          ;(this._point = 2), this._context.moveTo((this._x4 = t), (this._y4 = n))\n          break\n        case 2:\n          ;(this._point = 3), (this._x5 = t), (this._y5 = n)\n          break\n        default:\n          c_(this, t, n)\n      }\n      ;(this._x0 = this._x1),\n        (this._x1 = this._x2),\n        (this._x2 = t),\n        (this._y0 = this._y1),\n        (this._y1 = this._y2),\n        (this._y2 = n)\n    }\n  }\n  var h_ = (function t (n) {\n    function e (t) {\n      return new l_(t, n)\n    }\n    return (\n      (e.tension = function (n) {\n        return t(+n)\n      }),\n      e\n    )\n  })(0)\n  function d_ (t, n) {\n    ;(this._context = t), (this._k = (1 - n) / 6)\n  }\n  d_.prototype = {\n    areaStart: function () {\n      this._line = 0\n    },\n    areaEnd: function () {\n      this._line = NaN\n    },\n    lineStart: function () {\n      ;(this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN), (this._point = 0)\n    },\n    lineEnd: function () {\n      ;(this._line || (0 !== this._line && 3 === this._point)) && this._context.closePath(),\n        (this._line = 1 - this._line)\n    },\n    point: function (t, n) {\n      switch (((t = +t), (n = +n), this._point)) {\n        case 0:\n          this._point = 1\n          break\n        case 1:\n          this._point = 2\n          break\n        case 2:\n          ;(this._point = 3),\n            this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2)\n          break\n        case 3:\n          this._point = 4\n        default:\n          c_(this, t, n)\n      }\n      ;(this._x0 = this._x1),\n        (this._x1 = this._x2),\n        (this._x2 = t),\n        (this._y0 = this._y1),\n        (this._y1 = this._y2),\n        (this._y2 = n)\n    }\n  }\n  var p_ = (function t (n) {\n    function e (t) {\n      return new d_(t, n)\n    }\n    return (\n      (e.tension = function (n) {\n        return t(+n)\n      }),\n      e\n    )\n  })(0)\n  function v_ (t, n, e) {\n    var r = t._x1,\n      i = t._y1,\n      o = t._x2,\n      a = t._y2\n    if (t._l01_a > oy) {\n      var u = 2 * t._l01_2a + 3 * t._l01_a * t._l12_a + t._l12_2a,\n        c = 3 * t._l01_a * (t._l01_a + t._l12_a)\n      ;(r = (r * u - t._x0 * t._l12_2a + t._x2 * t._l01_2a) / c),\n        (i = (i * u - t._y0 * t._l12_2a + t._y2 * t._l01_2a) / c)\n    }\n    if (t._l23_a > oy) {\n      var f = 2 * t._l23_2a + 3 * t._l23_a * t._l12_a + t._l12_2a,\n        s = 3 * t._l23_a * (t._l23_a + t._l12_a)\n      ;(o = (o * f + t._x1 * t._l23_2a - n * t._l12_2a) / s), (a = (a * f + t._y1 * t._l23_2a - e * t._l12_2a) / s)\n    }\n    t._context.bezierCurveTo(r, i, o, a, t._x2, t._y2)\n  }\n  function g_ (t, n) {\n    ;(this._context = t), (this._alpha = n)\n  }\n  g_.prototype = {\n    areaStart: function () {\n      this._line = 0\n    },\n    areaEnd: function () {\n      this._line = NaN\n    },\n    lineStart: function () {\n      ;(this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN),\n        (this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0)\n    },\n    lineEnd: function () {\n      switch (this._point) {\n        case 2:\n          this._context.lineTo(this._x2, this._y2)\n          break\n        case 3:\n          this.point(this._x2, this._y2)\n      }\n      ;(this._line || (0 !== this._line && 1 === this._point)) && this._context.closePath(),\n        (this._line = 1 - this._line)\n    },\n    point: function (t, n) {\n      if (((t = +t), (n = +n), this._point)) {\n        var e = this._x2 - t,\n          r = this._y2 - n\n        this._l23_a = Math.sqrt((this._l23_2a = Math.pow(e * e + r * r, this._alpha)))\n      }\n      switch (this._point) {\n        case 0:\n          ;(this._point = 1), this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n)\n          break\n        case 1:\n          this._point = 2\n          break\n        case 2:\n          this._point = 3\n        default:\n          v_(this, t, n)\n      }\n      ;(this._l01_a = this._l12_a),\n        (this._l12_a = this._l23_a),\n        (this._l01_2a = this._l12_2a),\n        (this._l12_2a = this._l23_2a),\n        (this._x0 = this._x1),\n        (this._x1 = this._x2),\n        (this._x2 = t),\n        (this._y0 = this._y1),\n        (this._y1 = this._y2),\n        (this._y2 = n)\n    }\n  }\n  var y_ = (function t (n) {\n    function e (t) {\n      return n ? new g_(t, n) : new f_(t, 0)\n    }\n    return (\n      (e.alpha = function (n) {\n        return t(+n)\n      }),\n      e\n    )\n  })(0.5)\n  function __ (t, n) {\n    ;(this._context = t), (this._alpha = n)\n  }\n  __.prototype = {\n    areaStart: n_,\n    areaEnd: n_,\n    lineStart: function () {\n      ;(this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN),\n        (this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0)\n    },\n    lineEnd: function () {\n      switch (this._point) {\n        case 1:\n          this._context.moveTo(this._x3, this._y3), this._context.closePath()\n          break\n        case 2:\n          this._context.lineTo(this._x3, this._y3), this._context.closePath()\n          break\n        case 3:\n          this.point(this._x3, this._y3), this.point(this._x4, this._y4), this.point(this._x5, this._y5)\n      }\n    },\n    point: function (t, n) {\n      if (((t = +t), (n = +n), this._point)) {\n        var e = this._x2 - t,\n          r = this._y2 - n\n        this._l23_a = Math.sqrt((this._l23_2a = Math.pow(e * e + r * r, this._alpha)))\n      }\n      switch (this._point) {\n        case 0:\n          ;(this._point = 1), (this._x3 = t), (this._y3 = n)\n          break\n        case 1:\n          ;(this._point = 2), this._context.moveTo((this._x4 = t), (this._y4 = n))\n          break\n        case 2:\n          ;(this._point = 3), (this._x5 = t), (this._y5 = n)\n          break\n        default:\n          v_(this, t, n)\n      }\n      ;(this._l01_a = this._l12_a),\n        (this._l12_a = this._l23_a),\n        (this._l01_2a = this._l12_2a),\n        (this._l12_2a = this._l23_2a),\n        (this._x0 = this._x1),\n        (this._x1 = this._x2),\n        (this._x2 = t),\n        (this._y0 = this._y1),\n        (this._y1 = this._y2),\n        (this._y2 = n)\n    }\n  }\n  var b_ = (function t (n) {\n    function e (t) {\n      return n ? new __(t, n) : new l_(t, 0)\n    }\n    return (\n      (e.alpha = function (n) {\n        return t(+n)\n      }),\n      e\n    )\n  })(0.5)\n  function m_ (t, n) {\n    ;(this._context = t), (this._alpha = n)\n  }\n  m_.prototype = {\n    areaStart: function () {\n      this._line = 0\n    },\n    areaEnd: function () {\n      this._line = NaN\n    },\n    lineStart: function () {\n      ;(this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN),\n        (this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0)\n    },\n    lineEnd: function () {\n      ;(this._line || (0 !== this._line && 3 === this._point)) && this._context.closePath(),\n        (this._line = 1 - this._line)\n    },\n    point: function (t, n) {\n      if (((t = +t), (n = +n), this._point)) {\n        var e = this._x2 - t,\n          r = this._y2 - n\n        this._l23_a = Math.sqrt((this._l23_2a = Math.pow(e * e + r * r, this._alpha)))\n      }\n      switch (this._point) {\n        case 0:\n          this._point = 1\n          break\n        case 1:\n          this._point = 2\n          break\n        case 2:\n          ;(this._point = 3),\n            this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2)\n          break\n        case 3:\n          this._point = 4\n        default:\n          v_(this, t, n)\n      }\n      ;(this._l01_a = this._l12_a),\n        (this._l12_a = this._l23_a),\n        (this._l01_2a = this._l12_2a),\n        (this._l12_2a = this._l23_2a),\n        (this._x0 = this._x1),\n        (this._x1 = this._x2),\n        (this._x2 = t),\n        (this._y0 = this._y1),\n        (this._y1 = this._y2),\n        (this._y2 = n)\n    }\n  }\n  var x_ = (function t (n) {\n    function e (t) {\n      return n ? new m_(t, n) : new d_(t, 0)\n    }\n    return (\n      (e.alpha = function (n) {\n        return t(+n)\n      }),\n      e\n    )\n  })(0.5)\n  function w_ (t) {\n    this._context = t\n  }\n  function M_ (t) {\n    return t < 0 ? -1 : 1\n  }\n  function N_ (t, n, e) {\n    var r = t._x1 - t._x0,\n      i = n - t._x1,\n      o = (t._y1 - t._y0) / (r || (i < 0 && -0)),\n      a = (e - t._y1) / (i || (r < 0 && -0)),\n      u = (o * i + a * r) / (r + i)\n    return (M_(o) + M_(a)) * Math.min(Math.abs(o), Math.abs(a), 0.5 * Math.abs(u)) || 0\n  }\n  function A_ (t, n) {\n    var e = t._x1 - t._x0\n    return e ? ((3 * (t._y1 - t._y0)) / e - n) / 2 : n\n  }\n  function S_ (t, n, e) {\n    var r = t._x0,\n      i = t._y0,\n      o = t._x1,\n      a = t._y1,\n      u = (o - r) / 3\n    t._context.bezierCurveTo(r + u, i + u * n, o - u, a - u * e, o, a)\n  }\n  function k_ (t) {\n    this._context = t\n  }\n  function T_ (t) {\n    this._context = new E_(t)\n  }\n  function E_ (t) {\n    this._context = t\n  }\n  function C_ (t) {\n    this._context = t\n  }\n  function P_ (t) {\n    var n,\n      e,\n      r = t.length - 1,\n      i = new Array(r),\n      o = new Array(r),\n      a = new Array(r)\n    for (i[0] = 0, o[0] = 2, a[0] = t[0] + 2 * t[1], n = 1; n < r - 1; ++n)\n      (i[n] = 1), (o[n] = 4), (a[n] = 4 * t[n] + 2 * t[n + 1])\n    for (i[r - 1] = 2, o[r - 1] = 7, a[r - 1] = 8 * t[r - 1] + t[r], n = 1; n < r; ++n)\n      (e = i[n] / o[n - 1]), (o[n] -= e), (a[n] -= e * a[n - 1])\n    for (i[r - 1] = a[r - 1] / o[r - 1], n = r - 2; n >= 0; --n) i[n] = (a[n] - i[n + 1]) / o[n]\n    for (o[r - 1] = (t[r] + i[r - 1]) / 2, n = 0; n < r - 1; ++n) o[n] = 2 * t[n + 1] - i[n + 1]\n    return [i, o]\n  }\n  function z_ (t, n) {\n    ;(this._context = t), (this._t = n)\n  }\n  function R_ (t, n) {\n    if ((i = t.length) > 1)\n      for (var e, r, i, o = 1, a = t[n[0]], u = a.length; o < i; ++o)\n        for (r = a, a = t[n[o]], e = 0; e < u; ++e) a[e][1] += a[e][0] = isNaN(r[e][1]) ? r[e][0] : r[e][1]\n  }\n  function D_ (t) {\n    for (var n = t.length, e = new Array(n); --n >= 0; ) e[n] = n\n    return e\n  }\n  function q_ (t, n) {\n    return t[n]\n  }\n  function L_ (t) {\n    var n = t.map(U_)\n    return D_(t).sort(function (t, e) {\n      return n[t] - n[e]\n    })\n  }\n  function U_ (t) {\n    for (var n, e = -1, r = 0, i = t.length, o = -1 / 0; ++e < i; ) (n = +t[e][1]) > o && ((o = n), (r = e))\n    return r\n  }\n  function O_ (t) {\n    var n = t.map(B_)\n    return D_(t).sort(function (t, e) {\n      return n[t] - n[e]\n    })\n  }\n  function B_ (t) {\n    for (var n, e = 0, r = -1, i = t.length; ++r < i; ) (n = +t[r][1]) && (e += n)\n    return e\n  }\n  function Y_ (t) {\n    return function () {\n      return t\n    }\n  }\n  function F_ (t) {\n    return t[0]\n  }\n  function I_ (t) {\n    return t[1]\n  }\n  function j_ () {\n    this._ = null\n  }\n  function H_ (t) {\n    t.U = t.C = t.L = t.R = t.P = t.N = null\n  }\n  function X_ (t, n) {\n    var e = n,\n      r = n.R,\n      i = e.U\n    i ? (i.L === e ? (i.L = r) : (i.R = r)) : (t._ = r),\n      (r.U = i),\n      (e.U = r),\n      (e.R = r.L),\n      e.R && (e.R.U = e),\n      (r.L = e)\n  }\n  function G_ (t, n) {\n    var e = n,\n      r = n.L,\n      i = e.U\n    i ? (i.L === e ? (i.L = r) : (i.R = r)) : (t._ = r),\n      (r.U = i),\n      (e.U = r),\n      (e.L = r.R),\n      e.L && (e.L.U = e),\n      (r.R = e)\n  }\n  function V_ (t) {\n    for (; t.L; ) t = t.L\n    return t\n  }\n  function $_ (t, n, e, r) {\n    var i = [null, null],\n      o = _b.push(i) - 1\n    return (\n      (i.left = t),\n      (i.right = n),\n      e && Z_(i, t, n, e),\n      r && Z_(i, n, t, r),\n      gb[t.index].halfedges.push(o),\n      gb[n.index].halfedges.push(o),\n      i\n    )\n  }\n  function W_ (t, n, e) {\n    var r = [n, e]\n    return (r.left = t), r\n  }\n  function Z_ (t, n, e, r) {\n    t[0] || t[1] ? (t.left === e ? (t[1] = r) : (t[0] = r)) : ((t[0] = r), (t.left = n), (t.right = e))\n  }\n  function Q_ (t, n, e, r, i) {\n    var o,\n      a = t[0],\n      u = t[1],\n      c = a[0],\n      f = a[1],\n      s = 0,\n      l = 1,\n      h = u[0] - c,\n      d = u[1] - f\n    if (((o = n - c), h || !(o > 0))) {\n      if (((o /= h), h < 0)) {\n        if (o < s) return\n        o < l && (l = o)\n      } else if (h > 0) {\n        if (o > l) return\n        o > s && (s = o)\n      }\n      if (((o = r - c), h || !(o < 0))) {\n        if (((o /= h), h < 0)) {\n          if (o > l) return\n          o > s && (s = o)\n        } else if (h > 0) {\n          if (o < s) return\n          o < l && (l = o)\n        }\n        if (((o = e - f), d || !(o > 0))) {\n          if (((o /= d), d < 0)) {\n            if (o < s) return\n            o < l && (l = o)\n          } else if (d > 0) {\n            if (o > l) return\n            o > s && (s = o)\n          }\n          if (((o = i - f), d || !(o < 0))) {\n            if (((o /= d), d < 0)) {\n              if (o > l) return\n              o > s && (s = o)\n            } else if (d > 0) {\n              if (o < s) return\n              o < l && (l = o)\n            }\n            return (\n              !(s > 0 || l < 1) ||\n              (s > 0 && (t[0] = [c + s * h, f + s * d]), l < 1 && (t[1] = [c + l * h, f + l * d]), !0)\n            )\n          }\n        }\n      }\n    }\n  }\n  function J_ (t, n, e, r, i) {\n    var o = t[1]\n    if (o) return !0\n    var a,\n      u,\n      c = t[0],\n      f = t.left,\n      s = t.right,\n      l = f[0],\n      h = f[1],\n      d = s[0],\n      p = s[1],\n      v = (l + d) / 2,\n      g = (h + p) / 2\n    if (p === h) {\n      if (v < n || v >= r) return\n      if (l > d) {\n        if (c) {\n          if (c[1] >= i) return\n        } else c = [v, e]\n        o = [v, i]\n      } else {\n        if (c) {\n          if (c[1] < e) return\n        } else c = [v, i]\n        o = [v, e]\n      }\n    } else if (((u = g - (a = (l - d) / (p - h)) * v), a < -1 || a > 1))\n      if (l > d) {\n        if (c) {\n          if (c[1] >= i) return\n        } else c = [(e - u) / a, e]\n        o = [(i - u) / a, i]\n      } else {\n        if (c) {\n          if (c[1] < e) return\n        } else c = [(i - u) / a, i]\n        o = [(e - u) / a, e]\n      }\n    else if (h < p) {\n      if (c) {\n        if (c[0] >= r) return\n      } else c = [n, a * n + u]\n      o = [r, a * r + u]\n    } else {\n      if (c) {\n        if (c[0] < n) return\n      } else c = [r, a * r + u]\n      o = [n, a * n + u]\n    }\n    return (t[0] = c), (t[1] = o), !0\n  }\n  function K_ (t, n) {\n    var e = t.site,\n      r = n.left,\n      i = n.right\n    return (\n      e === i && ((i = r), (r = e)),\n      i\n        ? Math.atan2(i[1] - r[1], i[0] - r[0])\n        : (e === r ? ((r = n[1]), (i = n[0])) : ((r = n[0]), (i = n[1])), Math.atan2(r[0] - i[0], i[1] - r[1]))\n    )\n  }\n  function tb (t, n) {\n    return n[+(n.left !== t.site)]\n  }\n  function nb (t, n) {\n    return n[+(n.left === t.site)]\n  }\n  ;(w_.prototype = {\n    areaStart: n_,\n    areaEnd: n_,\n    lineStart: function () {\n      this._point = 0\n    },\n    lineEnd: function () {\n      this._point && this._context.closePath()\n    },\n    point: function (t, n) {\n      ;(t = +t), (n = +n), this._point ? this._context.lineTo(t, n) : ((this._point = 1), this._context.moveTo(t, n))\n    }\n  }),\n    (k_.prototype = {\n      areaStart: function () {\n        this._line = 0\n      },\n      areaEnd: function () {\n        this._line = NaN\n      },\n      lineStart: function () {\n        ;(this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN), (this._point = 0)\n      },\n      lineEnd: function () {\n        switch (this._point) {\n          case 2:\n            this._context.lineTo(this._x1, this._y1)\n            break\n          case 3:\n            S_(this, this._t0, A_(this, this._t0))\n        }\n        ;(this._line || (0 !== this._line && 1 === this._point)) && this._context.closePath(),\n          (this._line = 1 - this._line)\n      },\n      point: function (t, n) {\n        var e = NaN\n        if (((n = +n), (t = +t) !== this._x1 || n !== this._y1)) {\n          switch (this._point) {\n            case 0:\n              ;(this._point = 1), this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n)\n              break\n            case 1:\n              this._point = 2\n              break\n            case 2:\n              ;(this._point = 3), S_(this, A_(this, (e = N_(this, t, n))), e)\n              break\n            default:\n              S_(this, this._t0, (e = N_(this, t, n)))\n          }\n          ;(this._x0 = this._x1), (this._x1 = t), (this._y0 = this._y1), (this._y1 = n), (this._t0 = e)\n        }\n      }\n    }),\n    ((T_.prototype = Object.create(k_.prototype)).point = function (t, n) {\n      k_.prototype.point.call(this, n, t)\n    }),\n    (E_.prototype = {\n      moveTo: function (t, n) {\n        this._context.moveTo(n, t)\n      },\n      closePath: function () {\n        this._context.closePath()\n      },\n      lineTo: function (t, n) {\n        this._context.lineTo(n, t)\n      },\n      bezierCurveTo: function (t, n, e, r, i, o) {\n        this._context.bezierCurveTo(n, t, r, e, o, i)\n      }\n    }),\n    (C_.prototype = {\n      areaStart: function () {\n        this._line = 0\n      },\n      areaEnd: function () {\n        this._line = NaN\n      },\n      lineStart: function () {\n        ;(this._x = []), (this._y = [])\n      },\n      lineEnd: function () {\n        var t = this._x,\n          n = this._y,\n          e = t.length\n        if (e)\n          if ((this._line ? this._context.lineTo(t[0], n[0]) : this._context.moveTo(t[0], n[0]), 2 === e))\n            this._context.lineTo(t[1], n[1])\n          else\n            for (var r = P_(t), i = P_(n), o = 0, a = 1; a < e; ++o, ++a)\n              this._context.bezierCurveTo(r[0][o], i[0][o], r[1][o], i[1][o], t[a], n[a])\n        ;(this._line || (0 !== this._line && 1 === e)) && this._context.closePath(),\n          (this._line = 1 - this._line),\n          (this._x = this._y = null)\n      },\n      point: function (t, n) {\n        this._x.push(+t), this._y.push(+n)\n      }\n    }),\n    (z_.prototype = {\n      areaStart: function () {\n        this._line = 0\n      },\n      areaEnd: function () {\n        this._line = NaN\n      },\n      lineStart: function () {\n        ;(this._x = this._y = NaN), (this._point = 0)\n      },\n      lineEnd: function () {\n        0 < this._t && this._t < 1 && 2 === this._point && this._context.lineTo(this._x, this._y),\n          (this._line || (0 !== this._line && 1 === this._point)) && this._context.closePath(),\n          this._line >= 0 && ((this._t = 1 - this._t), (this._line = 1 - this._line))\n      },\n      point: function (t, n) {\n        switch (((t = +t), (n = +n), this._point)) {\n          case 0:\n            ;(this._point = 1), this._line ? this._context.lineTo(t, n) : this._context.moveTo(t, n)\n            break\n          case 1:\n            this._point = 2\n          default:\n            if (this._t <= 0) this._context.lineTo(this._x, n), this._context.lineTo(t, n)\n            else {\n              var e = this._x * (1 - this._t) + t * this._t\n              this._context.lineTo(e, this._y), this._context.lineTo(e, n)\n            }\n        }\n        ;(this._x = t), (this._y = n)\n      }\n    }),\n    (j_.prototype = {\n      constructor: j_,\n      insert: function (t, n) {\n        var e, r, i\n        if (t) {\n          if (((n.P = t), (n.N = t.N), t.N && (t.N.P = n), (t.N = n), t.R)) {\n            for (t = t.R; t.L; ) t = t.L\n            t.L = n\n          } else t.R = n\n          e = t\n        } else\n          this._\n            ? ((t = V_(this._)), (n.P = null), (n.N = t), (t.P = t.L = n), (e = t))\n            : ((n.P = n.N = null), (this._ = n), (e = null))\n        for (n.L = n.R = null, n.U = e, n.C = !0, t = n; e && e.C; )\n          e === (r = e.U).L\n            ? (i = r.R) && i.C\n              ? ((e.C = i.C = !1), (r.C = !0), (t = r))\n              : (t === e.R && (X_(this, e), (e = (t = e).U)), (e.C = !1), (r.C = !0), G_(this, r))\n            : (i = r.L) && i.C\n            ? ((e.C = i.C = !1), (r.C = !0), (t = r))\n            : (t === e.L && (G_(this, e), (e = (t = e).U)), (e.C = !1), (r.C = !0), X_(this, r)),\n            (e = t.U)\n        this._.C = !1\n      },\n      remove: function (t) {\n        t.N && (t.N.P = t.P), t.P && (t.P.N = t.N), (t.N = t.P = null)\n        var n,\n          e,\n          r,\n          i = t.U,\n          o = t.L,\n          a = t.R\n        if (\n          ((e = o ? (a ? V_(a) : o) : a),\n          i ? (i.L === t ? (i.L = e) : (i.R = e)) : (this._ = e),\n          o && a\n            ? ((r = e.C),\n              (e.C = t.C),\n              (e.L = o),\n              (o.U = e),\n              e !== a\n                ? ((i = e.U), (e.U = t.U), (t = e.R), (i.L = t), (e.R = a), (a.U = e))\n                : ((e.U = i), (i = e), (t = e.R)))\n            : ((r = t.C), (t = e)),\n          t && (t.U = i),\n          !r)\n        )\n          if (t && t.C) t.C = !1\n          else {\n            do {\n              if (t === this._) break\n              if (t === i.L) {\n                if (\n                  ((n = i.R).C && ((n.C = !1), (i.C = !0), X_(this, i), (n = i.R)), (n.L && n.L.C) || (n.R && n.R.C))\n                ) {\n                  ;(n.R && n.R.C) || ((n.L.C = !1), (n.C = !0), G_(this, n), (n = i.R)),\n                    (n.C = i.C),\n                    (i.C = n.R.C = !1),\n                    X_(this, i),\n                    (t = this._)\n                  break\n                }\n              } else if (\n                ((n = i.L).C && ((n.C = !1), (i.C = !0), G_(this, i), (n = i.L)), (n.L && n.L.C) || (n.R && n.R.C))\n              ) {\n                ;(n.L && n.L.C) || ((n.R.C = !1), (n.C = !0), X_(this, n), (n = i.L)),\n                  (n.C = i.C),\n                  (i.C = n.L.C = !1),\n                  G_(this, i),\n                  (t = this._)\n                break\n              }\n              ;(n.C = !0), (t = i), (i = i.U)\n            } while (!t.C)\n            t && (t.C = !1)\n          }\n      }\n    })\n  var eb,\n    rb = []\n  function ib () {\n    H_(this), (this.x = this.y = this.arc = this.site = this.cy = null)\n  }\n  function ob (t) {\n    var n = t.P,\n      e = t.N\n    if (n && e) {\n      var r = n.site,\n        i = t.site,\n        o = e.site\n      if (r !== o) {\n        var a = i[0],\n          u = i[1],\n          c = r[0] - a,\n          f = r[1] - u,\n          s = o[0] - a,\n          l = o[1] - u,\n          h = 2 * (c * l - f * s)\n        if (!(h >= -mb)) {\n          var d = c * c + f * f,\n            p = s * s + l * l,\n            v = (l * d - f * p) / h,\n            g = (c * p - s * d) / h,\n            y = rb.pop() || new ib()\n          ;(y.arc = t), (y.site = i), (y.x = v + a), (y.y = (y.cy = g + u) + Math.sqrt(v * v + g * g)), (t.circle = y)\n          for (var _ = null, b = yb._; b; )\n            if (y.y < b.y || (y.y === b.y && y.x <= b.x)) {\n              if (!b.L) {\n                _ = b.P\n                break\n              }\n              b = b.L\n            } else {\n              if (!b.R) {\n                _ = b\n                break\n              }\n              b = b.R\n            }\n          yb.insert(_, y), _ || (eb = y)\n        }\n      }\n    }\n  }\n  function ab (t) {\n    var n = t.circle\n    n && (n.P || (eb = n.N), yb.remove(n), rb.push(n), H_(n), (t.circle = null))\n  }\n  var ub = []\n  function cb () {\n    H_(this), (this.edge = this.site = this.circle = null)\n  }\n  function fb (t) {\n    var n = ub.pop() || new cb()\n    return (n.site = t), n\n  }\n  function sb (t) {\n    ab(t), vb.remove(t), ub.push(t), H_(t)\n  }\n  function lb (t) {\n    var n = t.circle,\n      e = n.x,\n      r = n.cy,\n      i = [e, r],\n      o = t.P,\n      a = t.N,\n      u = [t]\n    sb(t)\n    for (var c = o; c.circle && Math.abs(e - c.circle.x) < bb && Math.abs(r - c.circle.cy) < bb; )\n      (o = c.P), u.unshift(c), sb(c), (c = o)\n    u.unshift(c), ab(c)\n    for (var f = a; f.circle && Math.abs(e - f.circle.x) < bb && Math.abs(r - f.circle.cy) < bb; )\n      (a = f.N), u.push(f), sb(f), (f = a)\n    u.push(f), ab(f)\n    var s,\n      l = u.length\n    for (s = 1; s < l; ++s) (f = u[s]), (c = u[s - 1]), Z_(f.edge, c.site, f.site, i)\n    ;(c = u[0]), ((f = u[l - 1]).edge = $_(c.site, f.site, null, i)), ob(c), ob(f)\n  }\n  function hb (t) {\n    for (var n, e, r, i, o = t[0], a = t[1], u = vb._; u; )\n      if ((r = db(u, a) - o) > bb) u = u.L\n      else {\n        if (!((i = o - pb(u, a)) > bb)) {\n          r > -bb ? ((n = u.P), (e = u)) : i > -bb ? ((n = u), (e = u.N)) : (n = e = u)\n          break\n        }\n        if (!u.R) {\n          n = u\n          break\n        }\n        u = u.R\n      }\n    !(function (t) {\n      gb[t.index] = { site: t, halfedges: [] }\n    })(t)\n    var c = fb(t)\n    if ((vb.insert(n, c), n || e)) {\n      if (n === e)\n        return ab(n), (e = fb(n.site)), vb.insert(c, e), (c.edge = e.edge = $_(n.site, c.site)), ob(n), void ob(e)\n      if (e) {\n        ab(n), ab(e)\n        var f = n.site,\n          s = f[0],\n          l = f[1],\n          h = t[0] - s,\n          d = t[1] - l,\n          p = e.site,\n          v = p[0] - s,\n          g = p[1] - l,\n          y = 2 * (h * g - d * v),\n          _ = h * h + d * d,\n          b = v * v + g * g,\n          m = [(g * _ - d * b) / y + s, (h * b - v * _) / y + l]\n        Z_(e.edge, f, p, m), (c.edge = $_(f, t, null, m)), (e.edge = $_(t, p, null, m)), ob(n), ob(e)\n      } else c.edge = $_(n.site, c.site)\n    }\n  }\n  function db (t, n) {\n    var e = t.site,\n      r = e[0],\n      i = e[1],\n      o = i - n\n    if (!o) return r\n    var a = t.P\n    if (!a) return -1 / 0\n    var u = (e = a.site)[0],\n      c = e[1],\n      f = c - n\n    if (!f) return u\n    var s = u - r,\n      l = 1 / o - 1 / f,\n      h = s / f\n    return l ? (-h + Math.sqrt(h * h - 2 * l * ((s * s) / (-2 * f) - c + f / 2 + i - o / 2))) / l + r : (r + u) / 2\n  }\n  function pb (t, n) {\n    var e = t.N\n    if (e) return db(e, n)\n    var r = t.site\n    return r[1] === n ? r[0] : 1 / 0\n  }\n  var vb,\n    gb,\n    yb,\n    _b,\n    bb = 1e-6,\n    mb = 1e-12\n  function xb (t, n) {\n    return n[1] - t[1] || n[0] - t[0]\n  }\n  function wb (t, n) {\n    var e,\n      r,\n      i,\n      o = t.sort(xb).pop()\n    for (_b = [], gb = new Array(t.length), vb = new j_(), yb = new j_(); ; )\n      if (((i = eb), o && (!i || o[1] < i.y || (o[1] === i.y && o[0] < i.x))))\n        (o[0] === e && o[1] === r) || (hb(o), (e = o[0]), (r = o[1])), (o = t.pop())\n      else {\n        if (!i) break\n        lb(i.arc)\n      }\n    if (\n      ((function () {\n        for (var t, n, e, r, i = 0, o = gb.length; i < o; ++i)\n          if ((t = gb[i]) && (r = (n = t.halfedges).length)) {\n            var a = new Array(r),\n              u = new Array(r)\n            for (e = 0; e < r; ++e) (a[e] = e), (u[e] = K_(t, _b[n[e]]))\n            for (\n              a.sort(function (t, n) {\n                return u[n] - u[t]\n              }),\n                e = 0;\n              e < r;\n              ++e\n            )\n              u[e] = n[a[e]]\n            for (e = 0; e < r; ++e) n[e] = u[e]\n          }\n      })(),\n      n)\n    ) {\n      var a = +n[0][0],\n        u = +n[0][1],\n        c = +n[1][0],\n        f = +n[1][1]\n      !(function (t, n, e, r) {\n        for (var i, o = _b.length; o--; )\n          (J_((i = _b[o]), t, n, e, r) &&\n            Q_(i, t, n, e, r) &&\n            (Math.abs(i[0][0] - i[1][0]) > bb || Math.abs(i[0][1] - i[1][1]) > bb)) ||\n            delete _b[o]\n      })(a, u, c, f),\n        (function (t, n, e, r) {\n          var i,\n            o,\n            a,\n            u,\n            c,\n            f,\n            s,\n            l,\n            h,\n            d,\n            p,\n            v,\n            g = gb.length,\n            y = !0\n          for (i = 0; i < g; ++i)\n            if ((o = gb[i])) {\n              for (a = o.site, u = (c = o.halfedges).length; u--; ) _b[c[u]] || c.splice(u, 1)\n              for (u = 0, f = c.length; u < f; )\n                (p = (d = nb(o, _b[c[u]]))[0]),\n                  (v = d[1]),\n                  (l = (s = tb(o, _b[c[++u % f]]))[0]),\n                  (h = s[1]),\n                  (Math.abs(p - l) > bb || Math.abs(v - h) > bb) &&\n                    (c.splice(\n                      u,\n                      0,\n                      _b.push(\n                        W_(\n                          a,\n                          d,\n                          Math.abs(p - t) < bb && r - v > bb\n                            ? [t, Math.abs(l - t) < bb ? h : r]\n                            : Math.abs(v - r) < bb && e - p > bb\n                            ? [Math.abs(h - r) < bb ? l : e, r]\n                            : Math.abs(p - e) < bb && v - n > bb\n                            ? [e, Math.abs(l - e) < bb ? h : n]\n                            : Math.abs(v - n) < bb && p - t > bb\n                            ? [Math.abs(h - n) < bb ? l : t, n]\n                            : null\n                        )\n                      ) - 1\n                    ),\n                    ++f)\n              f && (y = !1)\n            }\n          if (y) {\n            var _,\n              b,\n              m,\n              x = 1 / 0\n            for (i = 0, y = null; i < g; ++i)\n              (o = gb[i]) && (m = (_ = (a = o.site)[0] - t) * _ + (b = a[1] - n) * b) < x && ((x = m), (y = o))\n            if (y) {\n              var w = [t, n],\n                M = [t, r],\n                N = [e, r],\n                A = [e, n]\n              y.halfedges.push(\n                _b.push(W_((a = y.site), w, M)) - 1,\n                _b.push(W_(a, M, N)) - 1,\n                _b.push(W_(a, N, A)) - 1,\n                _b.push(W_(a, A, w)) - 1\n              )\n            }\n          }\n          for (i = 0; i < g; ++i) (o = gb[i]) && (o.halfedges.length || delete gb[i])\n        })(a, u, c, f)\n    }\n    ;(this.edges = _b), (this.cells = gb), (vb = yb = _b = gb = null)\n  }\n  function Mb (t) {\n    return function () {\n      return t\n    }\n  }\n  function Nb (t, n, e) {\n    ;(this.target = t), (this.type = n), (this.transform = e)\n  }\n  function Ab (t, n, e) {\n    ;(this.k = t), (this.x = n), (this.y = e)\n  }\n  ;(wb.prototype = {\n    constructor: wb,\n    polygons: function () {\n      var t = this.edges\n      return this.cells.map(function (n) {\n        var e = n.halfedges.map(function (e) {\n          return tb(n, t[e])\n        })\n        return (e.data = n.site.data), e\n      })\n    },\n    triangles: function () {\n      var t = [],\n        n = this.edges\n      return (\n        this.cells.forEach(function (e, r) {\n          if ((o = (i = e.halfedges).length))\n            for (\n              var i, o, a, u, c, f, s = e.site, l = -1, h = n[i[o - 1]], d = h.left === s ? h.right : h.left;\n              ++l < o;\n\n            )\n              (a = d),\n                (d = (h = n[i[l]]).left === s ? h.right : h.left),\n                a &&\n                  d &&\n                  r < a.index &&\n                  r < d.index &&\n                  ((c = a), (f = d), ((u = s)[0] - f[0]) * (c[1] - u[1]) - (u[0] - c[0]) * (f[1] - u[1]) < 0) &&\n                  t.push([s.data, a.data, d.data])\n        }),\n        t\n      )\n    },\n    links: function () {\n      return this.edges\n        .filter(function (t) {\n          return t.right\n        })\n        .map(function (t) {\n          return { source: t.left.data, target: t.right.data }\n        })\n    },\n    find: function (t, n, e) {\n      for (var r, i, o = this, a = o._found || 0, u = o.cells.length; !(i = o.cells[a]); ) if (++a >= u) return null\n      var c = t - i.site[0],\n        f = n - i.site[1],\n        s = c * c + f * f\n      do {\n        ;(i = o.cells[(r = a)]),\n          (a = null),\n          i.halfedges.forEach(function (e) {\n            var r = o.edges[e],\n              u = r.left\n            if ((u !== i.site && u) || (u = r.right)) {\n              var c = t - u[0],\n                f = n - u[1],\n                l = c * c + f * f\n              l < s && ((s = l), (a = u.index))\n            }\n          })\n      } while (null !== a)\n      return (o._found = r), null == e || s <= e * e ? i.site : null\n    }\n  }),\n    (Ab.prototype = {\n      constructor: Ab,\n      scale: function (t) {\n        return 1 === t ? this : new Ab(this.k * t, this.x, this.y)\n      },\n      translate: function (t, n) {\n        return (0 === t) & (0 === n) ? this : new Ab(this.k, this.x + this.k * t, this.y + this.k * n)\n      },\n      apply: function (t) {\n        return [t[0] * this.k + this.x, t[1] * this.k + this.y]\n      },\n      applyX: function (t) {\n        return t * this.k + this.x\n      },\n      applyY: function (t) {\n        return t * this.k + this.y\n      },\n      invert: function (t) {\n        return [(t[0] - this.x) / this.k, (t[1] - this.y) / this.k]\n      },\n      invertX: function (t) {\n        return (t - this.x) / this.k\n      },\n      invertY: function (t) {\n        return (t - this.y) / this.k\n      },\n      rescaleX: function (t) {\n        return t.copy().domain(\n          t\n            .range()\n            .map(this.invertX, this)\n            .map(t.invert, t)\n        )\n      },\n      rescaleY: function (t) {\n        return t.copy().domain(\n          t\n            .range()\n            .map(this.invertY, this)\n            .map(t.invert, t)\n        )\n      },\n      toString: function () {\n        return 'translate(' + this.x + ',' + this.y + ') scale(' + this.k + ')'\n      }\n    })\n  var Sb = new Ab(1, 0, 0)\n  function kb (t) {\n    return t.__zoom || Sb\n  }\n  function Tb () {\n    t.event.stopImmediatePropagation()\n  }\n  function Eb () {\n    t.event.preventDefault(), t.event.stopImmediatePropagation()\n  }\n  function Cb () {\n    return !t.event.button\n  }\n  function Pb () {\n    var t,\n      n,\n      e = this\n    return (\n      e instanceof SVGElement\n        ? ((t = (e = e.ownerSVGElement || e).width.baseVal.value), (n = e.height.baseVal.value))\n        : ((t = e.clientWidth), (n = e.clientHeight)),\n      [[0, 0], [t, n]]\n    )\n  }\n  function zb () {\n    return this.__zoom || Sb\n  }\n  function Rb () {\n    return (-t.event.deltaY * (t.event.deltaMode ? 120 : 1)) / 500\n  }\n  function Db () {\n    return 'ontouchstart' in this\n  }\n  function qb (t, n, e) {\n    var r = t.invertX(n[0][0]) - e[0][0],\n      i = t.invertX(n[1][0]) - e[1][0],\n      o = t.invertY(n[0][1]) - e[0][1],\n      a = t.invertY(n[1][1]) - e[1][1]\n    return t.translate(\n      i > r ? (r + i) / 2 : Math.min(0, r) || Math.max(0, i),\n      a > o ? (o + a) / 2 : Math.min(0, o) || Math.max(0, a)\n    )\n  }\n  ;(kb.prototype = Ab.prototype),\n    (t.version = '5.9.0'),\n    (t.bisect = i),\n    (t.bisectRight = i),\n    (t.bisectLeft = o),\n    (t.ascending = n),\n    (t.bisector = e),\n    (t.cross = function (t, n, e) {\n      var r,\n        i,\n        o,\n        u,\n        c = t.length,\n        f = n.length,\n        s = new Array(c * f)\n      for (null == e && (e = a), r = o = 0; r < c; ++r) for (u = t[r], i = 0; i < f; ++i, ++o) s[o] = e(u, n[i])\n      return s\n    }),\n    (t.descending = function (t, n) {\n      return n < t ? -1 : n > t ? 1 : n >= t ? 0 : NaN\n    }),\n    (t.deviation = f),\n    (t.extent = s),\n    (t.histogram = function () {\n      var t = v,\n        n = s,\n        e = M\n      function r (r) {\n        var o,\n          a,\n          u = r.length,\n          c = new Array(u)\n        for (o = 0; o < u; ++o) c[o] = t(r[o], o, r)\n        var f = n(c),\n          s = f[0],\n          l = f[1],\n          h = e(c, s, l)\n        Array.isArray(h) || ((h = w(s, l, h)), (h = g(Math.ceil(s / h) * h, l, h)))\n        for (var d = h.length; h[0] <= s; ) h.shift(), --d\n        for (; h[d - 1] > l; ) h.pop(), --d\n        var p,\n          v = new Array(d + 1)\n        for (o = 0; o <= d; ++o) ((p = v[o] = []).x0 = o > 0 ? h[o - 1] : s), (p.x1 = o < d ? h[o] : l)\n        for (o = 0; o < u; ++o) s <= (a = c[o]) && a <= l && v[i(h, a, 0, d)].push(r[o])\n        return v\n      }\n      return (\n        (r.value = function (n) {\n          return arguments.length ? ((t = 'function' == typeof n ? n : p(n)), r) : t\n        }),\n        (r.domain = function (t) {\n          return arguments.length ? ((n = 'function' == typeof t ? t : p([t[0], t[1]])), r) : n\n        }),\n        (r.thresholds = function (t) {\n          return arguments.length ? ((e = 'function' == typeof t ? t : Array.isArray(t) ? p(h.call(t)) : p(t)), r) : e\n        }),\n        r\n      )\n    }),\n    (t.thresholdFreedmanDiaconis = function (t, e, r) {\n      return (\n        (t = d.call(t, u).sort(n)), Math.ceil((r - e) / (2 * (N(t, 0.75) - N(t, 0.25)) * Math.pow(t.length, -1 / 3)))\n      )\n    }),\n    (t.thresholdScott = function (t, n, e) {\n      return Math.ceil((e - n) / (3.5 * f(t) * Math.pow(t.length, -1 / 3)))\n    }),\n    (t.thresholdSturges = M),\n    (t.max = A),\n    (t.mean = function (t, n) {\n      var e,\n        r = t.length,\n        i = r,\n        o = -1,\n        a = 0\n      if (null == n) for (; ++o < r; ) isNaN((e = u(t[o]))) ? --i : (a += e)\n      else for (; ++o < r; ) isNaN((e = u(n(t[o], o, t)))) ? --i : (a += e)\n      if (i) return a / i\n    }),\n    (t.median = function (t, e) {\n      var r,\n        i = t.length,\n        o = -1,\n        a = []\n      if (null == e) for (; ++o < i; ) isNaN((r = u(t[o]))) || a.push(r)\n      else for (; ++o < i; ) isNaN((r = u(e(t[o], o, t)))) || a.push(r)\n      return N(a.sort(n), 0.5)\n    }),\n    (t.merge = S),\n    (t.min = k),\n    (t.pairs = function (t, n) {\n      null == n && (n = a)\n      for (var e = 0, r = t.length - 1, i = t[0], o = new Array(r < 0 ? 0 : r); e < r; ) o[e] = n(i, (i = t[++e]))\n      return o\n    }),\n    (t.permute = function (t, n) {\n      for (var e = n.length, r = new Array(e); e--; ) r[e] = t[n[e]]\n      return r\n    }),\n    (t.quantile = N),\n    (t.range = g),\n    (t.scan = function (t, e) {\n      if ((r = t.length)) {\n        var r,\n          i,\n          o = 0,\n          a = 0,\n          u = t[a]\n        for (null == e && (e = n); ++o < r; ) (e((i = t[o]), u) < 0 || 0 !== e(u, u)) && ((u = i), (a = o))\n        return 0 === e(u, u) ? a : void 0\n      }\n    }),\n    (t.shuffle = function (t, n, e) {\n      for (var r, i, o = (null == e ? t.length : e) - (n = null == n ? 0 : +n); o; )\n        (i = (Math.random() * o--) | 0), (r = t[o + n]), (t[o + n] = t[i + n]), (t[i + n] = r)\n      return t\n    }),\n    (t.sum = function (t, n) {\n      var e,\n        r = t.length,\n        i = -1,\n        o = 0\n      if (null == n) for (; ++i < r; ) (e = +t[i]) && (o += e)\n      else for (; ++i < r; ) (e = +n(t[i], i, t)) && (o += e)\n      return o\n    }),\n    (t.ticks = m),\n    (t.tickIncrement = x),\n    (t.tickStep = w),\n    (t.transpose = T),\n    (t.variance = c),\n    (t.zip = function () {\n      return T(arguments)\n    }),\n    (t.axisTop = function (t) {\n      return Y(z, t)\n    }),\n    (t.axisRight = function (t) {\n      return Y(R, t)\n    }),\n    (t.axisBottom = function (t) {\n      return Y(D, t)\n    }),\n    (t.axisLeft = function (t) {\n      return Y(q, t)\n    }),\n    (t.brush = function () {\n      return Pi(mi)\n    }),\n    (t.brushX = function () {\n      return Pi(_i)\n    }),\n    (t.brushY = function () {\n      return Pi(bi)\n    }),\n    (t.brushSelection = function (t) {\n      var n = t.__brush\n      return n ? n.dim.output(n.selection) : null\n    }),\n    (t.chord = function () {\n      var t = 0,\n        n = null,\n        e = null,\n        r = null\n      function i (i) {\n        var o,\n          a,\n          u,\n          c,\n          f,\n          s,\n          l = i.length,\n          h = [],\n          d = g(l),\n          p = [],\n          v = [],\n          y = (v.groups = new Array(l)),\n          _ = new Array(l * l)\n        for (o = 0, f = -1; ++f < l; ) {\n          for (a = 0, s = -1; ++s < l; ) a += i[f][s]\n          h.push(a), p.push(g(l)), (o += a)\n        }\n        for (\n          n &&\n            d.sort(function (t, e) {\n              return n(h[t], h[e])\n            }),\n            e &&\n              p.forEach(function (t, n) {\n                t.sort(function (t, r) {\n                  return e(i[n][t], i[n][r])\n                })\n              }),\n            c = (o = Ui(0, Li - t * l) / o) ? t : Li / l,\n            a = 0,\n            f = -1;\n          ++f < l;\n\n        ) {\n          for (u = a, s = -1; ++s < l; ) {\n            var b = d[f],\n              m = p[b][s],\n              x = i[b][m],\n              w = a,\n              M = (a += x * o)\n            _[m * l + b] = { index: b, subindex: m, startAngle: w, endAngle: M, value: x }\n          }\n          ;(y[b] = { index: b, startAngle: u, endAngle: a, value: h[b] }), (a += c)\n        }\n        for (f = -1; ++f < l; )\n          for (s = f - 1; ++s < l; ) {\n            var N = _[s * l + f],\n              A = _[f * l + s]\n            ;(N.value || A.value) && v.push(N.value < A.value ? { source: A, target: N } : { source: N, target: A })\n          }\n        return r ? v.sort(r) : v\n      }\n      return (\n        (i.padAngle = function (n) {\n          return arguments.length ? ((t = Ui(0, n)), i) : t\n        }),\n        (i.sortGroups = function (t) {\n          return arguments.length ? ((n = t), i) : n\n        }),\n        (i.sortSubgroups = function (t) {\n          return arguments.length ? ((e = t), i) : e\n        }),\n        (i.sortChords = function (t) {\n          return arguments.length\n            ? (null == t\n                ? (r = null)\n                : (((n = t),\n                  (r = function (t, e) {\n                    return n(t.source.value + t.target.value, e.source.value + e.target.value)\n                  }))._ = t),\n              i)\n            : r && r._\n          var n\n        }),\n        i\n      )\n    }),\n    (t.ribbon = function () {\n      var t = Xi,\n        n = Gi,\n        e = Vi,\n        r = $i,\n        i = Wi,\n        o = null\n      function a () {\n        var a,\n          u = Oi.call(arguments),\n          c = t.apply(this, u),\n          f = n.apply(this, u),\n          s = +e.apply(this, ((u[0] = c), u)),\n          l = r.apply(this, u) - qi,\n          h = i.apply(this, u) - qi,\n          d = s * zi(l),\n          p = s * Ri(l),\n          v = +e.apply(this, ((u[0] = f), u)),\n          g = r.apply(this, u) - qi,\n          y = i.apply(this, u) - qi\n        if (\n          (o || (o = a = Hi()),\n          o.moveTo(d, p),\n          o.arc(0, 0, s, l, h),\n          (l === g && h === y) || (o.quadraticCurveTo(0, 0, v * zi(g), v * Ri(g)), o.arc(0, 0, v, g, y)),\n          o.quadraticCurveTo(0, 0, d, p),\n          o.closePath(),\n          a)\n        )\n          return (o = null), a + '' || null\n      }\n      return (\n        (a.radius = function (t) {\n          return arguments.length ? ((e = 'function' == typeof t ? t : Bi(+t)), a) : e\n        }),\n        (a.startAngle = function (t) {\n          return arguments.length ? ((r = 'function' == typeof t ? t : Bi(+t)), a) : r\n        }),\n        (a.endAngle = function (t) {\n          return arguments.length ? ((i = 'function' == typeof t ? t : Bi(+t)), a) : i\n        }),\n        (a.source = function (n) {\n          return arguments.length ? ((t = n), a) : t\n        }),\n        (a.target = function (t) {\n          return arguments.length ? ((n = t), a) : n\n        }),\n        (a.context = function (t) {\n          return arguments.length ? ((o = null == t ? null : t), a) : o\n        }),\n        a\n      )\n    }),\n    (t.nest = function () {\n      var t,\n        n,\n        e,\n        r = [],\n        i = []\n      function o (e, i, a, u) {\n        if (i >= r.length) return null != t && e.sort(t), null != n ? n(e) : e\n        for (var c, f, s, l = -1, h = e.length, d = r[i++], p = Qi(), v = a(); ++l < h; )\n          (s = p.get((c = d((f = e[l])) + ''))) ? s.push(f) : p.set(c, [f])\n        return (\n          p.each(function (t, n) {\n            u(v, n, o(t, i, a, u))\n          }),\n          v\n        )\n      }\n      return (e = {\n        object: function (t) {\n          return o(t, 0, Ji, Ki)\n        },\n        map: function (t) {\n          return o(t, 0, to, no)\n        },\n        entries: function (t) {\n          return (function t (e, o) {\n            if (++o > r.length) return e\n            var a,\n              u = i[o - 1]\n            return (\n              null != n && o >= r.length\n                ? (a = e.entries())\n                : ((a = []),\n                  e.each(function (n, e) {\n                    a.push({ key: e, values: t(n, o) })\n                  })),\n              null != u\n                ? a.sort(function (t, n) {\n                    return u(t.key, n.key)\n                  })\n                : a\n            )\n          })(o(t, 0, to, no), 0)\n        },\n        key: function (t) {\n          return r.push(t), e\n        },\n        sortKeys: function (t) {\n          return (i[r.length - 1] = t), e\n        },\n        sortValues: function (n) {\n          return (t = n), e\n        },\n        rollup: function (t) {\n          return (n = t), e\n        }\n      })\n    }),\n    (t.set = io),\n    (t.map = Qi),\n    (t.keys = function (t) {\n      var n = []\n      for (var e in t) n.push(e)\n      return n\n    }),\n    (t.values = function (t) {\n      var n = []\n      for (var e in t) n.push(t[e])\n      return n\n    }),\n    (t.entries = function (t) {\n      var n = []\n      for (var e in t) n.push({ key: e, value: t[e] })\n      return n\n    }),\n    (t.color = hn),\n    (t.rgb = gn),\n    (t.hsl = mn),\n    (t.lab = Rn),\n    (t.hcl = Yn),\n    (t.lch = function (t, n, e, r) {\n      return 1 === arguments.length ? Bn(t) : new Fn(e, n, t, null == r ? 1 : r)\n    }),\n    (t.gray = function (t, n) {\n      return new Dn(t, 0, 0, null == n ? 1 : n)\n    }),\n    (t.cubehelix = Zn),\n    (t.contours = po),\n    (t.contourDensity = function () {\n      var t = yo,\n        n = _o,\n        e = bo,\n        r = 960,\n        i = 500,\n        o = 20,\n        a = 2,\n        u = 3 * o,\n        c = (r + 2 * u) >> a,\n        f = (i + 2 * u) >> a,\n        s = uo(20)\n      function l (r) {\n        var i = new Float32Array(c * f),\n          l = new Float32Array(c * f)\n        r.forEach(function (r, o, s) {\n          var l = (+t(r, o, s) + u) >> a,\n            h = (+n(r, o, s) + u) >> a,\n            d = +e(r, o, s)\n          l >= 0 && l < c && h >= 0 && h < f && (i[l + h * c] += d)\n        }),\n          vo({ width: c, height: f, data: i }, { width: c, height: f, data: l }, o >> a),\n          go({ width: c, height: f, data: l }, { width: c, height: f, data: i }, o >> a),\n          vo({ width: c, height: f, data: i }, { width: c, height: f, data: l }, o >> a),\n          go({ width: c, height: f, data: l }, { width: c, height: f, data: i }, o >> a),\n          vo({ width: c, height: f, data: i }, { width: c, height: f, data: l }, o >> a),\n          go({ width: c, height: f, data: l }, { width: c, height: f, data: i }, o >> a)\n        var d = s(i)\n        if (!Array.isArray(d)) {\n          var p = A(i)\n          ;(d = w(0, p, d)), (d = g(0, Math.floor(p / d) * d, d)).shift()\n        }\n        return po()\n          .thresholds(d)\n          .size([c, f])(i)\n          .map(h)\n      }\n      function h (t) {\n        return (t.value *= Math.pow(2, -2 * a)), t.coordinates.forEach(d), t\n      }\n      function d (t) {\n        t.forEach(p)\n      }\n      function p (t) {\n        t.forEach(v)\n      }\n      function v (t) {\n        ;(t[0] = t[0] * Math.pow(2, a) - u), (t[1] = t[1] * Math.pow(2, a) - u)\n      }\n      function y () {\n        return (c = (r + 2 * (u = 3 * o)) >> a), (f = (i + 2 * u) >> a), l\n      }\n      return (\n        (l.x = function (n) {\n          return arguments.length ? ((t = 'function' == typeof n ? n : uo(+n)), l) : t\n        }),\n        (l.y = function (t) {\n          return arguments.length ? ((n = 'function' == typeof t ? t : uo(+t)), l) : n\n        }),\n        (l.weight = function (t) {\n          return arguments.length ? ((e = 'function' == typeof t ? t : uo(+t)), l) : e\n        }),\n        (l.size = function (t) {\n          if (!arguments.length) return [r, i]\n          var n = Math.ceil(t[0]),\n            e = Math.ceil(t[1])\n          if (!(n >= 0 || n >= 0)) throw new Error('invalid size')\n          return (r = n), (i = e), y()\n        }),\n        (l.cellSize = function (t) {\n          if (!arguments.length) return 1 << a\n          if (!((t = +t) >= 1)) throw new Error('invalid cell size')\n          return (a = Math.floor(Math.log(t) / Math.LN2)), y()\n        }),\n        (l.thresholds = function (t) {\n          return arguments.length\n            ? ((s = 'function' == typeof t ? t : Array.isArray(t) ? uo(oo.call(t)) : uo(t)), l)\n            : s\n        }),\n        (l.bandwidth = function (t) {\n          if (!arguments.length) return Math.sqrt(o * (o + 1))\n          if (!((t = +t) >= 0)) throw new Error('invalid bandwidth')\n          return (o = Math.round((Math.sqrt(4 * t * t + 1) - 1) / 2)), y()\n        }),\n        l\n      )\n    }),\n    (t.dispatch = I),\n    (t.drag = function () {\n      var n,\n        e,\n        r,\n        i,\n        o = Gt,\n        a = Vt,\n        u = $t,\n        c = Wt,\n        f = {},\n        s = I('start', 'drag', 'end'),\n        l = 0,\n        h = 0\n      function d (t) {\n        t.on('mousedown.drag', p)\n          .filter(c)\n          .on('touchstart.drag', y)\n          .on('touchmove.drag', _)\n          .on('touchend.drag touchcancel.drag', b)\n          .style('touch-action', 'none')\n          .style('-webkit-tap-highlight-color', 'rgba(0,0,0,0)')\n      }\n      function p () {\n        if (!i && o.apply(this, arguments)) {\n          var u = m('mouse', a.apply(this, arguments), Ot, this, arguments)\n          u &&\n            (zt(t.event.view)\n              .on('mousemove.drag', v, !0)\n              .on('mouseup.drag', g, !0),\n            It(t.event.view),\n            Yt(),\n            (r = !1),\n            (n = t.event.clientX),\n            (e = t.event.clientY),\n            u('start'))\n        }\n      }\n      function v () {\n        if ((Ft(), !r)) {\n          var i = t.event.clientX - n,\n            o = t.event.clientY - e\n          r = i * i + o * o > h\n        }\n        f.mouse('drag')\n      }\n      function g () {\n        zt(t.event.view).on('mousemove.drag mouseup.drag', null), jt(t.event.view, r), Ft(), f.mouse('end')\n      }\n      function y () {\n        if (o.apply(this, arguments)) {\n          var n,\n            e,\n            r = t.event.changedTouches,\n            i = a.apply(this, arguments),\n            u = r.length\n          for (n = 0; n < u; ++n) (e = m(r[n].identifier, i, Bt, this, arguments)) && (Yt(), e('start'))\n        }\n      }\n      function _ () {\n        var n,\n          e,\n          r = t.event.changedTouches,\n          i = r.length\n        for (n = 0; n < i; ++n) (e = f[r[n].identifier]) && (Ft(), e('drag'))\n      }\n      function b () {\n        var n,\n          e,\n          r = t.event.changedTouches,\n          o = r.length\n        for (\n          i && clearTimeout(i),\n            i = setTimeout(function () {\n              i = null\n            }, 500),\n            n = 0;\n          n < o;\n          ++n\n        )\n          (e = f[r[n].identifier]) && (Yt(), e('end'))\n      }\n      function m (n, e, r, i, o) {\n        var a,\n          c,\n          h,\n          p = r(e, n),\n          v = s.copy()\n        if (\n          kt(new Xt(d, 'beforestart', a, n, l, p[0], p[1], 0, 0, v), function () {\n            return null != (t.event.subject = a = u.apply(i, o)) && ((c = a.x - p[0] || 0), (h = a.y - p[1] || 0), !0)\n          })\n        )\n          return function t (u) {\n            var s,\n              g = p\n            switch (u) {\n              case 'start':\n                ;(f[n] = t), (s = l++)\n                break\n              case 'end':\n                delete f[n], --l\n              case 'drag':\n                ;(p = r(e, n)), (s = l)\n            }\n            kt(new Xt(d, u, a, n, s, p[0] + c, p[1] + h, p[0] - g[0], p[1] - g[1], v), v.apply, v, [u, i, o])\n          }\n      }\n      return (\n        (d.filter = function (t) {\n          return arguments.length ? ((o = 'function' == typeof t ? t : Ht(!!t)), d) : o\n        }),\n        (d.container = function (t) {\n          return arguments.length ? ((a = 'function' == typeof t ? t : Ht(t)), d) : a\n        }),\n        (d.subject = function (t) {\n          return arguments.length ? ((u = 'function' == typeof t ? t : Ht(t)), d) : u\n        }),\n        (d.touchable = function (t) {\n          return arguments.length ? ((c = 'function' == typeof t ? t : Ht(!!t)), d) : c\n        }),\n        (d.on = function () {\n          var t = s.on.apply(s, arguments)\n          return t === s ? d : t\n        }),\n        (d.clickDistance = function (t) {\n          return arguments.length ? ((h = (t = +t) * t), d) : Math.sqrt(h)\n        }),\n        d\n      )\n    }),\n    (t.dragDisable = It),\n    (t.dragEnable = jt),\n    (t.dsvFormat = ko),\n    (t.csvParse = Eo),\n    (t.csvParseRows = Co),\n    (t.csvFormat = Po),\n    (t.csvFormatBody = zo),\n    (t.csvFormatRows = Ro),\n    (t.tsvParse = qo),\n    (t.tsvParseRows = Lo),\n    (t.tsvFormat = Uo),\n    (t.tsvFormatBody = Oo),\n    (t.tsvFormatRows = Bo),\n    (t.autoType = function (t) {\n      for (var n in t) {\n        var e,\n          r = t[n].trim()\n        if (r)\n          if ('true' === r) r = !0\n          else if ('false' === r) r = !1\n          else if ('NaN' === r) r = NaN\n          else if (isNaN((e = +r))) {\n            if (!/^([-+]\\d{2})?\\d{4}(-\\d{2}(-\\d{2})?)?(T\\d{2}:\\d{2}(:\\d{2}(\\.\\d{3})?)?(Z|[-+]\\d{2}:\\d{2})?)?$/.test(r))\n              continue\n            r = new Date(r)\n          } else r = e\n        else r = null\n        t[n] = r\n      }\n      return t\n    }),\n    (t.easeLinear = function (t) {\n      return +t\n    }),\n    (t.easeQuad = Rr),\n    (t.easeQuadIn = function (t) {\n      return t * t\n    }),\n    (t.easeQuadOut = function (t) {\n      return t * (2 - t)\n    }),\n    (t.easeQuadInOut = Rr),\n    (t.easeCubic = Dr),\n    (t.easeCubicIn = function (t) {\n      return t * t * t\n    }),\n    (t.easeCubicOut = function (t) {\n      return --t * t * t + 1\n    }),\n    (t.easeCubicInOut = Dr),\n    (t.easePoly = Ur),\n    (t.easePolyIn = qr),\n    (t.easePolyOut = Lr),\n    (t.easePolyInOut = Ur),\n    (t.easeSin = Yr),\n    (t.easeSinIn = function (t) {\n      return 1 - Math.cos(t * Br)\n    }),\n    (t.easeSinOut = function (t) {\n      return Math.sin(t * Br)\n    }),\n    (t.easeSinInOut = Yr),\n    (t.easeExp = Fr),\n    (t.easeExpIn = function (t) {\n      return Math.pow(2, 10 * t - 10)\n    }),\n    (t.easeExpOut = function (t) {\n      return 1 - Math.pow(2, -10 * t)\n    }),\n    (t.easeExpInOut = Fr),\n    (t.easeCircle = Ir),\n    (t.easeCircleIn = function (t) {\n      return 1 - Math.sqrt(1 - t * t)\n    }),\n    (t.easeCircleOut = function (t) {\n      return Math.sqrt(1 - --t * t)\n    }),\n    (t.easeCircleInOut = Ir),\n    (t.easeBounce = Kr),\n    (t.easeBounceIn = function (t) {\n      return 1 - Kr(1 - t)\n    }),\n    (t.easeBounceOut = Kr),\n    (t.easeBounceInOut = function (t) {\n      return ((t *= 2) <= 1 ? 1 - Kr(1 - t) : Kr(t - 1) + 1) / 2\n    }),\n    (t.easeBack = ei),\n    (t.easeBackIn = ti),\n    (t.easeBackOut = ni),\n    (t.easeBackInOut = ei),\n    (t.easeElastic = oi),\n    (t.easeElasticIn = ii),\n    (t.easeElasticOut = oi),\n    (t.easeElasticInOut = ai),\n    (t.blob = function (t, n) {\n      return fetch(t, n).then(Yo)\n    }),\n    (t.buffer = function (t, n) {\n      return fetch(t, n).then(Fo)\n    }),\n    (t.dsv = function (t, n, e, r) {\n      3 === arguments.length && 'function' == typeof e && ((r = e), (e = void 0))\n      var i = ko(t)\n      return jo(n, e).then(function (t) {\n        return i.parse(t, r)\n      })\n    }),\n    (t.csv = Xo),\n    (t.tsv = Go),\n    (t.image = function (t, n) {\n      return new Promise(function (e, r) {\n        var i = new Image()\n        for (var o in n) i[o] = n[o]\n        ;(i.onerror = r),\n          (i.onload = function () {\n            e(i)\n          }),\n          (i.src = t)\n      })\n    }),\n    (t.json = function (t, n) {\n      return fetch(t, n).then(Vo)\n    }),\n    (t.text = jo),\n    (t.xml = Wo),\n    (t.html = Zo),\n    (t.svg = Qo),\n    (t.forceCenter = function (t, n) {\n      var e\n      function r () {\n        var r,\n          i,\n          o = e.length,\n          a = 0,\n          u = 0\n        for (r = 0; r < o; ++r) (a += (i = e[r]).x), (u += i.y)\n        for (a = a / o - t, u = u / o - n, r = 0; r < o; ++r) ((i = e[r]).x -= a), (i.y -= u)\n      }\n      return (\n        null == t && (t = 0),\n        null == n && (n = 0),\n        (r.initialize = function (t) {\n          e = t\n        }),\n        (r.x = function (n) {\n          return arguments.length ? ((t = +n), r) : t\n        }),\n        (r.y = function (t) {\n          return arguments.length ? ((n = +t), r) : n\n        }),\n        r\n      )\n    }),\n    (t.forceCollide = function (t) {\n      var n,\n        e,\n        r = 1,\n        i = 1\n      function o () {\n        for (var t, o, u, c, f, s, l, h = n.length, d = 0; d < i; ++d)\n          for (o = ia(n, ca, fa).visitAfter(a), t = 0; t < h; ++t)\n            (u = n[t]), (s = e[u.index]), (l = s * s), (c = u.x + u.vx), (f = u.y + u.vy), o.visit(p)\n        function p (t, n, e, i, o) {\n          var a = t.data,\n            h = t.r,\n            d = s + h\n          if (!a) return n > c + d || i < c - d || e > f + d || o < f - d\n          if (a.index > u.index) {\n            var p = c - a.x - a.vx,\n              v = f - a.y - a.vy,\n              g = p * p + v * v\n            g < d * d &&\n              (0 === p && (g += (p = Ko()) * p),\n              0 === v && (g += (v = Ko()) * v),\n              (g = ((d - (g = Math.sqrt(g))) / g) * r),\n              (u.vx += (p *= g) * (d = (h *= h) / (l + h))),\n              (u.vy += (v *= g) * d),\n              (a.vx -= p * (d = 1 - d)),\n              (a.vy -= v * d))\n          }\n        }\n      }\n      function a (t) {\n        if (t.data) return (t.r = e[t.data.index])\n        for (var n = (t.r = 0); n < 4; ++n) t[n] && t[n].r > t.r && (t.r = t[n].r)\n      }\n      function u () {\n        if (n) {\n          var r,\n            i,\n            o = n.length\n          for (e = new Array(o), r = 0; r < o; ++r) (i = n[r]), (e[i.index] = +t(i, r, n))\n        }\n      }\n      return (\n        'function' != typeof t && (t = Jo(null == t ? 1 : +t)),\n        (o.initialize = function (t) {\n          ;(n = t), u()\n        }),\n        (o.iterations = function (t) {\n          return arguments.length ? ((i = +t), o) : i\n        }),\n        (o.strength = function (t) {\n          return arguments.length ? ((r = +t), o) : r\n        }),\n        (o.radius = function (n) {\n          return arguments.length ? ((t = 'function' == typeof n ? n : Jo(+n)), u(), o) : t\n        }),\n        o\n      )\n    }),\n    (t.forceLink = function (t) {\n      var n,\n        e,\n        r,\n        i,\n        o,\n        a = sa,\n        u = function (t) {\n          return 1 / Math.min(i[t.source.index], i[t.target.index])\n        },\n        c = Jo(30),\n        f = 1\n      function s (r) {\n        for (var i = 0, a = t.length; i < f; ++i)\n          for (var u, c, s, l, h, d, p, v = 0; v < a; ++v)\n            (c = (u = t[v]).source),\n              (l = (s = u.target).x + s.vx - c.x - c.vx || Ko()),\n              (h = s.y + s.vy - c.y - c.vy || Ko()),\n              (l *= d = (((d = Math.sqrt(l * l + h * h)) - e[v]) / d) * r * n[v]),\n              (h *= d),\n              (s.vx -= l * (p = o[v])),\n              (s.vy -= h * p),\n              (c.vx += l * (p = 1 - p)),\n              (c.vy += h * p)\n      }\n      function l () {\n        if (r) {\n          var u,\n            c,\n            f = r.length,\n            s = t.length,\n            l = Qi(r, a)\n          for (u = 0, i = new Array(f); u < s; ++u)\n            ((c = t[u]).index = u),\n              'object' != typeof c.source && (c.source = la(l, c.source)),\n              'object' != typeof c.target && (c.target = la(l, c.target)),\n              (i[c.source.index] = (i[c.source.index] || 0) + 1),\n              (i[c.target.index] = (i[c.target.index] || 0) + 1)\n          for (u = 0, o = new Array(s); u < s; ++u)\n            (c = t[u]), (o[u] = i[c.source.index] / (i[c.source.index] + i[c.target.index]))\n          ;(n = new Array(s)), h(), (e = new Array(s)), d()\n        }\n      }\n      function h () {\n        if (r) for (var e = 0, i = t.length; e < i; ++e) n[e] = +u(t[e], e, t)\n      }\n      function d () {\n        if (r) for (var n = 0, i = t.length; n < i; ++n) e[n] = +c(t[n], n, t)\n      }\n      return (\n        null == t && (t = []),\n        (s.initialize = function (t) {\n          ;(r = t), l()\n        }),\n        (s.links = function (n) {\n          return arguments.length ? ((t = n), l(), s) : t\n        }),\n        (s.id = function (t) {\n          return arguments.length ? ((a = t), s) : a\n        }),\n        (s.iterations = function (t) {\n          return arguments.length ? ((f = +t), s) : f\n        }),\n        (s.strength = function (t) {\n          return arguments.length ? ((u = 'function' == typeof t ? t : Jo(+t)), h(), s) : u\n        }),\n        (s.distance = function (t) {\n          return arguments.length ? ((c = 'function' == typeof t ? t : Jo(+t)), d(), s) : c\n        }),\n        s\n      )\n    }),\n    (t.forceManyBody = function () {\n      var t,\n        n,\n        e,\n        r,\n        i = Jo(-30),\n        o = 1,\n        a = 1 / 0,\n        u = 0.81\n      function c (r) {\n        var i,\n          o = t.length,\n          a = ia(t, ha, da).visitAfter(s)\n        for (e = r, i = 0; i < o; ++i) (n = t[i]), a.visit(l)\n      }\n      function f () {\n        if (t) {\n          var n,\n            e,\n            o = t.length\n          for (r = new Array(o), n = 0; n < o; ++n) (e = t[n]), (r[e.index] = +i(e, n, t))\n        }\n      }\n      function s (t) {\n        var n,\n          e,\n          i,\n          o,\n          a,\n          u = 0,\n          c = 0\n        if (t.length) {\n          for (i = o = a = 0; a < 4; ++a)\n            (n = t[a]) && (e = Math.abs(n.value)) && ((u += n.value), (c += e), (i += e * n.x), (o += e * n.y))\n          ;(t.x = i / c), (t.y = o / c)\n        } else {\n          ;((n = t).x = n.data.x), (n.y = n.data.y)\n          do {\n            u += r[n.data.index]\n          } while ((n = n.next))\n        }\n        t.value = u\n      }\n      function l (t, i, c, f) {\n        if (!t.value) return !0\n        var s = t.x - n.x,\n          l = t.y - n.y,\n          h = f - i,\n          d = s * s + l * l\n        if ((h * h) / u < d)\n          return (\n            d < a &&\n              (0 === s && (d += (s = Ko()) * s),\n              0 === l && (d += (l = Ko()) * l),\n              d < o && (d = Math.sqrt(o * d)),\n              (n.vx += (s * t.value * e) / d),\n              (n.vy += (l * t.value * e) / d)),\n            !0\n          )\n        if (!(t.length || d >= a)) {\n          ;(t.data !== n || t.next) &&\n            (0 === s && (d += (s = Ko()) * s), 0 === l && (d += (l = Ko()) * l), d < o && (d = Math.sqrt(o * d)))\n          do {\n            t.data !== n && ((h = (r[t.data.index] * e) / d), (n.vx += s * h), (n.vy += l * h))\n          } while ((t = t.next))\n        }\n      }\n      return (\n        (c.initialize = function (n) {\n          ;(t = n), f()\n        }),\n        (c.strength = function (t) {\n          return arguments.length ? ((i = 'function' == typeof t ? t : Jo(+t)), f(), c) : i\n        }),\n        (c.distanceMin = function (t) {\n          return arguments.length ? ((o = t * t), c) : Math.sqrt(o)\n        }),\n        (c.distanceMax = function (t) {\n          return arguments.length ? ((a = t * t), c) : Math.sqrt(a)\n        }),\n        (c.theta = function (t) {\n          return arguments.length ? ((u = t * t), c) : Math.sqrt(u)\n        }),\n        c\n      )\n    }),\n    (t.forceRadial = function (t, n, e) {\n      var r,\n        i,\n        o,\n        a = Jo(0.1)\n      function u (t) {\n        for (var a = 0, u = r.length; a < u; ++a) {\n          var c = r[a],\n            f = c.x - n || 1e-6,\n            s = c.y - e || 1e-6,\n            l = Math.sqrt(f * f + s * s),\n            h = ((o[a] - l) * i[a] * t) / l\n          ;(c.vx += f * h), (c.vy += s * h)\n        }\n      }\n      function c () {\n        if (r) {\n          var n,\n            e = r.length\n          for (i = new Array(e), o = new Array(e), n = 0; n < e; ++n)\n            (o[n] = +t(r[n], n, r)), (i[n] = isNaN(o[n]) ? 0 : +a(r[n], n, r))\n        }\n      }\n      return (\n        'function' != typeof t && (t = Jo(+t)),\n        null == n && (n = 0),\n        null == e && (e = 0),\n        (u.initialize = function (t) {\n          ;(r = t), c()\n        }),\n        (u.strength = function (t) {\n          return arguments.length ? ((a = 'function' == typeof t ? t : Jo(+t)), c(), u) : a\n        }),\n        (u.radius = function (n) {\n          return arguments.length ? ((t = 'function' == typeof n ? n : Jo(+n)), c(), u) : t\n        }),\n        (u.x = function (t) {\n          return arguments.length ? ((n = +t), u) : n\n        }),\n        (u.y = function (t) {\n          return arguments.length ? ((e = +t), u) : e\n        }),\n        u\n      )\n    }),\n    (t.forceSimulation = function (t) {\n      var n,\n        e = 1,\n        r = 0.001,\n        i = 1 - Math.pow(r, 1 / 300),\n        o = 0,\n        a = 0.6,\n        u = Qi(),\n        c = ir(s),\n        f = I('tick', 'end')\n      function s () {\n        l(), f.call('tick', n), e < r && (c.stop(), f.call('end', n))\n      }\n      function l (r) {\n        var c,\n          f,\n          s = t.length\n        void 0 === r && (r = 1)\n        for (var l = 0; l < r; ++l)\n          for (\n            e += (o - e) * i,\n              u.each(function (t) {\n                t(e)\n              }),\n              c = 0;\n            c < s;\n            ++c\n          )\n            null == (f = t[c]).fx ? (f.x += f.vx *= a) : ((f.x = f.fx), (f.vx = 0)),\n              null == f.fy ? (f.y += f.vy *= a) : ((f.y = f.fy), (f.vy = 0))\n        return n\n      }\n      function h () {\n        for (var n, e = 0, r = t.length; e < r; ++e) {\n          if (\n            (((n = t[e]).index = e), isNaN(n.fx) || (n.x = n.fx), isNaN(n.fy) || (n.y = n.fy), isNaN(n.x) || isNaN(n.y))\n          ) {\n            var i = pa * Math.sqrt(e),\n              o = e * va\n            ;(n.x = i * Math.cos(o)), (n.y = i * Math.sin(o))\n          }\n          ;(isNaN(n.vx) || isNaN(n.vy)) && (n.vx = n.vy = 0)\n        }\n      }\n      function d (n) {\n        return n.initialize && n.initialize(t), n\n      }\n      return (\n        null == t && (t = []),\n        h(),\n        (n = {\n          tick: l,\n          restart: function () {\n            return c.restart(s), n\n          },\n          stop: function () {\n            return c.stop(), n\n          },\n          nodes: function (e) {\n            return arguments.length ? ((t = e), h(), u.each(d), n) : t\n          },\n          alpha: function (t) {\n            return arguments.length ? ((e = +t), n) : e\n          },\n          alphaMin: function (t) {\n            return arguments.length ? ((r = +t), n) : r\n          },\n          alphaDecay: function (t) {\n            return arguments.length ? ((i = +t), n) : +i\n          },\n          alphaTarget: function (t) {\n            return arguments.length ? ((o = +t), n) : o\n          },\n          velocityDecay: function (t) {\n            return arguments.length ? ((a = 1 - t), n) : 1 - a\n          },\n          force: function (t, e) {\n            return arguments.length > 1 ? (null == e ? u.remove(t) : u.set(t, d(e)), n) : u.get(t)\n          },\n          find: function (n, e, r) {\n            var i,\n              o,\n              a,\n              u,\n              c,\n              f = 0,\n              s = t.length\n            for (null == r ? (r = 1 / 0) : (r *= r), f = 0; f < s; ++f)\n              (a = (i = n - (u = t[f]).x) * i + (o = e - u.y) * o) < r && ((c = u), (r = a))\n            return c\n          },\n          on: function (t, e) {\n            return arguments.length > 1 ? (f.on(t, e), n) : f.on(t)\n          }\n        })\n      )\n    }),\n    (t.forceX = function (t) {\n      var n,\n        e,\n        r,\n        i = Jo(0.1)\n      function o (t) {\n        for (var i, o = 0, a = n.length; o < a; ++o) (i = n[o]).vx += (r[o] - i.x) * e[o] * t\n      }\n      function a () {\n        if (n) {\n          var o,\n            a = n.length\n          for (e = new Array(a), r = new Array(a), o = 0; o < a; ++o)\n            e[o] = isNaN((r[o] = +t(n[o], o, n))) ? 0 : +i(n[o], o, n)\n        }\n      }\n      return (\n        'function' != typeof t && (t = Jo(null == t ? 0 : +t)),\n        (o.initialize = function (t) {\n          ;(n = t), a()\n        }),\n        (o.strength = function (t) {\n          return arguments.length ? ((i = 'function' == typeof t ? t : Jo(+t)), a(), o) : i\n        }),\n        (o.x = function (n) {\n          return arguments.length ? ((t = 'function' == typeof n ? n : Jo(+n)), a(), o) : t\n        }),\n        o\n      )\n    }),\n    (t.forceY = function (t) {\n      var n,\n        e,\n        r,\n        i = Jo(0.1)\n      function o (t) {\n        for (var i, o = 0, a = n.length; o < a; ++o) (i = n[o]).vy += (r[o] - i.y) * e[o] * t\n      }\n      function a () {\n        if (n) {\n          var o,\n            a = n.length\n          for (e = new Array(a), r = new Array(a), o = 0; o < a; ++o)\n            e[o] = isNaN((r[o] = +t(n[o], o, n))) ? 0 : +i(n[o], o, n)\n        }\n      }\n      return (\n        'function' != typeof t && (t = Jo(null == t ? 0 : +t)),\n        (o.initialize = function (t) {\n          ;(n = t), a()\n        }),\n        (o.strength = function (t) {\n          return arguments.length ? ((i = 'function' == typeof t ? t : Jo(+t)), a(), o) : i\n        }),\n        (o.y = function (n) {\n          return arguments.length ? ((t = 'function' == typeof n ? n : Jo(+n)), a(), o) : t\n        }),\n        o\n      )\n    }),\n    (t.formatDefaultLocale = Ta),\n    (t.formatLocale = ka),\n    (t.formatSpecifier = ma),\n    (t.precisionFixed = Ea),\n    (t.precisionPrefix = Ca),\n    (t.precisionRound = Pa),\n    (t.geoArea = function (t) {\n      return _u.reset(), lu(t, bu), 2 * _u\n    }),\n    (t.geoBounds = function (t) {\n      var n, e, r, i, o, a, u\n      if (((Du = Ru = -(Pu = zu = 1 / 0)), (Bu = []), lu(t, ic), (e = Bu.length))) {\n        for (Bu.sort(dc), n = 1, o = [(r = Bu[0])]; n < e; ++n)\n          pc(r, (i = Bu[n])[0]) || pc(r, i[1])\n            ? (hc(r[0], i[1]) > hc(r[0], r[1]) && (r[1] = i[1]), hc(i[0], r[1]) > hc(r[0], r[1]) && (r[0] = i[0]))\n            : o.push((r = i))\n        for (a = -1 / 0, n = 0, r = o[(e = o.length - 1)]; n <= e; r = i, ++n)\n          (i = o[n]), (u = hc(r[1], i[0])) > a && ((a = u), (Pu = i[0]), (Ru = r[1]))\n      }\n      return (Bu = Yu = null), Pu === 1 / 0 || zu === 1 / 0 ? [[NaN, NaN], [NaN, NaN]] : [[Pu, zu], [Ru, Du]]\n    }),\n    (t.geoCentroid = function (t) {\n      ;(Fu = Iu = ju = Hu = Xu = Gu = Vu = $u = Wu = Zu = Qu = 0), lu(t, vc)\n      var n = Wu,\n        e = Zu,\n        r = Qu,\n        i = n * n + e * e + r * r\n      return i < Ua &&\n        ((n = Gu), (e = Vu), (r = $u), Iu < La && ((n = ju), (e = Hu), (r = Xu)), (i = n * n + e * e + r * r) < Ua)\n        ? [NaN, NaN]\n        : [Ga(e, n) * Ia, ru(r / tu(i)) * Ia]\n    }),\n    (t.geoCircle = function () {\n      var t,\n        n,\n        e = Sc([0, 0]),\n        r = Sc(90),\n        i = Sc(6),\n        o = {\n          point: function (e, r) {\n            t.push((e = n(e, r))), (e[0] *= Ia), (e[1] *= Ia)\n          }\n        }\n      function a () {\n        var a = e.apply(this, arguments),\n          u = r.apply(this, arguments) * ja,\n          c = i.apply(this, arguments) * ja\n        return (\n          (t = []),\n          (n = Ec(-a[0] * ja, -a[1] * ja, 0).invert),\n          Dc(o, u, c, 1),\n          (a = { type: 'Polygon', coordinates: [t] }),\n          (t = n = null),\n          a\n        )\n      }\n      return (\n        (a.center = function (t) {\n          return arguments.length ? ((e = 'function' == typeof t ? t : Sc([+t[0], +t[1]])), a) : e\n        }),\n        (a.radius = function (t) {\n          return arguments.length ? ((r = 'function' == typeof t ? t : Sc(+t)), a) : r\n        }),\n        (a.precision = function (t) {\n          return arguments.length ? ((i = 'function' == typeof t ? t : Sc(+t)), a) : i\n        }),\n        a\n      )\n    }),\n    (t.geoClipAntimeridian = Gc),\n    (t.geoClipCircle = Vc),\n    (t.geoClipExtent = function () {\n      var t,\n        n,\n        e,\n        r = 0,\n        i = 0,\n        o = 960,\n        a = 500\n      return (e = {\n        stream: function (e) {\n          return t && n === e ? t : (t = Zc(r, i, o, a)((n = e)))\n        },\n        extent: function (u) {\n          return arguments.length\n            ? ((r = +u[0][0]), (i = +u[0][1]), (o = +u[1][0]), (a = +u[1][1]), (t = n = null), e)\n            : [[r, i], [o, a]]\n        }\n      })\n    }),\n    (t.geoClipRectangle = Zc),\n    (t.geoContains = function (t, n) {\n      return (t && sf.hasOwnProperty(t.type) ? sf[t.type] : hf)(t, n)\n    }),\n    (t.geoDistance = ff),\n    (t.geoGraticule = mf),\n    (t.geoGraticule10 = function () {\n      return mf()()\n    }),\n    (t.geoInterpolate = function (t, n) {\n      var e = t[0] * ja,\n        r = t[1] * ja,\n        i = n[0] * ja,\n        o = n[1] * ja,\n        a = Va(r),\n        u = Ja(r),\n        c = Va(o),\n        f = Ja(o),\n        s = a * Va(e),\n        l = a * Ja(e),\n        h = c * Va(i),\n        d = c * Ja(i),\n        p = 2 * ru(tu(iu(o - r) + a * c * iu(i - e))),\n        v = Ja(p),\n        g = p\n          ? function (t) {\n              var n = Ja((t *= p)) / v,\n                e = Ja(p - t) / v,\n                r = e * s + n * h,\n                i = e * l + n * d,\n                o = e * u + n * f\n              return [Ga(i, r) * Ia, Ga(o, tu(r * r + i * i)) * Ia]\n            }\n          : function () {\n              return [e * Ia, r * Ia]\n            }\n      return (g.distance = p), g\n    }),\n    (t.geoLength = af),\n    (t.geoPath = function (t, n) {\n      var e,\n        r,\n        i = 4.5\n      function o (t) {\n        return t && ('function' == typeof i && r.pointRadius(+i.apply(this, arguments)), lu(t, e(r))), r.result()\n      }\n      return (\n        (o.area = function (t) {\n          return lu(t, e(Tf)), Tf.result()\n        }),\n        (o.measure = function (t) {\n          return lu(t, e(ps)), ps.result()\n        }),\n        (o.bounds = function (t) {\n          return lu(t, e(Uf)), Uf.result()\n        }),\n        (o.centroid = function (t) {\n          return lu(t, e(Qf)), Qf.result()\n        }),\n        (o.projection = function (n) {\n          return arguments.length ? ((e = null == n ? ((t = null), xf) : (t = n).stream), o) : t\n        }),\n        (o.context = function (t) {\n          return arguments.length\n            ? ((r = null == t ? ((n = null), new ys()) : new us((n = t))),\n              'function' != typeof i && r.pointRadius(i),\n              o)\n            : n\n        }),\n        (o.pointRadius = function (t) {\n          return arguments.length ? ((i = 'function' == typeof t ? t : (r.pointRadius(+t), +t)), o) : i\n        }),\n        o.projection(t).context(n)\n      )\n    }),\n    (t.geoAlbers = Ls),\n    (t.geoAlbersUsa = function () {\n      var t,\n        n,\n        e,\n        r,\n        i,\n        o,\n        a = Ls(),\n        u = qs()\n          .rotate([154, 0])\n          .center([-2, 58.5])\n          .parallels([55, 65]),\n        c = qs()\n          .rotate([157, 0])\n          .center([-3, 19.9])\n          .parallels([8, 18]),\n        f = {\n          point: function (t, n) {\n            o = [t, n]\n          }\n        }\n      function s (t) {\n        var n = t[0],\n          a = t[1]\n        return (o = null), e.point(n, a), o || (r.point(n, a), o) || (i.point(n, a), o)\n      }\n      function l () {\n        return (t = n = null), s\n      }\n      return (\n        (s.invert = function (t) {\n          var n = a.scale(),\n            e = a.translate(),\n            r = (t[0] - e[0]) / n,\n            i = (t[1] - e[1]) / n\n          return (i >= 0.12 && i < 0.234 && r >= -0.425 && r < -0.214\n            ? u\n            : i >= 0.166 && i < 0.234 && r >= -0.214 && r < -0.115\n            ? c\n            : a\n          ).invert(t)\n        }),\n        (s.stream = function (e) {\n          return t && n === e\n            ? t\n            : ((r = [a.stream((n = e)), u.stream(e), c.stream(e)]),\n              (i = r.length),\n              (t = {\n                point: function (t, n) {\n                  for (var e = -1; ++e < i; ) r[e].point(t, n)\n                },\n                sphere: function () {\n                  for (var t = -1; ++t < i; ) r[t].sphere()\n                },\n                lineStart: function () {\n                  for (var t = -1; ++t < i; ) r[t].lineStart()\n                },\n                lineEnd: function () {\n                  for (var t = -1; ++t < i; ) r[t].lineEnd()\n                },\n                polygonStart: function () {\n                  for (var t = -1; ++t < i; ) r[t].polygonStart()\n                },\n                polygonEnd: function () {\n                  for (var t = -1; ++t < i; ) r[t].polygonEnd()\n                }\n              }))\n          var r, i\n        }),\n        (s.precision = function (t) {\n          return arguments.length ? (a.precision(t), u.precision(t), c.precision(t), l()) : a.precision()\n        }),\n        (s.scale = function (t) {\n          return arguments.length ? (a.scale(t), u.scale(0.35 * t), c.scale(t), s.translate(a.translate())) : a.scale()\n        }),\n        (s.translate = function (t) {\n          if (!arguments.length) return a.translate()\n          var n = a.scale(),\n            o = +t[0],\n            s = +t[1]\n          return (\n            (e = a\n              .translate(t)\n              .clipExtent([[o - 0.455 * n, s - 0.238 * n], [o + 0.455 * n, s + 0.238 * n]])\n              .stream(f)),\n            (r = u\n              .translate([o - 0.307 * n, s + 0.201 * n])\n              .clipExtent([[o - 0.425 * n + La, s + 0.12 * n + La], [o - 0.214 * n - La, s + 0.234 * n - La]])\n              .stream(f)),\n            (i = c\n              .translate([o - 0.205 * n, s + 0.212 * n])\n              .clipExtent([[o - 0.214 * n + La, s + 0.166 * n + La], [o - 0.115 * n - La, s + 0.234 * n - La]])\n              .stream(f)),\n            l()\n          )\n        }),\n        (s.fitExtent = function (t, n) {\n          return ws(s, t, n)\n        }),\n        (s.fitSize = function (t, n) {\n          return Ms(s, t, n)\n        }),\n        (s.fitWidth = function (t, n) {\n          return Ns(s, t, n)\n        }),\n        (s.fitHeight = function (t, n) {\n          return As(s, t, n)\n        }),\n        s.scale(1070)\n      )\n    }),\n    (t.geoAzimuthalEqualArea = function () {\n      return Ps(Bs)\n        .scale(124.75)\n        .clipAngle(179.999)\n    }),\n    (t.geoAzimuthalEqualAreaRaw = Bs),\n    (t.geoAzimuthalEquidistant = function () {\n      return Ps(Ys)\n        .scale(79.4188)\n        .clipAngle(179.999)\n    }),\n    (t.geoAzimuthalEquidistantRaw = Ys),\n    (t.geoConicConformal = function () {\n      return Rs(Hs)\n        .scale(109.5)\n        .parallels([30, 30])\n    }),\n    (t.geoConicConformalRaw = Hs),\n    (t.geoConicEqualArea = qs),\n    (t.geoConicEqualAreaRaw = Ds),\n    (t.geoConicEquidistant = function () {\n      return Rs(Gs)\n        .scale(131.154)\n        .center([0, 13.9389])\n    }),\n    (t.geoConicEquidistantRaw = Gs),\n    (t.geoEqualEarth = function () {\n      return Ps(Js).scale(177.158)\n    }),\n    (t.geoEqualEarthRaw = Js),\n    (t.geoEquirectangular = function () {\n      return Ps(Xs).scale(152.63)\n    }),\n    (t.geoEquirectangularRaw = Xs),\n    (t.geoGnomonic = function () {\n      return Ps(Ks)\n        .scale(144.049)\n        .clipAngle(60)\n    }),\n    (t.geoGnomonicRaw = Ks),\n    (t.geoIdentity = function () {\n      var t,\n        n,\n        e,\n        r,\n        i,\n        o,\n        a = 1,\n        u = 0,\n        c = 0,\n        f = 1,\n        s = 1,\n        l = xf,\n        h = null,\n        d = xf\n      function p () {\n        return (r = i = null), o\n      }\n      return (o = {\n        stream: function (t) {\n          return r && i === t ? r : (r = l(d((i = t))))\n        },\n        postclip: function (r) {\n          return arguments.length ? ((d = r), (h = t = n = e = null), p()) : d\n        },\n        clipExtent: function (r) {\n          return arguments.length\n            ? ((d =\n                null == r\n                  ? ((h = t = n = e = null), xf)\n                  : Zc((h = +r[0][0]), (t = +r[0][1]), (n = +r[1][0]), (e = +r[1][1]))),\n              p())\n            : null == h\n            ? null\n            : [[h, t], [n, e]]\n        },\n        scale: function (t) {\n          return arguments.length ? ((l = tl((a = +t) * f, a * s, u, c)), p()) : a\n        },\n        translate: function (t) {\n          return arguments.length ? ((l = tl(a * f, a * s, (u = +t[0]), (c = +t[1]))), p()) : [u, c]\n        },\n        reflectX: function (t) {\n          return arguments.length ? ((l = tl(a * (f = t ? -1 : 1), a * s, u, c)), p()) : f < 0\n        },\n        reflectY: function (t) {\n          return arguments.length ? ((l = tl(a * f, a * (s = t ? -1 : 1), u, c)), p()) : s < 0\n        },\n        fitExtent: function (t, n) {\n          return ws(o, t, n)\n        },\n        fitSize: function (t, n) {\n          return Ms(o, t, n)\n        },\n        fitWidth: function (t, n) {\n          return Ns(o, t, n)\n        },\n        fitHeight: function (t, n) {\n          return As(o, t, n)\n        }\n      })\n    }),\n    (t.geoProjection = Ps),\n    (t.geoProjectionMutator = zs),\n    (t.geoMercator = function () {\n      return Is(Fs).scale(961 / Fa)\n    }),\n    (t.geoMercatorRaw = Fs),\n    (t.geoNaturalEarth1 = function () {\n      return Ps(nl).scale(175.295)\n    }),\n    (t.geoNaturalEarth1Raw = nl),\n    (t.geoOrthographic = function () {\n      return Ps(el)\n        .scale(249.5)\n        .clipAngle(90 + La)\n    }),\n    (t.geoOrthographicRaw = el),\n    (t.geoStereographic = function () {\n      return Ps(rl)\n        .scale(250)\n        .clipAngle(142)\n    }),\n    (t.geoStereographicRaw = rl),\n    (t.geoTransverseMercator = function () {\n      var t = Is(il),\n        n = t.center,\n        e = t.rotate\n      return (\n        (t.center = function (t) {\n          return arguments.length ? n([-t[1], t[0]]) : [(t = n())[1], -t[0]]\n        }),\n        (t.rotate = function (t) {\n          return arguments.length ? e([t[0], t[1], t.length > 2 ? t[2] + 90 : 90]) : [(t = e())[0], t[1], t[2] - 90]\n        }),\n        e([0, 0, 90]).scale(159.155)\n      )\n    }),\n    (t.geoTransverseMercatorRaw = il),\n    (t.geoRotation = Rc),\n    (t.geoStream = lu),\n    (t.geoTransform = function (t) {\n      return { stream: bs(t) }\n    }),\n    (t.cluster = function () {\n      var t = ol,\n        n = 1,\n        e = 1,\n        r = !1\n      function i (i) {\n        var o,\n          a = 0\n        i.eachAfter(function (n) {\n          var e = n.children\n          e\n            ? ((n.x = (function (t) {\n                return t.reduce(al, 0) / t.length\n              })(e)),\n              (n.y = (function (t) {\n                return 1 + t.reduce(ul, 0)\n              })(e)))\n            : ((n.x = o ? (a += t(n, o)) : 0), (n.y = 0), (o = n))\n        })\n        var u = (function (t) {\n            for (var n; (n = t.children); ) t = n[0]\n            return t\n          })(i),\n          c = (function (t) {\n            for (var n; (n = t.children); ) t = n[n.length - 1]\n            return t\n          })(i),\n          f = u.x - t(u, c) / 2,\n          s = c.x + t(c, u) / 2\n        return i.eachAfter(\n          r\n            ? function (t) {\n                ;(t.x = (t.x - i.x) * n), (t.y = (i.y - t.y) * e)\n              }\n            : function (t) {\n                ;(t.x = ((t.x - f) / (s - f)) * n), (t.y = (1 - (i.y ? t.y / i.y : 1)) * e)\n              }\n        )\n      }\n      return (\n        (i.separation = function (n) {\n          return arguments.length ? ((t = n), i) : t\n        }),\n        (i.size = function (t) {\n          return arguments.length ? ((r = !1), (n = +t[0]), (e = +t[1]), i) : r ? null : [n, e]\n        }),\n        (i.nodeSize = function (t) {\n          return arguments.length ? ((r = !0), (n = +t[0]), (e = +t[1]), i) : r ? [n, e] : null\n        }),\n        i\n      )\n    }),\n    (t.hierarchy = fl),\n    (t.pack = function () {\n      var t = null,\n        n = 1,\n        e = 1,\n        r = El\n      function i (i) {\n        return (\n          (i.x = n / 2),\n          (i.y = e / 2),\n          t\n            ? i\n                .eachBefore(zl(t))\n                .eachAfter(Rl(r, 0.5))\n                .eachBefore(Dl(1))\n            : i\n                .eachBefore(zl(Pl))\n                .eachAfter(Rl(El, 1))\n                .eachAfter(Rl(r, i.r / Math.min(n, e)))\n                .eachBefore(Dl(Math.min(n, e) / (2 * i.r))),\n          i\n        )\n      }\n      return (\n        (i.radius = function (n) {\n          return arguments.length ? ((t = null == (e = n) ? null : Tl(e)), i) : t\n          var e\n        }),\n        (i.size = function (t) {\n          return arguments.length ? ((n = +t[0]), (e = +t[1]), i) : [n, e]\n        }),\n        (i.padding = function (t) {\n          return arguments.length ? ((r = 'function' == typeof t ? t : Cl(+t)), i) : r\n        }),\n        i\n      )\n    }),\n    (t.packSiblings = function (t) {\n      return kl(t), t\n    }),\n    (t.packEnclose = vl),\n    (t.partition = function () {\n      var t = 1,\n        n = 1,\n        e = 0,\n        r = !1\n      function i (i) {\n        var o = i.height + 1\n        return (\n          (i.x0 = i.y0 = e),\n          (i.x1 = t),\n          (i.y1 = n / o),\n          i.eachBefore(\n            (function (t, n) {\n              return function (r) {\n                r.children && Ll(r, r.x0, (t * (r.depth + 1)) / n, r.x1, (t * (r.depth + 2)) / n)\n                var i = r.x0,\n                  o = r.y0,\n                  a = r.x1 - e,\n                  u = r.y1 - e\n                a < i && (i = a = (i + a) / 2),\n                  u < o && (o = u = (o + u) / 2),\n                  (r.x0 = i),\n                  (r.y0 = o),\n                  (r.x1 = a),\n                  (r.y1 = u)\n              }\n            })(n, o)\n          ),\n          r && i.eachBefore(ql),\n          i\n        )\n      }\n      return (\n        (i.round = function (t) {\n          return arguments.length ? ((r = !!t), i) : r\n        }),\n        (i.size = function (e) {\n          return arguments.length ? ((t = +e[0]), (n = +e[1]), i) : [t, n]\n        }),\n        (i.padding = function (t) {\n          return arguments.length ? ((e = +t), i) : e\n        }),\n        i\n      )\n    }),\n    (t.stratify = function () {\n      var t = Yl,\n        n = Fl\n      function e (e) {\n        var r,\n          i,\n          o,\n          a,\n          u,\n          c,\n          f,\n          s = e.length,\n          l = new Array(s),\n          h = {}\n        for (i = 0; i < s; ++i)\n          (r = e[i]),\n            (u = l[i] = new dl(r)),\n            null != (c = t(r, i, e)) && (c += '') && (h[(f = Ul + (u.id = c))] = f in h ? Bl : u)\n        for (i = 0; i < s; ++i)\n          if (((u = l[i]), null != (c = n(e[i], i, e)) && (c += ''))) {\n            if (!(a = h[Ul + c])) throw new Error('missing: ' + c)\n            if (a === Bl) throw new Error('ambiguous: ' + c)\n            a.children ? a.children.push(u) : (a.children = [u]), (u.parent = a)\n          } else {\n            if (o) throw new Error('multiple roots')\n            o = u\n          }\n        if (!o) throw new Error('no root')\n        if (\n          ((o.parent = Ol),\n          o\n            .eachBefore(function (t) {\n              ;(t.depth = t.parent.depth + 1), --s\n            })\n            .eachBefore(hl),\n          (o.parent = null),\n          s > 0)\n        )\n          throw new Error('cycle')\n        return o\n      }\n      return (\n        (e.id = function (n) {\n          return arguments.length ? ((t = Tl(n)), e) : t\n        }),\n        (e.parentId = function (t) {\n          return arguments.length ? ((n = Tl(t)), e) : n\n        }),\n        e\n      )\n    }),\n    (t.tree = function () {\n      var t = Il,\n        n = 1,\n        e = 1,\n        r = null\n      function i (i) {\n        var c = (function (t) {\n          for (var n, e, r, i, o, a = new Vl(t, 0), u = [a]; (n = u.pop()); )\n            if ((r = n._.children))\n              for (n.children = new Array((o = r.length)), i = o - 1; i >= 0; --i)\n                u.push((e = n.children[i] = new Vl(r[i], i))), (e.parent = n)\n          return ((a.parent = new Vl(null, 0)).children = [a]), a\n        })(i)\n        if ((c.eachAfter(o), (c.parent.m = -c.z), c.eachBefore(a), r)) i.eachBefore(u)\n        else {\n          var f = i,\n            s = i,\n            l = i\n          i.eachBefore(function (t) {\n            t.x < f.x && (f = t), t.x > s.x && (s = t), t.depth > l.depth && (l = t)\n          })\n          var h = f === s ? 1 : t(f, s) / 2,\n            d = h - f.x,\n            p = n / (s.x + h + d),\n            v = e / (l.depth || 1)\n          i.eachBefore(function (t) {\n            ;(t.x = (t.x + d) * p), (t.y = t.depth * v)\n          })\n        }\n        return i\n      }\n      function o (n) {\n        var e = n.children,\n          r = n.parent.children,\n          i = n.i ? r[n.i - 1] : null\n        if (e) {\n          !(function (t) {\n            for (var n, e = 0, r = 0, i = t.children, o = i.length; --o >= 0; )\n              ((n = i[o]).z += e), (n.m += e), (e += n.s + (r += n.c))\n          })(n)\n          var o = (e[0].z + e[e.length - 1].z) / 2\n          i ? ((n.z = i.z + t(n._, i._)), (n.m = n.z - o)) : (n.z = o)\n        } else i && (n.z = i.z + t(n._, i._))\n        n.parent.A = (function (n, e, r) {\n          if (e) {\n            for (\n              var i, o = n, a = n, u = e, c = o.parent.children[0], f = o.m, s = a.m, l = u.m, h = c.m;\n              (u = Hl(u)), (o = jl(o)), u && o;\n\n            )\n              (c = jl(c)),\n                ((a = Hl(a)).a = n),\n                (i = u.z + l - o.z - f + t(u._, o._)) > 0 && (Xl(Gl(u, n, r), n, i), (f += i), (s += i)),\n                (l += u.m),\n                (f += o.m),\n                (h += c.m),\n                (s += a.m)\n            u && !Hl(a) && ((a.t = u), (a.m += l - s)), o && !jl(c) && ((c.t = o), (c.m += f - h), (r = n))\n          }\n          return r\n        })(n, i, n.parent.A || r[0])\n      }\n      function a (t) {\n        ;(t._.x = t.z + t.parent.m), (t.m += t.parent.m)\n      }\n      function u (t) {\n        ;(t.x *= n), (t.y = t.depth * e)\n      }\n      return (\n        (i.separation = function (n) {\n          return arguments.length ? ((t = n), i) : t\n        }),\n        (i.size = function (t) {\n          return arguments.length ? ((r = !1), (n = +t[0]), (e = +t[1]), i) : r ? null : [n, e]\n        }),\n        (i.nodeSize = function (t) {\n          return arguments.length ? ((r = !0), (n = +t[0]), (e = +t[1]), i) : r ? [n, e] : null\n        }),\n        i\n      )\n    }),\n    (t.treemap = function () {\n      var t = Ql,\n        n = !1,\n        e = 1,\n        r = 1,\n        i = [0],\n        o = El,\n        a = El,\n        u = El,\n        c = El,\n        f = El\n      function s (t) {\n        return (t.x0 = t.y0 = 0), (t.x1 = e), (t.y1 = r), t.eachBefore(l), (i = [0]), n && t.eachBefore(ql), t\n      }\n      function l (n) {\n        var e = i[n.depth],\n          r = n.x0 + e,\n          s = n.y0 + e,\n          l = n.x1 - e,\n          h = n.y1 - e\n        l < r && (r = l = (r + l) / 2),\n          h < s && (s = h = (s + h) / 2),\n          (n.x0 = r),\n          (n.y0 = s),\n          (n.x1 = l),\n          (n.y1 = h),\n          n.children &&\n            ((e = i[n.depth + 1] = o(n) / 2),\n            (r += f(n) - e),\n            (s += a(n) - e),\n            (l -= u(n) - e) < r && (r = l = (r + l) / 2),\n            (h -= c(n) - e) < s && (s = h = (s + h) / 2),\n            t(n, r, s, l, h))\n      }\n      return (\n        (s.round = function (t) {\n          return arguments.length ? ((n = !!t), s) : n\n        }),\n        (s.size = function (t) {\n          return arguments.length ? ((e = +t[0]), (r = +t[1]), s) : [e, r]\n        }),\n        (s.tile = function (n) {\n          return arguments.length ? ((t = Tl(n)), s) : t\n        }),\n        (s.padding = function (t) {\n          return arguments.length ? s.paddingInner(t).paddingOuter(t) : s.paddingInner()\n        }),\n        (s.paddingInner = function (t) {\n          return arguments.length ? ((o = 'function' == typeof t ? t : Cl(+t)), s) : o\n        }),\n        (s.paddingOuter = function (t) {\n          return arguments.length\n            ? s\n                .paddingTop(t)\n                .paddingRight(t)\n                .paddingBottom(t)\n                .paddingLeft(t)\n            : s.paddingTop()\n        }),\n        (s.paddingTop = function (t) {\n          return arguments.length ? ((a = 'function' == typeof t ? t : Cl(+t)), s) : a\n        }),\n        (s.paddingRight = function (t) {\n          return arguments.length ? ((u = 'function' == typeof t ? t : Cl(+t)), s) : u\n        }),\n        (s.paddingBottom = function (t) {\n          return arguments.length ? ((c = 'function' == typeof t ? t : Cl(+t)), s) : c\n        }),\n        (s.paddingLeft = function (t) {\n          return arguments.length ? ((f = 'function' == typeof t ? t : Cl(+t)), s) : f\n        }),\n        s\n      )\n    }),\n    (t.treemapBinary = function (t, n, e, r, i) {\n      var o,\n        a,\n        u = t.children,\n        c = u.length,\n        f = new Array(c + 1)\n      for (f[0] = a = o = 0; o < c; ++o) f[o + 1] = a += u[o].value\n      !(function t (n, e, r, i, o, a, c) {\n        if (n >= e - 1) {\n          var s = u[n]\n          return (s.x0 = i), (s.y0 = o), (s.x1 = a), void (s.y1 = c)\n        }\n        for (var l = f[n], h = r / 2 + l, d = n + 1, p = e - 1; d < p; ) {\n          var v = (d + p) >>> 1\n          f[v] < h ? (d = v + 1) : (p = v)\n        }\n        h - f[d - 1] < f[d] - h && n + 1 < d && --d\n        var g = f[d] - l,\n          y = r - g\n        if (a - i > c - o) {\n          var _ = (i * y + a * g) / r\n          t(n, d, g, i, o, _, c), t(d, e, y, _, o, a, c)\n        } else {\n          var b = (o * y + c * g) / r\n          t(n, d, g, i, o, a, b), t(d, e, y, i, b, a, c)\n        }\n      })(0, c, t.value, n, e, r, i)\n    }),\n    (t.treemapDice = Ll),\n    (t.treemapSlice = $l),\n    (t.treemapSliceDice = function (t, n, e, r, i) {\n      ;(1 & t.depth ? $l : Ll)(t, n, e, r, i)\n    }),\n    (t.treemapSquarify = Ql),\n    (t.treemapResquarify = Jl),\n    (t.interpolate = ye),\n    (t.interpolateArray = se),\n    (t.interpolateBasis = Kn),\n    (t.interpolateBasisClosed = te),\n    (t.interpolateDate = le),\n    (t.interpolateDiscrete = function (t) {\n      var n = t.length\n      return function (e) {\n        return t[Math.max(0, Math.min(n - 1, Math.floor(e * n)))]\n      }\n    }),\n    (t.interpolateHue = function (t, n) {\n      var e = re(+t, +n)\n      return function (t) {\n        var n = e(t)\n        return n - 360 * Math.floor(n / 360)\n      }\n    }),\n    (t.interpolateNumber = he),\n    (t.interpolateObject = de),\n    (t.interpolateRound = _e),\n    (t.interpolateString = ge),\n    (t.interpolateTransformCss = ke),\n    (t.interpolateTransformSvg = Te),\n    (t.interpolateZoom = De),\n    (t.interpolateRgb = ae),\n    (t.interpolateRgbBasis = ce),\n    (t.interpolateRgbBasisClosed = fe),\n    (t.interpolateHsl = Le),\n    (t.interpolateHslLong = Ue),\n    (t.interpolateLab = function (t, n) {\n      var e = oe((t = Rn(t)).l, (n = Rn(n)).l),\n        r = oe(t.a, n.a),\n        i = oe(t.b, n.b),\n        o = oe(t.opacity, n.opacity)\n      return function (n) {\n        return (t.l = e(n)), (t.a = r(n)), (t.b = i(n)), (t.opacity = o(n)), t + ''\n      }\n    }),\n    (t.interpolateHcl = Be),\n    (t.interpolateHclLong = Ye),\n    (t.interpolateCubehelix = Ie),\n    (t.interpolateCubehelixLong = je),\n    (t.piecewise = function (t, n) {\n      for (var e = 0, r = n.length - 1, i = n[0], o = new Array(r < 0 ? 0 : r); e < r; ) o[e] = t(i, (i = n[++e]))\n      return function (t) {\n        var n = Math.max(0, Math.min(r - 1, Math.floor((t *= r))))\n        return o[n](t - n)\n      }\n    }),\n    (t.quantize = function (t, n) {\n      for (var e = new Array(n), r = 0; r < n; ++r) e[r] = t(r / (n - 1))\n      return e\n    }),\n    (t.path = Hi),\n    (t.polygonArea = function (t) {\n      for (var n, e = -1, r = t.length, i = t[r - 1], o = 0; ++e < r; )\n        (n = i), (i = t[e]), (o += n[1] * i[0] - n[0] * i[1])\n      return o / 2\n    }),\n    (t.polygonCentroid = function (t) {\n      for (var n, e, r = -1, i = t.length, o = 0, a = 0, u = t[i - 1], c = 0; ++r < i; )\n        (n = u), (u = t[r]), (c += e = n[0] * u[1] - u[0] * n[1]), (o += (n[0] + u[0]) * e), (a += (n[1] + u[1]) * e)\n      return [o / (c *= 3), a / c]\n    }),\n    (t.polygonHull = function (t) {\n      if ((e = t.length) < 3) return null\n      var n,\n        e,\n        r = new Array(e),\n        i = new Array(e)\n      for (n = 0; n < e; ++n) r[n] = [+t[n][0], +t[n][1], n]\n      for (r.sort(Kl), n = 0; n < e; ++n) i[n] = [r[n][0], -r[n][1]]\n      var o = th(r),\n        a = th(i),\n        u = a[0] === o[0],\n        c = a[a.length - 1] === o[o.length - 1],\n        f = []\n      for (n = o.length - 1; n >= 0; --n) f.push(t[r[o[n]][2]])\n      for (n = +u; n < a.length - c; ++n) f.push(t[r[a[n]][2]])\n      return f\n    }),\n    (t.polygonContains = function (t, n) {\n      for (var e, r, i = t.length, o = t[i - 1], a = n[0], u = n[1], c = o[0], f = o[1], s = !1, l = 0; l < i; ++l)\n        (e = (o = t[l])[0]),\n          (r = o[1]) > u != f > u && a < ((c - e) * (u - r)) / (f - r) + e && (s = !s),\n          (c = e),\n          (f = r)\n      return s\n    }),\n    (t.polygonLength = function (t) {\n      for (var n, e, r = -1, i = t.length, o = t[i - 1], a = o[0], u = o[1], c = 0; ++r < i; )\n        (n = a), (e = u), (n -= a = (o = t[r])[0]), (e -= u = o[1]), (c += Math.sqrt(n * n + e * e))\n      return c\n    }),\n    (t.quadtree = ia),\n    (t.randomUniform = eh),\n    (t.randomNormal = rh),\n    (t.randomLogNormal = ih),\n    (t.randomBates = ah),\n    (t.randomIrwinHall = oh),\n    (t.randomExponential = uh),\n    (t.scaleBand = vh),\n    (t.scalePoint = function () {\n      return (function t (n) {\n        var e = n.copy\n        return (\n          (n.padding = n.paddingOuter),\n          delete n.paddingInner,\n          delete n.paddingOuter,\n          (n.copy = function () {\n            return t(e())\n          }),\n          n\n        )\n      })(vh.apply(null, arguments).paddingInner(1))\n    }),\n    (t.scaleIdentity = function t (n) {\n      var e\n      function r (t) {\n        return isNaN((t = +t)) ? e : t\n      }\n      return (\n        (r.invert = r),\n        (r.domain = r.range = function (t) {\n          return arguments.length ? ((n = lh.call(t, gh)), r) : n.slice()\n        }),\n        (r.unknown = function (t) {\n          return arguments.length ? ((e = t), r) : e\n        }),\n        (r.copy = function () {\n          return t(n).unknown(e)\n        }),\n        (n = arguments.length ? lh.call(n, gh) : [0, 1]),\n        kh(r)\n      )\n    }),\n    (t.scaleLinear = function t () {\n      var n = Ah(_h, _h)\n      return (\n        (n.copy = function () {\n          return Mh(n, t())\n        }),\n        ch.apply(n, arguments),\n        kh(n)\n      )\n    }),\n    (t.scaleLog = function t () {\n      var n = qh(Nh()).domain([1, 10])\n      return (\n        (n.copy = function () {\n          return Mh(n, t()).base(n.base())\n        }),\n        ch.apply(n, arguments),\n        n\n      )\n    }),\n    (t.scaleSymlog = function t () {\n      var n = Oh(Nh())\n      return (\n        (n.copy = function () {\n          return Mh(n, t()).constant(n.constant())\n        }),\n        ch.apply(n, arguments)\n      )\n    }),\n    (t.scaleOrdinal = ph),\n    (t.scaleImplicit = dh),\n    (t.scalePow = jh),\n    (t.scaleSqrt = function () {\n      return jh.apply(null, arguments).exponent(0.5)\n    }),\n    (t.scaleQuantile = function t () {\n      var e,\n        r = [],\n        o = [],\n        a = []\n      function u () {\n        var t = 0,\n          n = Math.max(1, o.length)\n        for (a = new Array(n - 1); ++t < n; ) a[t - 1] = N(r, t / n)\n        return c\n      }\n      function c (t) {\n        return isNaN((t = +t)) ? e : o[i(a, t)]\n      }\n      return (\n        (c.invertExtent = function (t) {\n          var n = o.indexOf(t)\n          return n < 0 ? [NaN, NaN] : [n > 0 ? a[n - 1] : r[0], n < a.length ? a[n] : r[r.length - 1]]\n        }),\n        (c.domain = function (t) {\n          if (!arguments.length) return r.slice()\n          r = []\n          for (var e, i = 0, o = t.length; i < o; ++i) null == (e = t[i]) || isNaN((e = +e)) || r.push(e)\n          return r.sort(n), u()\n        }),\n        (c.range = function (t) {\n          return arguments.length ? ((o = hh.call(t)), u()) : o.slice()\n        }),\n        (c.unknown = function (t) {\n          return arguments.length ? ((e = t), c) : e\n        }),\n        (c.quantiles = function () {\n          return a.slice()\n        }),\n        (c.copy = function () {\n          return t()\n            .domain(r)\n            .range(o)\n            .unknown(e)\n        }),\n        ch.apply(c, arguments)\n      )\n    }),\n    (t.scaleQuantize = function t () {\n      var n,\n        e = 0,\n        r = 1,\n        o = 1,\n        a = [0.5],\n        u = [0, 1]\n      function c (t) {\n        return t <= t ? u[i(a, t, 0, o)] : n\n      }\n      function f () {\n        var t = -1\n        for (a = new Array(o); ++t < o; ) a[t] = ((t + 1) * r - (t - o) * e) / (o + 1)\n        return c\n      }\n      return (\n        (c.domain = function (t) {\n          return arguments.length ? ((e = +t[0]), (r = +t[1]), f()) : [e, r]\n        }),\n        (c.range = function (t) {\n          return arguments.length ? ((o = (u = hh.call(t)).length - 1), f()) : u.slice()\n        }),\n        (c.invertExtent = function (t) {\n          var n = u.indexOf(t)\n          return n < 0 ? [NaN, NaN] : n < 1 ? [e, a[0]] : n >= o ? [a[o - 1], r] : [a[n - 1], a[n]]\n        }),\n        (c.unknown = function (t) {\n          return arguments.length ? ((n = t), c) : c\n        }),\n        (c.thresholds = function () {\n          return a.slice()\n        }),\n        (c.copy = function () {\n          return t()\n            .domain([e, r])\n            .range(u)\n            .unknown(n)\n        }),\n        ch.apply(kh(c), arguments)\n      )\n    }),\n    (t.scaleThreshold = function t () {\n      var n,\n        e = [0.5],\n        r = [0, 1],\n        o = 1\n      function a (t) {\n        return t <= t ? r[i(e, t, 0, o)] : n\n      }\n      return (\n        (a.domain = function (t) {\n          return arguments.length ? ((e = hh.call(t)), (o = Math.min(e.length, r.length - 1)), a) : e.slice()\n        }),\n        (a.range = function (t) {\n          return arguments.length ? ((r = hh.call(t)), (o = Math.min(e.length, r.length - 1)), a) : r.slice()\n        }),\n        (a.invertExtent = function (t) {\n          var n = r.indexOf(t)\n          return [e[n - 1], e[n]]\n        }),\n        (a.unknown = function (t) {\n          return arguments.length ? ((n = t), a) : n\n        }),\n        (a.copy = function () {\n          return t()\n            .domain(e)\n            .range(r)\n            .unknown(n)\n        }),\n        ch.apply(a, arguments)\n      )\n    }),\n    (t.scaleTime = function () {\n      return ch.apply(\n        wv(wd, md, ad, rd, nd, Kh, Qh, Vh, t.timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]),\n        arguments\n      )\n    }),\n    (t.scaleUtc = function () {\n      return ch.apply(\n        wv(Vd, Xd, Pd, Td, Sd, Nd, Qh, Vh, t.utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]),\n        arguments\n      )\n    }),\n    (t.scaleSequential = function t () {\n      var n = kh(Mv()(_h))\n      return (\n        (n.copy = function () {\n          return Nv(n, t())\n        }),\n        fh.apply(n, arguments)\n      )\n    }),\n    (t.scaleSequentialLog = function t () {\n      var n = qh(Mv()).domain([1, 10])\n      return (\n        (n.copy = function () {\n          return Nv(n, t()).base(n.base())\n        }),\n        fh.apply(n, arguments)\n      )\n    }),\n    (t.scaleSequentialPow = Av),\n    (t.scaleSequentialSqrt = function () {\n      return Av.apply(null, arguments).exponent(0.5)\n    }),\n    (t.scaleSequentialSymlog = function t () {\n      var n = Oh(Mv())\n      return (\n        (n.copy = function () {\n          return Nv(n, t()).constant(n.constant())\n        }),\n        fh.apply(n, arguments)\n      )\n    }),\n    (t.scaleSequentialQuantile = function t () {\n      var e = [],\n        r = _h\n      function o (t) {\n        if (!isNaN((t = +t))) return r((i(e, t) - 1) / (e.length - 1))\n      }\n      return (\n        (o.domain = function (t) {\n          if (!arguments.length) return e.slice()\n          e = []\n          for (var r, i = 0, a = t.length; i < a; ++i) null == (r = t[i]) || isNaN((r = +r)) || e.push(r)\n          return e.sort(n), o\n        }),\n        (o.interpolator = function (t) {\n          return arguments.length ? ((r = t), o) : r\n        }),\n        (o.copy = function () {\n          return t(r).domain(e)\n        }),\n        fh.apply(o, arguments)\n      )\n    }),\n    (t.scaleDiverging = function t () {\n      var n = kh(Sv()(_h))\n      return (\n        (n.copy = function () {\n          return Nv(n, t())\n        }),\n        fh.apply(n, arguments)\n      )\n    }),\n    (t.scaleDivergingLog = function t () {\n      var n = qh(Sv()).domain([0.1, 1, 10])\n      return (\n        (n.copy = function () {\n          return Nv(n, t()).base(n.base())\n        }),\n        fh.apply(n, arguments)\n      )\n    }),\n    (t.scaleDivergingPow = kv),\n    (t.scaleDivergingSqrt = function () {\n      return kv.apply(null, arguments).exponent(0.5)\n    }),\n    (t.scaleDivergingSymlog = function t () {\n      var n = Oh(Sv())\n      return (\n        (n.copy = function () {\n          return Nv(n, t()).constant(n.constant())\n        }),\n        fh.apply(n, arguments)\n      )\n    }),\n    (t.tickFormat = Sh),\n    (t.schemeCategory10 = Ev),\n    (t.schemeAccent = Cv),\n    (t.schemeDark2 = Pv),\n    (t.schemePaired = zv),\n    (t.schemePastel1 = Rv),\n    (t.schemePastel2 = Dv),\n    (t.schemeSet1 = qv),\n    (t.schemeSet2 = Lv),\n    (t.schemeSet3 = Uv),\n    (t.interpolateBrBG = Yv),\n    (t.schemeBrBG = Bv),\n    (t.interpolatePRGn = Iv),\n    (t.schemePRGn = Fv),\n    (t.interpolatePiYG = Hv),\n    (t.schemePiYG = jv),\n    (t.interpolatePuOr = Gv),\n    (t.schemePuOr = Xv),\n    (t.interpolateRdBu = $v),\n    (t.schemeRdBu = Vv),\n    (t.interpolateRdGy = Zv),\n    (t.schemeRdGy = Wv),\n    (t.interpolateRdYlBu = Jv),\n    (t.schemeRdYlBu = Qv),\n    (t.interpolateRdYlGn = tg),\n    (t.schemeRdYlGn = Kv),\n    (t.interpolateSpectral = eg),\n    (t.schemeSpectral = ng),\n    (t.interpolateBuGn = ig),\n    (t.schemeBuGn = rg),\n    (t.interpolateBuPu = ag),\n    (t.schemeBuPu = og),\n    (t.interpolateGnBu = cg),\n    (t.schemeGnBu = ug),\n    (t.interpolateOrRd = sg),\n    (t.schemeOrRd = fg),\n    (t.interpolatePuBuGn = hg),\n    (t.schemePuBuGn = lg),\n    (t.interpolatePuBu = pg),\n    (t.schemePuBu = dg),\n    (t.interpolatePuRd = gg),\n    (t.schemePuRd = vg),\n    (t.interpolateRdPu = _g),\n    (t.schemeRdPu = yg),\n    (t.interpolateYlGnBu = mg),\n    (t.schemeYlGnBu = bg),\n    (t.interpolateYlGn = wg),\n    (t.schemeYlGn = xg),\n    (t.interpolateYlOrBr = Ng),\n    (t.schemeYlOrBr = Mg),\n    (t.interpolateYlOrRd = Sg),\n    (t.schemeYlOrRd = Ag),\n    (t.interpolateBlues = Tg),\n    (t.schemeBlues = kg),\n    (t.interpolateGreens = Cg),\n    (t.schemeGreens = Eg),\n    (t.interpolateGreys = zg),\n    (t.schemeGreys = Pg),\n    (t.interpolatePurples = Dg),\n    (t.schemePurples = Rg),\n    (t.interpolateReds = Lg),\n    (t.schemeReds = qg),\n    (t.interpolateOranges = Og),\n    (t.schemeOranges = Ug),\n    (t.interpolateCubehelixDefault = Bg),\n    (t.interpolateRainbow = function (t) {\n      ;(t < 0 || t > 1) && (t -= Math.floor(t))\n      var n = Math.abs(t - 0.5)\n      return (Ig.h = 360 * t - 100), (Ig.s = 1.5 - 1.5 * n), (Ig.l = 0.8 - 0.9 * n), Ig + ''\n    }),\n    (t.interpolateWarm = Yg),\n    (t.interpolateCool = Fg),\n    (t.interpolateSinebow = function (t) {\n      var n\n      return (\n        (t = (0.5 - t) * Math.PI),\n        (jg.r = 255 * (n = Math.sin(t)) * n),\n        (jg.g = 255 * (n = Math.sin(t + Hg)) * n),\n        (jg.b = 255 * (n = Math.sin(t + Xg)) * n),\n        jg + ''\n      )\n    }),\n    (t.interpolateViridis = Vg),\n    (t.interpolateMagma = $g),\n    (t.interpolateInferno = Wg),\n    (t.interpolatePlasma = Zg),\n    (t.create = function (t) {\n      return zt(W(t).call(document.documentElement))\n    }),\n    (t.creator = W),\n    (t.local = Dt),\n    (t.matcher = tt),\n    (t.mouse = Ot),\n    (t.namespace = $),\n    (t.namespaces = V),\n    (t.clientPoint = Ut),\n    (t.select = zt),\n    (t.selectAll = function (t) {\n      return 'string' == typeof t\n        ? new Ct([document.querySelectorAll(t)], [document.documentElement])\n        : new Ct([null == t ? [] : t], Et)\n    }),\n    (t.selection = Pt),\n    (t.selector = Q),\n    (t.selectorAll = K),\n    (t.style = ct),\n    (t.touch = Bt),\n    (t.touches = function (t, n) {\n      null == n && (n = Lt().touches)\n      for (var e = 0, r = n ? n.length : 0, i = new Array(r); e < r; ++e) i[e] = Ut(t, n[e])\n      return i\n    }),\n    (t.window = ut),\n    (t.customEvent = kt),\n    (t.arc = function () {\n      var t = sy,\n        n = ly,\n        e = Qg(0),\n        r = null,\n        i = hy,\n        o = dy,\n        a = py,\n        u = null\n      function c () {\n        var c,\n          f,\n          s,\n          l = +t.apply(this, arguments),\n          h = +n.apply(this, arguments),\n          d = i.apply(this, arguments) - uy,\n          p = o.apply(this, arguments) - uy,\n          v = Jg(p - d),\n          g = p > d\n        if ((u || (u = c = Hi()), h < l && ((f = h), (h = l), (l = f)), h > oy))\n          if (v > cy - oy)\n            u.moveTo(h * ty(d), h * ry(d)),\n              u.arc(0, 0, h, d, p, !g),\n              l > oy && (u.moveTo(l * ty(p), l * ry(p)), u.arc(0, 0, l, p, d, g))\n          else {\n            var y,\n              _,\n              b = d,\n              m = p,\n              x = d,\n              w = p,\n              M = v,\n              N = v,\n              A = a.apply(this, arguments) / 2,\n              S = A > oy && (r ? +r.apply(this, arguments) : iy(l * l + h * h)),\n              k = ey(Jg(h - l) / 2, +e.apply(this, arguments)),\n              T = k,\n              E = k\n            if (S > oy) {\n              var C = fy((S / l) * ry(A)),\n                P = fy((S / h) * ry(A))\n              ;(M -= 2 * C) > oy ? ((x += C *= g ? 1 : -1), (w -= C)) : ((M = 0), (x = w = (d + p) / 2)),\n                (N -= 2 * P) > oy ? ((b += P *= g ? 1 : -1), (m -= P)) : ((N = 0), (b = m = (d + p) / 2))\n            }\n            var z = h * ty(b),\n              R = h * ry(b),\n              D = l * ty(w),\n              q = l * ry(w)\n            if (k > oy) {\n              var L,\n                U = h * ty(m),\n                O = h * ry(m),\n                B = l * ty(x),\n                Y = l * ry(x)\n              if (\n                v < ay &&\n                (L = (function (t, n, e, r, i, o, a, u) {\n                  var c = e - t,\n                    f = r - n,\n                    s = a - i,\n                    l = u - o,\n                    h = l * c - s * f\n                  if (!(h * h < oy)) return [t + (h = (s * (n - o) - l * (t - i)) / h) * c, n + h * f]\n                })(z, R, B, Y, U, O, D, q))\n              ) {\n                var F = z - L[0],\n                  I = R - L[1],\n                  j = U - L[0],\n                  H = O - L[1],\n                  X =\n                    1 /\n                    ry(\n                      ((s = (F * j + I * H) / (iy(F * F + I * I) * iy(j * j + H * H))) > 1\n                        ? 0\n                        : s < -1\n                        ? ay\n                        : Math.acos(s)) / 2\n                    ),\n                  G = iy(L[0] * L[0] + L[1] * L[1])\n                ;(T = ey(k, (l - G) / (X - 1))), (E = ey(k, (h - G) / (X + 1)))\n              }\n            }\n            N > oy\n              ? E > oy\n                ? ((y = vy(B, Y, z, R, h, E, g)),\n                  (_ = vy(U, O, D, q, h, E, g)),\n                  u.moveTo(y.cx + y.x01, y.cy + y.y01),\n                  E < k\n                    ? u.arc(y.cx, y.cy, E, Kg(y.y01, y.x01), Kg(_.y01, _.x01), !g)\n                    : (u.arc(y.cx, y.cy, E, Kg(y.y01, y.x01), Kg(y.y11, y.x11), !g),\n                      u.arc(0, 0, h, Kg(y.cy + y.y11, y.cx + y.x11), Kg(_.cy + _.y11, _.cx + _.x11), !g),\n                      u.arc(_.cx, _.cy, E, Kg(_.y11, _.x11), Kg(_.y01, _.x01), !g)))\n                : (u.moveTo(z, R), u.arc(0, 0, h, b, m, !g))\n              : u.moveTo(z, R),\n              l > oy && M > oy\n                ? T > oy\n                  ? ((y = vy(D, q, U, O, l, -T, g)),\n                    (_ = vy(z, R, B, Y, l, -T, g)),\n                    u.lineTo(y.cx + y.x01, y.cy + y.y01),\n                    T < k\n                      ? u.arc(y.cx, y.cy, T, Kg(y.y01, y.x01), Kg(_.y01, _.x01), !g)\n                      : (u.arc(y.cx, y.cy, T, Kg(y.y01, y.x01), Kg(y.y11, y.x11), !g),\n                        u.arc(0, 0, l, Kg(y.cy + y.y11, y.cx + y.x11), Kg(_.cy + _.y11, _.cx + _.x11), g),\n                        u.arc(_.cx, _.cy, T, Kg(_.y11, _.x11), Kg(_.y01, _.x01), !g)))\n                  : u.arc(0, 0, l, w, x, g)\n                : u.lineTo(D, q)\n          }\n        else u.moveTo(0, 0)\n        if ((u.closePath(), c)) return (u = null), c + '' || null\n      }\n      return (\n        (c.centroid = function () {\n          var e = (+t.apply(this, arguments) + +n.apply(this, arguments)) / 2,\n            r = (+i.apply(this, arguments) + +o.apply(this, arguments)) / 2 - ay / 2\n          return [ty(r) * e, ry(r) * e]\n        }),\n        (c.innerRadius = function (n) {\n          return arguments.length ? ((t = 'function' == typeof n ? n : Qg(+n)), c) : t\n        }),\n        (c.outerRadius = function (t) {\n          return arguments.length ? ((n = 'function' == typeof t ? t : Qg(+t)), c) : n\n        }),\n        (c.cornerRadius = function (t) {\n          return arguments.length ? ((e = 'function' == typeof t ? t : Qg(+t)), c) : e\n        }),\n        (c.padRadius = function (t) {\n          return arguments.length ? ((r = null == t ? null : 'function' == typeof t ? t : Qg(+t)), c) : r\n        }),\n        (c.startAngle = function (t) {\n          return arguments.length ? ((i = 'function' == typeof t ? t : Qg(+t)), c) : i\n        }),\n        (c.endAngle = function (t) {\n          return arguments.length ? ((o = 'function' == typeof t ? t : Qg(+t)), c) : o\n        }),\n        (c.padAngle = function (t) {\n          return arguments.length ? ((a = 'function' == typeof t ? t : Qg(+t)), c) : a\n        }),\n        (c.context = function (t) {\n          return arguments.length ? ((u = null == t ? null : t), c) : u\n        }),\n        c\n      )\n    }),\n    (t.area = xy),\n    (t.line = my),\n    (t.pie = function () {\n      var t = My,\n        n = wy,\n        e = null,\n        r = Qg(0),\n        i = Qg(cy),\n        o = Qg(0)\n      function a (a) {\n        var u,\n          c,\n          f,\n          s,\n          l,\n          h = a.length,\n          d = 0,\n          p = new Array(h),\n          v = new Array(h),\n          g = +r.apply(this, arguments),\n          y = Math.min(cy, Math.max(-cy, i.apply(this, arguments) - g)),\n          _ = Math.min(Math.abs(y) / h, o.apply(this, arguments)),\n          b = _ * (y < 0 ? -1 : 1)\n        for (u = 0; u < h; ++u) (l = v[(p[u] = u)] = +t(a[u], u, a)) > 0 && (d += l)\n        for (\n          null != n\n            ? p.sort(function (t, e) {\n                return n(v[t], v[e])\n              })\n            : null != e &&\n              p.sort(function (t, n) {\n                return e(a[t], a[n])\n              }),\n            u = 0,\n            f = d ? (y - h * b) / d : 0;\n          u < h;\n          ++u, g = s\n        )\n          (c = p[u]),\n            (s = g + ((l = v[c]) > 0 ? l * f : 0) + b),\n            (v[c] = { data: a[c], index: u, value: l, startAngle: g, endAngle: s, padAngle: _ })\n        return v\n      }\n      return (\n        (a.value = function (n) {\n          return arguments.length ? ((t = 'function' == typeof n ? n : Qg(+n)), a) : t\n        }),\n        (a.sortValues = function (t) {\n          return arguments.length ? ((n = t), (e = null), a) : n\n        }),\n        (a.sort = function (t) {\n          return arguments.length ? ((e = t), (n = null), a) : e\n        }),\n        (a.startAngle = function (t) {\n          return arguments.length ? ((r = 'function' == typeof t ? t : Qg(+t)), a) : r\n        }),\n        (a.endAngle = function (t) {\n          return arguments.length ? ((i = 'function' == typeof t ? t : Qg(+t)), a) : i\n        }),\n        (a.padAngle = function (t) {\n          return arguments.length ? ((o = 'function' == typeof t ? t : Qg(+t)), a) : o\n        }),\n        a\n      )\n    }),\n    (t.areaRadial = Ey),\n    (t.radialArea = Ey),\n    (t.lineRadial = Ty),\n    (t.radialLine = Ty),\n    (t.pointRadial = Cy),\n    (t.linkHorizontal = function () {\n      return Dy(qy)\n    }),\n    (t.linkVertical = function () {\n      return Dy(Ly)\n    }),\n    (t.linkRadial = function () {\n      var t = Dy(Uy)\n      return (t.angle = t.x), delete t.x, (t.radius = t.y), delete t.y, t\n    }),\n    (t.symbol = function () {\n      var t = Qg(Oy),\n        n = Qg(64),\n        e = null\n      function r () {\n        var r\n        if ((e || (e = r = Hi()), t.apply(this, arguments).draw(e, +n.apply(this, arguments)), r))\n          return (e = null), r + '' || null\n      }\n      return (\n        (r.type = function (n) {\n          return arguments.length ? ((t = 'function' == typeof n ? n : Qg(n)), r) : t\n        }),\n        (r.size = function (t) {\n          return arguments.length ? ((n = 'function' == typeof t ? t : Qg(+t)), r) : n\n        }),\n        (r.context = function (t) {\n          return arguments.length ? ((e = null == t ? null : t), r) : e\n        }),\n        r\n      )\n    }),\n    (t.symbols = t_),\n    (t.symbolCircle = Oy),\n    (t.symbolCross = By),\n    (t.symbolDiamond = Iy),\n    (t.symbolSquare = Vy),\n    (t.symbolStar = Gy),\n    (t.symbolTriangle = Wy),\n    (t.symbolWye = Ky),\n    (t.curveBasisClosed = function (t) {\n      return new i_(t)\n    }),\n    (t.curveBasisOpen = function (t) {\n      return new o_(t)\n    }),\n    (t.curveBasis = function (t) {\n      return new r_(t)\n    }),\n    (t.curveBundle = u_),\n    (t.curveCardinalClosed = h_),\n    (t.curveCardinalOpen = p_),\n    (t.curveCardinal = s_),\n    (t.curveCatmullRomClosed = b_),\n    (t.curveCatmullRomOpen = x_),\n    (t.curveCatmullRom = y_),\n    (t.curveLinearClosed = function (t) {\n      return new w_(t)\n    }),\n    (t.curveLinear = yy),\n    (t.curveMonotoneX = function (t) {\n      return new k_(t)\n    }),\n    (t.curveMonotoneY = function (t) {\n      return new T_(t)\n    }),\n    (t.curveNatural = function (t) {\n      return new C_(t)\n    }),\n    (t.curveStep = function (t) {\n      return new z_(t, 0.5)\n    }),\n    (t.curveStepAfter = function (t) {\n      return new z_(t, 1)\n    }),\n    (t.curveStepBefore = function (t) {\n      return new z_(t, 0)\n    }),\n    (t.stack = function () {\n      var t = Qg([]),\n        n = D_,\n        e = R_,\n        r = q_\n      function i (i) {\n        var o,\n          a,\n          u = t.apply(this, arguments),\n          c = i.length,\n          f = u.length,\n          s = new Array(f)\n        for (o = 0; o < f; ++o) {\n          for (var l, h = u[o], d = (s[o] = new Array(c)), p = 0; p < c; ++p)\n            (d[p] = l = [0, +r(i[p], h, p, i)]), (l.data = i[p])\n          d.key = h\n        }\n        for (o = 0, a = n(s); o < f; ++o) s[a[o]].index = o\n        return e(s, a), s\n      }\n      return (\n        (i.keys = function (n) {\n          return arguments.length ? ((t = 'function' == typeof n ? n : Qg(Py.call(n))), i) : t\n        }),\n        (i.value = function (t) {\n          return arguments.length ? ((r = 'function' == typeof t ? t : Qg(+t)), i) : r\n        }),\n        (i.order = function (t) {\n          return arguments.length ? ((n = null == t ? D_ : 'function' == typeof t ? t : Qg(Py.call(t))), i) : n\n        }),\n        (i.offset = function (t) {\n          return arguments.length ? ((e = null == t ? R_ : t), i) : e\n        }),\n        i\n      )\n    }),\n    (t.stackOffsetExpand = function (t, n) {\n      if ((r = t.length) > 0) {\n        for (var e, r, i, o = 0, a = t[0].length; o < a; ++o) {\n          for (i = e = 0; e < r; ++e) i += t[e][o][1] || 0\n          if (i) for (e = 0; e < r; ++e) t[e][o][1] /= i\n        }\n        R_(t, n)\n      }\n    }),\n    (t.stackOffsetDiverging = function (t, n) {\n      if ((u = t.length) > 1)\n        for (var e, r, i, o, a, u, c = 0, f = t[n[0]].length; c < f; ++c)\n          for (o = a = 0, e = 0; e < u; ++e)\n            (i = (r = t[n[e]][c])[1] - r[0]) >= 0\n              ? ((r[0] = o), (r[1] = o += i))\n              : i < 0\n              ? ((r[1] = a), (r[0] = a += i))\n              : (r[0] = o)\n    }),\n    (t.stackOffsetNone = R_),\n    (t.stackOffsetSilhouette = function (t, n) {\n      if ((e = t.length) > 0) {\n        for (var e, r = 0, i = t[n[0]], o = i.length; r < o; ++r) {\n          for (var a = 0, u = 0; a < e; ++a) u += t[a][r][1] || 0\n          i[r][1] += i[r][0] = -u / 2\n        }\n        R_(t, n)\n      }\n    }),\n    (t.stackOffsetWiggle = function (t, n) {\n      if ((i = t.length) > 0 && (r = (e = t[n[0]]).length) > 0) {\n        for (var e, r, i, o = 0, a = 1; a < r; ++a) {\n          for (var u = 0, c = 0, f = 0; u < i; ++u) {\n            for (var s = t[n[u]], l = s[a][1] || 0, h = (l - (s[a - 1][1] || 0)) / 2, d = 0; d < u; ++d) {\n              var p = t[n[d]]\n              h += (p[a][1] || 0) - (p[a - 1][1] || 0)\n            }\n            ;(c += l), (f += h * l)\n          }\n          ;(e[a - 1][1] += e[a - 1][0] = o), c && (o -= f / c)\n        }\n        ;(e[a - 1][1] += e[a - 1][0] = o), R_(t, n)\n      }\n    }),\n    (t.stackOrderAppearance = L_),\n    (t.stackOrderAscending = O_),\n    (t.stackOrderDescending = function (t) {\n      return O_(t).reverse()\n    }),\n    (t.stackOrderInsideOut = function (t) {\n      var n,\n        e,\n        r = t.length,\n        i = t.map(B_),\n        o = L_(t),\n        a = 0,\n        u = 0,\n        c = [],\n        f = []\n      for (n = 0; n < r; ++n) (e = o[n]), a < u ? ((a += i[e]), c.push(e)) : ((u += i[e]), f.push(e))\n      return f.reverse().concat(c)\n    }),\n    (t.stackOrderNone = D_),\n    (t.stackOrderReverse = function (t) {\n      return D_(t).reverse()\n    }),\n    (t.timeInterval = Gh),\n    (t.timeMillisecond = Vh),\n    (t.timeMilliseconds = $h),\n    (t.utcMillisecond = Vh),\n    (t.utcMilliseconds = $h),\n    (t.timeSecond = Qh),\n    (t.timeSeconds = Jh),\n    (t.utcSecond = Qh),\n    (t.utcSeconds = Jh),\n    (t.timeMinute = Kh),\n    (t.timeMinutes = td),\n    (t.timeHour = nd),\n    (t.timeHours = ed),\n    (t.timeDay = rd),\n    (t.timeDays = id),\n    (t.timeWeek = ad),\n    (t.timeWeeks = dd),\n    (t.timeSunday = ad),\n    (t.timeSundays = dd),\n    (t.timeMonday = ud),\n    (t.timeMondays = pd),\n    (t.timeTuesday = cd),\n    (t.timeTuesdays = vd),\n    (t.timeWednesday = fd),\n    (t.timeWednesdays = gd),\n    (t.timeThursday = sd),\n    (t.timeThursdays = yd),\n    (t.timeFriday = ld),\n    (t.timeFridays = _d),\n    (t.timeSaturday = hd),\n    (t.timeSaturdays = bd),\n    (t.timeMonth = md),\n    (t.timeMonths = xd),\n    (t.timeYear = wd),\n    (t.timeYears = Md),\n    (t.utcMinute = Nd),\n    (t.utcMinutes = Ad),\n    (t.utcHour = Sd),\n    (t.utcHours = kd),\n    (t.utcDay = Td),\n    (t.utcDays = Ed),\n    (t.utcWeek = Pd),\n    (t.utcWeeks = Od),\n    (t.utcSunday = Pd),\n    (t.utcSundays = Od),\n    (t.utcMonday = zd),\n    (t.utcMondays = Bd),\n    (t.utcTuesday = Rd),\n    (t.utcTuesdays = Yd),\n    (t.utcWednesday = Dd),\n    (t.utcWednesdays = Fd),\n    (t.utcThursday = qd),\n    (t.utcThursdays = Id),\n    (t.utcFriday = Ld),\n    (t.utcFridays = jd),\n    (t.utcSaturday = Ud),\n    (t.utcSaturdays = Hd),\n    (t.utcMonth = Xd),\n    (t.utcMonths = Gd),\n    (t.utcYear = Vd),\n    (t.utcYears = $d),\n    (t.timeFormatDefaultLocale = sv),\n    (t.timeFormatLocale = Jd),\n    (t.isoFormat = lv),\n    (t.isoParse = hv),\n    (t.now = nr),\n    (t.timer = ir),\n    (t.timerFlush = or),\n    (t.timeout = fr),\n    (t.interval = function (t, n, e) {\n      var r = new rr(),\n        i = n\n      return null == n\n        ? (r.restart(t, n, e), r)\n        : ((n = +n),\n          (e = null == e ? nr() : +e),\n          r.restart(\n            function o (a) {\n              ;(a += i), r.restart(o, (i += n), e), t(a)\n            },\n            n,\n            e\n          ),\n          r)\n    }),\n    (t.transition = Cr),\n    (t.active = function (t, n) {\n      var e,\n        r,\n        i = t.__transition\n      if (i)\n        for (r in ((n = null == n ? null : n + ''), i))\n          if ((e = i[r]).state > dr && e.name === n) return new Er([[t]], fi, n, +r)\n      return null\n    }),\n    (t.interrupt = Mr),\n    (t.voronoi = function () {\n      var t = F_,\n        n = I_,\n        e = null\n      function r (r) {\n        return new wb(\n          r.map(function (e, i) {\n            var o = [Math.round(t(e, i, r) / bb) * bb, Math.round(n(e, i, r) / bb) * bb]\n            return (o.index = i), (o.data = e), o\n          }),\n          e\n        )\n      }\n      return (\n        (r.polygons = function (t) {\n          return r(t).polygons()\n        }),\n        (r.links = function (t) {\n          return r(t).links()\n        }),\n        (r.triangles = function (t) {\n          return r(t).triangles()\n        }),\n        (r.x = function (n) {\n          return arguments.length ? ((t = 'function' == typeof n ? n : Y_(+n)), r) : t\n        }),\n        (r.y = function (t) {\n          return arguments.length ? ((n = 'function' == typeof t ? t : Y_(+t)), r) : n\n        }),\n        (r.extent = function (t) {\n          return arguments.length\n            ? ((e = null == t ? null : [[+t[0][0], +t[0][1]], [+t[1][0], +t[1][1]]]), r)\n            : e && [[e[0][0], e[0][1]], [e[1][0], e[1][1]]]\n        }),\n        (r.size = function (t) {\n          return arguments.length\n            ? ((e = null == t ? null : [[0, 0], [+t[0], +t[1]]]), r)\n            : e && [e[1][0] - e[0][0], e[1][1] - e[0][1]]\n        }),\n        r\n      )\n    }),\n    (t.zoom = function () {\n      var n,\n        e,\n        r = Cb,\n        i = Pb,\n        o = qb,\n        a = Rb,\n        u = Db,\n        c = [0, 1 / 0],\n        f = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]],\n        s = 250,\n        l = De,\n        h = [],\n        d = I('start', 'zoom', 'end'),\n        p = 500,\n        v = 150,\n        g = 0\n      function y (t) {\n        t.property('__zoom', zb)\n          .on('wheel.zoom', N)\n          .on('mousedown.zoom', A)\n          .on('dblclick.zoom', S)\n          .filter(u)\n          .on('touchstart.zoom', k)\n          .on('touchmove.zoom', T)\n          .on('touchend.zoom touchcancel.zoom', E)\n          .style('touch-action', 'none')\n          .style('-webkit-tap-highlight-color', 'rgba(0,0,0,0)')\n      }\n      function _ (t, n) {\n        return (n = Math.max(c[0], Math.min(c[1], n))) === t.k ? t : new Ab(n, t.x, t.y)\n      }\n      function b (t, n, e) {\n        var r = n[0] - e[0] * t.k,\n          i = n[1] - e[1] * t.k\n        return r === t.x && i === t.y ? t : new Ab(t.k, r, i)\n      }\n      function m (t) {\n        return [(+t[0][0] + +t[1][0]) / 2, (+t[0][1] + +t[1][1]) / 2]\n      }\n      function x (t, n, e) {\n        t.on('start.zoom', function () {\n          w(this, arguments).start()\n        })\n          .on('interrupt.zoom end.zoom', function () {\n            w(this, arguments).end()\n          })\n          .tween('zoom', function () {\n            var t = arguments,\n              r = w(this, t),\n              o = i.apply(this, t),\n              a = e || m(o),\n              u = Math.max(o[1][0] - o[0][0], o[1][1] - o[0][1]),\n              c = this.__zoom,\n              f = 'function' == typeof n ? n.apply(this, t) : n,\n              s = l(c.invert(a).concat(u / c.k), f.invert(a).concat(u / f.k))\n            return function (t) {\n              if (1 === t) t = f\n              else {\n                var n = s(t),\n                  e = u / n[2]\n                t = new Ab(e, a[0] - n[0] * e, a[1] - n[1] * e)\n              }\n              r.zoom(null, t)\n            }\n          })\n      }\n      function w (t, n) {\n        for (var e, r = 0, i = h.length; r < i; ++r) if ((e = h[r]).that === t) return e\n        return new M(t, n)\n      }\n      function M (t, n) {\n        ;(this.that = t), (this.args = n), (this.index = -1), (this.active = 0), (this.extent = i.apply(t, n))\n      }\n      function N () {\n        if (r.apply(this, arguments)) {\n          var t = w(this, arguments),\n            n = this.__zoom,\n            e = Math.max(c[0], Math.min(c[1], n.k * Math.pow(2, a.apply(this, arguments)))),\n            i = Ot(this)\n          if (t.wheel)\n            (t.mouse[0][0] === i[0] && t.mouse[0][1] === i[1]) || (t.mouse[1] = n.invert((t.mouse[0] = i))),\n              clearTimeout(t.wheel)\n          else {\n            if (n.k === e) return\n            ;(t.mouse = [i, n.invert(i)]), Mr(this), t.start()\n          }\n          Eb(),\n            (t.wheel = setTimeout(function () {\n              ;(t.wheel = null), t.end()\n            }, v)),\n            t.zoom('mouse', o(b(_(n, e), t.mouse[0], t.mouse[1]), t.extent, f))\n        }\n      }\n      function A () {\n        if (!e && r.apply(this, arguments)) {\n          var n = w(this, arguments),\n            i = zt(t.event.view)\n              .on(\n                'mousemove.zoom',\n                function () {\n                  if ((Eb(), !n.moved)) {\n                    var e = t.event.clientX - u,\n                      r = t.event.clientY - c\n                    n.moved = e * e + r * r > g\n                  }\n                  n.zoom('mouse', o(b(n.that.__zoom, (n.mouse[0] = Ot(n.that)), n.mouse[1]), n.extent, f))\n                },\n                !0\n              )\n              .on(\n                'mouseup.zoom',\n                function () {\n                  i.on('mousemove.zoom mouseup.zoom', null), jt(t.event.view, n.moved), Eb(), n.end()\n                },\n                !0\n              ),\n            a = Ot(this),\n            u = t.event.clientX,\n            c = t.event.clientY\n          It(t.event.view), Tb(), (n.mouse = [a, this.__zoom.invert(a)]), Mr(this), n.start()\n        }\n      }\n      function S () {\n        if (r.apply(this, arguments)) {\n          var n = this.__zoom,\n            e = Ot(this),\n            a = n.invert(e),\n            u = n.k * (t.event.shiftKey ? 0.5 : 2),\n            c = o(b(_(n, u), e, a), i.apply(this, arguments), f)\n          Eb(),\n            s > 0\n              ? zt(this)\n                  .transition()\n                  .duration(s)\n                  .call(x, c, e)\n              : zt(this).call(y.transform, c)\n        }\n      }\n      function k () {\n        if (r.apply(this, arguments)) {\n          var e,\n            i,\n            o,\n            a,\n            u = w(this, arguments),\n            c = t.event.changedTouches,\n            f = c.length\n          for (Tb(), i = 0; i < f; ++i)\n            (a = [(a = Bt(this, c, (o = c[i]).identifier)), this.__zoom.invert(a), o.identifier]),\n              u.touch0 ? u.touch1 || (u.touch1 = a) : ((u.touch0 = a), (e = !0))\n          if (n && ((n = clearTimeout(n)), !u.touch1))\n            return u.end(), void ((a = zt(this).on('dblclick.zoom')) && a.apply(this, arguments))\n          e &&\n            ((n = setTimeout(function () {\n              n = null\n            }, p)),\n            Mr(this),\n            u.start())\n        }\n      }\n      function T () {\n        var e,\n          r,\n          i,\n          a,\n          u = w(this, arguments),\n          c = t.event.changedTouches,\n          s = c.length\n        for (Eb(), n && (n = clearTimeout(n)), e = 0; e < s; ++e)\n          (i = Bt(this, c, (r = c[e]).identifier)),\n            u.touch0 && u.touch0[2] === r.identifier\n              ? (u.touch0[0] = i)\n              : u.touch1 && u.touch1[2] === r.identifier && (u.touch1[0] = i)\n        if (((r = u.that.__zoom), u.touch1)) {\n          var l = u.touch0[0],\n            h = u.touch0[1],\n            d = u.touch1[0],\n            p = u.touch1[1],\n            v = (v = d[0] - l[0]) * v + (v = d[1] - l[1]) * v,\n            g = (g = p[0] - h[0]) * g + (g = p[1] - h[1]) * g\n          ;(r = _(r, Math.sqrt(v / g))),\n            (i = [(l[0] + d[0]) / 2, (l[1] + d[1]) / 2]),\n            (a = [(h[0] + p[0]) / 2, (h[1] + p[1]) / 2])\n        } else {\n          if (!u.touch0) return\n          ;(i = u.touch0[0]), (a = u.touch0[1])\n        }\n        u.zoom('touch', o(b(r, i, a), u.extent, f))\n      }\n      function E () {\n        var n,\n          r,\n          i = w(this, arguments),\n          o = t.event.changedTouches,\n          a = o.length\n        for (\n          Tb(),\n            e && clearTimeout(e),\n            e = setTimeout(function () {\n              e = null\n            }, p),\n            n = 0;\n          n < a;\n          ++n\n        )\n          (r = o[n]),\n            i.touch0 && i.touch0[2] === r.identifier\n              ? delete i.touch0\n              : i.touch1 && i.touch1[2] === r.identifier && delete i.touch1\n        i.touch1 && !i.touch0 && ((i.touch0 = i.touch1), delete i.touch1),\n          i.touch0 ? (i.touch0[1] = this.__zoom.invert(i.touch0[0])) : i.end()\n      }\n      return (\n        (y.transform = function (t, n) {\n          var e = t.selection ? t.selection() : t\n          e.property('__zoom', zb),\n            t !== e\n              ? x(t, n)\n              : e.interrupt().each(function () {\n                  w(this, arguments)\n                    .start()\n                    .zoom(null, 'function' == typeof n ? n.apply(this, arguments) : n)\n                    .end()\n                })\n        }),\n        (y.scaleBy = function (t, n) {\n          y.scaleTo(t, function () {\n            return this.__zoom.k * ('function' == typeof n ? n.apply(this, arguments) : n)\n          })\n        }),\n        (y.scaleTo = function (t, n) {\n          y.transform(t, function () {\n            var t = i.apply(this, arguments),\n              e = this.__zoom,\n              r = m(t),\n              a = e.invert(r),\n              u = 'function' == typeof n ? n.apply(this, arguments) : n\n            return o(b(_(e, u), r, a), t, f)\n          })\n        }),\n        (y.translateBy = function (t, n, e) {\n          y.transform(t, function () {\n            return o(\n              this.__zoom.translate(\n                'function' == typeof n ? n.apply(this, arguments) : n,\n                'function' == typeof e ? e.apply(this, arguments) : e\n              ),\n              i.apply(this, arguments),\n              f\n            )\n          })\n        }),\n        (y.translateTo = function (t, n, e) {\n          y.transform(t, function () {\n            var t = i.apply(this, arguments),\n              r = this.__zoom,\n              a = m(t)\n            return o(\n              Sb.translate(a[0], a[1])\n                .scale(r.k)\n                .translate(\n                  'function' == typeof n ? -n.apply(this, arguments) : -n,\n                  'function' == typeof e ? -e.apply(this, arguments) : -e\n                ),\n              t,\n              f\n            )\n          })\n        }),\n        (M.prototype = {\n          start: function () {\n            return 1 == ++this.active && ((this.index = h.push(this) - 1), this.emit('start')), this\n          },\n          zoom: function (t, n) {\n            return (\n              this.mouse && 'mouse' !== t && (this.mouse[1] = n.invert(this.mouse[0])),\n              this.touch0 && 'touch' !== t && (this.touch0[1] = n.invert(this.touch0[0])),\n              this.touch1 && 'touch' !== t && (this.touch1[1] = n.invert(this.touch1[0])),\n              (this.that.__zoom = n),\n              this.emit('zoom'),\n              this\n            )\n          },\n          end: function () {\n            return 0 == --this.active && (h.splice(this.index, 1), (this.index = -1), this.emit('end')), this\n          },\n          emit: function (t) {\n            kt(new Nb(y, t, this.that.__zoom), d.apply, d, [t, this.that, this.args])\n          }\n        }),\n        (y.wheelDelta = function (t) {\n          return arguments.length ? ((a = 'function' == typeof t ? t : Mb(+t)), y) : a\n        }),\n        (y.filter = function (t) {\n          return arguments.length ? ((r = 'function' == typeof t ? t : Mb(!!t)), y) : r\n        }),\n        (y.touchable = function (t) {\n          return arguments.length ? ((u = 'function' == typeof t ? t : Mb(!!t)), y) : u\n        }),\n        (y.extent = function (t) {\n          return arguments.length\n            ? ((i = 'function' == typeof t ? t : Mb([[+t[0][0], +t[0][1]], [+t[1][0], +t[1][1]]])), y)\n            : i\n        }),\n        (y.scaleExtent = function (t) {\n          return arguments.length ? ((c[0] = +t[0]), (c[1] = +t[1]), y) : [c[0], c[1]]\n        }),\n        (y.translateExtent = function (t) {\n          return arguments.length\n            ? ((f[0][0] = +t[0][0]), (f[1][0] = +t[1][0]), (f[0][1] = +t[0][1]), (f[1][1] = +t[1][1]), y)\n            : [[f[0][0], f[0][1]], [f[1][0], f[1][1]]]\n        }),\n        (y.constrain = function (t) {\n          return arguments.length ? ((o = t), y) : o\n        }),\n        (y.duration = function (t) {\n          return arguments.length ? ((s = +t), y) : s\n        }),\n        (y.interpolate = function (t) {\n          return arguments.length ? ((l = t), y) : l\n        }),\n        (y.on = function () {\n          var t = d.on.apply(d, arguments)\n          return t === d ? y : t\n        }),\n        (y.clickDistance = function (t) {\n          return arguments.length ? ((g = (t = +t) * t), y) : Math.sqrt(g)\n        }),\n        y\n      )\n    }),\n    (t.zoomTransform = kb),\n    (t.zoomIdentity = Sb),\n    Object.defineProperty(t, '__esModule', { value: !0 })\n})\n\n\n//# sourceURL=webpack:///./src/public/js/vendor/d3/d3.min.js?");

/***/ }),

/***/ "./src/public/js/vendor/d3pie/d3pie.min.js":
/*!*************************************************!*\
  !*** ./src/public/js/vendor/d3pie/d3pie.min.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * d3pie\n * @author Ben Keen\n * @version 0.1.8\n * @date May 1st, 2015\n * @repo http://github.com/benkeen/d3pie\n */\n\n// UMD pattern from https://github.com/umdjs/umd/blob/master/returnExports.js\n;(function (root, factory) {\n  if (true) {\n    // AMD. Register as an anonymous module\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(this, function () {\n  var _scriptName = 'd3pie'\n  var _version = '0.1.6'\n\n  // used to uniquely generate IDs and classes, ensuring no conflict between multiple pies on the same page\n  var _uniqueIDCounter = 0\n\n  // this section includes all helper libs on the d3pie object. They're populated via grunt-template. Note: to keep\n  // the syntax highlighting from getting all messed up, I commented out each line. That REQUIRES each of the files\n  // to have an empty first line. Crumby, yes, but acceptable.\n  //// --------- _default-settings.js -----------/**\n  /**\n   * Contains the out-the-box settings for the script. Any of these settings that aren't explicitly overridden for the\n   * d3pie instance will inherit from these. This is also included on the main website for use in the generation script.\n   */\n  var defaultSettings = {\n    header: {\n      title: {\n        text: '',\n        color: '#333333',\n        fontSize: 18,\n        font: 'arial'\n      },\n      subtitle: {\n        text: '',\n        color: '#666666',\n        fontSize: 14,\n        font: 'arial'\n      },\n      location: 'top-center',\n      titleSubtitlePadding: 8\n    },\n    footer: {\n      text: '',\n      color: '#666666',\n      fontSize: 14,\n      font: 'arial',\n      location: 'left'\n    },\n    size: {\n      canvasHeight: 500,\n      canvasWidth: 500,\n      pieInnerRadius: '0%',\n      pieOuterRadius: null\n    },\n    data: {\n      sortOrder: 'none',\n      ignoreSmallSegments: {\n        enabled: false,\n        valueType: 'percentage',\n        value: null\n      },\n      smallSegmentGrouping: {\n        enabled: false,\n        value: 1,\n        valueType: 'percentage',\n        label: 'Other',\n        color: '#cccccc'\n      },\n      content: []\n    },\n    labels: {\n      outer: {\n        format: 'label',\n        hideWhenLessThanPercentage: null,\n        pieDistance: 30\n      },\n      inner: {\n        format: 'percentage',\n        hideWhenLessThanPercentage: null\n      },\n      mainLabel: {\n        color: '#333333',\n        font: 'arial',\n        fontSize: 10\n      },\n      percentage: {\n        color: '#dddddd',\n        font: 'arial',\n        fontSize: 10,\n        decimalPlaces: 0\n      },\n      value: {\n        color: '#cccc44',\n        font: 'arial',\n        fontSize: 10\n      },\n      lines: {\n        enabled: true,\n        style: 'curved',\n        color: 'segment'\n      },\n      truncation: {\n        enabled: false,\n        truncateLength: 30\n      },\n      formatter: null\n    },\n    effects: {\n      load: {\n        effect: 'default',\n        speed: 1000\n      },\n      pullOutSegmentOnClick: {\n        effect: 'bounce',\n        speed: 300,\n        size: 10\n      },\n      highlightSegmentOnMouseover: true,\n      highlightLuminosity: -0.2\n    },\n    tooltips: {\n      enabled: false,\n      type: 'placeholder', // caption|placeholder\n      string: '',\n      placeholderParser: null,\n      styles: {\n        fadeInSpeed: 250,\n        backgroundColor: '#000000',\n        backgroundOpacity: 0.5,\n        color: '#efefef',\n        borderRadius: 2,\n        font: 'arial',\n        fontSize: 10,\n        padding: 4\n      }\n    },\n    misc: {\n      colors: {\n        background: null,\n        segments: [\n          '#2484c1',\n          '#65a620',\n          '#7b6888',\n          '#a05d56',\n          '#961a1a',\n          '#d8d23a',\n          '#e98125',\n          '#d0743c',\n          '#635222',\n          '#6ada6a',\n          '#0c6197',\n          '#7d9058',\n          '#207f33',\n          '#44b9b0',\n          '#bca44a',\n          '#e4a14b',\n          '#a3acb2',\n          '#8cc3e9',\n          '#69a6f9',\n          '#5b388f',\n          '#546e91',\n          '#8bde95',\n          '#d2ab58',\n          '#273c71',\n          '#98bf6e',\n          '#4daa4b',\n          '#98abc5',\n          '#cc1010',\n          '#31383b',\n          '#006391',\n          '#c2643f',\n          '#b0a474',\n          '#a5a39c',\n          '#a9c2bc',\n          '#22af8c',\n          '#7fcecf',\n          '#987ac6',\n          '#3d3b87',\n          '#b77b1c',\n          '#c9c2b6',\n          '#807ece',\n          '#8db27c',\n          '#be66a2',\n          '#9ed3c6',\n          '#00644b',\n          '#005064',\n          '#77979f',\n          '#77e079',\n          '#9c73ab',\n          '#1f79a7'\n        ],\n        segmentStroke: '#ffffff'\n      },\n      gradient: {\n        enabled: false,\n        percentage: 95,\n        color: '#000000'\n      },\n      canvasPadding: {\n        top: 5,\n        right: 5,\n        bottom: 5,\n        left: 5\n      },\n      pieCenterOffset: {\n        x: 0,\n        y: 0\n      },\n      cssPrefix: null\n    },\n    callbacks: {\n      onload: null,\n      onMouseoverSegment: null,\n      onMouseoutSegment: null,\n      onClickSegment: null\n    }\n  }\n\n  //// --------- validate.js -----------\n  var validate = {\n    // called whenever a new pie chart is created\n    initialCheck: function (pie) {\n      var cssPrefix = pie.cssPrefix\n      var element = pie.element\n      var options = pie.options\n\n      // confirm d3 is available [check minimum version]\n      if (!window.d3 || !window.d3.hasOwnProperty('version')) {\n        console.error('d3pie error: d3 is not available')\n        return false\n      }\n\n      // confirm element is either a DOM element or a valid string for a DOM element\n      if (!(element instanceof HTMLElement || element instanceof SVGElement)) {\n        console.error('d3pie error: the first d3pie() param must be a valid DOM element (not jQuery) or a ID string.')\n        return false\n      }\n\n      // confirm the CSS prefix is valid. It has to start with a-Z and contain nothing but a-Z0-9_-\n      if (!/[a-zA-Z][a-zA-Z0-9_-]*$/.test(cssPrefix)) {\n        console.error('d3pie error: invalid options.misc.cssPrefix')\n        return false\n      }\n\n      // confirm some data has been supplied\n      if (!helpers.isArray(options.data.content)) {\n        console.error('d3pie error: invalid config structure: missing data.content property.')\n        return false\n      }\n      if (options.data.content.length === 0) {\n        console.error('d3pie error: no data supplied.')\n        return false\n      }\n\n      // clear out any invalid data. Each data row needs a valid positive number and a label\n      var data = []\n      for (var i = 0; i < options.data.content.length; i++) {\n        if (typeof options.data.content[i].value !== 'number' || isNaN(options.data.content[i].value)) {\n          console.log('not valid: ', options.data.content[i])\n          continue\n        }\n        if (options.data.content[i].value <= 0) {\n          console.log('not valid - should have positive value: ', options.data.content[i])\n          continue\n        }\n        data.push(options.data.content[i])\n      }\n      pie.options.data.content = data\n\n      // labels.outer.hideWhenLessThanPercentage - 1-100\n      // labels.inner.hideWhenLessThanPercentage - 1-100\n\n      return true\n    }\n  }\n\n  //// --------- helpers.js -----------\n  var helpers = {\n    // creates the SVG element\n    addSVGSpace: function (pie) {\n      var element = pie.element\n      var canvasWidth = pie.options.size.canvasWidth\n      var canvasHeight = pie.options.size.canvasHeight\n      var backgroundColor = pie.options.misc.colors.background\n\n      var svg = d3\n        .select(element)\n        .append('svg:svg')\n        .attr('width', canvasWidth)\n        .attr('height', canvasHeight)\n\n      if (backgroundColor !== 'transparent') {\n        svg.style('background-color', function () {\n          return backgroundColor\n        })\n      }\n\n      return svg\n    },\n\n    whenIdExists: function (id, callback) {\n      var inc = 1\n      var giveupIterationCount = 1000\n\n      var interval = setInterval(function () {\n        if (document.getElementById(id)) {\n          clearInterval(interval)\n          callback()\n        }\n        if (inc > giveupIterationCount) {\n          clearInterval(interval)\n        }\n        inc++\n      }, 1)\n    },\n\n    whenElementsExist: function (els, callback) {\n      var inc = 1\n      var giveupIterationCount = 1000\n\n      var interval = setInterval(function () {\n        var allExist = true\n        for (var i = 0; i < els.length; i++) {\n          if (!document.getElementById(els[i])) {\n            allExist = false\n            break\n          }\n        }\n        if (allExist) {\n          clearInterval(interval)\n          callback()\n        }\n        if (inc > giveupIterationCount) {\n          clearInterval(interval)\n        }\n        inc++\n      }, 1)\n    },\n\n    shuffleArray: function (array) {\n      var currentIndex = array.length,\n        tmpVal,\n        randomIndex\n\n      while (0 !== currentIndex) {\n        randomIndex = Math.floor(Math.random() * currentIndex)\n        currentIndex -= 1\n\n        // and swap it with the current element\n        tmpVal = array[currentIndex]\n        array[currentIndex] = array[randomIndex]\n        array[randomIndex] = tmpVal\n      }\n      return array\n    },\n\n    processObj: function (obj, is, value) {\n      if (typeof is === 'string') {\n        return helpers.processObj(obj, is.split('.'), value)\n      } else if (is.length === 1 && value !== undefined) {\n        obj[is[0]] = value\n        return obj[is[0]]\n      } else if (is.length === 0) {\n        return obj\n      } else {\n        return helpers.processObj(obj[is[0]], is.slice(1), value)\n      }\n    },\n\n    getDimensions: function (id) {\n      var el = document.getElementById(id)\n      var w = 0,\n        h = 0\n      if (el) {\n        var dimensions = el.getBBox()\n        w = dimensions.width\n        h = dimensions.height\n      } else {\n        console.log('error: getDimensions() ' + id + ' not found.')\n      }\n      return { w: w, h: h }\n    },\n\n    /**\n     * This is based on the SVG coordinate system, where top-left is 0,0 and bottom right is n-n.\n     * @param r1\n     * @param r2\n     * @returns {boolean}\n     */\n    rectIntersect: function (r1, r2) {\n      var returnVal =\n        // r2.left > r1.right\n        r2.x > r1.x + r1.w ||\n        // r2.right < r1.left\n        r2.x + r2.w < r1.x ||\n        // r2.top < r1.bottom\n        r2.y + r2.h < r1.y ||\n        // r2.bottom > r1.top\n        r2.y > r1.y + r1.h\n\n      return !returnVal\n    },\n\n    /**\n     * Returns a lighter/darker shade of a hex value, based on a luminance value passed.\n     * @param hex a hex color value such as “#abc” or “#123456″ (the hash is optional)\n     * @param lum the luminosity factor: -0.1 is 10% darker, 0.2 is 20% lighter, etc.\n     * @returns {string}\n     */\n    getColorShade: function (hex, lum) {\n      // validate hex string\n      hex = String(hex).replace(/[^0-9a-f]/gi, '')\n      if (hex.length < 6) {\n        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2]\n      }\n      lum = lum || 0\n\n      // convert to decimal and change luminosity\n      var newHex = '#'\n      for (var i = 0; i < 3; i++) {\n        var c = parseInt(hex.substr(i * 2, 2), 16)\n        c = Math.round(Math.min(Math.max(0, c + c * lum), 255)).toString(16)\n        newHex += ('00' + c).substr(c.length)\n      }\n\n      return newHex\n    },\n\n    /**\n     * Users can choose to specify segment colors in three ways (in order of precedence):\n     * \t1. include a \"color\" attribute for each row in data.content\n     * \t2. include a misc.colors.segments property which contains an array of hex codes\n     * \t3. specify nothing at all and rely on this lib provide some reasonable defaults\n     *\n     * This function sees what's included and populates this.options.colors with whatever's required\n     * for this pie chart.\n     * @param data\n     */\n    initSegmentColors: function (pie) {\n      var data = pie.options.data.content\n      var colors = pie.options.misc.colors.segments\n\n      // TODO this needs a ton of error handling\n\n      var finalColors = []\n      for (var i = 0; i < data.length; i++) {\n        if (data[i].hasOwnProperty('color')) {\n          finalColors.push(data[i].color)\n        } else {\n          finalColors.push(colors[i])\n        }\n      }\n\n      return finalColors\n    },\n\n    applySmallSegmentGrouping: function (data, smallSegmentGrouping) {\n      var totalSize\n      if (smallSegmentGrouping.valueType === 'percentage') {\n        totalSize = math.getTotalPieSize(data)\n      }\n\n      // loop through each data item\n      var newData = []\n      var groupedData = []\n      var totalGroupedData = 0\n      for (var i = 0; i < data.length; i++) {\n        if (smallSegmentGrouping.valueType === 'percentage') {\n          var dataPercent = (data[i].value / totalSize) * 100\n          if (dataPercent <= smallSegmentGrouping.value) {\n            groupedData.push(data[i])\n            totalGroupedData += data[i].value\n            continue\n          }\n          data[i].isGrouped = false\n          newData.push(data[i])\n        } else {\n          if (data[i].value <= smallSegmentGrouping.value) {\n            groupedData.push(data[i])\n            totalGroupedData += data[i].value\n            continue\n          }\n          data[i].isGrouped = false\n          newData.push(data[i])\n        }\n      }\n\n      // we're done! See if there's any small segment groups to add\n      if (groupedData.length) {\n        newData.push({\n          color: smallSegmentGrouping.color,\n          label: smallSegmentGrouping.label,\n          value: totalGroupedData,\n          isGrouped: true,\n          groupedData: groupedData\n        })\n      }\n\n      return newData\n    },\n\n    // for debugging\n    showPoint: function (svg, x, y) {\n      svg\n        .append('circle')\n        .attr('cx', x)\n        .attr('cy', y)\n        .attr('r', 2)\n        .style('fill', 'black')\n    },\n\n    isFunction: function (functionToCheck) {\n      var getType = {}\n      return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]'\n    },\n\n    isArray: function (o) {\n      return Object.prototype.toString.call(o) === '[object Array]'\n    }\n  }\n\n  // taken from jQuery\n  var extend = function () {\n    var options,\n      name,\n      src,\n      copy,\n      copyIsArray,\n      clone,\n      target = arguments[0] || {},\n      i = 1,\n      length = arguments.length,\n      deep = false,\n      toString = Object.prototype.toString,\n      hasOwn = Object.prototype.hasOwnProperty,\n      class2type = {\n        '[object Boolean]': 'boolean',\n        '[object Number]': 'number',\n        '[object String]': 'string',\n        '[object Function]': 'function',\n        '[object Array]': 'array',\n        '[object Date]': 'date',\n        '[object RegExp]': 'regexp',\n        '[object Object]': 'object'\n      },\n      jQuery = {\n        isFunction: function (obj) {\n          return jQuery.type(obj) === 'function'\n        },\n        isArray:\n          Array.isArray ||\n          function (obj) {\n            return jQuery.type(obj) === 'array'\n          },\n        isWindow: function (obj) {\n          return obj !== null && obj === obj.window\n        },\n        isNumeric: function (obj) {\n          return !isNaN(parseFloat(obj)) && isFinite(obj)\n        },\n        type: function (obj) {\n          return obj === null ? String(obj) : class2type[toString.call(obj)] || 'object'\n        },\n        isPlainObject: function (obj) {\n          if (!obj || jQuery.type(obj) !== 'object' || obj.nodeType) {\n            return false\n          }\n          try {\n            if (\n              obj.constructor &&\n              !hasOwn.call(obj, 'constructor') &&\n              !hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')\n            ) {\n              return false\n            }\n          } catch (e) {\n            return false\n          }\n          var key\n          for (key in obj) {\n          }\n          return key === undefined || hasOwn.call(obj, key)\n        }\n      }\n    if (typeof target === 'boolean') {\n      deep = target\n      target = arguments[1] || {}\n      i = 2\n    }\n    if (typeof target !== 'object' && !jQuery.isFunction(target)) {\n      target = {}\n    }\n    if (length === i) {\n      target = this\n      --i\n    }\n    for (i; i < length; i++) {\n      if ((options = arguments[i]) !== null) {\n        for (name in options) {\n          src = target[name]\n          copy = options[name]\n          if (target === copy) {\n            continue\n          }\n          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {\n            if (copyIsArray) {\n              copyIsArray = false\n              clone = src && jQuery.isArray(src) ? src : []\n            } else {\n              clone = src && jQuery.isPlainObject(src) ? src : {}\n            }\n            // WARNING: RECURSION\n            target[name] = extend(deep, clone, copy)\n          } else if (copy !== undefined) {\n            target[name] = copy\n          }\n        }\n      }\n    }\n    return target\n  }\n  //// --------- math.js -----------\n  var math = {\n    toRadians: function (degrees) {\n      return degrees * (Math.PI / 180)\n    },\n\n    toDegrees: function (radians) {\n      return radians * (180 / Math.PI)\n    },\n\n    computePieRadius: function (pie) {\n      var size = pie.options.size\n      var canvasPadding = pie.options.misc.canvasPadding\n\n      // outer radius is either specified (e.g. through the generator), or omitted altogether\n      // and calculated based on the canvas dimensions. Right now the estimated version isn't great - it should\n      // be possible to calculate it to precisely generate the maximum sized pie, but it's fussy as heck. Something\n      // for the next release.\n\n      // first, calculate the default _outerRadius\n      var w = size.canvasWidth - canvasPadding.left - canvasPadding.right\n      var h = size.canvasHeight - canvasPadding.top - canvasPadding.bottom\n\n      // now factor in the footer, title & subtitle\n      if (pie.options.header.location !== 'pie-center') {\n        h -= pie.textComponents.headerHeight\n      }\n\n      if (pie.textComponents.footer.exists) {\n        h -= pie.textComponents.footer.h\n      }\n\n      // for really teeny pies, h may be < 0. Adjust it back\n      h = h < 0 ? 0 : h\n\n      var outerRadius = (w < h ? w : h) / 3\n      var innerRadius, percent\n\n      // if the user specified something, use that instead\n      if (size.pieOuterRadius !== null) {\n        if (/%/.test(size.pieOuterRadius)) {\n          percent = parseInt(size.pieOuterRadius.replace(/[\\D]/, ''), 10)\n          percent = percent > 99 ? 99 : percent\n          percent = percent < 0 ? 0 : percent\n\n          var smallestDimension = w < h ? w : h\n\n          // now factor in the label line size\n          if (pie.options.labels.outer.format !== 'none') {\n            var pieDistanceSpace = parseInt(pie.options.labels.outer.pieDistance, 10) * 2\n            if (smallestDimension - pieDistanceSpace > 0) {\n              smallestDimension -= pieDistanceSpace\n            }\n          }\n\n          outerRadius = Math.floor((smallestDimension / 100) * percent) / 2\n        } else {\n          outerRadius = parseInt(size.pieOuterRadius, 10)\n        }\n      }\n\n      // inner radius\n      if (/%/.test(size.pieInnerRadius)) {\n        percent = parseInt(size.pieInnerRadius.replace(/[\\D]/, ''), 10)\n        percent = percent > 99 ? 99 : percent\n        percent = percent < 0 ? 0 : percent\n        innerRadius = Math.floor((outerRadius / 100) * percent)\n      } else {\n        innerRadius = parseInt(size.pieInnerRadius, 10)\n      }\n\n      pie.innerRadius = innerRadius\n      pie.outerRadius = outerRadius\n    },\n\n    getTotalPieSize: function (data) {\n      var totalSize = 0\n      for (var i = 0; i < data.length; i++) {\n        totalSize += data[i].value\n      }\n      return totalSize\n    },\n\n    sortPieData: function (pie) {\n      var data = pie.options.data.content\n      var sortOrder = pie.options.data.sortOrder\n\n      switch (sortOrder) {\n        case 'none':\n          // do nothing\n          break\n        case 'random':\n          data = helpers.shuffleArray(data)\n          break\n        case 'value-asc':\n          data.sort(function (a, b) {\n            return a.value < b.value ? -1 : 1\n          })\n          break\n        case 'value-desc':\n          data.sort(function (a, b) {\n            return a.value < b.value ? 1 : -1\n          })\n          break\n        case 'label-asc':\n          data.sort(function (a, b) {\n            return a.label.toLowerCase() > b.label.toLowerCase() ? 1 : -1\n          })\n          break\n        case 'label-desc':\n          data.sort(function (a, b) {\n            return a.label.toLowerCase() < b.label.toLowerCase() ? 1 : -1\n          })\n          break\n      }\n\n      return data\n    },\n\n    // var pieCenter = math.getPieCenter();\n    getPieTranslateCenter: function (pieCenter) {\n      return 'translate(' + pieCenter.x + ',' + pieCenter.y + ')'\n    },\n\n    /**\n     * Used to determine where on the canvas the center of the pie chart should be. It takes into account the\n     * height and position of the title, subtitle and footer, and the various paddings.\n     * @private\n     */\n    calculatePieCenter: function (pie) {\n      var pieCenterOffset = pie.options.misc.pieCenterOffset\n      var hasTopTitle = pie.textComponents.title.exists && pie.options.header.location !== 'pie-center'\n      var hasTopSubtitle = pie.textComponents.subtitle.exists && pie.options.header.location !== 'pie-center'\n\n      var headerOffset = pie.options.misc.canvasPadding.top\n      if (hasTopTitle && hasTopSubtitle) {\n        headerOffset +=\n          pie.textComponents.title.h + pie.options.header.titleSubtitlePadding + pie.textComponents.subtitle.h\n      } else if (hasTopTitle) {\n        headerOffset += pie.textComponents.title.h\n      } else if (hasTopSubtitle) {\n        headerOffset += pie.textComponents.subtitle.h\n      }\n\n      var footerOffset = 0\n      if (pie.textComponents.footer.exists) {\n        footerOffset = pie.textComponents.footer.h + pie.options.misc.canvasPadding.bottom\n      }\n\n      var x =\n        (pie.options.size.canvasWidth - pie.options.misc.canvasPadding.left - pie.options.misc.canvasPadding.right) /\n          2 +\n        pie.options.misc.canvasPadding.left\n      var y = (pie.options.size.canvasHeight - footerOffset - headerOffset) / 2 + headerOffset\n\n      x += pieCenterOffset.x\n      y += pieCenterOffset.y\n\n      pie.pieCenter = { x: x, y: y }\n    },\n\n    /**\n     * Rotates a point (x, y) around an axis (xm, ym) by degrees (a).\n     * @param x\n     * @param y\n     * @param xm\n     * @param ym\n     * @param a angle in degrees\n     * @returns {Array}\n     */\n    rotate: function (x, y, xm, ym, a) {\n      a = (a * Math.PI) / 180 // convert to radians\n\n      var cos = Math.cos,\n        sin = Math.sin,\n        // subtract midpoints, so that midpoint is translated to origin and add it in the end again\n        xr = (x - xm) * cos(a) - (y - ym) * sin(a) + xm,\n        yr = (x - xm) * sin(a) + (y - ym) * cos(a) + ym\n\n      return { x: xr, y: yr }\n    },\n\n    /**\n     * Translates a point x, y by distance d, and by angle a.\n     * @param x\n     * @param y\n     * @param dist\n     * @param a angle in degrees\n     */\n    translate: function (x, y, d, a) {\n      var rads = math.toRadians(a)\n      return {\n        x: x + d * Math.sin(rads),\n        y: y - d * Math.cos(rads)\n      }\n    },\n\n    // from: http://stackoverflow.com/questions/19792552/d3-put-arc-labels-in-a-pie-chart-if-there-is-enough-space\n    pointIsInArc: function (pt, ptData, d3Arc) {\n      // Center of the arc is assumed to be 0,0\n      // (pt.x, pt.y) are assumed to be relative to the center\n      var r1 = d3Arc.innerRadius()(ptData), // Note: Using the innerRadius\n        r2 = d3Arc.outerRadius()(ptData),\n        theta1 = d3Arc.startAngle()(ptData),\n        theta2 = d3Arc.endAngle()(ptData)\n\n      var dist = pt.x * pt.x + pt.y * pt.y,\n        angle = Math.atan2(pt.x, -pt.y) // Note: different coordinate system\n\n      angle = angle < 0 ? angle + Math.PI * 2 : angle\n\n      return r1 * r1 <= dist && dist <= r2 * r2 && theta1 <= angle && angle <= theta2\n    }\n  }\n\n  //// --------- labels.js -----------\n  var labels = {\n    /**\n     * Adds the labels to the pie chart, but doesn't position them. There are two locations for the\n     * labels: inside (center) of the segments, or outside the segments on the edge.\n     * @param section \"inner\" or \"outer\"\n     * @param sectionDisplayType \"percentage\", \"value\", \"label\", \"label-value1\", etc.\n     * @param pie\n     */\n    add: function (pie, section, sectionDisplayType) {\n      var include = labels.getIncludes(sectionDisplayType)\n      var settings = pie.options.labels\n\n      // group the label groups (label, percentage, value) into a single element for simpler positioning\n      var outerLabel = pie.svg\n        .insert('g', '.' + pie.cssPrefix + 'labels-' + section)\n        .attr('class', pie.cssPrefix + 'labels-' + section)\n\n      var labelGroup = outerLabel\n        .selectAll('.' + pie.cssPrefix + 'labelGroup-' + section)\n        .data(pie.options.data.content)\n        .enter()\n        .append('g')\n        .attr('id', function (d, i) {\n          return pie.cssPrefix + 'labelGroup' + i + '-' + section\n        })\n        .attr('data-index', function (d, i) {\n          return i\n        })\n        .attr('class', pie.cssPrefix + 'labelGroup-' + section)\n        .style('opacity', 0)\n\n      var formatterContext = { section: section, sectionDisplayType: sectionDisplayType }\n\n      // 1. Add the main label\n      if (include.mainLabel) {\n        labelGroup\n          .append('text')\n          .attr('id', function (d, i) {\n            return pie.cssPrefix + 'segmentMainLabel' + i + '-' + section\n          })\n          .attr('class', pie.cssPrefix + 'segmentMainLabel-' + section)\n          .text(function (d, i) {\n            var str = d.label\n\n            // if a custom formatter has been defined, pass it the raw label string - it can do whatever it wants with it.\n            // we only apply truncation if it's not defined\n            if (settings.formatter) {\n              formatterContext.index = i\n              formatterContext.part = 'mainLabel'\n              formatterContext.value = d.value\n              formatterContext.label = str\n              str = settings.formatter(formatterContext)\n            } else if (settings.truncation.enabled && d.label.length > settings.truncation.truncateLength) {\n              str = d.label.substring(0, settings.truncation.truncateLength) + '...'\n            }\n            return str\n          })\n          .style('font-size', settings.mainLabel.fontSize + 'px')\n          .style('font-family', settings.mainLabel.font)\n          .style('fill', settings.mainLabel.color)\n      }\n\n      // 2. Add the percentage label\n      if (include.percentage) {\n        labelGroup\n          .append('text')\n          .attr('id', function (d, i) {\n            return pie.cssPrefix + 'segmentPercentage' + i + '-' + section\n          })\n          .attr('class', pie.cssPrefix + 'segmentPercentage-' + section)\n          .text(function (d, i) {\n            var percentage = segments.getPercentage(pie, i, pie.options.labels.percentage.decimalPlaces)\n            if (settings.formatter) {\n              formatterContext.index = i\n              formatterContext.part = 'percentage'\n              formatterContext.value = d.value\n              formatterContext.label = percentage\n              percentage = settings.formatter(formatterContext)\n            } else {\n              percentage += '%'\n            }\n            return percentage\n          })\n          .style('font-size', settings.percentage.fontSize + 'px')\n          .style('font-family', settings.percentage.font)\n          .style('fill', settings.percentage.color)\n      }\n\n      // 3. Add the value label\n      if (include.value) {\n        labelGroup\n          .append('text')\n          .attr('id', function (d, i) {\n            return pie.cssPrefix + 'segmentValue' + i + '-' + section\n          })\n          .attr('class', pie.cssPrefix + 'segmentValue-' + section)\n          .text(function (d, i) {\n            formatterContext.index = i\n            formatterContext.part = 'value'\n            formatterContext.value = d.value\n            formatterContext.label = d.value\n            return settings.formatter ? settings.formatter(formatterContext, d.value) : d.value\n          })\n          .style('font-size', settings.value.fontSize + 'px')\n          .style('font-family', settings.value.font)\n          .style('fill', settings.value.color)\n      }\n    },\n\n    /**\n     * @param section \"inner\" / \"outer\"\n     */\n    positionLabelElements: function (pie, section, sectionDisplayType) {\n      labels['dimensions-' + section] = []\n\n      // get the latest widths, heights\n      var labelGroups = d3.selectAll('.' + pie.cssPrefix + 'labelGroup-' + section)\n      labelGroups.each(function (d, i) {\n        var mainLabel = d3.select(this).selectAll('.' + pie.cssPrefix + 'segmentMainLabel-' + section)\n        var percentage = d3.select(this).selectAll('.' + pie.cssPrefix + 'segmentPercentage-' + section)\n        var value = d3.select(this).selectAll('.' + pie.cssPrefix + 'segmentValue-' + section)\n\n        labels['dimensions-' + section].push({\n          mainLabel: mainLabel.node() !== null ? mainLabel.node().getBBox() : null,\n          percentage: percentage.node() !== null ? percentage.node().getBBox() : null,\n          value: value.node() !== null ? value.node().getBBox() : null\n        })\n      })\n\n      var singleLinePad = 5\n      var dims = labels['dimensions-' + section]\n      switch (sectionDisplayType) {\n        case 'label-value1':\n          d3.selectAll('.' + pie.cssPrefix + 'segmentValue-' + section).attr('dx', function (d, i) {\n            return dims[i].mainLabel.width + singleLinePad\n          })\n          break\n        case 'label-value2':\n          d3.selectAll('.' + pie.cssPrefix + 'segmentValue-' + section).attr('dy', function (d, i) {\n            return dims[i].mainLabel.height\n          })\n          break\n        case 'label-percentage1':\n          d3.selectAll('.' + pie.cssPrefix + 'segmentPercentage-' + section).attr('dx', function (d, i) {\n            return dims[i].mainLabel.width + singleLinePad\n          })\n          break\n        case 'label-percentage2':\n          d3.selectAll('.' + pie.cssPrefix + 'segmentPercentage-' + section)\n            .attr('dx', function (d, i) {\n              return dims[i].mainLabel.width / 2 - dims[i].percentage.width / 2\n            })\n            .attr('dy', function (d, i) {\n              return dims[i].mainLabel.height\n            })\n          break\n      }\n    },\n\n    computeLabelLinePositions: function (pie) {\n      pie.lineCoordGroups = []\n      d3.selectAll('.' + pie.cssPrefix + 'labelGroup-outer').each(function (d, i) {\n        return labels.computeLinePosition(pie, i)\n      })\n    },\n\n    computeLinePosition: function (pie, i) {\n      var angle = segments.getSegmentAngle(i, pie.options.data.content, pie.totalSize, { midpoint: true })\n      var originCoords = math.rotate(\n        pie.pieCenter.x,\n        pie.pieCenter.y - pie.outerRadius,\n        pie.pieCenter.x,\n        pie.pieCenter.y,\n        angle\n      )\n      var heightOffset = pie.outerLabelGroupData[i].h / 5 // TODO check\n      var labelXMargin = 6 // the x-distance of the label from the end of the line [TODO configurable]\n\n      var quarter = Math.floor(angle / 90)\n      var midPoint = 4\n      var x2, y2, x3, y3\n\n      // this resolves an issue when the\n      if (quarter === 2 && angle === 180) {\n        quarter = 1\n      }\n\n      switch (quarter) {\n        case 0:\n          x2 =\n            pie.outerLabelGroupData[i].x -\n            labelXMargin -\n            (pie.outerLabelGroupData[i].x - labelXMargin - originCoords.x) / 2\n          y2 = pie.outerLabelGroupData[i].y + (originCoords.y - pie.outerLabelGroupData[i].y) / midPoint\n          x3 = pie.outerLabelGroupData[i].x - labelXMargin\n          y3 = pie.outerLabelGroupData[i].y - heightOffset\n          break\n        case 1:\n          x2 = originCoords.x + (pie.outerLabelGroupData[i].x - originCoords.x) / midPoint\n          y2 = originCoords.y + (pie.outerLabelGroupData[i].y - originCoords.y) / midPoint\n          x3 = pie.outerLabelGroupData[i].x - labelXMargin\n          y3 = pie.outerLabelGroupData[i].y - heightOffset\n          break\n        case 2:\n          var startOfLabelX = pie.outerLabelGroupData[i].x + pie.outerLabelGroupData[i].w + labelXMargin\n          x2 = originCoords.x - (originCoords.x - startOfLabelX) / midPoint\n          y2 = originCoords.y + (pie.outerLabelGroupData[i].y - originCoords.y) / midPoint\n          x3 = pie.outerLabelGroupData[i].x + pie.outerLabelGroupData[i].w + labelXMargin\n          y3 = pie.outerLabelGroupData[i].y - heightOffset\n          break\n        case 3:\n          var startOfLabel = pie.outerLabelGroupData[i].x + pie.outerLabelGroupData[i].w + labelXMargin\n          x2 = startOfLabel + (originCoords.x - startOfLabel) / midPoint\n          y2 = pie.outerLabelGroupData[i].y + (originCoords.y - pie.outerLabelGroupData[i].y) / midPoint\n          x3 = pie.outerLabelGroupData[i].x + pie.outerLabelGroupData[i].w + labelXMargin\n          y3 = pie.outerLabelGroupData[i].y - heightOffset\n          break\n      }\n\n      /*\n       * x1 / y1: the x/y coords of the start of the line, at the mid point of the segments arc on the pie circumference\n       * x2 / y2: if \"curved\" line style is being used, this is the midpoint of the line. Other\n       * x3 / y3: the end of the line; closest point to the label\n       */\n      if (pie.options.labels.lines.style === 'straight') {\n        pie.lineCoordGroups[i] = [{ x: originCoords.x, y: originCoords.y }, { x: x3, y: y3 }]\n      } else {\n        pie.lineCoordGroups[i] = [{ x: originCoords.x, y: originCoords.y }, { x: x2, y: y2 }, { x: x3, y: y3 }]\n      }\n    },\n\n    addLabelLines: function (pie) {\n      var lineGroups = pie.svg\n        .insert('g', '.' + pie.cssPrefix + 'pieChart') // meaning, BEFORE .pieChart\n        .attr('class', pie.cssPrefix + 'lineGroups')\n        .style('opacity', 0)\n\n      var lineGroup = lineGroups\n        .selectAll('.' + pie.cssPrefix + 'lineGroup')\n        .data(pie.lineCoordGroups)\n        .enter()\n        .append('g')\n        .attr('class', pie.cssPrefix + 'lineGroup')\n\n      var lineFunction = d3.svg\n        .line()\n        .interpolate('basis')\n        .x(function (d) {\n          return d.x\n        })\n        .y(function (d) {\n          return d.y\n        })\n\n      lineGroup\n        .append('path')\n        .attr('d', lineFunction)\n        .attr('stroke', function (d, i) {\n          return pie.options.labels.lines.color === 'segment' ? pie.options.colors[i] : pie.options.labels.lines.color\n        })\n        .attr('stroke-width', 1)\n        .attr('fill', 'none')\n        .style('opacity', function (d, i) {\n          var percentage = pie.options.labels.outer.hideWhenLessThanPercentage\n          var segmentPercentage = segments.getPercentage(pie, i, pie.options.labels.percentage.decimalPlaces)\n          var isHidden =\n            (percentage !== null && segmentPercentage < percentage) || pie.options.data.content[i].label === ''\n          return isHidden ? 0 : 1\n        })\n    },\n\n    positionLabelGroups: function (pie, section) {\n      if (pie.options.labels[section].format === 'none') {\n        return\n      }\n\n      d3.selectAll('.' + pie.cssPrefix + 'labelGroup-' + section)\n        .style('opacity', 0)\n        .attr('transform', function (d, i) {\n          var x, y\n          if (section === 'outer') {\n            x = pie.outerLabelGroupData[i].x\n            y = pie.outerLabelGroupData[i].y\n          } else {\n            var pieCenterCopy = extend(true, {}, pie.pieCenter)\n\n            // now recompute the \"center\" based on the current _innerRadius\n            if (pie.innerRadius > 0) {\n              var angle = segments.getSegmentAngle(i, pie.options.data.content, pie.totalSize, { midpoint: true })\n              var newCoords = math.translate(pie.pieCenter.x, pie.pieCenter.y, pie.innerRadius, angle)\n              pieCenterCopy.x = newCoords.x\n              pieCenterCopy.y = newCoords.y\n            }\n\n            var dims = helpers.getDimensions(pie.cssPrefix + 'labelGroup' + i + '-inner')\n            var xOffset = dims.w / 2\n            var yOffset = dims.h / 4 // confusing! Why 4? should be 2, but it doesn't look right\n\n            x = pieCenterCopy.x + (pie.lineCoordGroups[i][0].x - pieCenterCopy.x) / 1.8\n            y = pieCenterCopy.y + (pie.lineCoordGroups[i][0].y - pieCenterCopy.y) / 1.8\n\n            x = x - xOffset\n            y = y + yOffset\n          }\n\n          return 'translate(' + x + ',' + y + ')'\n        })\n    },\n\n    fadeInLabelsAndLines: function (pie) {\n      // fade in the labels when the load effect is complete - or immediately if there's no load effect\n      var loadSpeed = pie.options.effects.load.effect === 'default' ? pie.options.effects.load.speed : 1\n      setTimeout(function () {\n        var labelFadeInTime = pie.options.effects.load.effect === 'default' ? 400 : 1 // 400 is hardcoded for the present\n\n        d3.selectAll('.' + pie.cssPrefix + 'labelGroup-outer')\n          .transition()\n          .duration(labelFadeInTime)\n          .style('opacity', function (d, i) {\n            var percentage = pie.options.labels.outer.hideWhenLessThanPercentage\n            var segmentPercentage = segments.getPercentage(pie, i, pie.options.labels.percentage.decimalPlaces)\n            return percentage !== null && segmentPercentage < percentage ? 0 : 1\n          })\n\n        d3.selectAll('.' + pie.cssPrefix + 'labelGroup-inner')\n          .transition()\n          .duration(labelFadeInTime)\n          .style('opacity', function (d, i) {\n            var percentage = pie.options.labels.inner.hideWhenLessThanPercentage\n            var segmentPercentage = segments.getPercentage(pie, i, pie.options.labels.percentage.decimalPlaces)\n            return percentage !== null && segmentPercentage < percentage ? 0 : 1\n          })\n\n        d3.selectAll('g.' + pie.cssPrefix + 'lineGroups')\n          .transition()\n          .duration(labelFadeInTime)\n          .style('opacity', 1)\n\n        // once everything's done loading, trigger the onload callback if defined\n        if (helpers.isFunction(pie.options.callbacks.onload)) {\n          setTimeout(function () {\n            try {\n              pie.options.callbacks.onload()\n            } catch (e) {}\n          }, labelFadeInTime)\n        }\n      }, loadSpeed)\n    },\n\n    getIncludes: function (val) {\n      var addMainLabel = false\n      var addValue = false\n      var addPercentage = false\n\n      switch (val) {\n        case 'label':\n          addMainLabel = true\n          break\n        case 'value':\n          addValue = true\n          break\n        case 'percentage':\n          addPercentage = true\n          break\n        case 'label-value1':\n        case 'label-value2':\n          addMainLabel = true\n          addValue = true\n          break\n        case 'label-percentage1':\n        case 'label-percentage2':\n          addMainLabel = true\n          addPercentage = true\n          break\n      }\n      return {\n        mainLabel: addMainLabel,\n        value: addValue,\n        percentage: addPercentage\n      }\n    },\n\n    /**\n     * This does the heavy-lifting to compute the actual coordinates for the outer label groups. It does two things:\n     * 1. Make a first pass and position them in the ideal positions, based on the pie sizes\n     * 2. Do some basic collision avoidance.\n     */\n    computeOuterLabelCoords: function (pie) {\n      // 1. figure out the ideal positions for the outer labels\n      pie.svg.selectAll('.' + pie.cssPrefix + 'labelGroup-outer').each(function (d, i) {\n        return labels.getIdealOuterLabelPositions(pie, i)\n      })\n\n      // 2. now adjust those positions to try to accommodate conflicts\n      labels.resolveOuterLabelCollisions(pie)\n    },\n\n    /**\n     * This attempts to resolve label positioning collisions.\n     */\n    resolveOuterLabelCollisions: function (pie) {\n      if (pie.options.labels.outer.format === 'none') {\n        return\n      }\n\n      var size = pie.options.data.content.length\n      labels.checkConflict(pie, 0, 'clockwise', size)\n      labels.checkConflict(pie, size - 1, 'anticlockwise', size)\n    },\n\n    checkConflict: function (pie, currIndex, direction, size) {\n      var i, curr\n\n      if (size <= 1) {\n        return\n      }\n\n      var currIndexHemisphere = pie.outerLabelGroupData[currIndex].hs\n      if (direction === 'clockwise' && currIndexHemisphere !== 'right') {\n        return\n      }\n      if (direction === 'anticlockwise' && currIndexHemisphere !== 'left') {\n        return\n      }\n      var nextIndex = direction === 'clockwise' ? currIndex + 1 : currIndex - 1\n\n      // this is the current label group being looked at. We KNOW it's positioned properly (the first item\n      // is always correct)\n      var currLabelGroup = pie.outerLabelGroupData[currIndex]\n\n      // this one we don't know about. That's the one we're going to look at and move if necessary\n      var examinedLabelGroup = pie.outerLabelGroupData[nextIndex]\n\n      var info = {\n        labelHeights: pie.outerLabelGroupData[0].h,\n        center: pie.pieCenter,\n        lineLength: pie.outerRadius + pie.options.labels.outer.pieDistance,\n        heightChange: pie.outerLabelGroupData[0].h + 1 // 1 = padding\n      }\n\n      // loop through *ALL* label groups examined so far to check for conflicts. This is because when they're\n      // very tightly fitted, a later label group may still appear high up on the page\n      if (direction === 'clockwise') {\n        i = 0\n        for (; i <= currIndex; i++) {\n          curr = pie.outerLabelGroupData[i]\n\n          // if there's a conflict with this label group, shift the label to be AFTER the last known\n          // one that's been properly placed\n          if (helpers.rectIntersect(curr, examinedLabelGroup)) {\n            labels.adjustLabelPos(pie, nextIndex, currLabelGroup, info)\n            break\n          }\n        }\n      } else {\n        i = size - 1\n        for (; i >= currIndex; i--) {\n          curr = pie.outerLabelGroupData[i]\n\n          // if there's a conflict with this label group, shift the label to be AFTER the last known\n          // one that's been properly placed\n          if (helpers.rectIntersect(curr, examinedLabelGroup)) {\n            labels.adjustLabelPos(pie, nextIndex, currLabelGroup, info)\n            break\n          }\n        }\n      }\n      labels.checkConflict(pie, nextIndex, direction, size)\n    },\n\n    // does a little math to shift a label into a new position based on the last properly placed one\n    adjustLabelPos: function (pie, nextIndex, lastCorrectlyPositionedLabel, info) {\n      var xDiff, yDiff, newXPos, newYPos\n      newYPos = lastCorrectlyPositionedLabel.y + info.heightChange\n      yDiff = info.center.y - newYPos\n\n      if (Math.abs(info.lineLength) > Math.abs(yDiff)) {\n        xDiff = Math.sqrt(info.lineLength * info.lineLength - yDiff * yDiff)\n      } else {\n        xDiff = Math.sqrt(yDiff * yDiff - info.lineLength * info.lineLength)\n      }\n\n      if (lastCorrectlyPositionedLabel.hs === 'right') {\n        newXPos = info.center.x + xDiff\n      } else {\n        newXPos = info.center.x - xDiff - pie.outerLabelGroupData[nextIndex].w\n      }\n\n      pie.outerLabelGroupData[nextIndex].x = newXPos\n      pie.outerLabelGroupData[nextIndex].y = newYPos\n    },\n\n    /**\n     * @param i 0-N where N is the dataset size - 1.\n     */\n    getIdealOuterLabelPositions: function (pie, i) {\n      var labelGroupNode = d3.select('#' + pie.cssPrefix + 'labelGroup' + i + '-outer').node()\n      if (!labelGroupNode) {\n        return\n      }\n      var labelGroupDims = labelGroupNode.getBBox()\n      var angle = segments.getSegmentAngle(i, pie.options.data.content, pie.totalSize, { midpoint: true })\n\n      var originalX = pie.pieCenter.x\n      var originalY = pie.pieCenter.y - (pie.outerRadius + pie.options.labels.outer.pieDistance)\n      var newCoords = math.rotate(originalX, originalY, pie.pieCenter.x, pie.pieCenter.y, angle)\n\n      // if the label is on the left half of the pie, adjust the values\n      var hemisphere = 'right' // hemisphere\n      if (angle > 180) {\n        newCoords.x -= labelGroupDims.width + 8\n        hemisphere = 'left'\n      } else {\n        newCoords.x += 8\n      }\n\n      pie.outerLabelGroupData[i] = {\n        x: newCoords.x,\n        y: newCoords.y,\n        w: labelGroupDims.width,\n        h: labelGroupDims.height,\n        hs: hemisphere\n      }\n    }\n  }\n\n  //// --------- segments.js -----------\n  var segments = {\n    /**\n     * Creates the pie chart segments and displays them according to the desired load effect.\n     * @private\n     */\n    create: function (pie) {\n      var pieCenter = pie.pieCenter\n      var colors = pie.options.colors\n      var loadEffects = pie.options.effects.load\n      var segmentStroke = pie.options.misc.colors.segmentStroke\n\n      // we insert the pie chart BEFORE the title, to ensure the title overlaps the pie\n      var pieChartElement = pie.svg\n        .insert('g', '#' + pie.cssPrefix + 'title')\n        .attr('transform', function () {\n          return math.getPieTranslateCenter(pieCenter)\n        })\n        .attr('class', pie.cssPrefix + 'pieChart')\n\n      var arc = d3.svg\n        .arc()\n        .innerRadius(pie.innerRadius)\n        .outerRadius(pie.outerRadius)\n        .startAngle(0)\n        .endAngle(function (d) {\n          return (d.value / pie.totalSize) * 2 * Math.PI\n        })\n\n      var g = pieChartElement\n        .selectAll('.' + pie.cssPrefix + 'arc')\n        .data(pie.options.data.content)\n        .enter()\n        .append('g')\n        .attr('class', pie.cssPrefix + 'arc')\n\n      // if we're not fading in the pie, just set the load speed to 0\n      var loadSpeed = loadEffects.speed\n      if (loadEffects.effect === 'none') {\n        loadSpeed = 0\n      }\n\n      g.append('path')\n        .attr('id', function (d, i) {\n          return pie.cssPrefix + 'segment' + i\n        })\n        .attr('fill', function (d, i) {\n          var color = colors[i]\n          if (pie.options.misc.gradient.enabled) {\n            color = 'url(#' + pie.cssPrefix + 'grad' + i + ')'\n          }\n          return color\n        })\n        .style('stroke', segmentStroke)\n        .style('stroke-width', 1)\n        .transition()\n        .ease('cubic-in-out')\n        .duration(loadSpeed)\n        .attr('data-index', function (d, i) {\n          return i\n        })\n        .attrTween('d', function (b) {\n          var i = d3.interpolate({ value: 0 }, b)\n          return function (t) {\n            return pie.arc(i(t))\n          }\n        })\n\n      pie.svg.selectAll('g.' + pie.cssPrefix + 'arc').attr('transform', function (d, i) {\n        var angle = 0\n        if (i > 0) {\n          angle = segments.getSegmentAngle(i - 1, pie.options.data.content, pie.totalSize)\n        }\n        return 'rotate(' + angle + ')'\n      })\n      pie.arc = arc\n    },\n\n    addGradients: function (pie) {\n      var grads = pie.svg\n        .append('defs')\n        .selectAll('radialGradient')\n        .data(pie.options.data.content)\n        .enter()\n        .append('radialGradient')\n        .attr('gradientUnits', 'userSpaceOnUse')\n        .attr('cx', 0)\n        .attr('cy', 0)\n        .attr('r', '120%')\n        .attr('id', function (d, i) {\n          return pie.cssPrefix + 'grad' + i\n        })\n\n      grads\n        .append('stop')\n        .attr('offset', '0%')\n        .style('stop-color', function (d, i) {\n          return pie.options.colors[i]\n        })\n      grads\n        .append('stop')\n        .attr('offset', pie.options.misc.gradient.percentage + '%')\n        .style('stop-color', pie.options.misc.gradient.color)\n    },\n\n    addSegmentEventHandlers: function (pie) {\n      var arc = d3.selectAll(\n        '.' + pie.cssPrefix + 'arc,.' + pie.cssPrefix + 'labelGroup-inner,.' + pie.cssPrefix + 'labelGroup-outer'\n      )\n\n      arc.on('click', function () {\n        var currentEl = d3.select(this)\n        var segment\n\n        // mouseover works on both the segments AND the segment labels, hence the following\n        if (currentEl.attr('class') === pie.cssPrefix + 'arc') {\n          segment = currentEl.select('path')\n        } else {\n          var index = currentEl.attr('data-index')\n          segment = d3.select('#' + pie.cssPrefix + 'segment' + index)\n        }\n        var isExpanded = segment.attr('class') === pie.cssPrefix + 'expanded'\n        segments.onSegmentEvent(pie, pie.options.callbacks.onClickSegment, segment, isExpanded)\n        if (pie.options.effects.pullOutSegmentOnClick.effect !== 'none') {\n          if (isExpanded) {\n            segments.closeSegment(pie, segment.node())\n          } else {\n            segments.openSegment(pie, segment.node())\n          }\n        }\n      })\n\n      arc.on('mouseover', function () {\n        var currentEl = d3.select(this)\n        var segment, index\n\n        if (currentEl.attr('class') === pie.cssPrefix + 'arc') {\n          segment = currentEl.select('path')\n        } else {\n          index = currentEl.attr('data-index')\n          segment = d3.select('#' + pie.cssPrefix + 'segment' + index)\n        }\n\n        if (pie.options.effects.highlightSegmentOnMouseover) {\n          index = segment.attr('data-index')\n          var segColor = pie.options.colors[index]\n          segment.style('fill', helpers.getColorShade(segColor, pie.options.effects.highlightLuminosity))\n        }\n\n        if (pie.options.tooltips.enabled) {\n          index = segment.attr('data-index')\n          tt.showTooltip(pie, index)\n        }\n\n        var isExpanded = segment.attr('class') === pie.cssPrefix + 'expanded'\n        segments.onSegmentEvent(pie, pie.options.callbacks.onMouseoverSegment, segment, isExpanded)\n      })\n\n      arc.on('mousemove', function () {\n        tt.moveTooltip(pie)\n      })\n\n      arc.on('mouseout', function () {\n        var currentEl = d3.select(this)\n        var segment, index\n\n        if (currentEl.attr('class') === pie.cssPrefix + 'arc') {\n          segment = currentEl.select('path')\n        } else {\n          index = currentEl.attr('data-index')\n          segment = d3.select('#' + pie.cssPrefix + 'segment' + index)\n        }\n\n        if (pie.options.effects.highlightSegmentOnMouseover) {\n          index = segment.attr('data-index')\n          var color = pie.options.colors[index]\n          if (pie.options.misc.gradient.enabled) {\n            color = 'url(#' + pie.cssPrefix + 'grad' + index + ')'\n          }\n          segment.style('fill', color)\n        }\n\n        if (pie.options.tooltips.enabled) {\n          index = segment.attr('data-index')\n          tt.hideTooltip(pie, index)\n        }\n\n        var isExpanded = segment.attr('class') === pie.cssPrefix + 'expanded'\n        segments.onSegmentEvent(pie, pie.options.callbacks.onMouseoutSegment, segment, isExpanded)\n      })\n    },\n\n    // helper function used to call the click, mouseover, mouseout segment callback functions\n    onSegmentEvent: function (pie, func, segment, isExpanded) {\n      if (!helpers.isFunction(func)) {\n        return\n      }\n      var index = parseInt(segment.attr('data-index'), 10)\n      func({\n        segment: segment.node(),\n        index: index,\n        expanded: isExpanded,\n        data: pie.options.data.content[index]\n      })\n    },\n\n    openSegment: function (pie, segment) {\n      if (pie.isOpeningSegment) {\n        return\n      }\n      pie.isOpeningSegment = true\n\n      // close any open segments\n      if (d3.selectAll('.' + pie.cssPrefix + 'expanded').length > 0) {\n        segments.closeSegment(pie, d3.select('.' + pie.cssPrefix + 'expanded').node())\n      }\n\n      d3.select(segment)\n        .transition()\n        .ease(pie.options.effects.pullOutSegmentOnClick.effect)\n        .duration(pie.options.effects.pullOutSegmentOnClick.speed)\n        .attr('transform', function (d, i) {\n          var c = pie.arc.centroid(d),\n            x = c[0],\n            y = c[1],\n            h = Math.sqrt(x * x + y * y),\n            pullOutSize = parseInt(pie.options.effects.pullOutSegmentOnClick.size, 10)\n\n          return 'translate(' + (x / h) * pullOutSize + ',' + (y / h) * pullOutSize + ')'\n        })\n        .each('end', function (d, i) {\n          pie.currentlyOpenSegment = segment\n          pie.isOpeningSegment = false\n          d3.select(this).attr('class', pie.cssPrefix + 'expanded')\n        })\n    },\n\n    closeSegment: function (pie, segment) {\n      d3.select(segment)\n        .transition()\n        .duration(400)\n        .attr('transform', 'translate(0,0)')\n        .each('end', function (d, i) {\n          d3.select(this).attr('class', '')\n          pie.currentlyOpenSegment = null\n        })\n    },\n\n    getCentroid: function (el) {\n      var bbox = el.getBBox()\n      return {\n        x: bbox.x + bbox.width / 2,\n        y: bbox.y + bbox.height / 2\n      }\n    },\n\n    /**\n     * General helper function to return a segment's angle, in various different ways.\n     * @param index\n     * @param opts optional object for fine-tuning exactly what you want.\n     */\n    getSegmentAngle: function (index, data, totalSize, opts) {\n      var options = extend(\n        {\n          // if true, this returns the full angle from the origin. Otherwise it returns the single segment angle\n          compounded: true,\n\n          // optionally returns the midpoint of the angle instead of the full angle\n          midpoint: false\n        },\n        opts\n      )\n\n      var currValue = data[index].value\n      var fullValue\n      if (options.compounded) {\n        fullValue = 0\n\n        // get all values up to and including the specified index\n        for (var i = 0; i <= index; i++) {\n          fullValue += data[i].value\n        }\n      }\n\n      if (typeof fullValue === 'undefined') {\n        fullValue = currValue\n      }\n\n      // now convert the full value to an angle\n      var angle = (fullValue / totalSize) * 360\n\n      // lastly, if we want the midpoint, factor that sucker in\n      if (options.midpoint) {\n        var currAngle = (currValue / totalSize) * 360\n        angle -= currAngle / 2\n      }\n\n      return angle\n    },\n\n    getPercentage: function (pie, index, decimalPlaces) {\n      var relativeAmount = pie.options.data.content[index].value / pie.totalSize\n      if (decimalPlaces <= 0) {\n        return Math.round(relativeAmount * 100)\n      } else {\n        return (relativeAmount * 100).toFixed(decimalPlaces)\n      }\n    }\n  }\n\n  //// --------- text.js -----------\n  var text = {\n    offscreenCoord: -10000,\n\n    addTitle: function (pie) {\n      var title = pie.svg\n        .selectAll('.' + pie.cssPrefix + 'title')\n        .data([pie.options.header.title])\n        .enter()\n        .append('text')\n        .text(function (d) {\n          return d.text\n        })\n        .attr({\n          id: pie.cssPrefix + 'title',\n          class: pie.cssPrefix + 'title',\n          x: text.offscreenCoord,\n          y: text.offscreenCoord\n        })\n        .attr('text-anchor', function () {\n          var location\n          if (pie.options.header.location === 'top-center' || pie.options.header.location === 'pie-center') {\n            location = 'middle'\n          } else {\n            location = 'left'\n          }\n          return location\n        })\n        .attr('fill', function (d) {\n          return d.color\n        })\n        .style('font-size', function (d) {\n          return d.fontSize + 'px'\n        })\n        .style('font-family', function (d) {\n          return d.font\n        })\n    },\n\n    positionTitle: function (pie) {\n      var textComponents = pie.textComponents\n      var headerLocation = pie.options.header.location\n      var canvasPadding = pie.options.misc.canvasPadding\n      var canvasWidth = pie.options.size.canvasWidth\n      var titleSubtitlePadding = pie.options.header.titleSubtitlePadding\n\n      var x\n      if (headerLocation === 'top-left') {\n        x = canvasPadding.left\n      } else {\n        x = (canvasWidth - canvasPadding.right) / 2 + canvasPadding.left\n      }\n\n      // add whatever offset has been added by user\n      x += pie.options.misc.pieCenterOffset.x\n\n      var y = canvasPadding.top + textComponents.title.h\n\n      if (headerLocation === 'pie-center') {\n        y = pie.pieCenter.y\n\n        // still not fully correct\n        if (textComponents.subtitle.exists) {\n          var totalTitleHeight = textComponents.title.h + titleSubtitlePadding + textComponents.subtitle.h\n          y = y - totalTitleHeight / 2 + textComponents.title.h\n        } else {\n          y += textComponents.title.h / 4\n        }\n      }\n\n      pie.svg\n        .select('#' + pie.cssPrefix + 'title')\n        .attr('x', x)\n        .attr('y', y)\n    },\n\n    addSubtitle: function (pie) {\n      var headerLocation = pie.options.header.location\n\n      pie.svg\n        .selectAll('.' + pie.cssPrefix + 'subtitle')\n        .data([pie.options.header.subtitle])\n        .enter()\n        .append('text')\n        .text(function (d) {\n          return d.text\n        })\n        .attr('x', text.offscreenCoord)\n        .attr('y', text.offscreenCoord)\n        .attr('id', pie.cssPrefix + 'subtitle')\n        .attr('class', pie.cssPrefix + 'subtitle')\n        .attr('text-anchor', function () {\n          var location\n          if (headerLocation === 'top-center' || headerLocation === 'pie-center') {\n            location = 'middle'\n          } else {\n            location = 'left'\n          }\n          return location\n        })\n        .attr('fill', function (d) {\n          return d.color\n        })\n        .style('font-size', function (d) {\n          return d.fontSize + 'px'\n        })\n        .style('font-family', function (d) {\n          return d.font\n        })\n    },\n\n    positionSubtitle: function (pie) {\n      var canvasPadding = pie.options.misc.canvasPadding\n      var canvasWidth = pie.options.size.canvasWidth\n\n      var x\n      if (pie.options.header.location === 'top-left') {\n        x = canvasPadding.left\n      } else {\n        x = (canvasWidth - canvasPadding.right) / 2 + canvasPadding.left\n      }\n\n      // add whatever offset has been added by user\n      x += pie.options.misc.pieCenterOffset.x\n\n      var y = text.getHeaderHeight(pie)\n      pie.svg\n        .select('#' + pie.cssPrefix + 'subtitle')\n        .attr('x', x)\n        .attr('y', y)\n    },\n\n    addFooter: function (pie) {\n      pie.svg\n        .selectAll('.' + pie.cssPrefix + 'footer')\n        .data([pie.options.footer])\n        .enter()\n        .append('text')\n        .text(function (d) {\n          return d.text\n        })\n        .attr('x', text.offscreenCoord)\n        .attr('y', text.offscreenCoord)\n        .attr('id', pie.cssPrefix + 'footer')\n        .attr('class', pie.cssPrefix + 'footer')\n        .attr('text-anchor', function () {\n          var location = 'left'\n          if (pie.options.footer.location === 'bottom-center') {\n            location = 'middle'\n          } else if (pie.options.footer.location === 'bottom-right') {\n            location = 'left' // on purpose. We have to change the x-coord to make it properly right-aligned\n          }\n          return location\n        })\n        .attr('fill', function (d) {\n          return d.color\n        })\n        .style('font-size', function (d) {\n          return d.fontSize + 'px'\n        })\n        .style('font-family', function (d) {\n          return d.font\n        })\n    },\n\n    positionFooter: function (pie) {\n      var footerLocation = pie.options.footer.location\n      var footerWidth = pie.textComponents.footer.w\n      var canvasWidth = pie.options.size.canvasWidth\n      var canvasHeight = pie.options.size.canvasHeight\n      var canvasPadding = pie.options.misc.canvasPadding\n\n      var x\n      if (footerLocation === 'bottom-left') {\n        x = canvasPadding.left\n      } else if (footerLocation === 'bottom-right') {\n        x = canvasWidth - footerWidth - canvasPadding.right\n      } else {\n        x = canvasWidth / 2 // TODO - shouldn't this also take into account padding?\n      }\n\n      pie.svg\n        .select('#' + pie.cssPrefix + 'footer')\n        .attr('x', x)\n        .attr('y', canvasHeight - canvasPadding.bottom)\n    },\n\n    getHeaderHeight: function (pie) {\n      var h\n      if (pie.textComponents.title.exists) {\n        // if the subtitle isn't defined, it'll be set to 0\n        var totalTitleHeight =\n          pie.textComponents.title.h + pie.options.header.titleSubtitlePadding + pie.textComponents.subtitle.h\n        if (pie.options.header.location === 'pie-center') {\n          h = pie.pieCenter.y - totalTitleHeight / 2 + totalTitleHeight\n        } else {\n          h = totalTitleHeight + pie.options.misc.canvasPadding.top\n        }\n      } else {\n        if (pie.options.header.location === 'pie-center') {\n          var footerPlusPadding = pie.options.misc.canvasPadding.bottom + pie.textComponents.footer.h\n          h =\n            (pie.options.size.canvasHeight - footerPlusPadding) / 2 +\n            pie.options.misc.canvasPadding.top +\n            pie.textComponents.subtitle.h / 2\n        } else {\n          h = pie.options.misc.canvasPadding.top + pie.textComponents.subtitle.h\n        }\n      }\n      return h\n    }\n  }\n\n  //// --------- validate.js -----------\n  var tt = {\n    addTooltips: function (pie) {\n      // group the label groups (label, percentage, value) into a single element for simpler positioning\n      var tooltips = pie.svg.insert('g').attr('class', pie.cssPrefix + 'tooltips')\n\n      tooltips\n        .selectAll('.' + pie.cssPrefix + 'tooltip')\n        .data(pie.options.data.content)\n        .enter()\n        .append('g')\n        .attr('class', pie.cssPrefix + 'tooltip')\n        .attr('id', function (d, i) {\n          return pie.cssPrefix + 'tooltip' + i\n        })\n        .style('opacity', 0)\n        .append('rect')\n        .attr({\n          rx: pie.options.tooltips.styles.borderRadius,\n          ry: pie.options.tooltips.styles.borderRadius,\n          x: -pie.options.tooltips.styles.padding,\n          opacity: pie.options.tooltips.styles.backgroundOpacity\n        })\n        .style('fill', pie.options.tooltips.styles.backgroundColor)\n\n      tooltips\n        .selectAll('.' + pie.cssPrefix + 'tooltip')\n        .data(pie.options.data.content)\n        .append('text')\n        .attr('fill', function (d) {\n          return pie.options.tooltips.styles.color\n        })\n        .style('font-size', function (d) {\n          return pie.options.tooltips.styles.fontSize\n        })\n        .style('font-family', function (d) {\n          return pie.options.tooltips.styles.font\n        })\n        .text(function (d, i) {\n          var caption = pie.options.tooltips.string\n          if (pie.options.tooltips.type === 'caption') {\n            caption = d.caption\n          }\n          return tt.replacePlaceholders(pie, caption, i, {\n            label: d.label,\n            value: d.value,\n            percentage: segments.getPercentage(pie, i, pie.options.labels.percentage.decimalPlaces)\n          })\n        })\n\n      tooltips.selectAll('.' + pie.cssPrefix + 'tooltip rect').attr({\n        width: function (d, i) {\n          var dims = helpers.getDimensions(pie.cssPrefix + 'tooltip' + i)\n          return dims.w + 2 * pie.options.tooltips.styles.padding\n        },\n        height: function (d, i) {\n          var dims = helpers.getDimensions(pie.cssPrefix + 'tooltip' + i)\n          return dims.h + 2 * pie.options.tooltips.styles.padding\n        },\n        y: function (d, i) {\n          var dims = helpers.getDimensions(pie.cssPrefix + 'tooltip' + i)\n          return -(dims.h / 2) + 1\n        }\n      })\n    },\n\n    showTooltip: function (pie, index) {\n      var fadeInSpeed = pie.options.tooltips.styles.fadeInSpeed\n      if (tt.currentTooltip === index) {\n        fadeInSpeed = 1\n      }\n\n      tt.currentTooltip = index\n      d3.select('#' + pie.cssPrefix + 'tooltip' + index)\n        .transition()\n        .duration(fadeInSpeed)\n        .style('opacity', function () {\n          return 1\n        })\n\n      tt.moveTooltip(pie)\n    },\n\n    moveTooltip: function (pie) {\n      d3.selectAll('#' + pie.cssPrefix + 'tooltip' + tt.currentTooltip).attr('transform', function (d) {\n        var mouseCoords = d3.mouse(this.parentNode)\n        var x = mouseCoords[0] + pie.options.tooltips.styles.padding + 2\n        var y = mouseCoords[1] - 2 * pie.options.tooltips.styles.padding - 2\n        return 'translate(' + x + ',' + y + ')'\n      })\n    },\n\n    hideTooltip: function (pie, index) {\n      d3.select('#' + pie.cssPrefix + 'tooltip' + index).style('opacity', function () {\n        return 0\n      })\n\n      // move the tooltip offscreen. This ensures that when the user next mouseovers the segment the hidden\n      // element won't interfere\n      d3.select('#' + pie.cssPrefix + 'tooltip' + tt.currentTooltip).attr('transform', function (d, i) {\n        // klutzy, but it accounts for tooltip padding which could push it onscreen\n        var x = pie.options.size.canvasWidth + 1000\n        var y = pie.options.size.canvasHeight + 1000\n        return 'translate(' + x + ',' + y + ')'\n      })\n    },\n\n    replacePlaceholders: function (pie, str, index, replacements) {\n      // if the user has defined a placeholderParser function, call it before doing the replacements\n      if (helpers.isFunction(pie.options.tooltips.placeholderParser)) {\n        pie.options.tooltips.placeholderParser(index, replacements)\n      }\n\n      var replacer = function () {\n        return function (match) {\n          var placeholder = arguments[1]\n          if (replacements.hasOwnProperty(placeholder)) {\n            return replacements[arguments[1]]\n          } else {\n            return arguments[0]\n          }\n        }\n      }\n      return str.replace(/\\{(\\w+)\\}/g, replacer(replacements))\n    }\n  }\n\n  // --------------------------------------------------------------------------------------------\n\n  // our constructor\n  var d3pie = function (element, options) {\n    // element can be an ID or DOM element\n    this.element = element\n    if (typeof element === 'string') {\n      var el = element.replace(/^#/, '') // replace any jQuery-like ID hash char\n      this.element = document.getElementById(el)\n    }\n\n    var opts = {}\n    extend(true, opts, defaultSettings, options)\n    this.options = opts\n\n    // if the user specified a custom CSS element prefix (ID, class), use it\n    if (this.options.misc.cssPrefix !== null) {\n      this.cssPrefix = this.options.misc.cssPrefix\n    } else {\n      this.cssPrefix = 'p' + _uniqueIDCounter + '_'\n      _uniqueIDCounter++\n    }\n\n    // now run some validation on the user-defined info\n    if (!validate.initialCheck(this)) {\n      return\n    }\n\n    // add a data-role to the DOM node to let anyone know that it contains a d3pie instance, and the d3pie version\n    d3.select(this.element).attr(_scriptName, _version)\n\n    // things that are done once\n    this.options.data.content = math.sortPieData(this)\n    if (this.options.data.smallSegmentGrouping.enabled) {\n      this.options.data.content = helpers.applySmallSegmentGrouping(\n        this.options.data.content,\n        this.options.data.smallSegmentGrouping\n      )\n    }\n    this.options.colors = helpers.initSegmentColors(this)\n    this.totalSize = math.getTotalPieSize(this.options.data.content)\n\n    _init.call(this)\n  }\n\n  d3pie.prototype.recreate = function () {\n    // now run some validation on the user-defined info\n    if (!validate.initialCheck(this)) {\n      return\n    }\n    this.options.data.content = math.sortPieData(this)\n    if (this.options.data.smallSegmentGrouping.enabled) {\n      this.options.data.content = helpers.applySmallSegmentGrouping(\n        this.options.data.content,\n        this.options.data.smallSegmentGrouping\n      )\n    }\n    this.options.colors = helpers.initSegmentColors(this)\n    this.totalSize = math.getTotalPieSize(this.options.data.content)\n\n    _init.call(this)\n  }\n\n  d3pie.prototype.redraw = function () {\n    this.element.innerHTML = ''\n    _init.call(this)\n  }\n\n  d3pie.prototype.destroy = function () {\n    this.element.innerHTML = '' // clear out the SVG\n    d3.select(this.element).attr(_scriptName, null) // remove the data attr\n  }\n\n  /**\n   * Returns all pertinent info about the current open info. Returns null if nothing's open, or if one is, an object of\n   * the following form:\n   * \t{\n   * \t  element: DOM NODE,\n   * \t  index: N,\n   * \t  data: {}\n   * \t}\n   */\n  d3pie.prototype.getOpenSegment = function () {\n    var segment = this.currentlyOpenSegment\n    if (segment !== null && typeof segment !== 'undefined') {\n      var index = parseInt(d3.select(segment).attr('data-index'), 10)\n      return {\n        element: segment,\n        index: index,\n        data: this.options.data.content[index]\n      }\n    } else {\n      return null\n    }\n  }\n\n  d3pie.prototype.openSegment = function (index) {\n    index = parseInt(index, 10)\n    if (index < 0 || index > this.options.data.content.length - 1) {\n      return\n    }\n    segments.openSegment(this, d3.select('#' + this.cssPrefix + 'segment' + index).node())\n  }\n\n  d3pie.prototype.closeSegment = function () {\n    var segment = this.currentlyOpenSegment\n    if (segment) {\n      segments.closeSegment(this, segment)\n    }\n  }\n\n  // this let's the user dynamically update aspects of the pie chart without causing a complete redraw. It\n  // intelligently re-renders only the part of the pie that the user specifies. Some things cause a repaint, others\n  // just redraw the single element\n  d3pie.prototype.updateProp = function (propKey, value) {\n    switch (propKey) {\n      case 'header.title.text':\n        var oldVal = helpers.processObj(this.options, propKey)\n        helpers.processObj(this.options, propKey, value)\n        d3.select('#' + this.cssPrefix + 'title').html(value)\n        if ((oldVal === '' && value !== '') || (oldVal !== '' && value === '')) {\n          this.redraw()\n        }\n        break\n\n      case 'header.subtitle.text':\n        var oldValue = helpers.processObj(this.options, propKey)\n        helpers.processObj(this.options, propKey, value)\n        d3.select('#' + this.cssPrefix + 'subtitle').html(value)\n        if ((oldValue === '' && value !== '') || (oldValue !== '' && value === '')) {\n          this.redraw()\n        }\n        break\n\n      case 'callbacks.onload':\n      case 'callbacks.onMouseoverSegment':\n      case 'callbacks.onMouseoutSegment':\n      case 'callbacks.onClickSegment':\n      case 'effects.pullOutSegmentOnClick.effect':\n      case 'effects.pullOutSegmentOnClick.speed':\n      case 'effects.pullOutSegmentOnClick.size':\n      case 'effects.highlightSegmentOnMouseover':\n      case 'effects.highlightLuminosity':\n        helpers.processObj(this.options, propKey, value)\n        break\n\n      // everything else, attempt to update it & do a repaint\n      default:\n        helpers.processObj(this.options, propKey, value)\n\n        this.destroy()\n        this.recreate()\n        break\n    }\n  }\n\n  // ------------------------------------------------------------------------------------------------\n\n  var _init = function () {\n    // prep-work\n    this.svg = helpers.addSVGSpace(this)\n\n    // store info about the main text components as part of the d3pie object instance\n    this.textComponents = {\n      headerHeight: 0,\n      title: {\n        exists: this.options.header.title.text !== '',\n        h: 0,\n        w: 0\n      },\n      subtitle: {\n        exists: this.options.header.subtitle.text !== '',\n        h: 0,\n        w: 0\n      },\n      footer: {\n        exists: this.options.footer.text !== '',\n        h: 0,\n        w: 0\n      }\n    }\n\n    this.outerLabelGroupData = []\n\n    // add the key text components offscreen (title, subtitle, footer). We need to know their widths/heights for later computation\n    if (this.textComponents.title.exists) {\n      text.addTitle(this)\n    }\n    if (this.textComponents.subtitle.exists) {\n      text.addSubtitle(this)\n    }\n    text.addFooter(this)\n\n    // the footer never moves. Put it in place now\n    var self = this\n    helpers.whenIdExists(this.cssPrefix + 'footer', function () {\n      text.positionFooter(self)\n      var d3 = helpers.getDimensions(self.cssPrefix + 'footer')\n      self.textComponents.footer.h = d3.h\n      self.textComponents.footer.w = d3.w\n    })\n\n    // now create the pie chart and position everything accordingly\n    var reqEls = []\n    if (this.textComponents.title.exists) {\n      reqEls.push(this.cssPrefix + 'title')\n    }\n    if (this.textComponents.subtitle.exists) {\n      reqEls.push(this.cssPrefix + 'subtitle')\n    }\n    if (this.textComponents.footer.exists) {\n      reqEls.push(this.cssPrefix + 'footer')\n    }\n\n    helpers.whenElementsExist(reqEls, function () {\n      if (self.textComponents.title.exists) {\n        var d1 = helpers.getDimensions(self.cssPrefix + 'title')\n        self.textComponents.title.h = d1.h\n        self.textComponents.title.w = d1.w\n      }\n      if (self.textComponents.subtitle.exists) {\n        var d2 = helpers.getDimensions(self.cssPrefix + 'subtitle')\n        self.textComponents.subtitle.h = d2.h\n        self.textComponents.subtitle.w = d2.w\n      }\n      // now compute the full header height\n      if (self.textComponents.title.exists || self.textComponents.subtitle.exists) {\n        var headerHeight = 0\n        if (self.textComponents.title.exists) {\n          headerHeight += self.textComponents.title.h\n          if (self.textComponents.subtitle.exists) {\n            headerHeight += self.options.header.titleSubtitlePadding\n          }\n        }\n        if (self.textComponents.subtitle.exists) {\n          headerHeight += self.textComponents.subtitle.h\n        }\n        self.textComponents.headerHeight = headerHeight\n      }\n\n      // at this point, all main text component dimensions have been calculated\n      math.computePieRadius(self)\n\n      // this value is used all over the place for placing things and calculating locations. We figure it out ONCE\n      // and store it as part of the object\n      math.calculatePieCenter(self)\n\n      // position the title and subtitle\n      text.positionTitle(self)\n      text.positionSubtitle(self)\n\n      // now create the pie chart segments, and gradients if the user desired\n      if (self.options.misc.gradient.enabled) {\n        segments.addGradients(self)\n      }\n      segments.create(self) // also creates this.arc\n      labels.add(self, 'inner', self.options.labels.inner.format)\n      labels.add(self, 'outer', self.options.labels.outer.format)\n\n      // position the label elements relatively within their individual group (label, percentage, value)\n      labels.positionLabelElements(self, 'inner', self.options.labels.inner.format)\n      labels.positionLabelElements(self, 'outer', self.options.labels.outer.format)\n      labels.computeOuterLabelCoords(self)\n\n      // this is (and should be) dumb. It just places the outer groups at their calculated, collision-free positions\n      labels.positionLabelGroups(self, 'outer')\n\n      // we use the label line positions for many other calculations, so ALWAYS compute them\n      labels.computeLabelLinePositions(self)\n\n      // only add them if they're actually enabled\n      if (self.options.labels.lines.enabled && self.options.labels.outer.format !== 'none') {\n        labels.addLabelLines(self)\n      }\n\n      labels.positionLabelGroups(self, 'inner')\n      labels.fadeInLabelsAndLines(self)\n\n      // add and position the tooltips\n      if (self.options.tooltips.enabled) {\n        tt.addTooltips(self)\n      }\n\n      segments.addSegmentEventHandlers(self)\n    })\n  }\n\n  return d3pie\n})\n\n\n//# sourceURL=webpack:///./src/public/js/vendor/d3pie/d3pie.min.js?");

/***/ }),

/***/ "./src/public/js/vendor/datatables/dataTables.grouping.js":
/*!****************************************************************!*\
  !*** ./src/public/js/vendor/datatables/dataTables.grouping.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(jQuery) {/*\n * File:        jquery.dataTables.grouping.js\n * Version:     1.2.9.\n * Author:      Jovan Popovic\n *\n * Copyright 2013 Jovan Popovic, all rights reserved.\n *\n * This source file is free software, under either the GPL v2 license or a\n * BSD style license, as supplied with this software.\n *\n * This source file is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE.\n * Parameters:\n * @iGroupingColumnIndex                                 Integer             Index of the column that will be used for grouping - default 0\n * @sGroupingColumnSortDirection                         Enumeration         Sort direction of the group\n * @iGroupingOrderByColumnIndex                          Integer             Index of the column that will be used for ordering groups\n * @sGroupingClass                                       String              Class that will be associated to the group row. Default - \"group\"\n * @sGroupItemClass                                      String              Class that will be associated to the group row of group items. Default - \"group-item\"\n * @bSetGroupingClassOnTR                                Boolean             If set class will be set to the TR instead of the TD withing the grouping TR\n * @bHideGroupingColumn                                  Boolean             Hide column used for grouping once results are grouped. Default - true\n * @bHideGroupingOrderByColumn                           Boolean             Hide column used for ordering groups once results are grouped. Default - true\n * @sGroupBy                                             Enumeration         Type of grouping that should be applied. Values \"name\"(default), \"letter\", \"year\"\n * @sGroupLabelPrefix                                    String              Prefix that will be added to each group cell\n * @bExpandableGrouping                                  Boolean             Attach expand/collapse handlers to the grouping rows\n * @bExpandSingleGroup                                   Boolean             Use accordon grouping\n * @iExpandGroupOffset                                   Integer             Number of pixels to set scroll position above the currently selected group. If -1 scroll will be alligned to the table\n * General settings\n * @sDateFormat: \"dd/MM/yyyy\"                            String              Date format used for grouping\n * @sEmptyGroupLabel                                     String              Lable that will be placed as group if grouping cells are empty. Default \"-\"\n\n * Parameters used in the second level grouping\n * @iGroupingColumnIndex2                                Integer             Index of the secondary column that will be used for grouping - default 0\n * @sGroupingColumnSortDirection2                        Enumeration         Sort direction of the secondary group\n * @iGroupingOrderByColumnIndex2                         Integer             Index of the column that will be used for ordering secondary groups\n * @sGroupingClass2                                      String              Class that will be associated to the secondary group row. Default \"subgroup\"\n * @sGroupItemClass2                                     String              Class that will be associated to the secondary group row of group items. Default \"subgroup-item\"\n * @bHideGroupingColumn2                                 Boolean             Hide column used for secondary grouping once results are grouped. Default - true,\n * @bHideGroupingOrderByColumn2                          Boolean             Hide column used for ordering secondary groups once results are grouped. Default - true,\n * @sGroupBy2                                            Enumeration         Type of grouping that should be applied to secondary column. Values \"name\"(default), \"letter\", \"year\",\n * @sGroupLabelPrefix2                                   String              Prefix that will be added to each secondary group cell\n * @fnOnGrouped                                          Function            Function that is called when grouping is finished. Function has no parameters.\n */\n;(function (a) {\n  a.fn.rowGrouping = function (e) {\n    function b () {}\n    function c (j, h, i) {}\n    function d (j, h, i) {}\n    function g (i) {\n      var h = [\n        'January',\n        'February',\n        'March',\n        'April',\n        'May',\n        'June',\n        'July',\n        'August',\n        'September',\n        'October',\n        'November',\n        'December'\n      ]\n      return h[i - 1]\n    }\n    var f = {\n      iGroupingColumnIndex: 0,\n      sGroupingColumnSortDirection: '',\n      iGroupingOrderByColumnIndex: -1,\n      sGroupingClass: 'group',\n      sGroupItemClass: 'group-item',\n      bHideGroupingColumn: true,\n      bHideGroupingOrderByColumn: true,\n      sGroupBy: 'name',\n      sGroupLabelPrefix: '',\n      fnGroupLabelFormat: function (h) {\n        return h\n      },\n      bExpandableGrouping: false,\n      bExpandSingleGroup: false,\n      iExpandGroupOffset: 100,\n      asExpandedGroups: null,\n      sDateFormat: 'dd/MM/yyyy',\n      sEmptyGroupLabel: '-',\n      bSetGroupingClassOnTR: false,\n      iGroupingColumnIndex2: -1,\n      sGroupingColumnSortDirection2: '',\n      iGroupingOrderByColumnIndex2: -1,\n      sGroupingClass2: 'subgroup',\n      sGroupItemClass2: 'subgroup-item',\n      bHideGroupingColumn2: true,\n      bHideGroupingOrderByColumn2: true,\n      sGroupBy2: 'name',\n      sGroupLabelPrefix2: '',\n      fnGroupLabelFormat2: function (h) {\n        return h\n      },\n      bExpandableGrouping2: false,\n      fnOnGrouped: b,\n      fnOnGroupCreated: c,\n      fnOnGroupCompleted: d,\n      oHideEffect: null,\n      oShowEffect: null,\n      bUseFilteringForGrouping: false\n    }\n    return this.each(function (s, J) {\n      var E = a(J).dataTable()\n      var B = new Array()\n      a(this).dataTableExt.aoGroups = B\n      function q (T, i, P) {\n        var R = document.createElement('tr')\n        var S = document.createElement('td')\n        R.id = 'group-id-' + E.attr('id') + '_' + T\n        var Q = {\n          id: R.id,\n          key: T,\n          text: i,\n          level: 0,\n          groupItemClass: '.group-item-' + T,\n          dataGroup: T,\n          aoSubgroups: new Array()\n        }\n        if (t.bSetGroupingClassOnTR) {\n          R.className = t.sGroupingClass + ' ' + T\n        } else {\n          S.className = t.sGroupingClass + ' ' + T\n        }\n        S.colSpan = P\n        S.innerHTML = t.sGroupLabelPrefix + t.fnGroupLabelFormat(i == '' ? t.sEmptyGroupLabel : i, Q)\n        if (t.bExpandableGrouping) {\n          if (!I(T)) {\n            S.className += ' expanded-group'\n            Q.state = 'expanded'\n          } else {\n            S.className += ' collapsed-group'\n            Q.state = 'collapsed'\n          }\n          S.className += ' group-item-expander'\n          a(S).attr('data-group', Q.dataGroup)\n          a(S).attr('data-group-level', Q.level)\n          a(S).click(h)\n        }\n        R.appendChild(S)\n        B[T] = Q\n        Q.nGroup = R\n        t.fnOnGroupCreated(Q, T, 1)\n        return Q\n      }\n      function w (R, Q, P, T) {\n        var i = document.createElement('tr')\n        i.id = T.id + '_' + R\n        var V = document.createElement('td')\n        var U = T.dataGroup + '_' + R\n        var S = {\n          id: i.id,\n          key: R,\n          text: Q,\n          level: T.level + 1,\n          groupItemClass: '.group-item-' + U,\n          dataGroup: U,\n          aoSubgroups: new Array()\n        }\n        if (t.bSetGroupingClassOnTR) {\n          i.className = t.sGroupingClass2 + ' ' + R\n        } else {\n          V.className = t.sGroupingClass2 + ' ' + R\n        }\n        V.colSpan = P\n        V.innerHTML = t.sGroupLabelPrefix2 + t.fnGroupLabelFormat2(Q == '' ? t.sEmptyGroupLabel : Q, S)\n        if (t.bExpandableGrouping) {\n          i.className += ' group-item-' + T.dataGroup\n        }\n        if (t.bExpandableGrouping && t.bExpandableGrouping2) {\n          if (!I(S.dataGroup)) {\n            V.className += ' expanded-group'\n            S.state = 'expanded'\n          } else {\n            V.className += ' collapsed-group'\n            S.state = 'collapsed'\n          }\n          V.className += ' group-item-expander'\n          a(V).attr('data-group', S.dataGroup)\n          a(V).attr('data-group-level', S.level)\n          a(V).click(h)\n        }\n        i.appendChild(V)\n        T.aoSubgroups[S.dataGroup] = S\n        B[S.dataGroup] = S\n        S.nGroup = i\n        t.fnOnGroupCreated(S, R, 2)\n        return S\n      }\n      function I (i) {\n        if (B[i] != null) {\n          return B[i].state == 'collapsed'\n        } else {\n          if (i.indexOf('_') > -1) {\n            true\n          } else {\n            if (l && (j == null || j.length == 0)) {\n              return false\n            } else {\n              return a.inArray(i, j) == -1\n            }\n          }\n        }\n      }\n      function L (i) {\n        if (i.length < x + K) {\n          return i\n        } else {\n          return i.substr(x, K)\n        }\n      }\n      function y (i) {\n        return i\n      }\n      function M (i) {\n        return i.substr(0, 1)\n      }\n      function O (i) {\n        return L(i)\n      }\n      function C (i) {\n        return i.substr(x, K) + ' ' + g(i.substr(r, H))\n      }\n      function u (i) {\n        if (i === '') {\n          return '-'\n        }\n        return i.toLowerCase().replace(/[^a-zA-Z0-9\\u0080-\\uFFFF]+/g, '-')\n      }\n      function D (R, P, i) {\n        if (R.nTable.id !== E[0].id) {\n          return true\n        }\n        var Q = P[t.iGroupingColumnIndex]\n        if (typeof Q === 'undefined') {\n          Q = P[R.aoColumns[t.iGroupingColumnIndex].mDataProp]\n        }\n        if (I(u(Q))) {\n          if (E.fnIsOpen(E.fnGetNodes(i))) {\n            if (t.fnOnRowClosed != null) {\n              t.fnOnRowClosed(this)\n            }\n            E.fnClose(E.fnGetNodes(i))\n          }\n          return false\n        }\n        return true\n      }\n      function p (i) {\n        B[i].state = 'expanded'\n        a(\"td[data-group^='\" + i + \"']\").removeClass('collapsed-group')\n        a(\"td[data-group^='\" + i + \"']\").addClass('expanded-group')\n        if (t.bUseFilteringForGrouping) {\n          E.fnDraw()\n          return\n        }\n        if (jQuery.inArray(i, j) == -1) {\n          j.push(i)\n        }\n        if (t.oHideEffect != null) {\n          a('.group-item-' + i, E)[t.oShowEffect.method](t.oShowEffect.duration, t.oShowEffect.easing, function () {})\n        } else {\n          a('.group-item-' + i, E).show()\n        }\n      }\n      function m (i) {\n        B[i].state = 'collapsed'\n        a(\"td[data-group^='\" + i + \"']\").removeClass('expanded-group')\n        a(\"td[data-group^='\" + i + \"']\").addClass('collapsed-group')\n        if (t.bUseFilteringForGrouping) {\n          E.fnDraw()\n          return\n        }\n        a('.group-item-' + i).each(function () {\n          if (E.fnIsOpen(this)) {\n            if (t.fnOnRowClosed != null) {\n              t.fnOnRowClosed(this)\n            }\n            E.fnClose(this)\n          }\n        })\n        if (t.oHideEffect != null) {\n          a('.group-item-' + i, E)[t.oHideEffect.method](t.oHideEffect.duration, t.oHideEffect.easing, function () {})\n        } else {\n          a('.group-item-' + i, E).hide()\n        }\n      }\n      function h (T) {\n        var Q = a(this).attr('data-group')\n        var S = a(this).attr('data-group-level')\n        var R = !I(Q)\n        if (t.bExpandSingleGroup) {\n          if (!R) {\n            var P = a('td.expanded-group').attr('data-group')\n            m(P)\n            p(Q)\n            if (t.iExpandGroupOffset != -1) {\n              var i = a('#group-id-' + E.attr('id') + '_' + Q).offset().top - t.iExpandGroupOffset\n              window.scroll(0, i)\n            } else {\n              var i = E.offset().top\n              window.scroll(0, i)\n            }\n          }\n        } else {\n          if (R) {\n            m(Q)\n          } else {\n            p(Q)\n          }\n        }\n        T.preventDefault()\n      }\n      function A (V) {\n        if (E.fnSettings().oFeatures.bServerSide) {\n          l = true\n        }\n        var Z = false\n        if (t.iGroupingColumnIndex2 != -1) {\n          Z = true\n        }\n        if (V.aiDisplayMaster.length == 0) {\n          return\n        }\n        var T = a('tbody tr', E)\n        var Q = 0\n        for (var ae = 0; ae < V.aoColumns.length; ae++) {\n          if (V.aoColumns[ae].bVisible) {\n            Q += 1\n          }\n        }\n        var ah = null\n        var aa = null\n        if (V.aiDisplay.length > 0) {\n          for (var ag = 0; ag < T.length; ag++) {\n            var U = V._iDisplayStart + ag\n            if (E.fnSettings().oFeatures.bServerSide) {\n              U = ag\n            }\n            var S = ''\n            var af = null\n            var P = ''\n            var Y = null\n            S = this.fnGetData(T[ag], t.iGroupingColumnIndex)\n            var af = S\n            if (t.sGroupBy != 'year') {\n              af = N(S)\n            }\n            if (Z) {\n              P = V.aoData[V.aiDisplay[U]]._aData[t.iGroupingColumnIndex2]\n              if (P == undefined) {\n                P = V.aoData[V.aiDisplay[U]]._aData[V.aoColumns[t.iGroupingColumnIndex2].mDataProp]\n              }\n              if (t.sGroupBy2 != 'year') {\n                Y = N(P)\n              }\n            }\n            if (ah == null || u(af) != u(ah)) {\n              var ab = u(af)\n              if (ah != null) {\n                t.fnOnGroupCompleted(B[u(ah)])\n              }\n              if (t.bAddAllGroupsAsExpanded && jQuery.inArray(ab, j) == -1) {\n                j.push(ab)\n              }\n              var W = q(ab, af, Q)\n              var R = W.nGroup\n              if (T[ag].parentNode != null) {\n                T[ag].parentNode.insertBefore(R, T[ag])\n              } else {\n                a(T[ag]).before(R)\n              }\n              ah = af\n              aa = null\n            }\n            a(T[ag]).attr('data-group', B[ab].dataGroup)\n            a(T[ag]).addClass(t.sGroupItemClass)\n            a(T[ag]).addClass('group-item-' + ab)\n            if (t.bExpandableGrouping) {\n              if (I(ab) && !t.bUseFilteringForGrouping) {\n                a(T[ag]).hide()\n              }\n            }\n            if (Z) {\n              if (aa == null || u(Y) != u(aa)) {\n                var X = u(af) + '-' + u(Y)\n                var ac = w(X, Y, Q, B[ab])\n                var ad = ac.nGroup\n                T[ag].parentNode.insertBefore(ad, T[ag])\n                aa = Y\n              }\n              a(T[ag])\n                .attr('data-group', ac.dataGroup)\n                .addClass(t.sGroupItemClass2)\n                .addClass('group-item-' + ac.dataGroup)\n            }\n          }\n        }\n        if (ah != null) {\n          t.fnOnGroupCompleted(B[u(ah)])\n        }\n        t.fnOnGrouped(B)\n        l = false\n      }\n      var x = 6\n      var K = 4\n      var j = new Array()\n      var l = true\n      var t = a.extend(f, e)\n      if (t.iGroupingOrderByColumnIndex == -1) {\n        t.bCustomColumnOrdering = false\n        t.iGroupingOrderByColumnIndex = t.iGroupingColumnIndex\n      } else {\n        t.bCustomColumnOrdering = true\n      }\n      if (t.sGroupingColumnSortDirection == '') {\n        if (t.sGroupBy == 'year') {\n          t.sGroupingColumnSortDirection = 'desc'\n        } else {\n          t.sGroupingColumnSortDirection = 'asc'\n        }\n      }\n      if (t.iGroupingOrderByColumnIndex2 == -1) {\n        t.bCustomColumnOrdering2 = false\n        t.iGroupingOrderByColumnIndex2 = t.iGroupingColumnIndex2\n      } else {\n        t.bCustomColumnOrdering2 = true\n      }\n      if (t.sGroupingColumnSortDirection2 == '') {\n        if (t.sGroupBy2 == 'year') {\n          t.sGroupingColumnSortDirection2 = 'desc'\n        } else {\n          t.sGroupingColumnSortDirection2 = 'asc'\n        }\n      }\n      x = t.sDateFormat.toLowerCase().indexOf('yy')\n      K = t.sDateFormat.toLowerCase().lastIndexOf('y') - t.sDateFormat.toLowerCase().indexOf('y') + 1\n      var r = t.sDateFormat.toLowerCase().indexOf('mm')\n      var H = t.sDateFormat.toLowerCase().lastIndexOf('m') - t.sDateFormat.toLowerCase().indexOf('m') + 1\n      var N = y\n      switch (t.sGroupBy) {\n        case 'letter':\n          N = M\n          break\n        case 'year':\n          N = O\n          break\n        case 'month':\n          N = C\n          break\n        default:\n          N = y\n          break\n      }\n      if (t.asExpandedGroups != null) {\n        if (t.asExpandedGroups == 'NONE') {\n          t.asExpandedGroups = []\n          j = t.asExpandedGroups\n          l = false\n        } else {\n          if (t.asExpandedGroups == 'ALL') {\n            t.bAddAllGroupsAsExpanded = true\n          } else {\n            if (t.asExpandedGroups.constructor == String) {\n              var k = t.asExpandedGroups\n              t.asExpandedGroups = new Array()\n              t.asExpandedGroups.push(u(k))\n              j = t.asExpandedGroups\n              l = false\n            } else {\n              if (t.asExpandedGroups.constructor == Array) {\n                for (var G = 0; G < t.asExpandedGroups.length; G++) {\n                  j.push(u(t.asExpandedGroups[G]))\n                  if (t.bExpandSingleGroup) {\n                    break\n                  }\n                }\n                l = false\n              }\n            }\n          }\n        }\n      } else {\n        t.asExpandedGroups = new Array()\n        t.bAddAllGroupsAsExpanded = true\n      }\n      if (t.bExpandSingleGroup) {\n        var o = a('tbody tr', E)\n        var n = E.fnGetData(o[0], t.iGroupingColumnIndex)\n        var F = n\n        if (t.sGroupBy != 'year') {\n          F = N(n)\n        }\n        var z = u(F)\n        t.asExpandedGroups = new Array()\n        t.asExpandedGroups.push(z)\n      }\n      E.fnSetColumnVis(t.iGroupingColumnIndex, !t.bHideGroupingColumn)\n      if (t.bCustomColumnOrdering) {\n        E.fnSetColumnVis(t.iGroupingOrderByColumnIndex, !t.bHideGroupingOrderByColumn)\n      }\n      if (t.iGroupingColumnIndex2 != -1) {\n        E.fnSetColumnVis(t.iGroupingColumnIndex2, !t.bHideGroupingColumn2)\n      }\n      if (t.bCustomColumnOrdering2) {\n        E.fnSetColumnVis(t.iGroupingOrderByColumnIndex2, !t.bHideGroupingOrderByColumn2)\n      }\n      E.fnSettings().aoDrawCallback.push({ fn: A, sName: 'fnRowGrouping' })\n      var v = new Array()\n      v.push([t.iGroupingOrderByColumnIndex, t.sGroupingColumnSortDirection])\n      if (t.iGroupingColumnIndex2 != -1) {\n        v.push([t.iGroupingOrderByColumnIndex2, t.sGroupingColumnSortDirection2])\n      }\n      E.fnSettings().aaSortingFixed = v\n      switch (t.sGroupBy) {\n        case 'name':\n          break\n        case 'letter':\n          E.fnSettings().aoColumns[t.iGroupingOrderByColumnIndex].sSortDataType = 'rg-letter'\n          a.fn.dataTableExt.afnSortData['rg-letter'] = function (Q, P) {\n            var i = []\n            a('td:eq(' + P + ')', Q.oApi._fnGetTrNodes(Q)).each(function () {\n              i.push(M(this.innerHTML))\n            })\n            return i\n          }\n          break\n        case 'year':\n          E.fnSettings().aoColumns[t.iGroupingOrderByColumnIndex].sSortDataType = 'rg-date'\n          a.fn.dataTableExt.afnSortData['rg-date'] = function (R, P) {\n            var i = []\n            var Q = R.oApi._fnGetTrNodes(R)\n            for (G = 0; G < Q.length; G++) {\n              i.push(L(E.fnGetData(Q[G], P)))\n            }\n            return i\n          }\n          break\n        default:\n          break\n      }\n      if (t.bUseFilteringForGrouping) {\n        a.fn.dataTableExt.afnFiltering.push(D)\n      }\n      E.fnDraw()\n    })\n  }\n})(jQuery)\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\")))\n\n//# sourceURL=webpack:///./src/public/js/vendor/datatables/dataTables.grouping.js?");

/***/ }),

/***/ "./src/public/js/vendor/datatables/dataTables.responsive.js":
/*!******************************************************************!*\
  !*** ./src/public/js/vendor/datatables/dataTables.responsive.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Responsive 1.0.1\n * 2014 SpryMedia Ltd - datatables.net/license\n */\n\n/**\n * @summary     Responsive\n * @description Responsive tables plug-in for DataTables\n * @version     1.0.1\n * @file        dataTables.responsive.js\n * @author      SpryMedia Ltd (www.sprymedia.co.uk)\n * @contact     www.sprymedia.co.uk/contact\n * @copyright   Copyright 2014 SpryMedia Ltd.\n *\n * This source file is free software, available under the following license:\n *   MIT license - http://datatables.net/license/mit\n *\n * This source file is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\n *\n * For details please refer to: http://www.datatables.net\n */\n\n;(function (window, document, undefined) {\n  var factory = function ($, DataTable) {\n    'use strict'\n\n    /**\n     * Responsive is a plug-in for the DataTables library that makes use of\n     * DataTables' ability to change the visibility of columns, changing the\n     * visibility of columns so the displayed columns fit into the table container.\n     * The end result is that complex tables will be dynamically adjusted to fit\n     * into the viewport, be it on a desktop, tablet or mobile browser.\n     *\n     * Responsive for DataTables has two modes of operation, which can used\n     * individually or combined:\n     *\n     * * Class name based control - columns assigned class names that match the\n     *   breakpoint logic can be shown / hidden as required for each breakpoint.\n     * * Automatic control - columns are automatically hidden when there is no\n     *   room left to display them. Columns removed from the right.\n     *\n     * In additional to column visibility control, Responsive also has built into\n     * options to use DataTables' child row display to show / hide the information\n     * from the table that has been hidden. There are also two modes of operation\n     * for this child row display:\n     *\n     * * Inline - when the control element that the user can use to show / hide\n     *   child rows is displayed inside the first column of the table.\n     * * Column - where a whole column is dedicated to be the show / hide control.\n     *\n     * Initialisation of Responsive is performed by:\n     *\n     * * Adding the class `responsive` or `dt-responsive` to the table. In this case\n     *   Responsive will automatically be initialised with the default configuration\n     *   options when the DataTable is created.\n     * * Using the `responsive` option in the DataTables configuration options. This\n     *   can also be used to specify the configuration options, or simply set to\n     *   `true` to use the defaults.\n     *\n     *  @class\n     *  @param {object} settings DataTables settings object for the host table\n     *  @param {object} [opts] Configuration options\n     *  @requires jQuery 1.7+\n     *  @requires DataTables 1.10.1+\n     *\n     *  @example\n     *      $('#example').DataTable( {\n     *        responsive: true\n     *      } );\n     *    } );\n     */\n    var Responsive = function (settings, opts) {\n      // Sanity check that we are using DataTables 1.10 or newer\n      if (!DataTable.versionCheck || !DataTable.versionCheck('1.10.1')) {\n        throw 'DataTables Responsive requires DataTables 1.10.1 or newer'\n      } else if (settings.responsive) {\n        return\n      }\n\n      this.s = {\n        dt: new DataTable.Api(settings),\n        columns: []\n      }\n\n      // details is an object, but for simplicity the user can give it as a string\n      if (opts && typeof opts.details === 'string') {\n        opts.details = { type: opts.details }\n      }\n\n      this.c = $.extend(true, {}, Responsive.defaults, opts)\n      settings.responsive = this\n      this._constructor()\n    }\n\n    Responsive.prototype = {\n      /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n       * Constructor\n       */\n\n      /**\n       * Initialise the Responsive instance\n       *\n       * @private\n       */\n      _constructor: function () {\n        var that = this\n        var dt = this.s.dt\n\n        dt.settings()[0]._responsive = this\n\n        // Use DataTables' private throttle function to avoid processor thrashing\n        $(window).on(\n          'resize.dtr orientationchange.dtr',\n          dt.settings()[0].oApi._fnThrottle(function () {\n            that._resize()\n          })\n        )\n\n        // Destroy event handler\n        dt.on('destroy.dtr', function () {\n          $(window).off('resize.dtr orientationchange.dtr')\n        })\n\n        // Reorder the breakpoints array here in case they have been added out\n        // of order\n        this.c.breakpoints.sort(function (a, b) {\n          return a.width < b.width ? 1 : a.width > b.width ? -1 : 0\n        })\n\n        this._classLogic()\n        this._resizeAuto()\n\n        // First pass - draw the table for the current viewport size\n        this._resize()\n\n        // Details handler\n        var details = this.c.details\n        if (details.type) {\n          that._detailsInit()\n          this._detailsVis()\n\n          dt.on('column-visibility.dtr', function () {\n            that._detailsVis()\n          })\n\n          $(dt.table().node()).addClass('dtr-' + details.type)\n        }\n      },\n\n      /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n       * Private methods\n       */\n\n      /**\n       * Calculate the visibility for the columns in a table for a given\n       * breakpoint. The result is pre-determined based on the class logic if\n       * class names are used to control all columns, but the width of the table\n       * is also used if there are columns which are to be automatically shown\n       * and hidden.\n       *\n       * @param  {string} breakpoint Breakpoint name to use for the calculation\n       * @return {array} Array of boolean values initiating the visibility of each\n       *   column.\n       *  @private\n       */\n      _columnsVisiblity: function (breakpoint) {\n        var dt = this.s.dt\n        var columns = this.s.columns\n        var i, ien\n\n        // Class logic - determine which columns are in this breakpoint based\n        // on the classes. If no class control (i.e. `auto`) then `-` is used\n        // to indicate this to the rest of the function\n        var display = $.map(columns, function (col) {\n          return col.auto && col.minWidth === null\n            ? false\n            : col.auto === true\n            ? '-'\n            : col.includeIn.indexOf(breakpoint) !== -1\n        })\n\n        // Auto column control - first pass: how much width is taken by the\n        // ones that must be included from the non-auto columns\n        var requiredWidth = 0\n        for (i = 0, ien = display.length; i < ien; i++) {\n          if (display[i] === true) {\n            requiredWidth += columns[i].minWidth\n          }\n        }\n\n        // Second pass, use up any remaining width for other columns\n        var widthAvailable = dt.table().container().offsetWidth\n        var usedWidth = widthAvailable - requiredWidth\n\n        for (i = 0, ien = display.length; i < ien; i++) {\n          // Control column needs to always be included. This makes it sub-\n          // optimal in terms of using the available with, but to stop layout\n          // thrashing or overflow\n          if (columns[i].control) {\n            usedWidth -= columns[i].minWidth\n          } else if (display[i] === '-') {\n            // Otherwise, remove the width\n            display[i] = usedWidth - columns[i].minWidth < 0 ? false : true\n\n            // Continue counting down the width, so a smaller column to the\n            // left won't be shown\n            usedWidth -= columns[i].minWidth\n          }\n        }\n\n        // Determine if the 'control' column should be shown (if there is one).\n        // This is the case when there is a hidden column (that is not the\n        // control column). The two loops look inefficient here, but they are\n        // trivial and will fly through. We need to know the outcome from the\n        // first , before the action in the second can be taken\n        var showControl = false\n\n        for (i = 0, ien = columns.length; i < ien; i++) {\n          if (!columns[i].control && !display[i]) {\n            showControl = true\n            break\n          }\n        }\n\n        for (i = 0, ien = columns.length; i < ien; i++) {\n          if (columns[i].control) {\n            display[i] = showControl\n          }\n        }\n\n        return display\n      },\n\n      /**\n       * Create the internal `columns` array with information about the columns\n       * for the table. This includes determining which breakpoints the column\n       * will appear in, based upon class names in the column, which makes up the\n       * vast majority of this method.\n       *\n       * @private\n       */\n      _classLogic: function () {\n        var that = this\n        var calc = {}\n        var breakpoints = this.c.breakpoints\n        var columns = this.s.dt\n          .columns()\n          .eq(0)\n          .map(function (i) {\n            return {\n              className: this.column(i).header().className,\n              includeIn: [],\n              auto: false,\n              control: false\n            }\n          })\n\n        // Simply add a breakpoint to `includeIn` array, ensuring that there are\n        // no duplicates\n        var add = function (colIdx, name) {\n          var includeIn = columns[colIdx].includeIn\n\n          if (includeIn.indexOf(name) === -1) {\n            includeIn.push(name)\n          }\n        }\n\n        var column = function (colIdx, name, operator, matched) {\n          var size, i, ien\n\n          if (!operator) {\n            columns[colIdx].includeIn.push(name)\n          } else if (operator === 'max-') {\n            // Add this breakpoint and all smaller\n            size = that._find(name).width\n\n            for (i = 0, ien = breakpoints.length; i < ien; i++) {\n              if (breakpoints[i].width <= size) {\n                add(colIdx, breakpoints[i].name)\n              }\n            }\n          } else if (operator === 'min-') {\n            // Add this breakpoint and all larger\n            size = that._find(name).width\n\n            for (i = 0, ien = breakpoints.length; i < ien; i++) {\n              if (breakpoints[i].width >= size) {\n                add(colIdx, breakpoints[i].name)\n              }\n            }\n          } else if (operator === 'not-') {\n            // Add all but this breakpoint (xxx need extra information)\n\n            for (i = 0, ien = breakpoints.length; i < ien; i++) {\n              if (breakpoints[i].name.indexOf(matched) === -1) {\n                add(colIdx, breakpoints[i].name)\n              }\n            }\n          }\n        }\n\n        // Loop over each column and determine if it has a responsive control\n        // class\n        columns.each(function (col, i) {\n          var classNames = col.className.split(' ')\n          var hasClass = false\n\n          // Split the class name up so multiple rules can be applied if needed\n          for (var k = 0, ken = classNames.length; k < ken; k++) {\n            var className = $.trim(classNames[k])\n\n            if (className === 'all') {\n              // Include in all\n              hasClass = true\n              col.includeIn = $.map(breakpoints, function (a) {\n                return a.name\n              })\n              return\n            } else if (className === 'none') {\n              // Include in none (default) and no auto\n              hasClass = true\n              return\n            } else if (className === 'control') {\n              // Special column that is only visible, when one of the other\n              // columns is hidden. This is used for the details control\n              hasClass = true\n              col.control = true\n              return\n            }\n\n            $.each(breakpoints, function (j, breakpoint) {\n              // Does this column have a class that matches this breakpoint?\n              var brokenPoint = breakpoint.name.split('-')\n              var re = new RegExp('(min\\\\-|max\\\\-|not\\\\-)?(' + brokenPoint[0] + ')(\\\\-[_a-zA-Z0-9])?')\n              var match = className.match(re)\n\n              if (match) {\n                hasClass = true\n\n                if (match[2] === brokenPoint[0] && match[3] === '-' + brokenPoint[1]) {\n                  // Class name matches breakpoint name fully\n                  column(i, breakpoint.name, match[1], match[2] + match[3])\n                } else if (match[2] === brokenPoint[0] && !match[3]) {\n                  // Class name matched primary breakpoint name with no qualifier\n                  column(i, breakpoint.name, match[1], match[2])\n                }\n              }\n            })\n          }\n\n          // If there was no control class, then automatic sizing is used\n          if (!hasClass) {\n            col.auto = true\n          }\n        })\n\n        this.s.columns = columns\n      },\n\n      /**\n       * Initialisation for the details handler\n       *\n       * @private\n       */\n      _detailsInit: function () {\n        var that = this\n        var dt = this.s.dt\n        var details = this.c.details\n\n        // The inline type always uses the first child as the target\n        if (details.type === 'inline') {\n          details.target = 'td:first-child'\n        }\n\n        // type.target can be a string jQuery selector or a column index\n        var target = details.target\n        var selector = typeof target === 'string' ? target : 'td'\n\n        // Click handler to show / hide the details rows when they are available\n        $(dt.table().body()).on('click', selector, function (e) {\n          // If the table is not collapsed (i.e. there is no hidden columns)\n          // then take no action\n          if (!$(dt.table().node()).hasClass('collapsed')) {\n            return\n          }\n\n          // For column index, we determine if we should act or not in the\n          // handler - otherwise it is already okay\n          if (typeof target === 'number') {\n            var targetIdx = target < 0 ? dt.columns().eq(0).length + target : target\n\n            if (dt.cell(this).index().column !== targetIdx) {\n              return\n            }\n          }\n\n          // $().closest() includes itself in its check\n          var row = dt.row($(this).closest('tr'))\n\n          if (row.child.isShown()) {\n            row.child(false)\n            $(row.node()).removeClass('parent')\n          } else {\n            var info = that.c.details.renderer(dt, row[0])\n            row.child(info, 'child').show()\n            $(row.node()).addClass('parent')\n          }\n        })\n      },\n\n      /**\n       * Update the child rows in the table whenever the column visibility changes\n       *\n       * @private\n       */\n      _detailsVis: function () {\n        var that = this\n        var dt = this.s.dt\n\n        var hiddenColumns = dt\n          .columns(':hidden')\n          .indexes()\n          .flatten()\n        var haveHidden = true\n\n        if (hiddenColumns.length === 0 || (hiddenColumns.length === 1 && this.s.columns[hiddenColumns[0]].control)) {\n          haveHidden = false\n        }\n\n        if (haveHidden) {\n          // Got hidden columns\n          $(dt.table().node()).addClass('collapsed')\n\n          // Show all existing child rows\n          dt.rows()\n            .eq(0)\n            .each(function (idx) {\n              var row = dt.row(idx)\n\n              if (row.child()) {\n                var info = that.c.details.renderer(dt, row[0])\n\n                // The renderer can return false to have no child row\n                if (info === false) {\n                  row.child.hide()\n                } else {\n                  row.child(info, 'child').show()\n                }\n              }\n            })\n        } else {\n          // No hidden columns\n          $(dt.table().node()).removeClass('collapsed')\n\n          // Hide all existing child rows\n          dt.rows()\n            .eq(0)\n            .each(function (idx) {\n              dt.row(idx).child.hide()\n            })\n        }\n      },\n\n      /**\n       * Find a breakpoint object from a name\n       * @param  {string} name Breakpoint name to find\n       * @return {object}      Breakpoint description object\n       */\n      _find: function (name) {\n        var breakpoints = this.c.breakpoints\n\n        for (var i = 0, ien = breakpoints.length; i < ien; i++) {\n          if (breakpoints[i].name === name) {\n            return breakpoints[i]\n          }\n        }\n      },\n\n      /**\n       * Alter the table display for a resized viewport. This involves first\n       * determining what breakpoint the window currently is in, getting the\n       * column visibilities to apply and then setting them.\n       *\n       * @private\n       */\n      _resize: function () {\n        var dt = this.s.dt\n        var width = $(window).width()\n        var breakpoints = this.c.breakpoints\n        var breakpoint = breakpoints[0].name\n\n        // Determine what breakpoint we are currently at\n        for (var i = breakpoints.length - 1; i >= 0; i--) {\n          if (width <= breakpoints[i].width) {\n            breakpoint = breakpoints[i].name\n            break\n          }\n        }\n\n        // Show the columns for that break point\n        var columns = this._columnsVisiblity(breakpoint)\n\n        dt.columns()\n          .eq(0)\n          .each(function (colIdx, i) {\n            dt.column(colIdx).visible(columns[i])\n          })\n      },\n\n      /**\n       * Determine the width of each column in the table so the auto column hiding\n       * has that information to work with. This method is never going to be 100%\n       * perfect since column widths can change slightly per page, but without\n       * seriously compromising performance this is quite effective.\n       *\n       * @private\n       */\n      _resizeAuto: function () {\n        var dt = this.s.dt\n        var columns = this.s.columns\n\n        // Are we allowed to do auto sizing?\n        if (!this.c.auto) {\n          return\n        }\n\n        // Are there any columns that actually need auto-sizing, or do they all\n        // have classes defined\n        if (\n          $.inArray(\n            true,\n            $.map(columns, function (c) {\n              return c.auto\n            })\n          ) === -1\n        ) {\n          return\n        }\n\n        // Clone the table with the current data in it\n        var tableWidth = dt.table().node().offsetWidth\n        var columnWidths = dt.columns\n        var clonedTable = dt\n          .table()\n          .node()\n          .cloneNode(false)\n        var clonedHeader = $(\n          dt\n            .table()\n            .header()\n            .cloneNode(false)\n        ).appendTo(clonedTable)\n        var clonedBody = $(\n          dt\n            .table()\n            .body()\n            .cloneNode(false)\n        ).appendTo(clonedTable)\n\n        // This is a bit slow, but we need to get a clone of each row that\n        // includes all columns. As such, try to do this as little as possible.\n        dt.rows({ page: 'current' })\n          .indexes()\n          .each(function (idx) {\n            var clone = dt\n              .row(idx)\n              .node()\n              .cloneNode(true)\n\n            if (dt.columns(':hidden').flatten().length) {\n              $(clone).append(\n                dt\n                  .cells(idx, ':hidden')\n                  .nodes()\n                  .to$()\n                  .clone()\n              )\n            }\n\n            $(clone).appendTo(clonedBody)\n          })\n\n        var cells = dt\n          .columns()\n          .header()\n          .to$()\n          .clone(false)\n          .wrapAll('tr')\n          .appendTo(clonedHeader)\n        var inserted = $('<div/>')\n          .css({\n            width: 1,\n            height: 1,\n            overflow: 'hidden'\n          })\n          .append(clonedTable)\n          .insertBefore(dt.table().node())\n\n        // The cloned header now contains the smallest that each column can be\n        dt.columns()\n          .eq(0)\n          .each(function (idx) {\n            columns[idx].minWidth = cells[idx].offsetWidth || 0\n          })\n\n        inserted.remove()\n      }\n    }\n\n    /**\n     * List of default breakpoints. Each item in the array is an object with two\n     * properties:\n     *\n     * * `name` - the breakpoint name.\n     * * `width` - the breakpoint width\n     *\n     * @name Responsive.breakpoints\n     * @static\n     */\n    Responsive.breakpoints = [\n      { name: 'desktop', width: Infinity },\n      { name: 'tablet-l', width: 1024 },\n      { name: 'tablet-p', width: 768 },\n      { name: 'mobile-l', width: 480 },\n      { name: 'mobile-p', width: 320 }\n    ]\n\n    /**\n     * Responsive default settings for initialisation\n     *\n     * @namespace\n     * @name Responsive.defaults\n     * @static\n     */\n    Responsive.defaults = {\n      /**\n       * List of breakpoints for the instance. Note that this means that each\n       * instance can have its own breakpoints. Additionally, the breakpoints\n       * cannot be changed once an instance has been creased.\n       *\n       * @type {Array}\n       * @default Takes the value of `Responsive.breakpoints`\n       */\n      breakpoints: Responsive.breakpoints,\n\n      /**\n       * Enable / disable auto hiding calculations. It can help to increase\n       * performance slightly if you disable this option, but all columns would\n       * need to have breakpoint classes assigned to them\n       *\n       * @type {Boolean}\n       * @default  `true`\n       */\n      auto: true,\n\n      /**\n       * Details control. If given as a string value, the `type` property of the\n       * default object is set to that value, and the defaults used for the rest\n       * of the object - this is for ease of implementation.\n       *\n       * The object consists of the following properties:\n       *\n       * * `renderer` - function that is called for display of the child row data.\n       *   The default function will show the data from the hidden columns\n       * * `target` - Used as the selector for what objects to attach the child\n       *   open / close to\n       * * `type` - `false` to disable the details display, `inline` or `column`\n       *   for the two control types\n       *\n       * @type {Object|string}\n       */\n      details: {\n        renderer: function (api, rowIdx) {\n          var data = api\n            .cells(rowIdx, ':hidden')\n            .eq(0)\n            .map(function (cell) {\n              var header = $(api.column(cell.column).header())\n\n              if (header.hasClass('control')) {\n                return ''\n              }\n\n              return (\n                '<li>' +\n                '<span class=\"dtr-title\">' +\n                header.text() +\n                ':' +\n                '</span> ' +\n                '<span class=\"dtr-data\">' +\n                api.cell(cell).data() +\n                '</span>' +\n                '</li>'\n              )\n            })\n            .toArray()\n            .join('')\n\n          return data ? $('<ul/>').append(data) : false\n        },\n\n        target: 0,\n\n        type: 'inline'\n      }\n    }\n\n    /*\n     * API\n     */\n    var Api = $.fn.dataTable.Api\n\n    // Doesn't do anything - work around for a bug in DT... Not documented\n    Api.register('responsive()', function () {\n      return this\n    })\n\n    Api.register('responsive.recalc()', function (rowIdx, intParse, virtual) {\n      this.iterator('table', function (ctx) {\n        if (ctx._responsive) {\n          ctx._responsive._resizeAuto()\n          ctx._responsive._resize()\n        }\n      })\n    })\n\n    /**\n     * Version information\n     *\n     * @name Responsive.version\n     * @static\n     */\n    Responsive.version = '1.0.1'\n\n    $.fn.dataTable.Responsive = Responsive\n    $.fn.DataTable.Responsive = Responsive\n\n    // Attach a listener to the document which listens for DataTables initialisation\n    // events so we can automatically initialise\n    $(document).on('init.dt.dtr', function (e, settings, json) {\n      if (\n        $(settings.nTable).hasClass('responsive') ||\n        $(settings.nTable).hasClass('dt-responsive') ||\n        settings.oInit.responsive\n      ) {\n        var init = settings.oInit.responsive\n\n        if (init !== false) {\n          new Responsive(settings, $.isPlainObject(init) ? init : {})\n        }\n      }\n    })\n\n    return Responsive\n  } // /factory\n\n  // Define as an AMD module if possible\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\"), __webpack_require__(/*! datatables */ \"./src/public/js/vendor/datatables/jquery.dataTables.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(window, document)\n\n\n//# sourceURL=webpack:///./src/public/js/vendor/datatables/dataTables.responsive.js?");

/***/ }),

/***/ "./src/public/js/vendor/datatables/dataTables.scroller.js":
/*!****************************************************************!*\
  !*** ./src/public/js/vendor/datatables/dataTables.scroller.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n Scroller 1.2.2\n Â©2011-2014 SpryMedia Ltd - datatables.net/license\n */\n;(function (m, n, k) {\n  var l = function (e) {\n    var g = function (a, b) {\n      !this instanceof g\n        ? alert(\"Scroller warning: Scroller must be initialised with the 'new' keyword.\")\n        : ('undefined' == typeof b && (b = {}),\n          (this.s = {\n            dt: a,\n            tableTop: 0,\n            tableBottom: 0,\n            redrawTop: 0,\n            redrawBottom: 0,\n            autoHeight: !0,\n            viewportRows: 0,\n            stateTO: null,\n            drawTO: null,\n            heights: { jump: null, page: null, virtual: null, scroll: null, row: null, viewport: null },\n            topRowFloat: 0,\n            scrollDrawDiff: null,\n            loaderVisible: !1\n          }),\n          (this.s = e.extend(this.s, g.oDefaults, b)),\n          (this.s.heights.row = this.s.rowHeight),\n          (this.dom = { force: n.createElement('div'), scroller: null, table: null, loader: null }),\n          (this.s.dt.oScroller = this),\n          this._fnConstruct())\n    }\n    g.prototype = {\n      fnRowToPixels: function (a, b, c) {\n        a = c\n          ? this._domain('virtualToPhysical', a * this.s.heights.row)\n          : this.s.baseScrollTop + (a - this.s.baseRowTop) * this.s.heights.row\n        return b || b === k ? parseInt(a, 10) : a\n      },\n      fnPixelsToRow: function (a, b, c) {\n        var d = a - this.s.baseScrollTop,\n          a = c ? this._domain('physicalToVirtual', a) / this.s.heights.row : d / this.s.heights.row + this.s.baseRowTop\n        return b || b === k ? parseInt(a, 10) : a\n      },\n      fnScrollToRow: function (a, b) {\n        var c = this,\n          d = !1,\n          f = this.fnRowToPixels(a),\n          h = a - ((this.s.displayBuffer - 1) / 2) * this.s.viewportRows\n        0 > h && (h = 0)\n        if ((f > this.s.redrawBottom || f < this.s.redrawTop) && this.s.dt._iDisplayStart !== h)\n          (d = !0), (f = this.fnRowToPixels(a, !1, !0))\n        'undefined' == typeof b || b\n          ? ((this.s.ani = d),\n            e(this.dom.scroller).animate({ scrollTop: f }, function () {\n              setTimeout(function () {\n                c.s.ani = !1\n              }, 25)\n            }))\n          : e(this.dom.scroller).scrollTop(f)\n      },\n      fnMeasure: function (a) {\n        this.s.autoHeight && this._fnCalcRowHeight()\n        var b = this.s.heights\n        b.viewport = e(this.dom.scroller).height()\n        this.s.viewportRows = parseInt(b.viewport / b.row, 10) + 1\n        this.s.dt._iDisplayLength = this.s.viewportRows * this.s.displayBuffer\n        ;(a === k || a) && this.s.dt.oInstance.fnDraw()\n      },\n      _fnConstruct: function () {\n        var a = this\n        if (this.s.dt.oFeatures.bPaginate) {\n          this.dom.force.style.position = 'absolute'\n          this.dom.force.style.top = '0px'\n          this.dom.force.style.left = '0px'\n          this.dom.force.style.width = '1px'\n          this.dom.scroller = e('div.' + this.s.dt.oClasses.sScrollBody, this.s.dt.nTableWrapper)[0]\n          this.dom.scroller.appendChild(this.dom.force)\n          this.dom.scroller.style.position = 'relative'\n          this.dom.table = e('>table', this.dom.scroller)[0]\n          this.dom.table.style.position = 'absolute'\n          this.dom.table.style.top = '0px'\n          this.dom.table.style.left = '0px'\n          e(this.s.dt.nTableWrapper).addClass('DTS')\n          this.s.loadingIndicator &&\n            ((this.dom.loader = e('<div class=\"DTS_Loading\">' + this.s.dt.oLanguage.sLoadingRecords + '</div>').css(\n              'display',\n              'none'\n            )),\n            e(this.dom.scroller.parentNode)\n              .css('position', 'relative')\n              .append(this.dom.loader))\n          this.s.heights.row && 'auto' != this.s.heights.row && (this.s.autoHeight = !1)\n          this.fnMeasure(!1)\n          this.s.ingnoreScroll = !0\n          this.s.stateSaveThrottle = this.s.dt.oApi._fnThrottle(function () {\n            a.s.dt.oApi._fnSaveState(a.s.dt)\n          }, 500)\n          e(this.dom.scroller).on('scroll.DTS', function () {\n            a._fnScroll.call(a)\n          })\n          e(this.dom.scroller).on('touchstart.DTS', function () {\n            a._fnScroll.call(a)\n          })\n          this.s.dt.aoDrawCallback.push({\n            fn: function () {\n              a.s.dt.bInitialised && a._fnDrawCallback.call(a)\n            },\n            sName: 'Scroller'\n          })\n          e(m).on('resize.DTS', function () {\n            a.fnMeasure(false)\n            a._fnInfo()\n          })\n          var b = !0\n          this.s.dt.oApi._fnCallbackReg(\n            this.s.dt,\n            'aoStateSaveParams',\n            function (c, d) {\n              if (b && a.s.dt.oLoadedState) {\n                d.iScroller = a.s.dt.oLoadedState.iScroller\n                d.iScrollerTopRow = a.s.dt.oLoadedState.iScrollerTopRow\n                b = false\n              } else {\n                d.iScroller = a.dom.scroller.scrollTop\n                d.iScrollerTopRow = a.s.topRowFloat\n              }\n            },\n            'Scroller_State'\n          )\n          this.s.dt.oLoadedState && (this.s.topRowFloat = this.s.dt.oLoadedState.iScrollerTopRow || 0)\n          this.s.dt.aoDestroyCallback.push({\n            sName: 'Scroller',\n            fn: function () {\n              e(m).off('resize.DTS')\n              e(a.dom.scroller).off('touchstart.DTS scroll.DTS')\n              e(a.s.dt.nTableWrapper).removeClass('DTS')\n              e('div.DTS_Loading', a.dom.scroller.parentNode).remove()\n              a.dom.table.style.position = ''\n              a.dom.table.style.top = ''\n              a.dom.table.style.left = ''\n            }\n          })\n        } else this.s.dt.oApi._fnLog(this.s.dt, 0, 'Pagination must be enabled for Scroller')\n      },\n      _fnScroll: function () {\n        var a = this,\n          b = this.s.heights,\n          c = this.dom.scroller.scrollTop,\n          d\n        if (!this.s.skip && !this.s.ingnoreScroll)\n          if (this.s.dt.bFiltered || this.s.dt.bSorted) this.s.lastScrollTop = 0\n          else {\n            this._fnInfo()\n            clearTimeout(this.s.stateTO)\n            this.s.stateTO = setTimeout(function () {\n              a.s.dt.oApi._fnSaveState(a.s.dt)\n            }, 250)\n            if (c < this.s.redrawTop || c > this.s.redrawBottom) {\n              var f = Math.ceil(((this.s.displayBuffer - 1) / 2) * this.s.viewportRows)\n              Math.abs(c - this.s.lastScrollTop) > b.viewport || this.s.ani\n                ? ((d = parseInt(this._domain('physicalToVirtual', c) / b.row, 10) - f),\n                  (this.s.topRowFloat = this._domain('physicalToVirtual', c) / b.row))\n                : ((d = this.fnPixelsToRow(c) - f), (this.s.topRowFloat = this.fnPixelsToRow(c, !1)))\n              0 >= d\n                ? (d = 0)\n                : d + this.s.dt._iDisplayLength > this.s.dt.fnRecordsDisplay()\n                ? ((d = this.s.dt.fnRecordsDisplay() - this.s.dt._iDisplayLength), 0 > d && (d = 0))\n                : 0 !== d % 2 && d++\n              if (\n                d != this.s.dt._iDisplayStart &&\n                ((this.s.tableTop = e(this.s.dt.nTable).offset().top),\n                (this.s.tableBottom = e(this.s.dt.nTable).height() + this.s.tableTop),\n                (b = function () {\n                  if (a.s.scrollDrawReq === null) a.s.scrollDrawReq = c\n                  a.s.dt._iDisplayStart = d\n                  a.s.dt.oApi._fnCalculateEnd && a.s.dt.oApi._fnCalculateEnd(a.s.dt)\n                  a.s.dt.oApi._fnDraw(a.s.dt)\n                }),\n                this.s.dt.oFeatures.bServerSide\n                  ? (clearTimeout(this.s.drawTO), (this.s.drawTO = setTimeout(b, this.s.serverWait)))\n                  : b(),\n                this.dom.loader && !this.s.loaderVisible)\n              )\n                this.dom.loader.css('display', 'block'), (this.s.loaderVisible = !0)\n            }\n            this.s.lastScrollTop = c\n            this.s.stateSaveThrottle()\n          }\n      },\n      _domain: function (a, b) {\n        var c = this.s.heights,\n          d\n        if (c.virtual === c.scroll) {\n          d = (c.virtual - c.viewport) / (c.scroll - c.viewport)\n          if ('virtualToPhysical' === a) return b / d\n          if ('physicalToVirtual' === a) return b * d\n        }\n        var e = (c.scroll - c.viewport) / 2,\n          h = (c.virtual - c.viewport) / 2\n        d = h / (e * e)\n        if ('virtualToPhysical' === a) {\n          if (b < h) return Math.pow(b / d, 0.5)\n          b = 2 * h - b\n          return 0 > b ? c.scroll : 2 * e - Math.pow(b / d, 0.5)\n        }\n        if ('physicalToVirtual' === a) {\n          if (b < e) return b * b * d\n          b = 2 * e - b\n          return 0 > b ? c.virtual : 2 * h - b * b * d\n        }\n      },\n      _fnDrawCallback: function () {\n        var a = this,\n          b = this.s.heights,\n          c = this.dom.scroller.scrollTop,\n          d = e(this.s.dt.nTable).height(),\n          f = this.s.dt._iDisplayStart,\n          h = this.s.dt._iDisplayLength,\n          g = this.s.dt.fnRecordsDisplay()\n        this.s.skip = !0\n        this._fnScrollForce()\n        c =\n          0 === f\n            ? this.s.topRowFloat * b.row\n            : f + h >= g\n            ? b.scroll - (g - this.s.topRowFloat) * b.row\n            : this._domain('virtualToPhysical', this.s.topRowFloat * b.row)\n        this.dom.scroller.scrollTop = c\n        this.s.baseScrollTop = c\n        this.s.baseRowTop = this.s.topRowFloat\n        var j = c - (this.s.topRowFloat - f) * b.row\n        0 === f ? (j = 0) : f + h >= g && (j = b.scroll - d)\n        this.dom.table.style.top = j + 'px'\n        this.s.tableTop = j\n        this.s.tableBottom = d + this.s.tableTop\n        d = (c - this.s.tableTop) * this.s.boundaryScale\n        this.s.redrawTop = c - d\n        this.s.redrawBottom = c + d\n        this.s.skip = !1\n        this.s.dt.oFeatures.bStateSave &&\n        null !== this.s.dt.oLoadedState &&\n        'undefined' != typeof this.s.dt.oLoadedState.iScroller\n          ? (((c = (this.s.dt.sAjaxSource || a.s.dt.ajax) && !this.s.dt.oFeatures.bServerSide ? !0 : !1) &&\n              2 == this.s.dt.iDraw) ||\n              (!c && 1 == this.s.dt.iDraw)) &&\n            setTimeout(function () {\n              e(a.dom.scroller).scrollTop(a.s.dt.oLoadedState.iScroller)\n              a.s.redrawTop = a.s.dt.oLoadedState.iScroller - b.viewport / 2\n              setTimeout(function () {\n                a.s.ingnoreScroll = !1\n              }, 0)\n            }, 0)\n          : (a.s.ingnoreScroll = !1)\n        setTimeout(function () {\n          a._fnInfo.call(a)\n        }, 0)\n        this.dom.loader && this.s.loaderVisible && (this.dom.loader.css('display', 'none'), (this.s.loaderVisible = !1))\n      },\n      _fnScrollForce: function () {\n        var a = this.s.heights\n        a.virtual = a.row * this.s.dt.fnRecordsDisplay()\n        a.scroll = a.virtual\n        1e6 < a.scroll && (a.scroll = 1e6)\n        this.dom.force.style.height = a.scroll + 'px'\n      },\n      _fnCalcRowHeight: function () {\n        var a = this.s.dt,\n          b = a.nTable,\n          c = b.cloneNode(!1),\n          d = e('<tbody/>').appendTo(c),\n          f = e(\n            '<div class=\"' +\n              a.oClasses.sWrapper +\n              ' DTS\"><div class=\"' +\n              a.oClasses.sScrollWrapper +\n              '\"><div class=\"' +\n              a.oClasses.sScrollBody +\n              '\"></div></div></div>'\n          )\n        for (\n          e('tbody tr:lt(4)', b)\n            .clone()\n            .appendTo(d);\n          3 > e('tr', d).length;\n\n        )\n          d.append('<tr><td>&nbsp;</td></tr>')\n        e('div.' + a.oClasses.sScrollBody, f).append(c)\n        a._bInitComplete\n          ? (a = b.parentNode)\n          : (this.s.dt.nHolding || (this.s.dt.nHolding = e('<div></div>').insertBefore(this.s.dt.nTable)),\n            (a = this.s.dt.nHolding))\n        f.appendTo(a)\n        this.s.heights.row = e('tr', d)\n          .eq(1)\n          .outerHeight()\n        f.remove()\n      },\n      _fnInfo: function () {\n        if (this.s.dt.oFeatures.bInfo) {\n          var a = this.s.dt,\n            b = a.oLanguage,\n            c = this.dom.scroller.scrollTop,\n            d = Math.floor(this.fnPixelsToRow(c, !1, this.s.ani) + 1),\n            f = a.fnRecordsTotal(),\n            h = a.fnRecordsDisplay(),\n            c = Math.ceil(this.fnPixelsToRow(c + this.s.heights.viewport, !1, this.s.ani)),\n            c = h < c ? h : c,\n            g = a.fnFormatNumber(d),\n            j = a.fnFormatNumber(c),\n            i = a.fnFormatNumber(f),\n            k = a.fnFormatNumber(h),\n            g =\n              0 === a.fnRecordsDisplay() && a.fnRecordsDisplay() == a.fnRecordsTotal()\n                ? b.sInfoEmpty + b.sInfoPostFix\n                : 0 === a.fnRecordsDisplay()\n                ? b.sInfoEmpty + ' ' + b.sInfoFiltered.replace('_MAX_', i) + b.sInfoPostFix\n                : a.fnRecordsDisplay() == a.fnRecordsTotal()\n                ? b.sInfo\n                    .replace('_START_', g)\n                    .replace('_END_', j)\n                    .replace('_MAX_', i)\n                    .replace('_TOTAL_', k) + b.sInfoPostFix\n                : b.sInfo\n                    .replace('_START_', g)\n                    .replace('_END_', j)\n                    .replace('_MAX_', i)\n                    .replace('_TOTAL_', k) +\n                  ' ' +\n                  b.sInfoFiltered.replace('_MAX_', a.fnFormatNumber(a.fnRecordsTotal())) +\n                  b.sInfoPostFix\n          ;(b = b.fnInfoCallback) && (g = b.call(a.oInstance, a, d, c, f, h, g))\n          a = a.aanFeatures.i\n          if ('undefined' != typeof a) {\n            d = 0\n            for (f = a.length; d < f; d++) e(a[d]).html(g)\n          }\n        }\n      }\n    }\n    g.defaults = {\n      trace: !1,\n      rowHeight: 'auto',\n      serverWait: 200,\n      displayBuffer: 9,\n      boundaryScale: 0.5,\n      loadingIndicator: !1\n    }\n    g.oDefaults = g.defaults\n    g.version = '1.2.2'\n    'function' == typeof e.fn.dataTable &&\n    'function' == typeof e.fn.dataTableExt.fnVersionCheck &&\n    e.fn.dataTableExt.fnVersionCheck('1.9.0')\n      ? e.fn.dataTableExt.aoFeatures.push({\n          fnInit: function (a) {\n            var b = a.oInit\n            return new g(a, b.scroller || b.oScroller || {}).dom.wrapper\n          },\n          cFeature: 'S',\n          sFeature: 'Scroller'\n        })\n      : alert('Warning: Scroller requires DataTables 1.9.0 or greater - www.datatables.net/download')\n    e.fn.dataTable.Scroller = g\n    e.fn.DataTable.Scroller = g\n    if (e.fn.dataTable.Api) {\n      var i = e.fn.dataTable.Api\n      i.register('scroller()', function () {\n        return this\n      })\n      i.register('scroller().rowToPixels()', function (a, b, c) {\n        var d = this.context\n        if (d.length && d[0].oScroller) return d[0].oScroller.fnRowToPixels(a, b, c)\n      })\n      i.register('scroller().pixelsToRow()', function (a, b, c) {\n        var d = this.context\n        if (d.length && d[0].oScroller) return d[0].oScroller.fnPixelsToRow(a, b, c)\n      })\n      i.register('scroller().scrollToRow()', function (a, b) {\n        this.iterator('table', function (c) {\n          c.oScroller && c.oScroller.fnScrollToRow(a, b)\n        })\n        return this\n      })\n      i.register('scroller().measure()', function (a) {\n        this.iterator('table', function (b) {\n          b.oScroller && b.oScroller.fnMeasure(a)\n        })\n        return this\n      })\n    }\n    return g\n  }\n   true\n    ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\"), __webpack_require__(/*! datatables */ \"./src/public/js/vendor/datatables/jquery.dataTables.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (l),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n    : undefined\n})(window, document)\n\n\n//# sourceURL=webpack:///./src/public/js/vendor/datatables/dataTables.scroller.js?");

/***/ }),

/***/ "./src/public/js/vendor/datatables/jquery.dataTables.js":
/*!**************************************************************!*\
  !*** ./src/public/js/vendor/datatables/jquery.dataTables.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(jQuery) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! DataTables 1.10.2\n * ©2008-2014 SpryMedia Ltd - datatables.net/license\n */\n\n/**\n * @summary     DataTables\n * @description Paginate, search and order HTML tables\n * @version     1.10.2\n * @file        jquery.dataTables.js\n * @author      SpryMedia Ltd (www.sprymedia.co.uk)\n * @contact     www.sprymedia.co.uk/contact\n * @copyright   Copyright 2008-2014 SpryMedia Ltd.\n *\n * This source file is free software, available under the following license:\n *   MIT license - http://datatables.net/license\n *\n * This source file is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\n *\n * For details please refer to: http://www.datatables.net\n */\n\n/*jslint evil: true, undef: true, browser: true */\n/*globals $,require,jQuery,define,_selector_run,_selector_opts,_selector_first,_selector_row_indexes,_ext,_Api,_api_register,_api_registerPlural,_re_new_lines,_re_html,_re_formatted_numeric,_re_escape_regex,_empty,_intVal,_numToDecimal,_isNumber,_isHtml,_htmlNumeric,_pluck,_pluck_order,_range,_stripHtml,_unique,_fnBuildAjax,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnAjaxDataSrc,_fnAddColumn,_fnColumnOptions,_fnAdjustColumnSizing,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnVisbleColumns,_fnGetColumns,_fnColumnTypes,_fnApplyColumnDefs,_fnHungarianMap,_fnCamelToHungarian,_fnLanguageCompat,_fnBrowserDetect,_fnAddData,_fnAddTr,_fnNodeToDataIndex,_fnNodeToColumnIndex,_fnGetCellData,_fnSetCellData,_fnSplitObjNotation,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnGetDataMaster,_fnClearTable,_fnDeleteIndex,_fnInvalidateRow,_fnGetRowElements,_fnCreateTr,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAddOptionsHtml,_fnDetectHeader,_fnGetUniqueThs,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnFilterCreateSearch,_fnEscapeRegex,_fnFilterData,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnInfoMacros,_fnInitialise,_fnInitComplete,_fnLengthChange,_fnFeatureHtmlLength,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnFeatureHtmlTable,_fnScrollDraw,_fnApplyToChildren,_fnCalculateColumnWidths,_fnThrottle,_fnConvertToWidth,_fnScrollingWidthAdjust,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnScrollBarWidth,_fnSortFlatten,_fnSort,_fnSortAria,_fnSortListener,_fnSortAttachListener,_fnSortingClasses,_fnSortData,_fnSaveState,_fnLoadState,_fnSettingsFromNode,_fnLog,_fnMap,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnLengthOverflow,_fnRenderer,_fnDataSource,_fnRowAttributes*/\n\n/** @lends <global> */ ;(function (window, document, undefined) {\n  ;(function (factory) {\n    'use strict'\n\n    if (true) {\n      // Define as an AMD module if possible\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n    } else {}\n  })(\n    /** @lends <global> */ function ($) {\n      'use strict'\n\n      /**\n       * DataTables is a plug-in for the jQuery Javascript library. It is a highly\n       * flexible tool, based upon the foundations of progressive enhancement,\n       * which will add advanced interaction controls to any HTML table. For a\n       * full list of features please refer to\n       * [DataTables.net](href=\"http://datatables.net).\n       *\n       * Note that the `DataTable` object is not a global variable but is aliased\n       * to `jQuery.fn.DataTable` and `jQuery.fn.dataTable` through which it may\n       * be  accessed.\n       *\n       *  @class\n       *  @param {object} [init={}] Configuration object for DataTables. Options\n       *    are defined by {@link DataTable.defaults}\n       *  @requires jQuery 1.7+\n       *\n       *  @example\n       *    // Basic initialisation\n       *    $(document).ready( function {\n       *      $('#example').dataTable();\n       *    } );\n       *\n       *  @example\n       *    // Initialisation with configuration options - in this case, disable\n       *    // pagination and sorting.\n       *    $(document).ready( function {\n       *      $('#example').dataTable( {\n       *        \"paginate\": false,\n       *        \"sort\": false\n       *      } );\n       *    } );\n       */\n      var DataTable\n\n      /*\n       * It is useful to have variables which are scoped locally so only the\n       * DataTables functions can access them and they don't leak into global space.\n       * At the same time these functions are often useful over multiple files in the\n       * core and API, so we list, or at least document, all variables which are used\n       * by DataTables as private variables here. This also ensures that there is no\n       * clashing of variable names and that they can easily referenced for reuse.\n       */\n\n      // Defined else where\n      //  _selector_run\n      //  _selector_opts\n      //  _selector_first\n      //  _selector_row_indexes\n\n      var _ext // DataTable.ext\n      var _Api // DataTable.Api\n      var _api_register // DataTable.Api.register\n      var _api_registerPlural // DataTable.Api.registerPlural\n\n      var _re_dic = {}\n      var _re_new_lines = /[\\r\\n]/g\n      var _re_html = /<.*?>/g\n      var _re_date_start = /^[\\w\\+\\-]/\n      var _re_date_end = /[\\w\\+\\-]$/\n\n      // Escape regular expression special characters\n      var _re_escape_regex = new RegExp(\n        '(\\\\' + ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\\\', '$', '^', '-'].join('|\\\\') + ')',\n        'g'\n      )\n\n      // U+2009 is thin space and U+202F is narrow no-break space, both used in many\n      // standards as thousands separators\n      var _re_formatted_numeric = /[',$£€¥%\\u2009\\u202F]/g\n\n      var _empty = function (d) {\n        return !d || d === true || d === '-' ? true : false\n      }\n\n      var _intVal = function (s) {\n        var integer = parseInt(s, 10)\n        return !isNaN(integer) && isFinite(s) ? integer : null\n      }\n\n      // Convert from a formatted number with characters other than `.` as the\n      // decimal place, to a Javascript number\n      var _numToDecimal = function (num, decimalPoint) {\n        // Cache created regular expressions for speed as this function is called often\n        if (!_re_dic[decimalPoint]) {\n          _re_dic[decimalPoint] = new RegExp(_fnEscapeRegex(decimalPoint), 'g')\n        }\n        return typeof num === 'string' ? num.replace(/\\./g, '').replace(_re_dic[decimalPoint], '.') : num\n      }\n\n      var _isNumber = function (d, decimalPoint, formatted) {\n        var strType = typeof d === 'string'\n\n        if (decimalPoint && strType) {\n          d = _numToDecimal(d, decimalPoint)\n        }\n\n        if (formatted && strType) {\n          d = d.replace(_re_formatted_numeric, '')\n        }\n\n        return _empty(d) || (!isNaN(parseFloat(d)) && isFinite(d))\n      }\n\n      // A string without HTML in it can be considered to be HTML still\n      var _isHtml = function (d) {\n        return _empty(d) || typeof d === 'string'\n      }\n\n      var _htmlNumeric = function (d, decimalPoint, formatted) {\n        if (_empty(d)) {\n          return true\n        }\n\n        var html = _isHtml(d)\n        return !html ? null : _isNumber(_stripHtml(d), decimalPoint, formatted) ? true : null\n      }\n\n      var _pluck = function (a, prop, prop2) {\n        var out = []\n        var i = 0,\n          ien = a.length\n\n        // Could have the test in the loop for slightly smaller code, but speed\n        // is essential here\n        if (prop2 !== undefined) {\n          for (; i < ien; i++) {\n            if (a[i] && a[i][prop]) {\n              out.push(a[i][prop][prop2])\n            }\n          }\n        } else {\n          for (; i < ien; i++) {\n            if (a[i]) {\n              out.push(a[i][prop])\n            }\n          }\n        }\n\n        return out\n      }\n\n      // Basically the same as _pluck, but rather than looping over `a` we use `order`\n      // as the indexes to pick from `a`\n      var _pluck_order = function (a, order, prop, prop2) {\n        var out = []\n        var i = 0,\n          ien = order.length\n\n        // Could have the test in the loop for slightly smaller code, but speed\n        // is essential here\n        if (prop2 !== undefined) {\n          for (; i < ien; i++) {\n            out.push(a[order[i]][prop][prop2])\n          }\n        } else {\n          for (; i < ien; i++) {\n            out.push(a[order[i]][prop])\n          }\n        }\n\n        return out\n      }\n\n      var _range = function (len, start) {\n        var out = []\n        var end\n\n        if (start === undefined) {\n          start = 0\n          end = len\n        } else {\n          end = start\n          start = len\n        }\n\n        for (var i = start; i < end; i++) {\n          out.push(i)\n        }\n\n        return out\n      }\n\n      var _stripHtml = function (d) {\n        return d.replace(_re_html, '')\n      }\n\n      /**\n       * Find the unique elements in a source array.\n       *\n       * @param  {array} src Source array\n       * @return {array} Array of unique items\n       * @ignore\n       */\n      var _unique = function (src) {\n        // A faster unique method is to use object keys to identify used values,\n        // but this doesn't work with arrays or objects, which we must also\n        // consider. See jsperf.com/compare-array-unique-versions/4 for more\n        // information.\n        var out = [],\n          val,\n          i,\n          ien = src.length,\n          j,\n          k = 0\n\n        again: for (i = 0; i < ien; i++) {\n          val = src[i]\n\n          for (j = 0; j < k; j++) {\n            if (out[j] === val) {\n              continue again\n            }\n          }\n\n          out.push(val)\n          k++\n        }\n\n        return out\n      }\n\n      /**\n       * Create a mapping object that allows camel case parameters to be looked up\n       * for their Hungarian counterparts. The mapping is stored in a private\n       * parameter called `_hungarianMap` which can be accessed on the source object.\n       *  @param {object} o\n       *  @memberof DataTable#oApi\n       */\n      function _fnHungarianMap (o) {\n        var hungarian = 'a aa ai ao as b fn i m o s ',\n          match,\n          newKey,\n          map = {}\n\n        $.each(o, function (key, val) {\n          match = key.match(/^([^A-Z]+?)([A-Z])/)\n\n          if (match && hungarian.indexOf(match[1] + ' ') !== -1) {\n            newKey = key.replace(match[0], match[2].toLowerCase())\n            map[newKey] = key\n\n            //console.log( key, match );\n            if (match[1] === 'o') {\n              _fnHungarianMap(o[key])\n            }\n          }\n        })\n\n        o._hungarianMap = map\n      }\n\n      /**\n       * Convert from camel case parameters to Hungarian, based on a Hungarian map\n       * created by _fnHungarianMap.\n       *  @param {object} src The model object which holds all parameters that can be\n       *    mapped.\n       *  @param {object} user The object to convert from camel case to Hungarian.\n       *  @param {boolean} force When set to `true`, properties which already have a\n       *    Hungarian value in the `user` object will be overwritten. Otherwise they\n       *    won't be.\n       *  @memberof DataTable#oApi\n       */\n      function _fnCamelToHungarian (src, user, force) {\n        if (!src._hungarianMap) {\n          _fnHungarianMap(src)\n        }\n\n        var hungarianKey\n\n        $.each(user, function (key, val) {\n          hungarianKey = src._hungarianMap[key]\n\n          if (hungarianKey !== undefined && (force || user[hungarianKey] === undefined)) {\n            // For objects, we need to buzz down into the object to copy parameters\n            if (hungarianKey.charAt(0) === 'o') {\n              // Copy the camelCase options over to the hungarian\n              if (!user[hungarianKey]) {\n                user[hungarianKey] = {}\n              }\n              $.extend(true, user[hungarianKey], user[key])\n\n              _fnCamelToHungarian(src[hungarianKey], user[hungarianKey], force)\n            } else {\n              user[hungarianKey] = user[key]\n            }\n          }\n        })\n      }\n\n      /**\n       * Language compatibility - when certain options are given, and others aren't, we\n       * need to duplicate the values over, in order to provide backwards compatibility\n       * with older language files.\n       *  @param {object} oSettings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnLanguageCompat (lang) {\n        var defaults = DataTable.defaults.oLanguage\n        var zeroRecords = lang.sZeroRecords\n\n        /* Backwards compatibility - if there is no sEmptyTable given, then use the same as\n         * sZeroRecords - assuming that is given.\n         */\n        if (!lang.sEmptyTable && zeroRecords && defaults.sEmptyTable === 'No data available in table') {\n          _fnMap(lang, lang, 'sZeroRecords', 'sEmptyTable')\n        }\n\n        /* Likewise with loading records */\n        if (!lang.sLoadingRecords && zeroRecords && defaults.sLoadingRecords === 'Loading...') {\n          _fnMap(lang, lang, 'sZeroRecords', 'sLoadingRecords')\n        }\n\n        // Old parameter name of the thousands separator mapped onto the new\n        if (lang.sInfoThousands) {\n          lang.sThousands = lang.sInfoThousands\n        }\n\n        var decimal = lang.sDecimal\n        if (decimal) {\n          _addNumericSort(decimal)\n        }\n      }\n\n      /**\n       * Map one parameter onto another\n       *  @param {object} o Object to map\n       *  @param {*} knew The new parameter name\n       *  @param {*} old The old parameter name\n       */\n      var _fnCompatMap = function (o, knew, old) {\n        if (o[knew] !== undefined) {\n          o[old] = o[knew]\n        }\n      }\n\n      /**\n       * Provide backwards compatibility for the main DT options. Note that the new\n       * options are mapped onto the old parameters, so this is an external interface\n       * change only.\n       *  @param {object} init Object to map\n       */\n      function _fnCompatOpts (init) {\n        _fnCompatMap(init, 'ordering', 'bSort')\n        _fnCompatMap(init, 'orderMulti', 'bSortMulti')\n        _fnCompatMap(init, 'orderClasses', 'bSortClasses')\n        _fnCompatMap(init, 'orderCellsTop', 'bSortCellsTop')\n        _fnCompatMap(init, 'order', 'aaSorting')\n        _fnCompatMap(init, 'orderFixed', 'aaSortingFixed')\n        _fnCompatMap(init, 'paging', 'bPaginate')\n        _fnCompatMap(init, 'pagingType', 'sPaginationType')\n        _fnCompatMap(init, 'pageLength', 'iDisplayLength')\n        _fnCompatMap(init, 'searching', 'bFilter')\n\n        // Column search objects are in an array, so it needs to be converted\n        // element by element\n        var searchCols = init.aoSearchCols\n\n        if (searchCols) {\n          for (var i = 0, ien = searchCols.length; i < ien; i++) {\n            if (searchCols[i]) {\n              _fnCamelToHungarian(DataTable.models.oSearch, searchCols[i])\n            }\n          }\n        }\n      }\n\n      /**\n       * Provide backwards compatibility for column options. Note that the new options\n       * are mapped onto the old parameters, so this is an external interface change\n       * only.\n       *  @param {object} init Object to map\n       */\n      function _fnCompatCols (init) {\n        _fnCompatMap(init, 'orderable', 'bSortable')\n        _fnCompatMap(init, 'orderData', 'aDataSort')\n        _fnCompatMap(init, 'orderSequence', 'asSorting')\n        _fnCompatMap(init, 'orderDataType', 'sortDataType')\n      }\n\n      /**\n       * Browser feature detection for capabilities, quirks\n       *  @param {object} settings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnBrowserDetect (settings) {\n        var browser = settings.oBrowser\n\n        // Scrolling feature / quirks detection\n        var n = $('<div/>')\n          .css({\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            height: 1,\n            width: 1,\n            overflow: 'hidden'\n          })\n          .append(\n            $('<div/>')\n              .css({\n                position: 'absolute',\n                top: 1,\n                left: 1,\n                width: 100,\n                overflow: 'scroll'\n              })\n              .append(\n                $('<div class=\"test\"/>').css({\n                  width: '100%',\n                  height: 10\n                })\n              )\n          )\n          .appendTo('body')\n\n        var test = n.find('.test')\n\n        // IE6/7 will oversize a width 100% element inside a scrolling element, to\n        // include the width of the scrollbar, while other browsers ensure the inner\n        // element is contained without forcing scrolling\n        browser.bScrollOversize = test[0].offsetWidth === 100\n\n        // In rtl text layout, some browsers (most, but not all) will place the\n        // scrollbar on the left, rather than the right.\n        browser.bScrollbarLeft = test.offset().left !== 1\n\n        n.remove()\n      }\n\n      /**\n       * Array.prototype reduce[Right] method, used for browsers which don't support\n       * JS 1.6. Done this way to reduce code size, since we iterate either way\n       *  @param {object} settings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnReduce (that, fn, init, start, end, inc) {\n        var i = start,\n          value,\n          isSet = false\n\n        if (init !== undefined) {\n          value = init\n          isSet = true\n        }\n\n        while (i !== end) {\n          if (!that.hasOwnProperty(i)) {\n            continue\n          }\n\n          value = isSet ? fn(value, that[i], i, that) : that[i]\n\n          isSet = true\n          i += inc\n        }\n\n        return value\n      }\n\n      /**\n       * Add a column to the list used for the table with default values\n       *  @param {object} oSettings dataTables settings object\n       *  @param {node} nTh The th element for this column\n       *  @memberof DataTable#oApi\n       */\n      function _fnAddColumn (oSettings, nTh) {\n        // Add column to aoColumns array\n        var oDefaults = DataTable.defaults.column\n        var iCol = oSettings.aoColumns.length\n        var oCol = $.extend({}, DataTable.models.oColumn, oDefaults, {\n          nTh: nTh ? nTh : document.createElement('th'),\n          sTitle: oDefaults.sTitle ? oDefaults.sTitle : nTh ? nTh.innerHTML : '',\n          aDataSort: oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],\n          mData: oDefaults.mData ? oDefaults.mData : iCol,\n          idx: iCol\n        })\n        oSettings.aoColumns.push(oCol)\n\n        // Add search object for column specific search. Note that the `searchCols[ iCol ]`\n        // passed into extend can be undefined. This allows the user to give a default\n        // with only some of the parameters defined, and also not give a default\n        var searchCols = oSettings.aoPreSearchCols\n        searchCols[iCol] = $.extend({}, DataTable.models.oSearch, searchCols[iCol])\n\n        // Use the default column options function to initialise classes etc\n        _fnColumnOptions(oSettings, iCol, null)\n      }\n\n      /**\n       * Apply options for a column\n       *  @param {object} oSettings dataTables settings object\n       *  @param {int} iCol column index to consider\n       *  @param {object} oOptions object with sType, bVisible and bSearchable etc\n       *  @memberof DataTable#oApi\n       */\n      function _fnColumnOptions (oSettings, iCol, oOptions) {\n        var oCol = oSettings.aoColumns[iCol]\n        var oClasses = oSettings.oClasses\n        var th = $(oCol.nTh)\n\n        // Try to get width information from the DOM. We can't get it from CSS\n        // as we'd need to parse the CSS stylesheet. `width` option can override\n        if (!oCol.sWidthOrig) {\n          // Width attribute\n          oCol.sWidthOrig = th.attr('width') || null\n\n          // Style attribute\n          var t = (th.attr('style') || '').match(/width:\\s*(\\d+[pxem%]+)/)\n          if (t) {\n            oCol.sWidthOrig = t[1]\n          }\n        }\n\n        /* User specified column options */\n        if (oOptions !== undefined && oOptions !== null) {\n          // Backwards compatibility\n          _fnCompatCols(oOptions)\n\n          // Map camel case parameters to their Hungarian counterparts\n          _fnCamelToHungarian(DataTable.defaults.column, oOptions)\n\n          /* Backwards compatibility for mDataProp */\n          if (oOptions.mDataProp !== undefined && !oOptions.mData) {\n            oOptions.mData = oOptions.mDataProp\n          }\n\n          if (oOptions.sType) {\n            oCol._sManualType = oOptions.sType\n          }\n\n          // `class` is a reserved word in Javascript, so we need to provide\n          // the ability to use a valid name for the camel case input\n          if (oOptions.className && !oOptions.sClass) {\n            oOptions.sClass = oOptions.className\n          }\n\n          $.extend(oCol, oOptions)\n          _fnMap(oCol, oOptions, 'sWidth', 'sWidthOrig')\n\n          /* iDataSort to be applied (backwards compatibility), but aDataSort will take\n           * priority if defined\n           */\n          if (typeof oOptions.iDataSort === 'number') {\n            oCol.aDataSort = [oOptions.iDataSort]\n          }\n          _fnMap(oCol, oOptions, 'aDataSort')\n        }\n\n        /* Cache the data get and set functions for speed */\n        var mDataSrc = oCol.mData\n        var mData = _fnGetObjectDataFn(mDataSrc)\n        var mRender = oCol.mRender ? _fnGetObjectDataFn(oCol.mRender) : null\n\n        var attrTest = function (src) {\n          return typeof src === 'string' && src.indexOf('@') !== -1\n        }\n        oCol._bAttrSrc =\n          $.isPlainObject(mDataSrc) && (attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter))\n\n        oCol.fnGetData = function (rowData, type, meta) {\n          var innerData = mData(rowData, type, undefined, meta)\n\n          return mRender && type ? mRender(innerData, type, rowData, meta) : innerData\n        }\n        oCol.fnSetData = function (rowData, val, meta) {\n          return _fnSetObjectDataFn(mDataSrc)(rowData, val, meta)\n        }\n\n        /* Feature sorting overrides column specific when off */\n        if (!oSettings.oFeatures.bSort) {\n          oCol.bSortable = false\n          th.addClass(oClasses.sSortableNone) // Have to add class here as order event isn't called\n        }\n\n        /* Check that the class assignment is correct for sorting */\n        var bAsc = $.inArray('asc', oCol.asSorting) !== -1\n        var bDesc = $.inArray('desc', oCol.asSorting) !== -1\n        if (!oCol.bSortable || (!bAsc && !bDesc)) {\n          oCol.sSortingClass = oClasses.sSortableNone\n          oCol.sSortingClassJUI = ''\n        } else if (bAsc && !bDesc) {\n          oCol.sSortingClass = oClasses.sSortableAsc\n          oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed\n        } else if (!bAsc && bDesc) {\n          oCol.sSortingClass = oClasses.sSortableDesc\n          oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed\n        } else {\n          oCol.sSortingClass = oClasses.sSortable\n          oCol.sSortingClassJUI = oClasses.sSortJUI\n        }\n      }\n\n      /**\n       * Adjust the table column widths for new data. Note: you would probably want to\n       * do a redraw after calling this function!\n       *  @param {object} settings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnAdjustColumnSizing (settings) {\n        /* Not interested in doing column width calculation if auto-width is disabled */\n        if (settings.oFeatures.bAutoWidth !== false) {\n          var columns = settings.aoColumns\n\n          _fnCalculateColumnWidths(settings)\n          for (var i = 0, iLen = columns.length; i < iLen; i++) {\n            columns[i].nTh.style.width = columns[i].sWidth\n          }\n        }\n\n        var scroll = settings.oScroll\n        if (scroll.sY !== '' || scroll.sX !== '') {\n          _fnScrollDraw(settings)\n        }\n\n        _fnCallbackFire(settings, null, 'column-sizing', [settings])\n      }\n\n      /**\n       * Covert the index of a visible column to the index in the data array (take account\n       * of hidden columns)\n       *  @param {object} oSettings dataTables settings object\n       *  @param {int} iMatch Visible column index to lookup\n       *  @returns {int} i the data index\n       *  @memberof DataTable#oApi\n       */\n      function _fnVisibleToColumnIndex (oSettings, iMatch) {\n        var aiVis = _fnGetColumns(oSettings, 'bVisible')\n\n        return typeof aiVis[iMatch] === 'number' ? aiVis[iMatch] : null\n      }\n\n      /**\n       * Covert the index of an index in the data array and convert it to the visible\n       *   column index (take account of hidden columns)\n       *  @param {int} iMatch Column index to lookup\n       *  @param {object} oSettings dataTables settings object\n       *  @returns {int} i the data index\n       *  @memberof DataTable#oApi\n       */\n      function _fnColumnIndexToVisible (oSettings, iMatch) {\n        var aiVis = _fnGetColumns(oSettings, 'bVisible')\n        var iPos = $.inArray(iMatch, aiVis)\n\n        return iPos !== -1 ? iPos : null\n      }\n\n      /**\n       * Get the number of visible columns\n       *  @param {object} oSettings dataTables settings object\n       *  @returns {int} i the number of visible columns\n       *  @memberof DataTable#oApi\n       */\n      function _fnVisbleColumns (oSettings) {\n        return _fnGetColumns(oSettings, 'bVisible').length\n      }\n\n      /**\n       * Get an array of column indexes that match a given property\n       *  @param {object} oSettings dataTables settings object\n       *  @param {string} sParam Parameter in aoColumns to look for - typically\n       *    bVisible or bSearchable\n       *  @returns {array} Array of indexes with matched properties\n       *  @memberof DataTable#oApi\n       */\n      function _fnGetColumns (oSettings, sParam) {\n        var a = []\n\n        $.map(oSettings.aoColumns, function (val, i) {\n          if (val[sParam]) {\n            a.push(i)\n          }\n        })\n\n        return a\n      }\n\n      /**\n       * Calculate the 'type' of a column\n       *  @param {object} settings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnColumnTypes (settings) {\n        var columns = settings.aoColumns\n        var data = settings.aoData\n        var types = DataTable.ext.type.detect\n        var i, ien, j, jen, k, ken\n        var col, cell, detectedType, cache\n\n        // For each column, spin over the\n        for (i = 0, ien = columns.length; i < ien; i++) {\n          col = columns[i]\n          cache = []\n\n          if (!col.sType && col._sManualType) {\n            col.sType = col._sManualType\n          } else if (!col.sType) {\n            for (j = 0, jen = types.length; j < jen; j++) {\n              for (k = 0, ken = data.length; k < ken; k++) {\n                // Use a cache array so we only need to get the type data\n                // from the formatter once (when using multiple detectors)\n                if (cache[k] === undefined) {\n                  cache[k] = _fnGetCellData(settings, k, i, 'type')\n                }\n\n                detectedType = types[j](cache[k], settings)\n\n                // Doesn't match, so break early, since this type can't\n                // apply to this column. Also, HTML is a special case since\n                // it is so similar to `string`. Just a single match is\n                // needed for a column to be html type\n                if (!detectedType || detectedType === 'html') {\n                  break\n                }\n              }\n\n              // Type is valid for all data points in the column - use this\n              // type\n              if (detectedType) {\n                col.sType = detectedType\n                break\n              }\n            }\n\n            // Fall back - if no type was detected, always use string\n            if (!col.sType) {\n              col.sType = 'string'\n            }\n          }\n        }\n      }\n\n      /**\n       * Take the column definitions and static columns arrays and calculate how\n       * they relate to column indexes. The callback function will then apply the\n       * definition found for a column to a suitable configuration object.\n       *  @param {object} oSettings dataTables settings object\n       *  @param {array} aoColDefs The aoColumnDefs array that is to be applied\n       *  @param {array} aoCols The aoColumns array that defines columns individually\n       *  @param {function} fn Callback function - takes two parameters, the calculated\n       *    column index and the definition for that column.\n       *  @memberof DataTable#oApi\n       */\n      function _fnApplyColumnDefs (oSettings, aoColDefs, aoCols, fn) {\n        var i, iLen, j, jLen, k, kLen, def\n        var columns = oSettings.aoColumns\n\n        // Column definitions with aTargets\n        if (aoColDefs) {\n          /* Loop over the definitions array - loop in reverse so first instance has priority */\n          for (i = aoColDefs.length - 1; i >= 0; i--) {\n            def = aoColDefs[i]\n\n            /* Each definition can target multiple columns, as it is an array */\n            var aTargets = def.targets !== undefined ? def.targets : def.aTargets\n\n            if (!$.isArray(aTargets)) {\n              aTargets = [aTargets]\n            }\n\n            for (j = 0, jLen = aTargets.length; j < jLen; j++) {\n              if (typeof aTargets[j] === 'number' && aTargets[j] >= 0) {\n                /* Add columns that we don't yet know about */\n                while (columns.length <= aTargets[j]) {\n                  _fnAddColumn(oSettings)\n                }\n\n                /* Integer, basic index */\n                fn(aTargets[j], def)\n              } else if (typeof aTargets[j] === 'number' && aTargets[j] < 0) {\n                /* Negative integer, right to left column counting */\n                fn(columns.length + aTargets[j], def)\n              } else if (typeof aTargets[j] === 'string') {\n                /* Class name matching on TH element */\n                for (k = 0, kLen = columns.length; k < kLen; k++) {\n                  if (aTargets[j] == '_all' || $(columns[k].nTh).hasClass(aTargets[j])) {\n                    fn(k, def)\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        // Statically defined columns array\n        if (aoCols) {\n          for (i = 0, iLen = aoCols.length; i < iLen; i++) {\n            fn(i, aoCols[i])\n          }\n        }\n      }\n\n      /**\n       * Add a data array to the table, creating DOM node etc. This is the parallel to\n       * _fnGatherData, but for adding rows from a Javascript source, rather than a\n       * DOM source.\n       *  @param {object} oSettings dataTables settings object\n       *  @param {array} aData data array to be added\n       *  @param {node} [nTr] TR element to add to the table - optional. If not given,\n       *    DataTables will create a row automatically\n       *  @param {array} [anTds] Array of TD|TH elements for the row - must be given\n       *    if nTr is.\n       *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed\n       *  @memberof DataTable#oApi\n       */\n      function _fnAddData (oSettings, aDataIn, nTr, anTds) {\n        /* Create the object for storing information about this new row */\n        var iRow = oSettings.aoData.length\n        var oData = $.extend(true, {}, DataTable.models.oRow, {\n          src: nTr ? 'dom' : 'data'\n        })\n\n        oData._aData = aDataIn\n        oSettings.aoData.push(oData)\n\n        /* Create the cells */\n        var nTd, sThisType\n        var columns = oSettings.aoColumns\n        for (var i = 0, iLen = columns.length; i < iLen; i++) {\n          // When working with a row, the data source object must be populated. In\n          // all other cases, the data source object is already populated, so we\n          // don't overwrite it, which might break bindings etc\n          if (nTr) {\n            _fnSetCellData(oSettings, iRow, i, _fnGetCellData(oSettings, iRow, i))\n          }\n          columns[i].sType = null\n        }\n\n        /* Add to the display array */\n        oSettings.aiDisplayMaster.push(iRow)\n\n        /* Create the DOM information, or register it if already present */\n        if (nTr || !oSettings.oFeatures.bDeferRender) {\n          _fnCreateTr(oSettings, iRow, nTr, anTds)\n        }\n\n        return iRow\n      }\n\n      /**\n       * Add one or more TR elements to the table. Generally we'd expect to\n       * use this for reading data from a DOM sourced table, but it could be\n       * used for an TR element. Note that if a TR is given, it is used (i.e.\n       * it is not cloned).\n       *  @param {object} settings dataTables settings object\n       *  @param {array|node|jQuery} trs The TR element(s) to add to the table\n       *  @returns {array} Array of indexes for the added rows\n       *  @memberof DataTable#oApi\n       */\n      function _fnAddTr (settings, trs) {\n        var row\n\n        // Allow an individual node to be passed in\n        if (!(trs instanceof $)) {\n          trs = $(trs)\n        }\n\n        return trs.map(function (i, el) {\n          row = _fnGetRowElements(settings, el)\n          return _fnAddData(settings, row.data, el, row.cells)\n        })\n      }\n\n      /**\n       * Take a TR element and convert it to an index in aoData\n       *  @param {object} oSettings dataTables settings object\n       *  @param {node} n the TR element to find\n       *  @returns {int} index if the node is found, null if not\n       *  @memberof DataTable#oApi\n       */\n      function _fnNodeToDataIndex (oSettings, n) {\n        return n._DT_RowIndex !== undefined ? n._DT_RowIndex : null\n      }\n\n      /**\n       * Take a TD element and convert it into a column data index (not the visible index)\n       *  @param {object} oSettings dataTables settings object\n       *  @param {int} iRow The row number the TD/TH can be found in\n       *  @param {node} n The TD/TH element to find\n       *  @returns {int} index if the node is found, -1 if not\n       *  @memberof DataTable#oApi\n       */\n      function _fnNodeToColumnIndex (oSettings, iRow, n) {\n        return $.inArray(n, oSettings.aoData[iRow].anCells)\n      }\n\n      /**\n       * Get the data for a given cell from the internal cache, taking into account data mapping\n       *  @param {object} settings dataTables settings object\n       *  @param {int} rowIdx aoData row id\n       *  @param {int} colIdx Column index\n       *  @param {string} type data get type ('display', 'type' 'filter' 'sort')\n       *  @returns {*} Cell data\n       *  @memberof DataTable#oApi\n       */\n      function _fnGetCellData (settings, rowIdx, colIdx, type) {\n        var draw = settings.iDraw\n        var col = settings.aoColumns[colIdx]\n        var rowData = settings.aoData[rowIdx]._aData\n        var defaultContent = col.sDefaultContent\n        var cellData = col.fnGetData(rowData, type, {\n          settings: settings,\n          row: rowIdx,\n          col: colIdx\n        })\n\n        if (cellData === undefined) {\n          if (settings.iDrawError != draw && defaultContent === null) {\n            _fnLog(\n              settings,\n              0,\n              'Requested unknown parameter ' +\n                (typeof col.mData == 'function' ? '{function}' : \"'\" + col.mData + \"'\") +\n                ' for row ' +\n                rowIdx,\n              4\n            )\n            settings.iDrawError = draw\n          }\n          return defaultContent\n        }\n\n        /* When the data source is null, we can use default column data */\n        if ((cellData === rowData || cellData === null) && defaultContent !== null) {\n          cellData = defaultContent\n        } else if (typeof cellData === 'function') {\n          // If the data source is a function, then we run it and use the return,\n          // executing in the scope of the data object (for instances)\n          return cellData.call(rowData)\n        }\n\n        if (cellData === null && type == 'display') {\n          return ''\n        }\n        return cellData\n      }\n\n      /**\n       * Set the value for a specific cell, into the internal data cache\n       *  @param {object} settings dataTables settings object\n       *  @param {int} rowIdx aoData row id\n       *  @param {int} colIdx Column index\n       *  @param {*} val Value to set\n       *  @memberof DataTable#oApi\n       */\n      function _fnSetCellData (settings, rowIdx, colIdx, val) {\n        var col = settings.aoColumns[colIdx]\n        var rowData = settings.aoData[rowIdx]._aData\n\n        col.fnSetData(rowData, val, {\n          settings: settings,\n          row: rowIdx,\n          col: colIdx\n        })\n      }\n\n      // Private variable that is used to match action syntax in the data property object\n      var __reArray = /\\[.*?\\]$/\n      var __reFn = /\\(\\)$/\n\n      /**\n       * Split string on periods, taking into account escaped periods\n       * @param  {string} str String to split\n       * @return {array} Split string\n       */\n      function _fnSplitObjNotation (str) {\n        return $.map(str.match(/(\\\\.|[^\\.])+/g), function (s) {\n          return s.replace(/\\\\./g, '.')\n        })\n      }\n\n      /**\n       * Return a function that can be used to get data from a source object, taking\n       * into account the ability to use nested objects as a source\n       *  @param {string|int|function} mSource The data source for the object\n       *  @returns {function} Data get function\n       *  @memberof DataTable#oApi\n       */\n      function _fnGetObjectDataFn (mSource) {\n        if ($.isPlainObject(mSource)) {\n          /* Build an object of get functions, and wrap them in a single call */\n          var o = {}\n          $.each(mSource, function (key, val) {\n            if (val) {\n              o[key] = _fnGetObjectDataFn(val)\n            }\n          })\n\n          return function (data, type, row, meta) {\n            var t = o[type] || o._\n            return t !== undefined ? t(data, type, row, meta) : data\n          }\n        } else if (mSource === null) {\n          /* Give an empty string for rendering / sorting etc */\n          return function (data) {\n            // type, row and meta also passed, but not used\n            return data\n          }\n        } else if (typeof mSource === 'function') {\n          return function (data, type, row, meta) {\n            return mSource(data, type, row, meta)\n          }\n        } else if (\n          typeof mSource === 'string' &&\n          (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)\n        ) {\n          /* If there is a . in the source string then the data source is in a\n           * nested object so we loop over the data for each level to get the next\n           * level down. On each loop we test for undefined, and if found immediately\n           * return. This allows entire objects to be missing and sDefaultContent to\n           * be used if defined, rather than throwing an error\n           */\n          var fetchData = function (data, type, src) {\n            var arrayNotation, funcNotation, out, innerSrc\n\n            if (src !== '') {\n              var a = _fnSplitObjNotation(src)\n\n              for (var i = 0, iLen = a.length; i < iLen; i++) {\n                // Check if we are dealing with special notation\n                arrayNotation = a[i].match(__reArray)\n                funcNotation = a[i].match(__reFn)\n\n                if (arrayNotation) {\n                  // Array notation\n                  a[i] = a[i].replace(__reArray, '')\n\n                  // Condition allows simply [] to be passed in\n                  if (a[i] !== '') {\n                    data = data[a[i]]\n                  }\n                  out = []\n\n                  // Get the remainder of the nested object to get\n                  a.splice(0, i + 1)\n                  innerSrc = a.join('.')\n\n                  // Traverse each entry in the array getting the properties requested\n                  for (var j = 0, jLen = data.length; j < jLen; j++) {\n                    out.push(fetchData(data[j], type, innerSrc))\n                  }\n\n                  // If a string is given in between the array notation indicators, that\n                  // is used to join the strings together, otherwise an array is returned\n                  var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1)\n                  data = join === '' ? out : out.join(join)\n\n                  // The inner call to fetchData has already traversed through the remainder\n                  // of the source requested, so we exit from the loop\n                  break\n                } else if (funcNotation) {\n                  // Function call\n                  a[i] = a[i].replace(__reFn, '')\n                  data = data[a[i]]()\n                  continue\n                }\n\n                if (data === null || data[a[i]] === undefined) {\n                  return undefined\n                }\n                data = data[a[i]]\n              }\n            }\n\n            return data\n          }\n\n          return function (data, type) {\n            // row and meta also passed, but not used\n            return fetchData(data, type, mSource)\n          }\n        } else {\n          /* Array or flat object mapping */\n          return function (data, type) {\n            // row and meta also passed, but not used\n            return data[mSource]\n          }\n        }\n      }\n\n      /**\n       * Return a function that can be used to set data from a source object, taking\n       * into account the ability to use nested objects as a source\n       *  @param {string|int|function} mSource The data source for the object\n       *  @returns {function} Data set function\n       *  @memberof DataTable#oApi\n       */\n      function _fnSetObjectDataFn (mSource) {\n        if ($.isPlainObject(mSource)) {\n          /* Unlike get, only the underscore (global) option is used for for\n           * setting data since we don't know the type here. This is why an object\n           * option is not documented for `mData` (which is read/write), but it is\n           * for `mRender` which is read only.\n           */\n          return _fnSetObjectDataFn(mSource._)\n        } else if (mSource === null) {\n          /* Nothing to do when the data source is null */\n          return function () {}\n        } else if (typeof mSource === 'function') {\n          return function (data, val, meta) {\n            mSource(data, 'set', val, meta)\n          }\n        } else if (\n          typeof mSource === 'string' &&\n          (mSource.indexOf('.') !== -1 || mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)\n        ) {\n          /* Like the get, we need to get data from a nested object */\n          var setData = function (data, val, src) {\n            var a = _fnSplitObjNotation(src),\n              b\n            var aLast = a[a.length - 1]\n            var arrayNotation, funcNotation, o, innerSrc\n\n            for (var i = 0, iLen = a.length - 1; i < iLen; i++) {\n              // Check if we are dealing with an array notation request\n              arrayNotation = a[i].match(__reArray)\n              funcNotation = a[i].match(__reFn)\n\n              if (arrayNotation) {\n                a[i] = a[i].replace(__reArray, '')\n                data[a[i]] = []\n\n                // Get the remainder of the nested object to set so we can recurse\n                b = a.slice()\n                b.splice(0, i + 1)\n                innerSrc = b.join('.')\n\n                // Traverse each entry in the array setting the properties requested\n                for (var j = 0, jLen = val.length; j < jLen; j++) {\n                  o = {}\n                  setData(o, val[j], innerSrc)\n                  data[a[i]].push(o)\n                }\n\n                // The inner call to setData has already traversed through the remainder\n                // of the source and has set the data, thus we can exit here\n                return\n              } else if (funcNotation) {\n                // Function call\n                a[i] = a[i].replace(__reFn, '')\n                data = data[a[i]](val)\n              }\n\n              // If the nested object doesn't currently exist - since we are\n              // trying to set the value - create it\n              if (data[a[i]] === null || data[a[i]] === undefined) {\n                data[a[i]] = {}\n              }\n              data = data[a[i]]\n            }\n\n            // Last item in the input - i.e, the actual set\n            if (aLast.match(__reFn)) {\n              // Function call\n              data = data[aLast.replace(__reFn, '')](val)\n            } else {\n              // If array notation is used, we just want to strip it and use the property name\n              // and assign the value. If it isn't used, then we get the result we want anyway\n              data[aLast.replace(__reArray, '')] = val\n            }\n          }\n\n          return function (data, val) {\n            // meta is also passed in, but not used\n            return setData(data, val, mSource)\n          }\n        } else {\n          /* Array or flat object mapping */\n          return function (data, val) {\n            // meta is also passed in, but not used\n            data[mSource] = val\n          }\n        }\n      }\n\n      /**\n       * Return an array with the full table data\n       *  @param {object} oSettings dataTables settings object\n       *  @returns array {array} aData Master data array\n       *  @memberof DataTable#oApi\n       */\n      function _fnGetDataMaster (settings) {\n        return _pluck(settings.aoData, '_aData')\n      }\n\n      /**\n       * Nuke the table\n       *  @param {object} oSettings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnClearTable (settings) {\n        settings.aoData.length = 0\n        settings.aiDisplayMaster.length = 0\n        settings.aiDisplay.length = 0\n      }\n\n      /**\n       * Take an array of integers (index array) and remove a target integer (value - not\n       * the key!)\n       *  @param {array} a Index array to target\n       *  @param {int} iTarget value to find\n       *  @memberof DataTable#oApi\n       */\n      function _fnDeleteIndex (a, iTarget, splice) {\n        var iTargetIndex = -1\n\n        for (var i = 0, iLen = a.length; i < iLen; i++) {\n          if (a[i] == iTarget) {\n            iTargetIndex = i\n          } else if (a[i] > iTarget) {\n            a[i]--\n          }\n        }\n\n        if (iTargetIndex != -1 && splice === undefined) {\n          a.splice(iTargetIndex, 1)\n        }\n      }\n\n      /**\n       * Mark cached data as invalid such that a re-read of the data will occur when\n       * the cached data is next requested. Also update from the data source object.\n       *\n       * @param {object} settings DataTables settings object\n       * @param  {int}    rowIdx   Row index to invalidate\n       * @memberof DataTable#oApi\n       *\n       * @todo For the modularisation of v1.11 this will need to become a callback, so\n       *   the sort and filter methods can subscribe to it. That will required\n       *   initialisation options for sorting, which is why it is not already baked in\n       */\n      function _fnInvalidateRow (settings, rowIdx, src, column) {\n        var row = settings.aoData[rowIdx]\n        var i, ien\n\n        // Are we reading last data from DOM or the data object?\n        if (src === 'dom' || ((!src || src === 'auto') && row.src === 'dom')) {\n          // Read the data from the DOM\n          row._aData = _fnGetRowElements(settings, row).data\n        } else {\n          // Reading from data object, update the DOM\n          var cells = row.anCells\n          var cell\n\n          if (cells) {\n            for (i = 0, ien = cells.length; i < ien; i++) {\n              cell = cells[i]\n\n              // This is very frustrating, but in IE if you just write directly\n              // to innerHTML, and elements that are overwritten are GC'ed,\n              // even if there is a reference to them elsewhere\n              while (cell.childNodes.length) {\n                cell.removeChild(cell.firstChild)\n              }\n\n              cells[i].innerHTML = _fnGetCellData(settings, rowIdx, i, 'display')\n            }\n          }\n        }\n\n        row._aSortData = null\n        row._aFilterData = null\n\n        // Invalidate the type for a specific column (if given) or all columns since\n        // the data might have changed\n        var cols = settings.aoColumns\n        if (column !== undefined) {\n          cols[column].sType = null\n        } else {\n          for (i = 0, ien = cols.length; i < ien; i++) {\n            cols[i].sType = null\n          }\n        }\n\n        // Update DataTables special `DT_*` attributes for the row\n        _fnRowAttributes(row)\n      }\n\n      /**\n       * Build a data source object from an HTML row, reading the contents of the\n       * cells that are in the row.\n       *\n       * @param {object} settings DataTables settings object\n       * @param {node|object} TR element from which to read data or existing row\n       *   object from which to re-read the data from the cells\n       * @returns {object} Object with two parameters: `data` the data read, in\n       *   document order, and `cells` and array of nodes (they can be useful to the\n       *   caller, so rather than needing a second traversal to get them, just return\n       *   them from here).\n       * @memberof DataTable#oApi\n       */\n      function _fnGetRowElements (settings, row) {\n        var d = [],\n          tds = [],\n          td = row.firstChild,\n          name,\n          col,\n          o,\n          i = 0,\n          contents,\n          columns = settings.aoColumns\n\n        var attr = function (str, data, td) {\n          if (typeof str === 'string') {\n            var idx = str.indexOf('@')\n\n            if (idx !== -1) {\n              var src = str.substring(idx + 1)\n              o['@' + src] = td.getAttribute(src)\n            }\n          }\n        }\n\n        var cellProcess = function (cell) {\n          col = columns[i]\n          contents = $.trim(cell.innerHTML)\n\n          if (col && col._bAttrSrc) {\n            o = {\n              display: contents\n            }\n\n            attr(col.mData.sort, o, cell)\n            attr(col.mData.type, o, cell)\n            attr(col.mData.filter, o, cell)\n\n            d.push(o)\n          } else {\n            d.push(contents)\n          }\n\n          i++\n        }\n\n        if (td) {\n          // `tr` element passed in\n          while (td) {\n            name = td.nodeName.toUpperCase()\n\n            if (name == 'TD' || name == 'TH') {\n              cellProcess(td)\n              tds.push(td)\n            }\n\n            td = td.nextSibling\n          }\n        } else {\n          // Existing row object passed in\n          tds = row.anCells\n\n          for (var j = 0, jen = tds.length; j < jen; j++) {\n            cellProcess(tds[j])\n          }\n        }\n\n        return {\n          data: d,\n          cells: tds\n        }\n      }\n      /**\n       * Create a new TR element (and it's TD children) for a row\n       *  @param {object} oSettings dataTables settings object\n       *  @param {int} iRow Row to consider\n       *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,\n       *    DataTables will create a row automatically\n       *  @param {array} [anTds] Array of TD|TH elements for the row - must be given\n       *    if nTr is.\n       *  @memberof DataTable#oApi\n       */\n      function _fnCreateTr (oSettings, iRow, nTrIn, anTds) {\n        var row = oSettings.aoData[iRow],\n          rowData = row._aData,\n          cells = [],\n          nTr,\n          nTd,\n          oCol,\n          i,\n          iLen\n\n        if (row.nTr === null) {\n          nTr = nTrIn || document.createElement('tr')\n\n          row.nTr = nTr\n          row.anCells = cells\n\n          /* Use a private property on the node to allow reserve mapping from the node\n           * to the aoData array for fast look up\n           */\n          nTr._DT_RowIndex = iRow\n\n          /* Special parameters can be given by the data source to be used on the row */\n          _fnRowAttributes(row)\n\n          /* Process each column */\n          for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {\n            oCol = oSettings.aoColumns[i]\n\n            nTd = nTrIn ? anTds[i] : document.createElement(oCol.sCellType)\n            cells.push(nTd)\n\n            // Need to create the HTML if new, or if a rendering function is defined\n            if (!nTrIn || oCol.mRender || oCol.mData !== i) {\n              nTd.innerHTML = _fnGetCellData(oSettings, iRow, i, 'display')\n            }\n\n            /* Add user defined class */\n            if (oCol.sClass) {\n              nTd.className += ' ' + oCol.sClass\n            }\n\n            // Visibility - add or remove as required\n            if (oCol.bVisible && !nTrIn) {\n              nTr.appendChild(nTd)\n            } else if (!oCol.bVisible && nTrIn) {\n              nTd.parentNode.removeChild(nTd)\n            }\n\n            if (oCol.fnCreatedCell) {\n              oCol.fnCreatedCell.call(oSettings.oInstance, nTd, _fnGetCellData(oSettings, iRow, i), rowData, iRow, i)\n            }\n          }\n\n          _fnCallbackFire(oSettings, 'aoRowCreatedCallback', null, [nTr, rowData, iRow])\n        }\n\n        // Remove once webkit bug 131819 and Chromium bug 365619 have been resolved\n        // and deployed\n        row.nTr.setAttribute('role', 'row')\n      }\n\n      /**\n       * Add attributes to a row based on the special `DT_*` parameters in a data\n       * source object.\n       *  @param {object} DataTables row object for the row to be modified\n       *  @memberof DataTable#oApi\n       */\n      function _fnRowAttributes (row) {\n        var tr = row.nTr\n        var data = row._aData\n\n        if (tr) {\n          if (data.DT_RowId) {\n            tr.id = data.DT_RowId\n          }\n\n          if (data.DT_RowClass) {\n            // Remove any classes added by DT_RowClass before\n            var a = data.DT_RowClass.split(' ')\n            row.__rowc = row.__rowc ? _unique(row.__rowc.concat(a)) : a\n\n            $(tr)\n              .removeClass(row.__rowc.join(' '))\n              .addClass(data.DT_RowClass)\n          }\n\n          if (data.DT_RowData) {\n            $(tr).data(data.DT_RowData)\n          }\n        }\n      }\n\n      /**\n       * Create the HTML header for the table\n       *  @param {object} oSettings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnBuildHead (oSettings) {\n        var i, ien, cell, row, column\n        var thead = oSettings.nTHead\n        var tfoot = oSettings.nTFoot\n        var createHeader = $('th, td', thead).length === 0\n        var classes = oSettings.oClasses\n        var columns = oSettings.aoColumns\n\n        if (createHeader) {\n          row = $('<tr/>').appendTo(thead)\n        }\n\n        for (i = 0, ien = columns.length; i < ien; i++) {\n          column = columns[i]\n          cell = $(column.nTh).addClass(column.sClass)\n\n          if (createHeader) {\n            cell.appendTo(row)\n          }\n\n          // 1.11 move into sorting\n          if (oSettings.oFeatures.bSort) {\n            cell.addClass(column.sSortingClass)\n\n            if (column.bSortable !== false) {\n              cell.attr('tabindex', oSettings.iTabIndex).attr('aria-controls', oSettings.sTableId)\n\n              _fnSortAttachListener(oSettings, column.nTh, i)\n            }\n          }\n\n          if (column.sTitle != cell.html()) {\n            cell.html(column.sTitle)\n          }\n\n          _fnRenderer(oSettings, 'header')(oSettings, cell, column, classes)\n        }\n\n        if (createHeader) {\n          _fnDetectHeader(oSettings.aoHeader, thead)\n        }\n\n        /* ARIA role for the rows */\n        $(thead)\n          .find('>tr')\n          .attr('role', 'row')\n\n        /* Deal with the footer - add classes if required */\n        $(thead)\n          .find('>tr>th, >tr>td')\n          .addClass(classes.sHeaderTH)\n        $(tfoot)\n          .find('>tr>th, >tr>td')\n          .addClass(classes.sFooterTH)\n\n        // Cache the footer cells. Note that we only take the cells from the first\n        // row in the footer. If there is more than one row the user wants to\n        // interact with, they need to use the table().foot() method. Note also this\n        // allows cells to be used for multiple columns using colspan\n        if (tfoot !== null) {\n          var cells = oSettings.aoFooter[0]\n\n          for (i = 0, ien = cells.length; i < ien; i++) {\n            column = columns[i]\n            column.nTf = cells[i].cell\n\n            if (column.sClass) {\n              $(column.nTf).addClass(column.sClass)\n            }\n          }\n        }\n      }\n\n      /**\n       * Draw the header (or footer) element based on the column visibility states. The\n       * methodology here is to use the layout array from _fnDetectHeader, modified for\n       * the instantaneous column visibility, to construct the new layout. The grid is\n       * traversed over cell at a time in a rows x columns grid fashion, although each\n       * cell insert can cover multiple elements in the grid - which is tracks using the\n       * aApplied array. Cell inserts in the grid will only occur where there isn't\n       * already a cell in that position.\n       *  @param {object} oSettings dataTables settings object\n       *  @param array {objects} aoSource Layout array from _fnDetectHeader\n       *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,\n       *  @memberof DataTable#oApi\n       */\n      function _fnDrawHead (oSettings, aoSource, bIncludeHidden) {\n        var i, iLen, j, jLen, k, kLen, n, nLocalTr\n        var aoLocal = []\n        var aApplied = []\n        var iColumns = oSettings.aoColumns.length\n        var iRowspan, iColspan\n\n        if (!aoSource) {\n          return\n        }\n\n        if (bIncludeHidden === undefined) {\n          bIncludeHidden = false\n        }\n\n        /* Make a copy of the master layout array, but without the visible columns in it */\n        for (i = 0, iLen = aoSource.length; i < iLen; i++) {\n          aoLocal[i] = aoSource[i].slice()\n          aoLocal[i].nTr = aoSource[i].nTr\n\n          /* Remove any columns which are currently hidden */\n          for (j = iColumns - 1; j >= 0; j--) {\n            if (!oSettings.aoColumns[j].bVisible && !bIncludeHidden) {\n              aoLocal[i].splice(j, 1)\n            }\n          }\n\n          /* Prep the applied array - it needs an element for each row */\n          aApplied.push([])\n        }\n\n        for (i = 0, iLen = aoLocal.length; i < iLen; i++) {\n          nLocalTr = aoLocal[i].nTr\n\n          /* All cells are going to be replaced, so empty out the row */\n          if (nLocalTr) {\n            while ((n = nLocalTr.firstChild)) {\n              nLocalTr.removeChild(n)\n            }\n          }\n\n          for (j = 0, jLen = aoLocal[i].length; j < jLen; j++) {\n            iRowspan = 1\n            iColspan = 1\n\n            /* Check to see if there is already a cell (row/colspan) covering our target\n             * insert point. If there is, then there is nothing to do.\n             */\n            if (aApplied[i][j] === undefined) {\n              nLocalTr.appendChild(aoLocal[i][j].cell)\n              aApplied[i][j] = 1\n\n              /* Expand the cell to cover as many rows as needed */\n              while (aoLocal[i + iRowspan] !== undefined && aoLocal[i][j].cell == aoLocal[i + iRowspan][j].cell) {\n                aApplied[i + iRowspan][j] = 1\n                iRowspan++\n              }\n\n              /* Expand the cell to cover as many columns as needed */\n              while (aoLocal[i][j + iColspan] !== undefined && aoLocal[i][j].cell == aoLocal[i][j + iColspan].cell) {\n                /* Must update the applied array over the rows for the columns */\n                for (k = 0; k < iRowspan; k++) {\n                  aApplied[i + k][j + iColspan] = 1\n                }\n                iColspan++\n              }\n\n              /* Do the actual expansion in the DOM */\n              $(aoLocal[i][j].cell)\n                .attr('rowspan', iRowspan)\n                .attr('colspan', iColspan)\n            }\n          }\n        }\n      }\n\n      /**\n       * Insert the required TR nodes into the table for display\n       *  @param {object} oSettings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnDraw (oSettings) {\n        /* Provide a pre-callback function which can be used to cancel the draw is false is returned */\n        var aPreDraw = _fnCallbackFire(oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings])\n        if ($.inArray(false, aPreDraw) !== -1) {\n          _fnProcessingDisplay(oSettings, false)\n          return\n        }\n\n        var i, iLen, n\n        var anRows = []\n        var iRowCount = 0\n        var asStripeClasses = oSettings.asStripeClasses\n        var iStripes = asStripeClasses.length\n        var iOpenRows = oSettings.aoOpenRows.length\n        var oLang = oSettings.oLanguage\n        var iInitDisplayStart = oSettings.iInitDisplayStart\n        var bServerSide = _fnDataSource(oSettings) == 'ssp'\n        var aiDisplay = oSettings.aiDisplay\n\n        oSettings.bDrawing = true\n\n        /* Check and see if we have an initial draw position from state saving */\n        if (iInitDisplayStart !== undefined && iInitDisplayStart !== -1) {\n          oSettings._iDisplayStart = bServerSide\n            ? iInitDisplayStart\n            : iInitDisplayStart >= oSettings.fnRecordsDisplay()\n            ? 0\n            : iInitDisplayStart\n\n          oSettings.iInitDisplayStart = -1\n        }\n\n        var iDisplayStart = oSettings._iDisplayStart\n        var iDisplayEnd = oSettings.fnDisplayEnd()\n\n        /* Server-side processing draw intercept */\n        if (oSettings.bDeferLoading) {\n          oSettings.bDeferLoading = false\n          oSettings.iDraw++\n          _fnProcessingDisplay(oSettings, false)\n        } else if (!bServerSide) {\n          oSettings.iDraw++\n        } else if (!oSettings.bDestroying && !_fnAjaxUpdate(oSettings)) {\n          return\n        }\n\n        if (aiDisplay.length !== 0) {\n          var iStart = bServerSide ? 0 : iDisplayStart\n          var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd\n\n          for (var j = iStart; j < iEnd; j++) {\n            var iDataIndex = aiDisplay[j]\n            var aoData = oSettings.aoData[iDataIndex]\n            if (aoData.nTr === null) {\n              _fnCreateTr(oSettings, iDataIndex)\n            }\n\n            var nRow = aoData.nTr\n\n            /* Remove the old striping classes and then add the new one */\n            if (iStripes !== 0) {\n              var sStripe = asStripeClasses[iRowCount % iStripes]\n              if (aoData._sRowStripe != sStripe) {\n                $(nRow)\n                  .removeClass(aoData._sRowStripe)\n                  .addClass(sStripe)\n                aoData._sRowStripe = sStripe\n              }\n            }\n\n            /* Row callback functions - might want to manipulate the row */\n            _fnCallbackFire(oSettings, 'aoRowCallback', null, [nRow, aoData._aData, iRowCount, j])\n\n            anRows.push(nRow)\n            iRowCount++\n          }\n        } else {\n          /* Table is empty - create a row with an empty message in it */\n          var sZero = oLang.sZeroRecords\n          if (oSettings.iDraw == 1 && _fnDataSource(oSettings) == 'ajax') {\n            sZero = oLang.sLoadingRecords\n          } else if (oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0) {\n            sZero = oLang.sEmptyTable\n          }\n\n          anRows[0] = $('<tr/>', { class: iStripes ? asStripeClasses[0] : '' }).append(\n            $('<td />', {\n              valign: 'top',\n              colSpan: _fnVisbleColumns(oSettings),\n              class: oSettings.oClasses.sRowEmpty\n            }).html(sZero)\n          )[0]\n        }\n\n        /* Header and footer callbacks */\n        _fnCallbackFire(oSettings, 'aoHeaderCallback', 'header', [\n          $(oSettings.nTHead).children('tr')[0],\n          _fnGetDataMaster(oSettings),\n          iDisplayStart,\n          iDisplayEnd,\n          aiDisplay\n        ])\n\n        _fnCallbackFire(oSettings, 'aoFooterCallback', 'footer', [\n          $(oSettings.nTFoot).children('tr')[0],\n          _fnGetDataMaster(oSettings),\n          iDisplayStart,\n          iDisplayEnd,\n          aiDisplay\n        ])\n\n        var body = $(oSettings.nTBody)\n\n        body.children().detach()\n        body.append($(anRows))\n\n        /* Call all required callback functions for the end of a draw */\n        _fnCallbackFire(oSettings, 'aoDrawCallback', 'draw', [oSettings])\n\n        /* Draw is complete, sorting and filtering must be as well */\n        oSettings.bSorted = false\n        oSettings.bFiltered = false\n        oSettings.bDrawing = false\n      }\n\n      /**\n       * Redraw the table - taking account of the various features which are enabled\n       *  @param {object} oSettings dataTables settings object\n       *  @param {boolean} [holdPosition] Keep the current paging position. By default\n       *    the paging is reset to the first page\n       *  @memberof DataTable#oApi\n       */\n      function _fnReDraw (settings, holdPosition) {\n        var features = settings.oFeatures,\n          sort = features.bSort,\n          filter = features.bFilter\n\n        if (sort) {\n          _fnSort(settings)\n        }\n\n        if (filter) {\n          _fnFilterComplete(settings, settings.oPreviousSearch)\n        } else {\n          // No filtering, so we want to just use the display master\n          settings.aiDisplay = settings.aiDisplayMaster.slice()\n        }\n\n        if (holdPosition !== true) {\n          settings._iDisplayStart = 0\n        }\n\n        // Let any modules know about the draw hold position state (used by\n        // scrolling internally)\n        settings._drawHold = holdPosition\n\n        _fnDraw(settings)\n\n        settings._drawHold = false\n      }\n\n      /**\n       * Add the options to the page HTML for the table\n       *  @param {object} oSettings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnAddOptionsHtml (oSettings) {\n        var classes = oSettings.oClasses\n        var table = $(oSettings.nTable)\n        var holding = $('<div/>').insertBefore(table) // Holding element for speed\n        var features = oSettings.oFeatures\n\n        // All DataTables are wrapped in a div\n        var insert = $('<div/>', {\n          id: oSettings.sTableId + '_wrapper',\n          class: classes.sWrapper + (oSettings.nTFoot ? '' : ' ' + classes.sNoFooter)\n        })\n\n        oSettings.nHolding = holding[0]\n        oSettings.nTableWrapper = insert[0]\n        oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling\n\n        /* Loop over the user set positioning and place the elements as needed */\n        var aDom = oSettings.sDom.split('')\n        var featureNode, cOption, nNewNode, cNext, sAttr, j\n        for (var i = 0; i < aDom.length; i++) {\n          featureNode = null\n          cOption = aDom[i]\n\n          if (cOption == '<') {\n            /* New container div */\n            nNewNode = $('<div/>')[0]\n\n            /* Check to see if we should append an id and/or a class name to the container */\n            cNext = aDom[i + 1]\n            if (cNext == \"'\" || cNext == '\"') {\n              sAttr = ''\n              j = 2\n              while (aDom[i + j] != cNext) {\n                sAttr += aDom[i + j]\n                j++\n              }\n\n              /* Replace jQuery UI constants @todo depreciated */\n              if (sAttr == 'H') {\n                sAttr = classes.sJUIHeader\n              } else if (sAttr == 'F') {\n                sAttr = classes.sJUIFooter\n              }\n\n              /* The attribute can be in the format of \"#id.class\", \"#id\" or \"class\" This logic\n               * breaks the string into parts and applies them as needed\n               */\n              if (sAttr.indexOf('.') != -1) {\n                var aSplit = sAttr.split('.')\n                nNewNode.id = aSplit[0].substr(1, aSplit[0].length - 1)\n                nNewNode.className = aSplit[1]\n              } else if (sAttr.charAt(0) == '#') {\n                nNewNode.id = sAttr.substr(1, sAttr.length - 1)\n              } else {\n                nNewNode.className = sAttr\n              }\n\n              i += j /* Move along the position array */\n            }\n\n            insert.append(nNewNode)\n            insert = $(nNewNode)\n          } else if (cOption == '>') {\n            /* End container div */\n            insert = insert.parent()\n          }\n          // @todo Move options into their own plugins?\n          else if (cOption == 'l' && features.bPaginate && features.bLengthChange) {\n            /* Length */\n            featureNode = _fnFeatureHtmlLength(oSettings)\n          } else if (cOption == 'f' && features.bFilter) {\n            /* Filter */\n            featureNode = _fnFeatureHtmlFilter(oSettings)\n          } else if (cOption == 'r' && features.bProcessing) {\n            /* pRocessing */\n            featureNode = _fnFeatureHtmlProcessing(oSettings)\n          } else if (cOption == 't') {\n            /* Table */\n            featureNode = _fnFeatureHtmlTable(oSettings)\n          } else if (cOption == 'i' && features.bInfo) {\n            /* Info */\n            featureNode = _fnFeatureHtmlInfo(oSettings)\n          } else if (cOption == 'p' && features.bPaginate) {\n            /* Pagination */\n            featureNode = _fnFeatureHtmlPaginate(oSettings)\n          } else if (DataTable.ext.feature.length !== 0) {\n            /* Plug-in features */\n            var aoFeatures = DataTable.ext.feature\n            for (var k = 0, kLen = aoFeatures.length; k < kLen; k++) {\n              if (cOption == aoFeatures[k].cFeature) {\n                featureNode = aoFeatures[k].fnInit(oSettings)\n                break\n              }\n            }\n          }\n\n          /* Add to the 2D features array */\n          if (featureNode) {\n            var aanFeatures = oSettings.aanFeatures\n\n            if (!aanFeatures[cOption]) {\n              aanFeatures[cOption] = []\n            }\n\n            aanFeatures[cOption].push(featureNode)\n            insert.append(featureNode)\n          }\n        }\n\n        /* Built our DOM structure - replace the holding div with what we want */\n        holding.replaceWith(insert)\n      }\n\n      /**\n       * Use the DOM source to create up an array of header cells. The idea here is to\n       * create a layout grid (array) of rows x columns, which contains a reference\n       * to the cell that that point in the grid (regardless of col/rowspan), such that\n       * any column / row could be removed and the new grid constructed\n       *  @param array {object} aLayout Array to store the calculated layout in\n       *  @param {node} nThead The header/footer element for the table\n       *  @memberof DataTable#oApi\n       */\n      function _fnDetectHeader (aLayout, nThead) {\n        var nTrs = $(nThead).children('tr')\n        var nTr, nCell\n        var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan\n        var bUnique\n        var fnShiftCol = function (a, i, j) {\n          var k = a[i]\n          while (k[j]) {\n            j++\n          }\n          return j\n        }\n\n        aLayout.splice(0, aLayout.length)\n\n        /* We know how many rows there are in the layout - so prep it */\n        for (i = 0, iLen = nTrs.length; i < iLen; i++) {\n          aLayout.push([])\n        }\n\n        /* Calculate a layout array */\n        for (i = 0, iLen = nTrs.length; i < iLen; i++) {\n          nTr = nTrs[i]\n          iColumn = 0\n\n          /* For every cell in the row... */\n          nCell = nTr.firstChild\n          while (nCell) {\n            if (nCell.nodeName.toUpperCase() == 'TD' || nCell.nodeName.toUpperCase() == 'TH') {\n              /* Get the col and rowspan attributes from the DOM and sanitise them */\n              iColspan = nCell.getAttribute('colspan') * 1\n              iRowspan = nCell.getAttribute('rowspan') * 1\n              iColspan = !iColspan || iColspan === 0 || iColspan === 1 ? 1 : iColspan\n              iRowspan = !iRowspan || iRowspan === 0 || iRowspan === 1 ? 1 : iRowspan\n\n              /* There might be colspan cells already in this row, so shift our target\n               * accordingly\n               */\n              iColShifted = fnShiftCol(aLayout, i, iColumn)\n\n              /* Cache calculation for unique columns */\n              bUnique = iColspan === 1 ? true : false\n\n              /* If there is col / rowspan, copy the information into the layout grid */\n              for (l = 0; l < iColspan; l++) {\n                for (k = 0; k < iRowspan; k++) {\n                  aLayout[i + k][iColShifted + l] = {\n                    cell: nCell,\n                    unique: bUnique\n                  }\n                  aLayout[i + k].nTr = nTr\n                }\n              }\n            }\n            nCell = nCell.nextSibling\n          }\n        }\n      }\n\n      /**\n       * Get an array of unique th elements, one for each column\n       *  @param {object} oSettings dataTables settings object\n       *  @param {node} nHeader automatically detect the layout from this node - optional\n       *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional\n       *  @returns array {node} aReturn list of unique th's\n       *  @memberof DataTable#oApi\n       */\n      function _fnGetUniqueThs (oSettings, nHeader, aLayout) {\n        var aReturn = []\n        if (!aLayout) {\n          aLayout = oSettings.aoHeader\n          if (nHeader) {\n            aLayout = []\n            _fnDetectHeader(aLayout, nHeader)\n          }\n        }\n\n        for (var i = 0, iLen = aLayout.length; i < iLen; i++) {\n          for (var j = 0, jLen = aLayout[i].length; j < jLen; j++) {\n            if (aLayout[i][j].unique && (!aReturn[j] || !oSettings.bSortCellsTop)) {\n              aReturn[j] = aLayout[i][j].cell\n            }\n          }\n        }\n\n        return aReturn\n      }\n\n      /**\n       * Create an Ajax call based on the table's settings, taking into account that\n       * parameters can have multiple forms, and backwards compatibility.\n       *\n       * @param {object} oSettings dataTables settings object\n       * @param {array} data Data to send to the server, required by\n       *     DataTables - may be augmented by developer callbacks\n       * @param {function} fn Callback function to run when data is obtained\n       */\n      function _fnBuildAjax (oSettings, data, fn) {\n        // Compatibility with 1.9-, allow fnServerData and event to manipulate\n        _fnCallbackFire(oSettings, 'aoServerParams', 'serverParams', [data])\n\n        // Convert to object based for 1.10+ if using the old array scheme which can\n        // come from server-side processing or serverParams\n        if (data && $.isArray(data)) {\n          var tmp = {}\n          var rbracket = /(.*?)\\[\\]$/\n\n          $.each(data, function (key, val) {\n            var match = val.name.match(rbracket)\n\n            if (match) {\n              // Support for arrays\n              var name = match[0]\n\n              if (!tmp[name]) {\n                tmp[name] = []\n              }\n              tmp[name].push(val.value)\n            } else {\n              tmp[val.name] = val.value\n            }\n          })\n          data = tmp\n        }\n\n        var ajaxData\n        var ajax = oSettings.ajax\n        var instance = oSettings.oInstance\n\n        if ($.isPlainObject(ajax) && ajax.data) {\n          ajaxData = ajax.data\n\n          var newData = $.isFunction(ajaxData)\n            ? ajaxData(data) // fn can manipulate data or return an object\n            : ajaxData // object or array to merge\n\n          // If the function returned an object, use that alone\n          data = $.isFunction(ajaxData) && newData ? newData : $.extend(true, data, newData)\n\n          // Remove the data property as we've resolved it already and don't want\n          // jQuery to do it again (it is restored at the end of the function)\n          delete ajax.data\n        }\n\n        var baseAjax = {\n          data: data,\n          success: function (json) {\n            var error = json.error || json.sError\n            if (error) {\n              oSettings.oApi._fnLog(oSettings, 0, error)\n            }\n\n            oSettings.json = json\n            _fnCallbackFire(oSettings, null, 'xhr', [oSettings, json])\n            fn(json)\n          },\n          dataType: 'json',\n          cache: false,\n          type: oSettings.sServerMethod,\n          error: function (xhr, error, thrown) {\n            var log = oSettings.oApi._fnLog\n\n            if (error == 'parsererror') {\n              log(oSettings, 0, 'Invalid JSON response', 1)\n            } else if (xhr.readyState === 4) {\n              log(oSettings, 0, 'Ajax error', 7)\n            }\n\n            _fnProcessingDisplay(oSettings, false)\n          }\n        }\n\n        // Store the data submitted for the API\n        oSettings.oAjaxData = data\n\n        // Allow plug-ins and external processes to modify the data\n        _fnCallbackFire(oSettings, null, 'preXhr', [oSettings, data])\n\n        if (oSettings.fnServerData) {\n          // DataTables 1.9- compatibility\n          oSettings.fnServerData.call(\n            instance,\n            oSettings.sAjaxSource,\n            $.map(data, function (val, key) {\n              // Need to convert back to 1.9 trad format\n              return { name: key, value: val }\n            }),\n            fn,\n            oSettings\n          )\n        } else if (oSettings.sAjaxSource || typeof ajax === 'string') {\n          // DataTables 1.9- compatibility\n          oSettings.jqXHR = $.ajax(\n            $.extend(baseAjax, {\n              url: ajax || oSettings.sAjaxSource\n            })\n          )\n        } else if ($.isFunction(ajax)) {\n          // Is a function - let the caller define what needs to be done\n          oSettings.jqXHR = ajax.call(instance, data, fn, oSettings)\n        } else {\n          // Object to extend the base settings\n          oSettings.jqXHR = $.ajax($.extend(baseAjax, ajax))\n\n          // Restore for next time around\n          ajax.data = ajaxData\n        }\n      }\n\n      /**\n       * Update the table using an Ajax call\n       *  @param {object} settings dataTables settings object\n       *  @returns {boolean} Block the table drawing or not\n       *  @memberof DataTable#oApi\n       */\n      function _fnAjaxUpdate (settings) {\n        if (settings.bAjaxDataGet) {\n          settings.iDraw++\n          _fnProcessingDisplay(settings, true)\n\n          _fnBuildAjax(settings, _fnAjaxParameters(settings), function (json) {\n            _fnAjaxUpdateDraw(settings, json)\n          })\n\n          return false\n        }\n        return true\n      }\n\n      /**\n       * Build up the parameters in an object needed for a server-side processing\n       * request. Note that this is basically done twice, is different ways - a modern\n       * method which is used by default in DataTables 1.10 which uses objects and\n       * arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if\n       * the sAjaxSource option is used in the initialisation, or the legacyAjax\n       * option is set.\n       *  @param {object} oSettings dataTables settings object\n       *  @returns {bool} block the table drawing or not\n       *  @memberof DataTable#oApi\n       */\n      function _fnAjaxParameters (settings) {\n        var columns = settings.aoColumns,\n          columnCount = columns.length,\n          features = settings.oFeatures,\n          preSearch = settings.oPreviousSearch,\n          preColSearch = settings.aoPreSearchCols,\n          i,\n          data = [],\n          dataProp,\n          column,\n          columnSearch,\n          sort = _fnSortFlatten(settings),\n          displayStart = settings._iDisplayStart,\n          displayLength = features.bPaginate !== false ? settings._iDisplayLength : -1\n\n        var param = function (name, value) {\n          data.push({ name: name, value: value })\n        }\n\n        // DataTables 1.9- compatible method\n        param('sEcho', settings.iDraw)\n        param('iColumns', columnCount)\n        param('sColumns', _pluck(columns, 'sName').join(','))\n        param('iDisplayStart', displayStart)\n        param('iDisplayLength', displayLength)\n\n        // DataTables 1.10+ method\n        var d = {\n          draw: settings.iDraw,\n          columns: [],\n          order: [],\n          start: displayStart,\n          length: displayLength,\n          search: {\n            value: preSearch.sSearch,\n            regex: preSearch.bRegex\n          }\n        }\n\n        for (i = 0; i < columnCount; i++) {\n          column = columns[i]\n          columnSearch = preColSearch[i]\n          dataProp = typeof column.mData == 'function' ? 'function' : column.mData\n\n          d.columns.push({\n            data: dataProp,\n            name: column.sName,\n            searchable: column.bSearchable,\n            orderable: column.bSortable,\n            search: {\n              value: columnSearch.sSearch,\n              regex: columnSearch.bRegex\n            }\n          })\n\n          param('mDataProp_' + i, dataProp)\n\n          if (features.bFilter) {\n            param('sSearch_' + i, columnSearch.sSearch)\n            param('bRegex_' + i, columnSearch.bRegex)\n            param('bSearchable_' + i, column.bSearchable)\n          }\n\n          if (features.bSort) {\n            param('bSortable_' + i, column.bSortable)\n          }\n        }\n\n        if (features.bFilter) {\n          param('sSearch', preSearch.sSearch)\n          param('bRegex', preSearch.bRegex)\n        }\n\n        if (features.bSort) {\n          $.each(sort, function (i, val) {\n            d.order.push({ column: val.col, dir: val.dir })\n\n            param('iSortCol_' + i, val.col)\n            param('sSortDir_' + i, val.dir)\n          })\n\n          param('iSortingCols', sort.length)\n        }\n\n        // If the legacy.ajax parameter is null, then we automatically decide which\n        // form to use, based on sAjaxSource\n        var legacy = DataTable.ext.legacy.ajax\n        if (legacy === null) {\n          return settings.sAjaxSource ? data : d\n        }\n\n        // Otherwise, if legacy has been specified then we use that to decide on the\n        // form\n        return legacy ? data : d\n      }\n\n      /**\n       * Data the data from the server (nuking the old) and redraw the table\n       *  @param {object} oSettings dataTables settings object\n       *  @param {object} json json data return from the server.\n       *  @param {string} json.sEcho Tracking flag for DataTables to match requests\n       *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering\n       *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering\n       *  @param {array} json.aaData The data to display on this page\n       *  @param {string} [json.sColumns] Column ordering (sName, comma separated)\n       *  @memberof DataTable#oApi\n       */\n      function _fnAjaxUpdateDraw (settings, json) {\n        // v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.\n        // Support both\n        var compat = function (old, modern) {\n          return json[old] !== undefined ? json[old] : json[modern]\n        }\n\n        var draw = compat('sEcho', 'draw')\n        var recordsTotal = compat('iTotalRecords', 'recordsTotal')\n        var rocordsFiltered = compat('iTotalDisplayRecords', 'recordsFiltered')\n\n        if (draw) {\n          // Protect against out of sequence returns\n          if (draw * 1 < settings.iDraw) {\n            return\n          }\n          settings.iDraw = draw * 1\n        }\n\n        _fnClearTable(settings)\n        settings._iRecordsTotal = parseInt(recordsTotal, 10)\n        settings._iRecordsDisplay = parseInt(rocordsFiltered, 10)\n\n        var data = _fnAjaxDataSrc(settings, json)\n        for (var i = 0, ien = data.length; i < ien; i++) {\n          _fnAddData(settings, data[i])\n        }\n        settings.aiDisplay = settings.aiDisplayMaster.slice()\n\n        settings.bAjaxDataGet = false\n        _fnDraw(settings)\n\n        if (!settings._bInitComplete) {\n          _fnInitComplete(settings, json)\n        }\n\n        settings.bAjaxDataGet = true\n        _fnProcessingDisplay(settings, false)\n      }\n\n      /**\n       * Get the data from the JSON data source to use for drawing a table. Using\n       * `_fnGetObjectDataFn` allows the data to be sourced from a property of the\n       * source object, or from a processing function.\n       *  @param {object} oSettings dataTables settings object\n       *  @param  {object} json Data source object / array from the server\n       *  @return {array} Array of data to use\n       */\n      function _fnAjaxDataSrc (oSettings, json) {\n        var dataSrc =\n          $.isPlainObject(oSettings.ajax) && oSettings.ajax.dataSrc !== undefined\n            ? oSettings.ajax.dataSrc\n            : oSettings.sAjaxDataProp // Compatibility with 1.9-.\n\n        // Compatibility with 1.9-. In order to read from aaData, check if the\n        // default has been changed, if not, check for aaData\n        if (dataSrc === 'data') {\n          return json.aaData || json[dataSrc]\n        }\n\n        return dataSrc !== '' ? _fnGetObjectDataFn(dataSrc)(json) : json\n      }\n\n      /**\n       * Generate the node required for filtering text\n       *  @returns {node} Filter control element\n       *  @param {object} oSettings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnFeatureHtmlFilter (settings) {\n        var classes = settings.oClasses\n        var tableId = settings.sTableId\n        var language = settings.oLanguage\n        var previousSearch = settings.oPreviousSearch\n        var features = settings.aanFeatures\n        var input = '<input type=\"search\" class=\"' + classes.sFilterInput + '\"/>'\n\n        var str = language.sSearch\n        str = str.match(/_INPUT_/) ? str.replace('_INPUT_', input) : str + input\n\n        var filter = $('<div/>', {\n          id: !features.f ? tableId + '_filter' : null,\n          class: classes.sFilter\n        }).append($('<label/>').append(str))\n\n        var searchFn = function () {\n          /* Update all other filter input elements for the new display */\n          var n = features.f\n          var val = !this.value ? '' : this.value // mental IE8 fix :-(\n\n          /* Now do the filter */\n          if (val != previousSearch.sSearch) {\n            _fnFilterComplete(settings, {\n              sSearch: val,\n              bRegex: previousSearch.bRegex,\n              bSmart: previousSearch.bSmart,\n              bCaseInsensitive: previousSearch.bCaseInsensitive\n            })\n\n            // Need to redraw, without resorting\n            settings._iDisplayStart = 0\n            _fnDraw(settings)\n          }\n        }\n        var jqFilter = $('input', filter)\n          .val(previousSearch.sSearch)\n          .attr('placeholder', language.sSearchPlaceholder)\n          .bind(\n            'keyup.DT search.DT input.DT paste.DT cut.DT',\n            _fnDataSource(settings) === 'ssp' ? _fnThrottle(searchFn, 400) : searchFn\n          )\n          .bind('keypress.DT', function (e) {\n            /* Prevent form submission */\n            if (e.keyCode == 13) {\n              return false\n            }\n          })\n          .attr('aria-controls', tableId)\n\n        // Update the input elements whenever the table is filtered\n        $(settings.nTable).on('search.dt.DT', function (ev, s) {\n          if (settings === s) {\n            // IE9 throws an 'unknown error' if document.activeElement is used\n            // inside an iframe or frame...\n            try {\n              if (jqFilter[0] !== document.activeElement) {\n                jqFilter.val(previousSearch.sSearch)\n              }\n            } catch (e) {}\n          }\n        })\n\n        return filter[0]\n      }\n\n      /**\n       * Filter the table using both the global filter and column based filtering\n       *  @param {object} oSettings dataTables settings object\n       *  @param {object} oSearch search information\n       *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)\n       *  @memberof DataTable#oApi\n       */\n      function _fnFilterComplete (oSettings, oInput, iForce) {\n        var oPrevSearch = oSettings.oPreviousSearch\n        var aoPrevSearch = oSettings.aoPreSearchCols\n        var fnSaveFilter = function (oFilter) {\n          /* Save the filtering values */\n          oPrevSearch.sSearch = oFilter.sSearch\n          oPrevSearch.bRegex = oFilter.bRegex\n          oPrevSearch.bSmart = oFilter.bSmart\n          oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive\n        }\n        var fnRegex = function (o) {\n          // Backwards compatibility with the bEscapeRegex option\n          return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex\n        }\n\n        // Resolve any column types that are unknown due to addition or invalidation\n        // @todo As per sort - can this be moved into an event handler?\n        _fnColumnTypes(oSettings)\n\n        /* In server-side processing all filtering is done by the server, so no point hanging around here */\n        if (_fnDataSource(oSettings) != 'ssp') {\n          /* Global filter */\n          _fnFilter(oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive)\n          fnSaveFilter(oInput)\n\n          /* Now do the individual column filter */\n          for (var i = 0; i < aoPrevSearch.length; i++) {\n            _fnFilterColumn(\n              oSettings,\n              aoPrevSearch[i].sSearch,\n              i,\n              fnRegex(aoPrevSearch[i]),\n              aoPrevSearch[i].bSmart,\n              aoPrevSearch[i].bCaseInsensitive\n            )\n          }\n\n          /* Custom filtering */\n          _fnFilterCustom(oSettings)\n        } else {\n          fnSaveFilter(oInput)\n        }\n\n        /* Tell the draw function we have been filtering */\n        oSettings.bFiltered = true\n        _fnCallbackFire(oSettings, null, 'search', [oSettings])\n      }\n\n      /**\n       * Apply custom filtering functions\n       *  @param {object} oSettings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnFilterCustom (settings) {\n        var filters = DataTable.ext.search\n        var displayRows = settings.aiDisplay\n        var row, rowIdx\n\n        for (var i = 0, ien = filters.length; i < ien; i++) {\n          var rows = []\n\n          // Loop over each row and see if it should be included\n          for (var j = 0, jen = displayRows.length; j < jen; j++) {\n            rowIdx = displayRows[j]\n            row = settings.aoData[rowIdx]\n\n            if (filters[i](settings, row._aFilterData, rowIdx, row._aData, j)) {\n              rows.push(rowIdx)\n            }\n          }\n\n          // So the array reference doesn't break set the results into the\n          // existing array\n          displayRows.length = 0\n          displayRows.push.apply(displayRows, rows)\n        }\n      }\n\n      /**\n       * Filter the table on a per-column basis\n       *  @param {object} oSettings dataTables settings object\n       *  @param {string} sInput string to filter on\n       *  @param {int} iColumn column to filter\n       *  @param {bool} bRegex treat search string as a regular expression or not\n       *  @param {bool} bSmart use smart filtering or not\n       *  @param {bool} bCaseInsensitive Do case insenstive matching or not\n       *  @memberof DataTable#oApi\n       */\n      function _fnFilterColumn (settings, searchStr, colIdx, regex, smart, caseInsensitive) {\n        if (searchStr === '') {\n          return\n        }\n\n        var data\n        var display = settings.aiDisplay\n        var rpSearch = _fnFilterCreateSearch(searchStr, regex, smart, caseInsensitive)\n\n        for (var i = display.length - 1; i >= 0; i--) {\n          data = settings.aoData[display[i]]._aFilterData[colIdx]\n\n          if (!rpSearch.test(data)) {\n            display.splice(i, 1)\n          }\n        }\n      }\n\n      /**\n       * Filter the data table based on user input and draw the table\n       *  @param {object} settings dataTables settings object\n       *  @param {string} input string to filter on\n       *  @param {int} force optional - force a research of the master array (1) or not (undefined or 0)\n       *  @param {bool} regex treat as a regular expression or not\n       *  @param {bool} smart perform smart filtering or not\n       *  @param {bool} caseInsensitive Do case insenstive matching or not\n       *  @memberof DataTable#oApi\n       */\n      function _fnFilter (settings, input, force, regex, smart, caseInsensitive) {\n        var rpSearch = _fnFilterCreateSearch(input, regex, smart, caseInsensitive)\n        var prevSearch = settings.oPreviousSearch.sSearch\n        var displayMaster = settings.aiDisplayMaster\n        var display, invalidated, i\n\n        // Need to take account of custom filtering functions - always filter\n        if (DataTable.ext.search.length !== 0) {\n          force = true\n        }\n\n        // Check if any of the rows were invalidated\n        invalidated = _fnFilterData(settings)\n\n        // If the input is blank - we just want the full data set\n        if (input.length <= 0) {\n          settings.aiDisplay = displayMaster.slice()\n        } else {\n          // New search - start from the master array\n          if (\n            invalidated ||\n            force ||\n            prevSearch.length > input.length ||\n            input.indexOf(prevSearch) !== 0 ||\n            settings.bSorted // On resort, the display master needs to be\n            // re-filtered since indexes will have changed\n          ) {\n            settings.aiDisplay = displayMaster.slice()\n          }\n\n          // Search the display array\n          display = settings.aiDisplay\n\n          for (i = display.length - 1; i >= 0; i--) {\n            if (!rpSearch.test(settings.aoData[display[i]]._sFilterRow)) {\n              display.splice(i, 1)\n            }\n          }\n        }\n      }\n\n      /**\n       * Build a regular expression object suitable for searching a table\n       *  @param {string} sSearch string to search for\n       *  @param {bool} bRegex treat as a regular expression or not\n       *  @param {bool} bSmart perform smart filtering or not\n       *  @param {bool} bCaseInsensitive Do case insensitive matching or not\n       *  @returns {RegExp} constructed object\n       *  @memberof DataTable#oApi\n       */\n      function _fnFilterCreateSearch (search, regex, smart, caseInsensitive) {\n        search = regex ? search : _fnEscapeRegex(search)\n\n        if (smart) {\n          /* For smart filtering we want to allow the search to work regardless of\n           * word order. We also want double quoted text to be preserved, so word\n           * order is important - a la google. So this is what we want to\n           * generate:\n           *\n           * ^(?=.*?\\bone\\b)(?=.*?\\btwo three\\b)(?=.*?\\bfour\\b).*$\n           */\n          var a = $.map(search.match(/\"[^\"]+\"|[^ ]+/g) || '', function (word) {\n            return word.charAt(0) === '\"' ? word.match(/^\"(.*)\"$/)[1] : word\n          })\n\n          search = '^(?=.*?' + a.join(')(?=.*?') + ').*$'\n        }\n\n        return new RegExp(search, caseInsensitive ? 'i' : '')\n      }\n\n      /**\n       * scape a string such that it can be used in a regular expression\n       *  @param {string} sVal string to escape\n       *  @returns {string} escaped string\n       *  @memberof DataTable#oApi\n       */\n      function _fnEscapeRegex (sVal) {\n        return sVal.replace(_re_escape_regex, '\\\\$1')\n      }\n\n      var __filter_div = $('<div>')[0]\n      var __filter_div_textContent = __filter_div.textContent !== undefined\n\n      // Update the filtering data for each row if needed (by invalidation or first run)\n      function _fnFilterData (settings) {\n        var columns = settings.aoColumns\n        var column\n        var i, j, ien, jen, filterData, cellData, row\n        var fomatters = DataTable.ext.type.search\n        var wasInvalidated = false\n\n        for (i = 0, ien = settings.aoData.length; i < ien; i++) {\n          row = settings.aoData[i]\n\n          if (!row._aFilterData) {\n            filterData = []\n\n            for (j = 0, jen = columns.length; j < jen; j++) {\n              column = columns[j]\n\n              if (column.bSearchable) {\n                cellData = _fnGetCellData(settings, i, j, 'filter')\n\n                if (fomatters[column.sType]) {\n                  cellData = fomatters[column.sType](cellData)\n                }\n\n                // Search in DataTables 1.10 is string based. In 1.11 this\n                // should be altered to also allow strict type checking.\n                if (cellData === null) {\n                  cellData = ''\n                }\n\n                if (typeof cellData !== 'string' && cellData.toString) {\n                  cellData = cellData.toString()\n                }\n              } else {\n                cellData = ''\n              }\n\n              // If it looks like there is an HTML entity in the string,\n              // attempt to decode it so sorting works as expected. Note that\n              // we could use a single line of jQuery to do this, but the DOM\n              // method used here is much faster http://jsperf.com/html-decode\n              if (cellData.indexOf && cellData.indexOf('&') !== -1) {\n                __filter_div.innerHTML = cellData\n                cellData = __filter_div_textContent ? __filter_div.textContent : __filter_div.innerText\n              }\n\n              if (cellData.replace) {\n                cellData = cellData.replace(/[\\r\\n]/g, '')\n              }\n\n              filterData.push(cellData)\n            }\n\n            row._aFilterData = filterData\n            row._sFilterRow = filterData.join('  ')\n            wasInvalidated = true\n          }\n        }\n\n        return wasInvalidated\n      }\n\n      /**\n       * Convert from the internal Hungarian notation to camelCase for external\n       * interaction\n       *  @param {object} obj Object to convert\n       *  @returns {object} Inverted object\n       *  @memberof DataTable#oApi\n       */\n      function _fnSearchToCamel (obj) {\n        return {\n          search: obj.sSearch,\n          smart: obj.bSmart,\n          regex: obj.bRegex,\n          caseInsensitive: obj.bCaseInsensitive\n        }\n      }\n\n      /**\n       * Convert from camelCase notation to the internal Hungarian. We could use the\n       * Hungarian convert function here, but this is cleaner\n       *  @param {object} obj Object to convert\n       *  @returns {object} Inverted object\n       *  @memberof DataTable#oApi\n       */\n      function _fnSearchToHung (obj) {\n        return {\n          sSearch: obj.search,\n          bSmart: obj.smart,\n          bRegex: obj.regex,\n          bCaseInsensitive: obj.caseInsensitive\n        }\n      }\n\n      /**\n       * Generate the node required for the info display\n       *  @param {object} oSettings dataTables settings object\n       *  @returns {node} Information element\n       *  @memberof DataTable#oApi\n       */\n      function _fnFeatureHtmlInfo (settings) {\n        var tid = settings.sTableId,\n          nodes = settings.aanFeatures.i,\n          n = $('<div/>', {\n            class: settings.oClasses.sInfo,\n            id: !nodes ? tid + '_info' : null\n          })\n\n        if (!nodes) {\n          // Update display on each draw\n          settings.aoDrawCallback.push({\n            fn: _fnUpdateInfo,\n            sName: 'information'\n          })\n\n          n.attr('role', 'status').attr('aria-live', 'polite')\n\n          // Table is described by our info div\n          $(settings.nTable).attr('aria-describedby', tid + '_info')\n        }\n\n        return n[0]\n      }\n\n      /**\n       * Update the information elements in the display\n       *  @param {object} settings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnUpdateInfo (settings) {\n        /* Show information about the table */\n        var nodes = settings.aanFeatures.i\n        if (nodes.length === 0) {\n          return\n        }\n\n        var lang = settings.oLanguage,\n          start = settings._iDisplayStart + 1,\n          end = settings.fnDisplayEnd(),\n          max = settings.fnRecordsTotal(),\n          total = settings.fnRecordsDisplay(),\n          out = total ? lang.sInfo : lang.sInfoEmpty\n\n        if (total !== max) {\n          /* Record set after filtering */\n          out += ' ' + lang.sInfoFiltered\n        }\n\n        // Convert the macros\n        out += lang.sInfoPostFix\n        out = _fnInfoMacros(settings, out)\n\n        var callback = lang.fnInfoCallback\n        if (callback !== null) {\n          out = callback.call(settings.oInstance, settings, start, end, max, total, out)\n        }\n\n        $(nodes).html(out)\n      }\n\n      function _fnInfoMacros (settings, str) {\n        // When infinite scrolling, we are always starting at 1. _iDisplayStart is used only\n        // internally\n        var formatter = settings.fnFormatNumber,\n          start = settings._iDisplayStart + 1,\n          len = settings._iDisplayLength,\n          vis = settings.fnRecordsDisplay(),\n          all = len === -1\n\n        return str\n          .replace(/_START_/g, formatter.call(settings, start))\n          .replace(/_END_/g, formatter.call(settings, settings.fnDisplayEnd()))\n          .replace(/_MAX_/g, formatter.call(settings, settings.fnRecordsTotal()))\n          .replace(/_TOTAL_/g, formatter.call(settings, vis))\n          .replace(/_PAGE_/g, formatter.call(settings, all ? 1 : Math.ceil(start / len)))\n          .replace(/_PAGES_/g, formatter.call(settings, all ? 1 : Math.ceil(vis / len)))\n      }\n\n      /**\n       * Draw the table for the first time, adding all required features\n       *  @param {object} settings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnInitialise (settings) {\n        var i,\n          iLen,\n          iAjaxStart = settings.iInitDisplayStart\n        var columns = settings.aoColumns,\n          column\n        var features = settings.oFeatures\n\n        /* Ensure that the table data is fully initialised */\n        if (!settings.bInitialised) {\n          setTimeout(function () {\n            _fnInitialise(settings)\n          }, 200)\n          return\n        }\n\n        /* Show the display HTML options */\n        _fnAddOptionsHtml(settings)\n\n        /* Build and draw the header / footer for the table */\n        _fnBuildHead(settings)\n        _fnDrawHead(settings, settings.aoHeader)\n        _fnDrawHead(settings, settings.aoFooter)\n\n        /* Okay to show that something is going on now */\n        _fnProcessingDisplay(settings, true)\n\n        /* Calculate sizes for columns */\n        if (features.bAutoWidth) {\n          _fnCalculateColumnWidths(settings)\n        }\n\n        for (i = 0, iLen = columns.length; i < iLen; i++) {\n          column = columns[i]\n\n          if (column.sWidth) {\n            column.nTh.style.width = _fnStringToCss(column.sWidth)\n          }\n        }\n\n        // If there is default sorting required - let's do it. The sort function\n        // will do the drawing for us. Otherwise we draw the table regardless of the\n        // Ajax source - this allows the table to look initialised for Ajax sourcing\n        // data (show 'loading' message possibly)\n        _fnReDraw(settings)\n\n        // Server-side processing init complete is done by _fnAjaxUpdateDraw\n        var dataSrc = _fnDataSource(settings)\n        if (dataSrc != 'ssp') {\n          // if there is an ajax source load the data\n          if (dataSrc == 'ajax') {\n            _fnBuildAjax(\n              settings,\n              [],\n              function (json) {\n                var aData = _fnAjaxDataSrc(settings, json)\n\n                // Got the data - add it to the table\n                for (i = 0; i < aData.length; i++) {\n                  _fnAddData(settings, aData[i])\n                }\n\n                // Reset the init display for cookie saving. We've already done\n                // a filter, and therefore cleared it before. So we need to make\n                // it appear 'fresh'\n                settings.iInitDisplayStart = iAjaxStart\n\n                _fnReDraw(settings)\n\n                _fnProcessingDisplay(settings, false)\n                _fnInitComplete(settings, json)\n              },\n              settings\n            )\n          } else {\n            _fnProcessingDisplay(settings, false)\n            _fnInitComplete(settings)\n          }\n        }\n      }\n\n      /**\n       * Draw the table for the first time, adding all required features\n       *  @param {object} oSettings dataTables settings object\n       *  @param {object} [json] JSON from the server that completed the table, if using Ajax source\n       *    with client-side processing (optional)\n       *  @memberof DataTable#oApi\n       */\n      function _fnInitComplete (settings, json) {\n        settings._bInitComplete = true\n\n        // On an Ajax load we now have data and therefore want to apply the column\n        // sizing\n        if (json) {\n          _fnAdjustColumnSizing(settings)\n        }\n\n        _fnCallbackFire(settings, 'aoInitComplete', 'init', [settings, json])\n      }\n\n      function _fnLengthChange (settings, val) {\n        var len = parseInt(val, 10)\n        settings._iDisplayLength = len\n\n        _fnLengthOverflow(settings)\n\n        // Fire length change event\n        _fnCallbackFire(settings, null, 'length', [settings, len])\n      }\n\n      /**\n       * Generate the node required for user display length changing\n       *  @param {object} settings dataTables settings object\n       *  @returns {node} Display length feature node\n       *  @memberof DataTable#oApi\n       */\n      function _fnFeatureHtmlLength (settings) {\n        var classes = settings.oClasses,\n          tableId = settings.sTableId,\n          menu = settings.aLengthMenu,\n          d2 = $.isArray(menu[0]),\n          lengths = d2 ? menu[0] : menu,\n          language = d2 ? menu[1] : menu\n\n        var select = $('<select/>', {\n          name: tableId + '_length',\n          'aria-controls': tableId,\n          class: classes.sLengthSelect\n        })\n\n        for (var i = 0, ien = lengths.length; i < ien; i++) {\n          select[0][i] = new Option(language[i], lengths[i])\n        }\n\n        var div = $('<div><label/></div>').addClass(classes.sLength)\n        if (!settings.aanFeatures.l) {\n          div[0].id = tableId + '_length'\n        }\n\n        div.children().append(settings.oLanguage.sLengthMenu.replace('_MENU_', select[0].outerHTML))\n\n        // Can't use `select` variable as user might provide their own and the\n        // reference is broken by the use of outerHTML\n        $('select', div)\n          .val(settings._iDisplayLength)\n          .bind('change.DT', function (e) {\n            _fnLengthChange(settings, $(this).val())\n            _fnDraw(settings)\n          })\n\n        // Update node value whenever anything changes the table's length\n        $(settings.nTable).bind('length.dt.DT', function (e, s, len) {\n          if (settings === s) {\n            $('select', div).val(len)\n          }\n        })\n\n        return div[0]\n      }\n\n      /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n       * Note that most of the paging logic is done in\n       * DataTable.ext.pager\n       */\n\n      /**\n       * Generate the node required for default pagination\n       *  @param {object} oSettings dataTables settings object\n       *  @returns {node} Pagination feature node\n       *  @memberof DataTable#oApi\n       */\n      function _fnFeatureHtmlPaginate (settings) {\n        var type = settings.sPaginationType,\n          plugin = DataTable.ext.pager[type],\n          modern = typeof plugin === 'function',\n          redraw = function (settings) {\n            _fnDraw(settings)\n          },\n          node = $('<div/>').addClass(settings.oClasses.sPaging + type)[0],\n          features = settings.aanFeatures\n\n        if (!modern) {\n          plugin.fnInit(settings, node, redraw)\n        }\n\n        /* Add a draw callback for the pagination on first instance, to update the paging display */\n        if (!features.p) {\n          node.id = settings.sTableId + '_paginate'\n\n          settings.aoDrawCallback.push({\n            fn: function (settings) {\n              if (modern) {\n                var start = settings._iDisplayStart,\n                  len = settings._iDisplayLength,\n                  visRecords = settings.fnRecordsDisplay(),\n                  all = len === -1,\n                  page = all ? 0 : Math.ceil(start / len),\n                  pages = all ? 1 : Math.ceil(visRecords / len),\n                  buttons = plugin(page, pages),\n                  i,\n                  ien\n\n                for (i = 0, ien = features.p.length; i < ien; i++) {\n                  _fnRenderer(settings, 'pageButton')(settings, features.p[i], i, buttons, page, pages)\n                }\n              } else {\n                plugin.fnUpdate(settings, redraw)\n              }\n            },\n            sName: 'pagination'\n          })\n        }\n\n        return node\n      }\n\n      /**\n       * Alter the display settings to change the page\n       *  @param {object} settings DataTables settings object\n       *  @param {string|int} action Paging action to take: \"first\", \"previous\",\n       *    \"next\" or \"last\" or page number to jump to (integer)\n       *  @param [bool] redraw Automatically draw the update or not\n       *  @returns {bool} true page has changed, false - no change\n       *  @memberof DataTable#oApi\n       */\n      function _fnPageChange (settings, action, redraw) {\n        var start = settings._iDisplayStart,\n          len = settings._iDisplayLength,\n          records = settings.fnRecordsDisplay()\n\n        if (records === 0 || len === -1) {\n          start = 0\n        } else if (typeof action === 'number') {\n          start = action * len\n\n          if (start > records) {\n            start = 0\n          }\n        } else if (action == 'first') {\n          start = 0\n        } else if (action == 'previous') {\n          start = len >= 0 ? start - len : 0\n\n          if (start < 0) {\n            start = 0\n          }\n        } else if (action == 'next') {\n          if (start + len < records) {\n            start += len\n          }\n        } else if (action == 'last') {\n          start = Math.floor((records - 1) / len) * len\n        } else {\n          _fnLog(settings, 0, 'Unknown paging action: ' + action, 5)\n        }\n\n        var changed = settings._iDisplayStart !== start\n        settings._iDisplayStart = start\n\n        if (changed) {\n          _fnCallbackFire(settings, null, 'page', [settings])\n\n          if (redraw) {\n            _fnDraw(settings)\n          }\n        }\n\n        return changed\n      }\n\n      /**\n       * Generate the node required for the processing node\n       *  @param {object} settings dataTables settings object\n       *  @returns {node} Processing element\n       *  @memberof DataTable#oApi\n       */\n      function _fnFeatureHtmlProcessing (settings) {\n        return $('<div/>', {\n          id: !settings.aanFeatures.r ? settings.sTableId + '_processing' : null,\n          class: settings.oClasses.sProcessing\n        })\n          .html(settings.oLanguage.sProcessing)\n          .insertBefore(settings.nTable)[0]\n      }\n\n      /**\n       * Display or hide the processing indicator\n       *  @param {object} settings dataTables settings object\n       *  @param {bool} show Show the processing indicator (true) or not (false)\n       *  @memberof DataTable#oApi\n       */\n      function _fnProcessingDisplay (settings, show) {\n        if (settings.oFeatures.bProcessing) {\n          $(settings.aanFeatures.r).css('display', show ? 'block' : 'none')\n        }\n\n        _fnCallbackFire(settings, null, 'processing', [settings, show])\n      }\n\n      /**\n       * Add any control elements for the table - specifically scrolling\n       *  @param {object} settings dataTables settings object\n       *  @returns {node} Node to add to the DOM\n       *  @memberof DataTable#oApi\n       */\n      function _fnFeatureHtmlTable (settings) {\n        var table = $(settings.nTable)\n\n        // Add the ARIA grid role to the table\n        table.attr('role', 'grid')\n\n        // Scrolling from here on in\n        var scroll = settings.oScroll\n\n        if (scroll.sX === '' && scroll.sY === '') {\n          return settings.nTable\n        }\n\n        var scrollX = scroll.sX\n        var scrollY = scroll.sY\n        var classes = settings.oClasses\n        var caption = table.children('caption')\n        var captionSide = caption.length ? caption[0]._captionSide : null\n        var headerClone = $(table[0].cloneNode(false))\n        var footerClone = $(table[0].cloneNode(false))\n        var footer = table.children('tfoot')\n        var _div = '<div/>'\n        var size = function (s) {\n          return !s ? null : _fnStringToCss(s)\n        }\n\n        // This is fairly messy, but with x scrolling enabled, if the table has a\n        // width attribute, regardless of any width applied using the column width\n        // options, the browser will shrink or grow the table as needed to fit into\n        // that 100%. That would make the width options useless. So we remove it.\n        // This is okay, under the assumption that width:100% is applied to the\n        // table in CSS (it is in the default stylesheet) which will set the table\n        // width as appropriate (the attribute and css behave differently...)\n        if (scroll.sX && table.attr('width') === '100%') {\n          table.removeAttr('width')\n        }\n\n        if (!footer.length) {\n          footer = null\n        }\n\n        /*\n         * The HTML structure that we want to generate in this function is:\n         *  div - scroller\n         *    div - scroll head\n         *      div - scroll head inner\n         *        table - scroll head table\n         *          thead - thead\n         *    div - scroll body\n         *      table - table (master table)\n         *        thead - thead clone for sizing\n         *        tbody - tbody\n         *    div - scroll foot\n         *      div - scroll foot inner\n         *        table - scroll foot table\n         *          tfoot - tfoot\n         */\n        var scroller = $(_div, { class: classes.sScrollWrapper })\n          .append(\n            $(_div, { class: classes.sScrollHead })\n              .css({\n                overflow: 'hidden',\n                position: 'relative',\n                border: 0,\n                width: scrollX ? size(scrollX) : '100%'\n              })\n              .append(\n                $(_div, { class: classes.sScrollHeadInner })\n                  .css({\n                    'box-sizing': 'content-box',\n                    width: scroll.sXInner || '100%'\n                  })\n                  .append(\n                    headerClone\n                      .removeAttr('id')\n                      .css('margin-left', 0)\n                      .append(table.children('thead'))\n                  )\n              )\n              .append(captionSide === 'top' ? caption : null)\n          )\n          .append(\n            $(_div, { class: classes.sScrollBody })\n              .css({\n                overflow: 'auto',\n                height: size(scrollY),\n                width: size(scrollX)\n              })\n              .append(table)\n          )\n\n        if (footer) {\n          scroller.append(\n            $(_div, { class: classes.sScrollFoot })\n              .css({\n                overflow: 'hidden',\n                border: 0,\n                width: scrollX ? size(scrollX) : '100%'\n              })\n              .append(\n                $(_div, { class: classes.sScrollFootInner }).append(\n                  footerClone\n                    .removeAttr('id')\n                    .css('margin-left', 0)\n                    .append(table.children('tfoot'))\n                )\n              )\n              .append(captionSide === 'bottom' ? caption : null)\n          )\n        }\n\n        var children = scroller.children()\n        var scrollHead = children[0]\n        var scrollBody = children[1]\n        var scrollFoot = footer ? children[2] : null\n\n        // When the body is scrolled, then we also want to scroll the headers\n        if (scrollX) {\n          $(scrollBody).scroll(function (e) {\n            var scrollLeft = this.scrollLeft\n\n            scrollHead.scrollLeft = scrollLeft\n\n            if (footer) {\n              scrollFoot.scrollLeft = scrollLeft\n            }\n          })\n        }\n\n        settings.nScrollHead = scrollHead\n        settings.nScrollBody = scrollBody\n        settings.nScrollFoot = scrollFoot\n\n        // On redraw - align columns\n        settings.aoDrawCallback.push({\n          fn: _fnScrollDraw,\n          sName: 'scrolling'\n        })\n\n        return scroller[0]\n      }\n\n      /**\n       * Update the header, footer and body tables for resizing - i.e. column\n       * alignment.\n       *\n       * Welcome to the most horrible function DataTables. The process that this\n       * function follows is basically:\n       *   1. Re-create the table inside the scrolling div\n       *   2. Take live measurements from the DOM\n       *   3. Apply the measurements to align the columns\n       *   4. Clean up\n       *\n       *  @param {object} settings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnScrollDraw (settings) {\n        // Given that this is such a monster function, a lot of variables are use\n        // to try and keep the minimised size as small as possible\n        var scroll = settings.oScroll,\n          scrollX = scroll.sX,\n          scrollXInner = scroll.sXInner,\n          scrollY = scroll.sY,\n          barWidth = scroll.iBarWidth,\n          divHeader = $(settings.nScrollHead),\n          divHeaderStyle = divHeader[0].style,\n          divHeaderInner = divHeader.children('div'),\n          divHeaderInnerStyle = divHeaderInner[0].style,\n          divHeaderTable = divHeaderInner.children('table'),\n          divBodyEl = settings.nScrollBody,\n          divBody = $(divBodyEl),\n          divBodyStyle = divBodyEl.style,\n          divFooter = $(settings.nScrollFoot),\n          divFooterInner = divFooter.children('div'),\n          divFooterTable = divFooterInner.children('table'),\n          header = $(settings.nTHead),\n          table = $(settings.nTable),\n          tableEl = table[0],\n          tableStyle = tableEl.style,\n          footer = settings.nTFoot ? $(settings.nTFoot) : null,\n          browser = settings.oBrowser,\n          ie67 = browser.bScrollOversize,\n          headerTrgEls,\n          footerTrgEls,\n          headerSrcEls,\n          footerSrcEls,\n          headerCopy,\n          footerCopy,\n          headerWidths = [],\n          footerWidths = [],\n          headerContent = [],\n          idx,\n          correction,\n          sanityWidth,\n          zeroOut = function (nSizer) {\n            var style = nSizer.style\n            style.paddingTop = '0'\n            style.paddingBottom = '0'\n            style.borderTopWidth = '0'\n            style.borderBottomWidth = '0'\n            style.height = 0\n          }\n\n        /*\n         * 1. Re-create the table inside the scrolling div\n         */\n\n        // Remove the old minimised thead and tfoot elements in the inner table\n        table.children('thead, tfoot').remove()\n\n        // Clone the current header and footer elements and then place it into the inner table\n        headerCopy = header.clone().prependTo(table)\n        headerTrgEls = header.find('tr') // original header is in its own table\n        headerSrcEls = headerCopy.find('tr')\n        headerCopy.find('th, td').removeAttr('tabindex')\n\n        if (footer) {\n          footerCopy = footer.clone().prependTo(table)\n          footerTrgEls = footer.find('tr') // the original tfoot is in its own table and must be sized\n          footerSrcEls = footerCopy.find('tr')\n        }\n\n        /*\n         * 2. Take live measurements from the DOM - do not alter the DOM itself!\n         */\n\n        // Remove old sizing and apply the calculated column widths\n        // Get the unique column headers in the newly created (cloned) header. We want to apply the\n        // calculated sizes to this header\n        if (!scrollX) {\n          divBodyStyle.width = '100%'\n          divHeader[0].style.width = '100%'\n        }\n\n        $.each(_fnGetUniqueThs(settings, headerCopy), function (i, el) {\n          idx = _fnVisibleToColumnIndex(settings, i)\n          el.style.width = settings.aoColumns[idx].sWidth\n        })\n\n        if (footer) {\n          _fnApplyToChildren(function (n) {\n            n.style.width = ''\n          }, footerSrcEls)\n        }\n\n        // If scroll collapse is enabled, when we put the headers back into the body for sizing, we\n        // will end up forcing the scrollbar to appear, making our measurements wrong for when we\n        // then hide it (end of this function), so add the header height to the body scroller.\n        if (scroll.bCollapse && scrollY !== '') {\n          divBodyStyle.height = divBody[0].offsetHeight + header[0].offsetHeight + 'px'\n        }\n\n        // Size the table as a whole\n        sanityWidth = table.outerWidth()\n        if (scrollX === '') {\n          // No x scrolling\n          tableStyle.width = '100%'\n\n          // IE7 will make the width of the table when 100% include the scrollbar\n          // - which is shouldn't. When there is a scrollbar we need to take this\n          // into account.\n          if (\n            ie67 &&\n            (table.find('tbody').height() > divBodyEl.offsetHeight || divBody.css('overflow-y') == 'scroll')\n          ) {\n            tableStyle.width = _fnStringToCss(table.outerWidth() - barWidth)\n          }\n        } else {\n          // x scrolling\n          if (scrollXInner !== '') {\n            // x scroll inner has been given - use it\n            tableStyle.width = _fnStringToCss(scrollXInner)\n          } else if (sanityWidth == divBody.width() && divBody.height() < table.height()) {\n            // There is y-scrolling - try to take account of the y scroll bar\n            tableStyle.width = _fnStringToCss(sanityWidth - barWidth)\n            if (table.outerWidth() > sanityWidth - barWidth) {\n              // Not possible to take account of it\n              tableStyle.width = _fnStringToCss(sanityWidth)\n            }\n          } else {\n            // When all else fails\n            tableStyle.width = _fnStringToCss(sanityWidth)\n          }\n        }\n\n        // Recalculate the sanity width - now that we've applied the required width,\n        // before it was a temporary variable. This is required because the column\n        // width calculation is done before this table DOM is created.\n        sanityWidth = table.outerWidth()\n\n        // Hidden header should have zero height, so remove padding and borders. Then\n        // set the width based on the real headers\n\n        // Apply all styles in one pass\n        _fnApplyToChildren(zeroOut, headerSrcEls)\n\n        // Read all widths in next pass\n        _fnApplyToChildren(function (nSizer) {\n          headerContent.push(nSizer.innerHTML)\n          headerWidths.push(_fnStringToCss($(nSizer).css('width')))\n        }, headerSrcEls)\n\n        // Apply all widths in final pass\n        _fnApplyToChildren(function (nToSize, i) {\n          nToSize.style.width = headerWidths[i]\n        }, headerTrgEls)\n\n        $(headerSrcEls).height(0)\n\n        /* Same again with the footer if we have one */\n        if (footer) {\n          _fnApplyToChildren(zeroOut, footerSrcEls)\n\n          _fnApplyToChildren(function (nSizer) {\n            footerWidths.push(_fnStringToCss($(nSizer).css('width')))\n          }, footerSrcEls)\n\n          _fnApplyToChildren(function (nToSize, i) {\n            nToSize.style.width = footerWidths[i]\n          }, footerTrgEls)\n\n          $(footerSrcEls).height(0)\n        }\n\n        /*\n         * 3. Apply the measurements\n         */\n\n        // \"Hide\" the header and footer that we used for the sizing. We need to keep\n        // the content of the cell so that the width applied to the header and body\n        // both match, but we want to hide it completely. We want to also fix their\n        // width to what they currently are\n        _fnApplyToChildren(function (nSizer, i) {\n          nSizer.innerHTML =\n            '<div class=\"dataTables_sizing\" style=\"height:0;overflow:hidden;\">' + headerContent[i] + '</div>'\n          nSizer.style.width = headerWidths[i]\n        }, headerSrcEls)\n\n        if (footer) {\n          _fnApplyToChildren(function (nSizer, i) {\n            nSizer.innerHTML = ''\n            nSizer.style.width = footerWidths[i]\n          }, footerSrcEls)\n        }\n\n        // Sanity check that the table is of a sensible width. If not then we are going to get\n        // misalignment - try to prevent this by not allowing the table to shrink below its min width\n        if (table.outerWidth() < sanityWidth) {\n          // The min width depends upon if we have a vertical scrollbar visible or not */\n          correction =\n            divBodyEl.scrollHeight > divBodyEl.offsetHeight || divBody.css('overflow-y') == 'scroll'\n              ? sanityWidth + barWidth\n              : sanityWidth\n\n          // IE6/7 are a law unto themselves...\n          if (ie67 && (divBodyEl.scrollHeight > divBodyEl.offsetHeight || divBody.css('overflow-y') == 'scroll')) {\n            tableStyle.width = _fnStringToCss(correction - barWidth)\n          }\n\n          // And give the user a warning that we've stopped the table getting too small\n          if (scrollX === '' || scrollXInner !== '') {\n            _fnLog(settings, 1, 'Possible column misalignment', 6)\n          }\n        } else {\n          correction = '100%'\n        }\n\n        // Apply to the container elements\n        divBodyStyle.width = _fnStringToCss(correction)\n        divHeaderStyle.width = _fnStringToCss(correction)\n\n        if (footer) {\n          settings.nScrollFoot.style.width = _fnStringToCss(correction)\n        }\n\n        /*\n         * 4. Clean up\n         */\n        if (!scrollY) {\n          /* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting\n           * the scrollbar height from the visible display, rather than adding it on. We need to\n           * set the height in order to sort this. Don't want to do it in any other browsers.\n           */\n          if (ie67) {\n            divBodyStyle.height = _fnStringToCss(tableEl.offsetHeight + barWidth)\n          }\n        }\n\n        if (scrollY && scroll.bCollapse) {\n          divBodyStyle.height = _fnStringToCss(scrollY)\n\n          var iExtra = scrollX && tableEl.offsetWidth > divBodyEl.offsetWidth ? barWidth : 0\n\n          if (tableEl.offsetHeight < divBodyEl.offsetHeight) {\n            divBodyStyle.height = _fnStringToCss(tableEl.offsetHeight + iExtra)\n          }\n        }\n\n        /* Finally set the width's of the header and footer tables */\n        var iOuterWidth = table.outerWidth()\n        divHeaderTable[0].style.width = _fnStringToCss(iOuterWidth)\n        divHeaderInnerStyle.width = _fnStringToCss(iOuterWidth)\n\n        // Figure out if there are scrollbar present - if so then we need a the header and footer to\n        // provide a bit more space to allow \"overflow\" scrolling (i.e. past the scrollbar)\n        var bScrolling = table.height() > divBodyEl.clientHeight || divBody.css('overflow-y') == 'scroll'\n        var padding = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right')\n        divHeaderInnerStyle[padding] = bScrolling ? barWidth + 'px' : '0px'\n\n        if (footer) {\n          divFooterTable[0].style.width = _fnStringToCss(iOuterWidth)\n          divFooterInner[0].style.width = _fnStringToCss(iOuterWidth)\n          divFooterInner[0].style[padding] = bScrolling ? barWidth + 'px' : '0px'\n        }\n\n        /* Adjust the position of the header in case we loose the y-scrollbar */\n        divBody.scroll()\n\n        // If sorting or filtering has occurred, jump the scrolling back to the top\n        // only if we aren't holding the position\n        if ((settings.bSorted || settings.bFiltered) && !settings._drawHold) {\n          divBodyEl.scrollTop = 0\n        }\n      }\n\n      /**\n       * Apply a given function to the display child nodes of an element array (typically\n       * TD children of TR rows\n       *  @param {function} fn Method to apply to the objects\n       *  @param array {nodes} an1 List of elements to look through for display children\n       *  @param array {nodes} an2 Another list (identical structure to the first) - optional\n       *  @memberof DataTable#oApi\n       */\n      function _fnApplyToChildren (fn, an1, an2) {\n        var index = 0,\n          i = 0,\n          iLen = an1.length\n        var nNode1, nNode2\n\n        while (i < iLen) {\n          nNode1 = an1[i].firstChild\n          nNode2 = an2 ? an2[i].firstChild : null\n\n          while (nNode1) {\n            if (nNode1.nodeType === 1) {\n              if (an2) {\n                fn(nNode1, nNode2, index)\n              } else {\n                fn(nNode1, index)\n              }\n\n              index++\n            }\n\n            nNode1 = nNode1.nextSibling\n            nNode2 = an2 ? nNode2.nextSibling : null\n          }\n\n          i++\n        }\n      }\n\n      var __re_html_remove = /<.*?>/g\n\n      /**\n       * Calculate the width of columns for the table\n       *  @param {object} oSettings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnCalculateColumnWidths (oSettings) {\n        var table = oSettings.nTable,\n          columns = oSettings.aoColumns,\n          scroll = oSettings.oScroll,\n          scrollY = scroll.sY,\n          scrollX = scroll.sX,\n          scrollXInner = scroll.sXInner,\n          columnCount = columns.length,\n          visibleColumns = _fnGetColumns(oSettings, 'bVisible'),\n          headerCells = $('th', oSettings.nTHead),\n          tableWidthAttr = table.getAttribute('width'),\n          tableContainer = table.parentNode,\n          userInputs = false,\n          i,\n          column,\n          columnIdx,\n          width,\n          outerWidth\n\n        /* Convert any user input sizes into pixel sizes */\n        for (i = 0; i < visibleColumns.length; i++) {\n          column = columns[visibleColumns[i]]\n\n          if (column.sWidth !== null) {\n            column.sWidth = _fnConvertToWidth(column.sWidthOrig, tableContainer)\n\n            userInputs = true\n          }\n        }\n\n        /* If the number of columns in the DOM equals the number that we have to\n         * process in DataTables, then we can use the offsets that are created by\n         * the web- browser. No custom sizes can be set in order for this to happen,\n         * nor scrolling used\n         */\n        if (\n          !userInputs &&\n          !scrollX &&\n          !scrollY &&\n          columnCount == _fnVisbleColumns(oSettings) &&\n          columnCount == headerCells.length\n        ) {\n          for (i = 0; i < columnCount; i++) {\n            columns[i].sWidth = _fnStringToCss(headerCells.eq(i).width())\n          }\n        } else {\n          // Otherwise construct a single row table with the widest node in the\n          // data, assign any user defined widths, then insert it into the DOM and\n          // allow the browser to do all the hard work of calculating table widths\n          var tmpTable = $(table)\n            .clone() // don't use cloneNode - IE8 will remove events on the main table\n            .empty()\n            .css('visibility', 'hidden')\n            .removeAttr('id')\n            .append($(oSettings.nTHead).clone(false))\n            .append($(oSettings.nTFoot).clone(false))\n            .append($('<tbody><tr/></tbody>'))\n\n          // Remove any assigned widths from the footer (from scrolling)\n          tmpTable.find('tfoot th, tfoot td').css('width', '')\n\n          var tr = tmpTable.find('tbody tr')\n\n          // Apply custom sizing to the cloned header\n          headerCells = _fnGetUniqueThs(oSettings, tmpTable.find('thead')[0])\n\n          for (i = 0; i < visibleColumns.length; i++) {\n            column = columns[visibleColumns[i]]\n\n            headerCells[i].style.width =\n              column.sWidthOrig !== null && column.sWidthOrig !== '' ? _fnStringToCss(column.sWidthOrig) : ''\n          }\n\n          // Find the widest cell for each column and put it into the table\n          if (oSettings.aoData.length) {\n            for (i = 0; i < visibleColumns.length; i++) {\n              columnIdx = visibleColumns[i]\n              column = columns[columnIdx]\n\n              $(_fnGetWidestNode(oSettings, columnIdx))\n                .clone(false)\n                .append(column.sContentPadding)\n                .appendTo(tr)\n            }\n          }\n\n          // Table has been built, attach to the document so we can work with it\n          tmpTable.appendTo(tableContainer)\n\n          // When scrolling (X or Y) we want to set the width of the table as\n          // appropriate. However, when not scrolling leave the table width as it\n          // is. This results in slightly different, but I think correct behaviour\n          if (scrollX && scrollXInner) {\n            tmpTable.width(scrollXInner)\n          } else if (scrollX) {\n            tmpTable.css('width', 'auto')\n\n            if (tmpTable.width() < tableContainer.offsetWidth) {\n              tmpTable.width(tableContainer.offsetWidth)\n            }\n          } else if (scrollY) {\n            tmpTable.width(tableContainer.offsetWidth)\n          } else if (tableWidthAttr) {\n            tmpTable.width(tableWidthAttr)\n          }\n\n          // Take into account the y scrollbar\n          _fnScrollingWidthAdjust(oSettings, tmpTable[0])\n\n          // Browsers need a bit of a hand when a width is assigned to any columns\n          // when x-scrolling as they tend to collapse the table to the min-width,\n          // even if we sent the column widths. So we need to keep track of what\n          // the table width should be by summing the user given values, and the\n          // automatic values\n          if (scrollX) {\n            var total = 0\n\n            for (i = 0; i < visibleColumns.length; i++) {\n              column = columns[visibleColumns[i]]\n              outerWidth = $(headerCells[i]).outerWidth()\n\n              total +=\n                column.sWidthOrig === null\n                  ? outerWidth\n                  : parseInt(column.sWidth, 10) + outerWidth - $(headerCells[i]).width()\n            }\n\n            tmpTable.width(_fnStringToCss(total))\n            table.style.width = _fnStringToCss(total)\n          }\n\n          // Get the width of each column in the constructed table\n          for (i = 0; i < visibleColumns.length; i++) {\n            column = columns[visibleColumns[i]]\n            width = $(headerCells[i]).width()\n\n            if (width) {\n              column.sWidth = _fnStringToCss(width)\n            }\n          }\n\n          table.style.width = _fnStringToCss(tmpTable.css('width'))\n\n          // Finished with the table - ditch it\n          tmpTable.remove()\n        }\n\n        // If there is a width attr, we want to attach an event listener which\n        // allows the table sizing to automatically adjust when the window is\n        // resized. Use the width attr rather than CSS, since we can't know if the\n        // CSS is a relative value or absolute - DOM read is always px.\n        if (tableWidthAttr) {\n          table.style.width = _fnStringToCss(tableWidthAttr)\n        }\n\n        if ((tableWidthAttr || scrollX) && !oSettings._reszEvt) {\n          $(window).bind(\n            'resize.DT-' + oSettings.sInstance,\n            _fnThrottle(function () {\n              _fnAdjustColumnSizing(oSettings)\n            })\n          )\n\n          oSettings._reszEvt = true\n        }\n      }\n\n      /**\n       * Throttle the calls to a function. Arguments and context are maintained for\n       * the throttled function\n       *  @param {function} fn Function to be called\n       *  @param {int} [freq=200] call frequency in mS\n       *  @returns {function} wrapped function\n       *  @memberof DataTable#oApi\n       */\n      function _fnThrottle (fn, freq) {\n        var frequency = freq || 200,\n          last,\n          timer\n\n        return function () {\n          var that = this,\n            now = +new Date(),\n            args = arguments\n\n          if (last && now < last + frequency) {\n            clearTimeout(timer)\n\n            timer = setTimeout(function () {\n              last = undefined\n              fn.apply(that, args)\n            }, frequency)\n          } else if (last) {\n            last = now\n            fn.apply(that, args)\n          } else {\n            last = now\n          }\n        }\n      }\n\n      /**\n       * Convert a CSS unit width to pixels (e.g. 2em)\n       *  @param {string} width width to be converted\n       *  @param {node} parent parent to get the with for (required for relative widths) - optional\n       *  @returns {int} width in pixels\n       *  @memberof DataTable#oApi\n       */\n      function _fnConvertToWidth (width, parent) {\n        if (!width) {\n          return 0\n        }\n\n        var n = $('<div/>')\n          .css('width', _fnStringToCss(width))\n          .appendTo(parent || document.body)\n\n        var val = n[0].offsetWidth\n        n.remove()\n\n        return val\n      }\n\n      /**\n       * Adjust a table's width to take account of vertical scroll bar\n       *  @param {object} oSettings dataTables settings object\n       *  @param {node} n table node\n       *  @memberof DataTable#oApi\n       */\n\n      function _fnScrollingWidthAdjust (settings, n) {\n        var scroll = settings.oScroll\n\n        if (scroll.sX || scroll.sY) {\n          // When y-scrolling only, we want to remove the width of the scroll bar\n          // so the table + scroll bar will fit into the area available, otherwise\n          // we fix the table at its current size with no adjustment\n          var correction = !scroll.sX ? scroll.iBarWidth : 0\n          n.style.width = _fnStringToCss($(n).outerWidth() - correction)\n        }\n      }\n\n      /**\n       * Get the widest node\n       *  @param {object} settings dataTables settings object\n       *  @param {int} colIdx column of interest\n       *  @returns {node} widest table node\n       *  @memberof DataTable#oApi\n       */\n      function _fnGetWidestNode (settings, colIdx) {\n        var idx = _fnGetMaxLenString(settings, colIdx)\n        if (idx < 0) {\n          return null\n        }\n\n        var data = settings.aoData[idx]\n        return !data.nTr // Might not have been created when deferred rendering\n          ? $('<td/>').html(_fnGetCellData(settings, idx, colIdx, 'display'))[0]\n          : data.anCells[colIdx]\n      }\n\n      /**\n       * Get the maximum strlen for each data column\n       *  @param {object} settings dataTables settings object\n       *  @param {int} colIdx column of interest\n       *  @returns {string} max string length for each column\n       *  @memberof DataTable#oApi\n       */\n      function _fnGetMaxLenString (settings, colIdx) {\n        var s,\n          max = -1,\n          maxIdx = -1\n\n        for (var i = 0, ien = settings.aoData.length; i < ien; i++) {\n          s = _fnGetCellData(settings, i, colIdx, 'display') + ''\n          s = s.replace(__re_html_remove, '')\n\n          if (s.length > max) {\n            max = s.length\n            maxIdx = i\n          }\n        }\n\n        return maxIdx\n      }\n\n      /**\n       * Append a CSS unit (only if required) to a string\n       *  @param {string} value to css-ify\n       *  @returns {string} value with css unit\n       *  @memberof DataTable#oApi\n       */\n      function _fnStringToCss (s) {\n        if (s === null) {\n          return '0px'\n        }\n\n        if (typeof s == 'number') {\n          return s < 0 ? '0px' : s + 'px'\n        }\n\n        // Check it has a unit character already\n        return s.match(/\\d$/) ? s + 'px' : s\n      }\n\n      /**\n       * Get the width of a scroll bar in this browser being used\n       *  @returns {int} width in pixels\n       *  @memberof DataTable#oApi\n       */\n      function _fnScrollBarWidth () {\n        // On first run a static variable is set, since this is only needed once.\n        // Subsequent runs will just use the previously calculated value\n        if (!DataTable.__scrollbarWidth) {\n          var inner = $('<p/>').css({\n            width: '100%',\n            height: 200,\n            padding: 0\n          })[0]\n\n          var outer = $('<div/>')\n            .css({\n              position: 'absolute',\n              top: 0,\n              left: 0,\n              width: 200,\n              height: 150,\n              padding: 0,\n              overflow: 'hidden',\n              visibility: 'hidden'\n            })\n            .append(inner)\n            .appendTo('body')\n\n          var w1 = inner.offsetWidth\n          outer.css('overflow', 'scroll')\n          var w2 = inner.offsetWidth\n\n          if (w1 === w2) {\n            w2 = outer[0].clientWidth\n          }\n\n          outer.remove()\n\n          DataTable.__scrollbarWidth = w1 - w2\n        }\n\n        return DataTable.__scrollbarWidth\n      }\n\n      function _fnSortFlatten (settings) {\n        var i,\n          iLen,\n          k,\n          kLen,\n          aSort = [],\n          aiOrig = [],\n          aoColumns = settings.aoColumns,\n          aDataSort,\n          iCol,\n          sType,\n          srcCol,\n          fixed = settings.aaSortingFixed,\n          fixedObj = $.isPlainObject(fixed),\n          nestedSort = [],\n          add = function (a) {\n            if (a.length && !$.isArray(a[0])) {\n              // 1D array\n              nestedSort.push(a)\n            } else {\n              // 2D array\n              nestedSort.push.apply(nestedSort, a)\n            }\n          }\n\n        // Build the sort array, with pre-fix and post-fix options if they have been\n        // specified\n        if ($.isArray(fixed)) {\n          add(fixed)\n        }\n\n        if (fixedObj && fixed.pre) {\n          add(fixed.pre)\n        }\n\n        add(settings.aaSorting)\n\n        if (fixedObj && fixed.post) {\n          add(fixed.post)\n        }\n\n        for (i = 0; i < nestedSort.length; i++) {\n          srcCol = nestedSort[i][0]\n          aDataSort = aoColumns[srcCol].aDataSort\n\n          for (k = 0, kLen = aDataSort.length; k < kLen; k++) {\n            iCol = aDataSort[k]\n            sType = aoColumns[iCol].sType || 'string'\n\n            aSort.push({\n              src: srcCol,\n              col: iCol,\n              dir: nestedSort[i][1],\n              index: nestedSort[i][2],\n              type: sType,\n              formatter: DataTable.ext.type.order[sType + '-pre']\n            })\n          }\n        }\n\n        return aSort\n      }\n\n      /**\n       * Change the order of the table\n       *  @param {object} oSettings dataTables settings object\n       *  @memberof DataTable#oApi\n       *  @todo This really needs split up!\n       */\n      function _fnSort (oSettings) {\n        var i,\n          ien,\n          iLen,\n          j,\n          jLen,\n          k,\n          kLen,\n          sDataType,\n          nTh,\n          aiOrig = [],\n          oExtSort = DataTable.ext.type.order,\n          aoData = oSettings.aoData,\n          aoColumns = oSettings.aoColumns,\n          aDataSort,\n          data,\n          iCol,\n          sType,\n          oSort,\n          formatters = 0,\n          sortCol,\n          displayMaster = oSettings.aiDisplayMaster,\n          aSort\n\n        // Resolve any column types that are unknown due to addition or invalidation\n        // @todo Can this be moved into a 'data-ready' handler which is called when\n        //   data is going to be used in the table?\n        _fnColumnTypes(oSettings)\n\n        aSort = _fnSortFlatten(oSettings)\n\n        for (i = 0, ien = aSort.length; i < ien; i++) {\n          sortCol = aSort[i]\n\n          // Track if we can use the fast sort algorithm\n          if (sortCol.formatter) {\n            formatters++\n          }\n\n          // Load the data needed for the sort, for each cell\n          _fnSortData(oSettings, sortCol.col)\n        }\n\n        /* No sorting required if server-side or no sorting array */\n        if (_fnDataSource(oSettings) != 'ssp' && aSort.length !== 0) {\n          // Create a value - key array of the current row positions such that we can use their\n          // current position during the sort, if values match, in order to perform stable sorting\n          for (i = 0, iLen = displayMaster.length; i < iLen; i++) {\n            aiOrig[displayMaster[i]] = i\n          }\n\n          /* Do the sort - here we want multi-column sorting based on a given data source (column)\n           * and sorting function (from oSort) in a certain direction. It's reasonably complex to\n           * follow on it's own, but this is what we want (example two column sorting):\n           *  fnLocalSorting = function(a,b){\n           *    var iTest;\n           *    iTest = oSort['string-asc']('data11', 'data12');\n           *      if (iTest !== 0)\n           *        return iTest;\n           *    iTest = oSort['numeric-desc']('data21', 'data22');\n           *    if (iTest !== 0)\n           *      return iTest;\n           *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );\n           *  }\n           * Basically we have a test for each sorting column, if the data in that column is equal,\n           * test the next column. If all columns match, then we use a numeric sort on the row\n           * positions in the original data array to provide a stable sort.\n           *\n           * Note - I know it seems excessive to have two sorting methods, but the first is around\n           * 15% faster, so the second is only maintained for backwards compatibility with sorting\n           * methods which do not have a pre-sort formatting function.\n           */\n          if (formatters === aSort.length) {\n            // All sort types have formatting functions\n            displayMaster.sort(function (a, b) {\n              var x,\n                y,\n                k,\n                test,\n                sort,\n                len = aSort.length,\n                dataA = aoData[a]._aSortData,\n                dataB = aoData[b]._aSortData\n\n              for (k = 0; k < len; k++) {\n                sort = aSort[k]\n\n                x = dataA[sort.col]\n                y = dataB[sort.col]\n\n                test = x < y ? -1 : x > y ? 1 : 0\n                if (test !== 0) {\n                  return sort.dir === 'asc' ? test : -test\n                }\n              }\n\n              x = aiOrig[a]\n              y = aiOrig[b]\n              return x < y ? -1 : x > y ? 1 : 0\n            })\n          } else {\n            // Depreciated - remove in 1.11 (providing a plug-in option)\n            // Not all sort types have formatting methods, so we have to call their sorting\n            // methods.\n            displayMaster.sort(function (a, b) {\n              var x,\n                y,\n                k,\n                l,\n                test,\n                sort,\n                fn,\n                len = aSort.length,\n                dataA = aoData[a]._aSortData,\n                dataB = aoData[b]._aSortData\n\n              for (k = 0; k < len; k++) {\n                sort = aSort[k]\n\n                x = dataA[sort.col]\n                y = dataB[sort.col]\n\n                fn = oExtSort[sort.type + '-' + sort.dir] || oExtSort['string-' + sort.dir]\n                test = fn(x, y)\n                if (test !== 0) {\n                  return test\n                }\n              }\n\n              x = aiOrig[a]\n              y = aiOrig[b]\n              return x < y ? -1 : x > y ? 1 : 0\n            })\n          }\n        }\n\n        /* Tell the draw function that we have sorted the data */\n        oSettings.bSorted = true\n      }\n\n      function _fnSortAria (settings) {\n        var label\n        var nextSort\n        var columns = settings.aoColumns\n        var aSort = _fnSortFlatten(settings)\n        var oAria = settings.oLanguage.oAria\n\n        // ARIA attributes - need to loop all columns, to update all (removing old\n        // attributes as needed)\n        for (var i = 0, iLen = columns.length; i < iLen; i++) {\n          var col = columns[i]\n          var asSorting = col.asSorting\n          var sTitle = col.sTitle.replace(/<.*?>/g, '')\n          var th = col.nTh\n\n          // IE7 is throwing an error when setting these properties with jQuery's\n          // attr() and removeAttr() methods...\n          th.removeAttribute('aria-sort')\n\n          /* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */\n          if (col.bSortable) {\n            if (aSort.length > 0 && aSort[0].col == i) {\n              th.setAttribute('aria-sort', aSort[0].dir == 'asc' ? 'ascending' : 'descending')\n              nextSort = asSorting[aSort[0].index + 1] || asSorting[0]\n            } else {\n              nextSort = asSorting[0]\n            }\n\n            label = sTitle + (nextSort === 'asc' ? oAria.sSortAscending : oAria.sSortDescending)\n          } else {\n            label = sTitle\n          }\n\n          th.setAttribute('aria-label', label)\n        }\n      }\n\n      /**\n       * Function to run on user sort request\n       *  @param {object} settings dataTables settings object\n       *  @param {node} attachTo node to attach the handler to\n       *  @param {int} colIdx column sorting index\n       *  @param {boolean} [append=false] Append the requested sort to the existing\n       *    sort if true (i.e. multi-column sort)\n       *  @param {function} [callback] callback function\n       *  @memberof DataTable#oApi\n       */\n      function _fnSortListener (settings, colIdx, append, callback) {\n        var col = settings.aoColumns[colIdx]\n        var sorting = settings.aaSorting\n        var asSorting = col.asSorting\n        var nextSortIdx\n        var next = function (a) {\n          var idx = a._idx\n          if (idx === undefined) {\n            idx = $.inArray(a[1], asSorting)\n          }\n\n          return idx + 1 >= asSorting.length ? 0 : idx + 1\n        }\n\n        // Convert to 2D array if needed\n        if (typeof sorting[0] === 'number') {\n          sorting = settings.aaSorting = [sorting]\n        }\n\n        // If appending the sort then we are multi-column sorting\n        if (append && settings.oFeatures.bSortMulti) {\n          // Are we already doing some kind of sort on this column?\n          var sortIdx = $.inArray(colIdx, _pluck(sorting, '0'))\n\n          if (sortIdx !== -1) {\n            // Yes, modify the sort\n            nextSortIdx = next(sorting[sortIdx])\n\n            sorting[sortIdx][1] = asSorting[nextSortIdx]\n            sorting[sortIdx]._idx = nextSortIdx\n          } else {\n            // No sort on this column yet\n            sorting.push([colIdx, asSorting[0], 0])\n            sorting[sorting.length - 1]._idx = 0\n          }\n        } else if (sorting.length && sorting[0][0] == colIdx) {\n          // Single column - already sorting on this column, modify the sort\n          nextSortIdx = next(sorting[0])\n\n          sorting.length = 1\n          sorting[0][1] = asSorting[nextSortIdx]\n          sorting[0]._idx = nextSortIdx\n        } else {\n          // Single column - sort only on this column\n          sorting.length = 0\n          sorting.push([colIdx, asSorting[0]])\n          sorting[0]._idx = 0\n        }\n\n        // Run the sort by calling a full redraw\n        _fnReDraw(settings)\n\n        // callback used for async user interaction\n        if (typeof callback == 'function') {\n          callback(settings)\n        }\n      }\n\n      /**\n       * Attach a sort handler (click) to a node\n       *  @param {object} settings dataTables settings object\n       *  @param {node} attachTo node to attach the handler to\n       *  @param {int} colIdx column sorting index\n       *  @param {function} [callback] callback function\n       *  @memberof DataTable#oApi\n       */\n      function _fnSortAttachListener (settings, attachTo, colIdx, callback) {\n        var col = settings.aoColumns[colIdx]\n\n        _fnBindAction(attachTo, {}, function (e) {\n          /* If the column is not sortable - don't to anything */\n          if (col.bSortable === false) {\n            return\n          }\n\n          // If processing is enabled use a timeout to allow the processing\n          // display to be shown - otherwise to it synchronously\n          if (settings.oFeatures.bProcessing) {\n            _fnProcessingDisplay(settings, true)\n\n            setTimeout(function () {\n              _fnSortListener(settings, colIdx, e.shiftKey, callback)\n\n              // In server-side processing, the draw callback will remove the\n              // processing display\n              if (_fnDataSource(settings) !== 'ssp') {\n                _fnProcessingDisplay(settings, false)\n              }\n            }, 0)\n          } else {\n            _fnSortListener(settings, colIdx, e.shiftKey, callback)\n          }\n        })\n      }\n\n      /**\n       * Set the sorting classes on table's body, Note: it is safe to call this function\n       * when bSort and bSortClasses are false\n       *  @param {object} oSettings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnSortingClasses (settings) {\n        var oldSort = settings.aLastSort\n        var sortClass = settings.oClasses.sSortColumn\n        var sort = _fnSortFlatten(settings)\n        var features = settings.oFeatures\n        var i, ien, colIdx\n\n        if (features.bSort && features.bSortClasses) {\n          // Remove old sorting classes\n          for (i = 0, ien = oldSort.length; i < ien; i++) {\n            colIdx = oldSort[i].src\n\n            // Remove column sorting\n            $(_pluck(settings.aoData, 'anCells', colIdx)).removeClass(sortClass + (i < 2 ? i + 1 : 3))\n          }\n\n          // Add new column sorting\n          for (i = 0, ien = sort.length; i < ien; i++) {\n            colIdx = sort[i].src\n\n            $(_pluck(settings.aoData, 'anCells', colIdx)).addClass(sortClass + (i < 2 ? i + 1 : 3))\n          }\n        }\n\n        settings.aLastSort = sort\n      }\n\n      // Get the data to sort a column, be it from cache, fresh (populating the\n      // cache), or from a sort formatter\n      function _fnSortData (settings, idx) {\n        // Custom sorting function - provided by the sort data type\n        var column = settings.aoColumns[idx]\n        var customSort = DataTable.ext.order[column.sSortDataType]\n        var customData\n\n        if (customSort) {\n          customData = customSort.call(settings.oInstance, settings, idx, _fnColumnIndexToVisible(settings, idx))\n        }\n\n        // Use / populate cache\n        var row, cellData\n        var formatter = DataTable.ext.type.order[column.sType + '-pre']\n\n        for (var i = 0, ien = settings.aoData.length; i < ien; i++) {\n          row = settings.aoData[i]\n\n          if (!row._aSortData) {\n            row._aSortData = []\n          }\n\n          if (!row._aSortData[idx] || customSort) {\n            cellData = customSort\n              ? customData[i] // If there was a custom sort function, use data from there\n              : _fnGetCellData(settings, i, idx, 'sort')\n\n            row._aSortData[idx] = formatter ? formatter(cellData) : cellData\n          }\n        }\n      }\n\n      /**\n       * Save the state of a table\n       *  @param {object} oSettings dataTables settings object\n       *  @memberof DataTable#oApi\n       */\n      function _fnSaveState (settings) {\n        if (!settings.oFeatures.bStateSave || settings.bDestroying) {\n          return\n        }\n\n        /* Store the interesting variables */\n        var state = {\n          time: +new Date(),\n          start: settings._iDisplayStart,\n          length: settings._iDisplayLength,\n          order: $.extend(true, [], settings.aaSorting),\n          search: _fnSearchToCamel(settings.oPreviousSearch),\n          columns: $.map(settings.aoColumns, function (col, i) {\n            return {\n              visible: col.bVisible,\n              search: _fnSearchToCamel(settings.aoPreSearchCols[i])\n            }\n          })\n        }\n\n        _fnCallbackFire(settings, 'aoStateSaveParams', 'stateSaveParams', [settings, state])\n\n        settings.oSavedState = state\n        settings.fnStateSaveCallback.call(settings.oInstance, settings, state)\n      }\n\n      /**\n       * Attempt to load a saved table state\n       *  @param {object} oSettings dataTables settings object\n       *  @param {object} oInit DataTables init object so we can override settings\n       *  @memberof DataTable#oApi\n       */\n      function _fnLoadState (settings, oInit) {\n        var i, ien\n        var columns = settings.aoColumns\n\n        if (!settings.oFeatures.bStateSave) {\n          return\n        }\n\n        var state = settings.fnStateLoadCallback.call(settings.oInstance, settings)\n        if (!state || !state.time) {\n          return\n        }\n\n        /* Allow custom and plug-in manipulation functions to alter the saved data set and\n         * cancelling of loading by returning false\n         */\n        var abStateLoad = _fnCallbackFire(settings, 'aoStateLoadParams', 'stateLoadParams', [settings, state])\n        if ($.inArray(false, abStateLoad) !== -1) {\n          return\n        }\n\n        /* Reject old data */\n        var duration = settings.iStateDuration\n        if (duration > 0 && state.time < +new Date() - duration * 1000) {\n          return\n        }\n\n        // Number of columns have changed - all bets are off, no restore of settings\n        if (columns.length !== state.columns.length) {\n          return\n        }\n\n        // Store the saved state so it might be accessed at any time\n        settings.oLoadedState = $.extend(true, {}, state)\n\n        // Restore key features - todo - for 1.11 this needs to be done by\n        // subscribed events\n        settings._iDisplayStart = state.start\n        settings.iInitDisplayStart = state.start\n        settings._iDisplayLength = state.length\n        settings.aaSorting = []\n\n        // Order\n        $.each(state.order, function (i, col) {\n          settings.aaSorting.push(col[0] >= columns.length ? [0, col[1]] : col)\n        })\n\n        // Search\n        $.extend(settings.oPreviousSearch, _fnSearchToHung(state.search))\n\n        // Columns\n        for (i = 0, ien = state.columns.length; i < ien; i++) {\n          var col = state.columns[i]\n\n          // Visibility\n          columns[i].bVisible = col.visible\n\n          // Search\n          $.extend(settings.aoPreSearchCols[i], _fnSearchToHung(col.search))\n        }\n\n        _fnCallbackFire(settings, 'aoStateLoaded', 'stateLoaded', [settings, state])\n      }\n\n      /**\n       * Return the settings object for a particular table\n       *  @param {node} table table we are using as a dataTable\n       *  @returns {object} Settings object - or null if not found\n       *  @memberof DataTable#oApi\n       */\n      function _fnSettingsFromNode (table) {\n        var settings = DataTable.settings\n        var idx = $.inArray(table, _pluck(settings, 'nTable'))\n\n        return idx !== -1 ? settings[idx] : null\n      }\n\n      /**\n       * Log an error message\n       *  @param {object} settings dataTables settings object\n       *  @param {int} level log error messages, or display them to the user\n       *  @param {string} msg error message\n       *  @param {int} tn Technical note id to get more information about the error.\n       *  @memberof DataTable#oApi\n       */\n      function _fnLog (settings, level, msg, tn) {\n        msg = 'DataTables warning: ' + (settings !== null ? 'table id=' + settings.sTableId + ' - ' : '') + msg\n\n        if (tn) {\n          msg += '. For more information about this error, please see ' + 'http://datatables.net/tn/' + tn\n        }\n\n        if (!level) {\n          // Backwards compatibility pre 1.10\n          var ext = DataTable.ext\n          var type = ext.sErrMode || ext.errMode\n\n          if (type == 'alert') {\n            alert(msg)\n          } else {\n            throw new Error(msg)\n          }\n        } else if (window.console && console.log) {\n          console.log(msg)\n        }\n      }\n\n      /**\n       * See if a property is defined on one object, if so assign it to the other object\n       *  @param {object} ret target object\n       *  @param {object} src source object\n       *  @param {string} name property\n       *  @param {string} [mappedName] name to map too - optional, name used if not given\n       *  @memberof DataTable#oApi\n       */\n      function _fnMap (ret, src, name, mappedName) {\n        if ($.isArray(name)) {\n          $.each(name, function (i, val) {\n            if ($.isArray(val)) {\n              _fnMap(ret, src, val[0], val[1])\n            } else {\n              _fnMap(ret, src, val)\n            }\n          })\n\n          return\n        }\n\n        if (mappedName === undefined) {\n          mappedName = name\n        }\n\n        if (src[name] !== undefined) {\n          ret[mappedName] = src[name]\n        }\n      }\n\n      /**\n       * Extend objects - very similar to jQuery.extend, but deep copy objects, and\n       * shallow copy arrays. The reason we need to do this, is that we don't want to\n       * deep copy array init values (such as aaSorting) since the dev wouldn't be\n       * able to override them, but we do want to deep copy arrays.\n       *  @param {object} out Object to extend\n       *  @param {object} extender Object from which the properties will be applied to\n       *      out\n       *  @param {boolean} breakRefs If true, then arrays will be sliced to take an\n       *      independent copy with the exception of the `data` or `aaData` parameters\n       *      if they are present. This is so you can pass in a collection to\n       *      DataTables and have that used as your data source without breaking the\n       *      references\n       *  @returns {object} out Reference, just for convenience - out === the return.\n       *  @memberof DataTable#oApi\n       *  @todo This doesn't take account of arrays inside the deep copied objects.\n       */\n      function _fnExtend (out, extender, breakRefs) {\n        var val\n\n        for (var prop in extender) {\n          if (extender.hasOwnProperty(prop)) {\n            val = extender[prop]\n\n            if ($.isPlainObject(val)) {\n              if (!$.isPlainObject(out[prop])) {\n                out[prop] = {}\n              }\n              $.extend(true, out[prop], val)\n            } else if (breakRefs && prop !== 'data' && prop !== 'aaData' && $.isArray(val)) {\n              out[prop] = val.slice()\n            } else {\n              out[prop] = val\n            }\n          }\n        }\n\n        return out\n      }\n\n      /**\n       * Bind an event handers to allow a click or return key to activate the callback.\n       * This is good for accessibility since a return on the keyboard will have the\n       * same effect as a click, if the element has focus.\n       *  @param {element} n Element to bind the action to\n       *  @param {object} oData Data object to pass to the triggered function\n       *  @param {function} fn Callback function for when the event is triggered\n       *  @memberof DataTable#oApi\n       */\n      function _fnBindAction (n, oData, fn) {\n        $(n)\n          .bind('click.DT', oData, function (e) {\n            n.blur() // Remove focus outline for mouse users\n            fn(e)\n          })\n          .bind('keypress.DT', oData, function (e) {\n            if (e.which === 13) {\n              e.preventDefault()\n              fn(e)\n            }\n          })\n          .bind('selectstart.DT', function () {\n            /* Take the brutal approach to cancelling text selection */\n            return false\n          })\n      }\n\n      /**\n       * Register a callback function. Easily allows a callback function to be added to\n       * an array store of callback functions that can then all be called together.\n       *  @param {object} oSettings dataTables settings object\n       *  @param {string} sStore Name of the array storage for the callbacks in oSettings\n       *  @param {function} fn Function to be called back\n       *  @param {string} sName Identifying name for the callback (i.e. a label)\n       *  @memberof DataTable#oApi\n       */\n      function _fnCallbackReg (oSettings, sStore, fn, sName) {\n        if (fn) {\n          oSettings[sStore].push({\n            fn: fn,\n            sName: sName\n          })\n        }\n      }\n\n      /**\n       * Fire callback functions and trigger events. Note that the loop over the\n       * callback array store is done backwards! Further note that you do not want to\n       * fire off triggers in time sensitive applications (for example cell creation)\n       * as its slow.\n       *  @param {object} settings dataTables settings object\n       *  @param {string} callbackArr Name of the array storage for the callbacks in\n       *      oSettings\n       *  @param {string} event Name of the jQuery custom event to trigger. If null no\n       *      trigger is fired\n       *  @param {array} args Array of arguments to pass to the callback function /\n       *      trigger\n       *  @memberof DataTable#oApi\n       */\n      function _fnCallbackFire (settings, callbackArr, e, args) {\n        var ret = []\n\n        if (callbackArr) {\n          ret = $.map(settings[callbackArr].slice().reverse(), function (val, i) {\n            return val.fn.apply(settings.oInstance, args)\n          })\n        }\n\n        if (e !== null) {\n          $(settings.nTable).trigger(e + '.dt', args)\n        }\n\n        return ret\n      }\n\n      function _fnLengthOverflow (settings) {\n        var start = settings._iDisplayStart,\n          end = settings.fnDisplayEnd(),\n          len = settings._iDisplayLength\n\n        /* If we have space to show extra rows (backing up from the end point - then do so */\n        if (end === settings.fnRecordsDisplay()) {\n          start = end - len\n        }\n\n        if (len === -1 || start < 0) {\n          start = 0\n        }\n\n        settings._iDisplayStart = start\n      }\n\n      function _fnRenderer (settings, type) {\n        var renderer = settings.renderer\n        var host = DataTable.ext.renderer[type]\n\n        if ($.isPlainObject(renderer) && renderer[type]) {\n          // Specific renderer for this type. If available use it, otherwise use\n          // the default.\n          return host[renderer[type]] || host._\n        } else if (typeof renderer === 'string') {\n          // Common renderer - if there is one available for this type use it,\n          // otherwise use the default\n          return host[renderer] || host._\n        }\n\n        // Use the default\n        return host._\n      }\n\n      /**\n       * Detect the data source being used for the table. Used to simplify the code\n       * a little (ajax) and to make it compress a little smaller.\n       *\n       *  @param {object} settings dataTables settings object\n       *  @returns {string} Data source\n       *  @memberof DataTable#oApi\n       */\n      function _fnDataSource (settings) {\n        if (settings.oFeatures.bServerSide) {\n          return 'ssp'\n        } else if (settings.ajax || settings.sAjaxSource) {\n          return 'ajax'\n        }\n        return 'dom'\n      }\n\n      DataTable = function (options) {\n        /**\n         * Perform a jQuery selector action on the table's TR elements (from the tbody) and\n         * return the resulting jQuery object.\n         *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on\n         *  @param {object} [oOpts] Optional parameters for modifying the rows to be included\n         *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter\n         *    criterion (\"applied\") or all TR elements (i.e. no filter).\n         *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.\n         *    Can be either 'current', whereby the current sorting of the table is used, or\n         *    'original' whereby the original order the data was read into the table is used.\n         *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page\n         *    (\"current\") or not (\"all\"). If 'current' is given, then order is assumed to be\n         *    'current' and filter is 'applied', regardless of what they might be given as.\n         *  @returns {object} jQuery object, filtered by the given selector.\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *\n         *      // Highlight every second row\n         *      oTable.$('tr:odd').css('backgroundColor', 'blue');\n         *    } );\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *\n         *      // Filter to rows with 'Webkit' in them, add a background colour and then\n         *      // remove the filter, thus highlighting the 'Webkit' rows only.\n         *      oTable.fnFilter('Webkit');\n         *      oTable.$('tr', {\"search\": \"applied\"}).css('backgroundColor', 'blue');\n         *      oTable.fnFilter('');\n         *    } );\n         */\n        this.$ = function (sSelector, oOpts) {\n          return this.api(true).$(sSelector, oOpts)\n        }\n\n        /**\n         * Almost identical to $ in operation, but in this case returns the data for the matched\n         * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes\n         * rather than any descendants, so the data can be obtained for the row/cell. If matching\n         * rows are found, the data returned is the original data array/object that was used to\n         * create the row (or a generated array if from a DOM source).\n         *\n         * This method is often useful in-combination with $ where both functions are given the\n         * same parameters and the array indexes will match identically.\n         *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on\n         *  @param {object} [oOpts] Optional parameters for modifying the rows to be included\n         *  @param {string} [oOpts.filter=none] Select elements that meet the current filter\n         *    criterion (\"applied\") or all elements (i.e. no filter).\n         *  @param {string} [oOpts.order=current] Order of the data in the processed array.\n         *    Can be either 'current', whereby the current sorting of the table is used, or\n         *    'original' whereby the original order the data was read into the table is used.\n         *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page\n         *    (\"current\") or not (\"all\"). If 'current' is given, then order is assumed to be\n         *    'current' and filter is 'applied', regardless of what they might be given as.\n         *  @returns {array} Data for the matched elements. If any elements, as a result of the\n         *    selector, were not TR, TD or TH elements in the DataTable, they will have a null\n         *    entry in the array.\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *\n         *      // Get the data from the first row in the table\n         *      var data = oTable._('tr:first');\n         *\n         *      // Do something useful with the data\n         *      alert( \"First cell is: \"+data[0] );\n         *    } );\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *\n         *      // Filter to 'Webkit' and get all data for\n         *      oTable.fnFilter('Webkit');\n         *      var data = oTable._('tr', {\"search\": \"applied\"});\n         *\n         *      // Do something with the data\n         *      alert( data.length+\" rows matched the search\" );\n         *    } );\n         */\n        this._ = function (sSelector, oOpts) {\n          return this.api(true)\n            .rows(sSelector, oOpts)\n            .data()\n        }\n\n        /**\n         * Create a DataTables Api instance, with the currently selected tables for\n         * the Api's context.\n         * @param {boolean} [traditional=false] Set the API instance's context to be\n         *   only the table referred to by the `DataTable.ext.iApiIndex` option, as was\n         *   used in the API presented by DataTables 1.9- (i.e. the traditional mode),\n         *   or if all tables captured in the jQuery object should be used.\n         * @return {DataTables.Api}\n         */\n        this.api = function (traditional) {\n          return traditional ? new _Api(_fnSettingsFromNode(this[_ext.iApiIndex])) : new _Api(this)\n        }\n\n        /**\n         * Add a single new row or multiple rows of data to the table. Please note\n         * that this is suitable for client-side processing only - if you are using\n         * server-side processing (i.e. \"bServerSide\": true), then to add data, you\n         * must add it to the data source, i.e. the server-side, through an Ajax call.\n         *  @param {array|object} data The data to be added to the table. This can be:\n         *    <ul>\n         *      <li>1D array of data - add a single row with the data provided</li>\n         *      <li>2D array of arrays - add multiple rows in a single call</li>\n         *      <li>object - data object when using <i>mData</i></li>\n         *      <li>array of objects - multiple data objects when using <i>mData</i></li>\n         *    </ul>\n         *  @param {bool} [redraw=true] redraw the table or not\n         *  @returns {array} An array of integers, representing the list of indexes in\n         *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to\n         *    the table.\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    // Global var for counter\n         *    var giCount = 2;\n         *\n         *    $(document).ready(function() {\n         *      $('#example').dataTable();\n         *    } );\n         *\n         *    function fnClickAddRow() {\n         *      $('#example').dataTable().fnAddData( [\n         *        giCount+\".1\",\n         *        giCount+\".2\",\n         *        giCount+\".3\",\n         *        giCount+\".4\" ]\n         *      );\n         *\n         *      giCount++;\n         *    }\n         */\n        this.fnAddData = function (data, redraw) {\n          var api = this.api(true)\n\n          /* Check if we want to add multiple rows or not */\n          var rows =\n            $.isArray(data) && ($.isArray(data[0]) || $.isPlainObject(data[0])) ? api.rows.add(data) : api.row.add(data)\n\n          if (redraw === undefined || redraw) {\n            api.draw()\n          }\n\n          return rows.flatten().toArray()\n        }\n\n        /**\n         * This function will make DataTables recalculate the column sizes, based on the data\n         * contained in the table and the sizes applied to the columns (in the DOM, CSS or\n         * through the sWidth parameter). This can be useful when the width of the table's\n         * parent element changes (for example a window resize).\n         *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable( {\n         *        \"sScrollY\": \"200px\",\n         *        \"bPaginate\": false\n         *      } );\n         *\n         *      $(window).bind('resize', function () {\n         *        oTable.fnAdjustColumnSizing();\n         *      } );\n         *    } );\n         */\n        this.fnAdjustColumnSizing = function (bRedraw) {\n          var api = this.api(true).columns.adjust()\n          var settings = api.settings()[0]\n          var scroll = settings.oScroll\n\n          if (bRedraw === undefined || bRedraw) {\n            api.draw(false)\n          } else if (scroll.sX !== '' || scroll.sY !== '') {\n            /* If not redrawing, but scrolling, we want to apply the new column sizes anyway */\n            _fnScrollDraw(settings)\n          }\n        }\n\n        /**\n         * Quickly and simply clear a table\n         *  @param {bool} [bRedraw=true] redraw the table or not\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *\n         *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)\n         *      oTable.fnClearTable();\n         *    } );\n         */\n        this.fnClearTable = function (bRedraw) {\n          var api = this.api(true).clear()\n\n          if (bRedraw === undefined || bRedraw) {\n            api.draw()\n          }\n        }\n\n        /**\n         * The exact opposite of 'opening' a row, this function will close any rows which\n         * are currently 'open'.\n         *  @param {node} nTr the table row to 'close'\n         *  @returns {int} 0 on success, or 1 if failed (can't find the row)\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable;\n         *\n         *      // 'open' an information row when a row is clicked on\n         *      $('#example tbody tr').click( function () {\n         *        if ( oTable.fnIsOpen(this) ) {\n         *          oTable.fnClose( this );\n         *        } else {\n         *          oTable.fnOpen( this, \"Temporary row opened\", \"info_row\" );\n         *        }\n         *      } );\n         *\n         *      oTable = $('#example').dataTable();\n         *    } );\n         */\n        this.fnClose = function (nTr) {\n          this.api(true)\n            .row(nTr)\n            .child.hide()\n        }\n\n        /**\n         * Remove a row for the table\n         *  @param {mixed} target The index of the row from aoData to be deleted, or\n         *    the TR element you want to delete\n         *  @param {function|null} [callBack] Callback function\n         *  @param {bool} [redraw=true] Redraw the table or not\n         *  @returns {array} The row that was deleted\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *\n         *      // Immediately remove the first row\n         *      oTable.fnDeleteRow( 0 );\n         *    } );\n         */\n        this.fnDeleteRow = function (target, callback, redraw) {\n          var api = this.api(true)\n          var rows = api.rows(target)\n          var settings = rows.settings()[0]\n          var data = settings.aoData[rows[0][0]]\n\n          rows.remove()\n\n          if (callback) {\n            callback.call(this, settings, data)\n          }\n\n          if (redraw === undefined || redraw) {\n            api.draw()\n          }\n\n          return data\n        }\n\n        /**\n         * Restore the table to it's original state in the DOM by removing all of DataTables\n         * enhancements, alterations to the DOM structure of the table and event listeners.\n         *  @param {boolean} [remove=false] Completely remove the table from the DOM\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      // This example is fairly pointless in reality, but shows how fnDestroy can be used\n         *      var oTable = $('#example').dataTable();\n         *      oTable.fnDestroy();\n         *    } );\n         */\n        this.fnDestroy = function (remove) {\n          this.api(true).destroy(remove)\n        }\n\n        /**\n         * Redraw the table\n         *  @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *\n         *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)\n         *      oTable.fnDraw();\n         *    } );\n         */\n        this.fnDraw = function (complete) {\n          // Note that this isn't an exact match to the old call to _fnDraw - it takes\n          // into account the new data, but can old position.\n          this.api(true).draw(!complete)\n        }\n\n        /**\n         * Filter the input based on data\n         *  @param {string} sInput String to filter the table on\n         *  @param {int|null} [iColumn] Column to limit filtering to\n         *  @param {bool} [bRegex=false] Treat as regular expression or not\n         *  @param {bool} [bSmart=true] Perform smart filtering or not\n         *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)\n         *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *\n         *      // Sometime later - filter...\n         *      oTable.fnFilter( 'test string' );\n         *    } );\n         */\n        this.fnFilter = function (sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive) {\n          var api = this.api(true)\n\n          if (iColumn === null || iColumn === undefined) {\n            api.search(sInput, bRegex, bSmart, bCaseInsensitive)\n          } else {\n            api.column(iColumn).search(sInput, bRegex, bSmart, bCaseInsensitive)\n          }\n\n          api.draw()\n        }\n\n        /**\n         * Get the data for the whole table, an individual row or an individual cell based on the\n         * provided parameters.\n         *  @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as\n         *    a TR node then the data source for the whole row will be returned. If given as a\n         *    TD/TH cell node then iCol will be automatically calculated and the data for the\n         *    cell returned. If given as an integer, then this is treated as the aoData internal\n         *    data index for the row (see fnGetPosition) and the data for that row used.\n         *  @param {int} [col] Optional column index that you want the data of.\n         *  @returns {array|object|string} If mRow is undefined, then the data for all rows is\n         *    returned. If mRow is defined, just data for that row, and is iCol is\n         *    defined, only data for the designated cell is returned.\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    // Row data\n         *    $(document).ready(function() {\n         *      oTable = $('#example').dataTable();\n         *\n         *      oTable.$('tr').click( function () {\n         *        var data = oTable.fnGetData( this );\n         *        // ... do something with the array / object of data for the row\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Individual cell data\n         *    $(document).ready(function() {\n         *      oTable = $('#example').dataTable();\n         *\n         *      oTable.$('td').click( function () {\n         *        var sData = oTable.fnGetData( this );\n         *        alert( 'The cell clicked on had the value of '+sData );\n         *      } );\n         *    } );\n         */\n        this.fnGetData = function (src, col) {\n          var api = this.api(true)\n\n          if (src !== undefined) {\n            var type = src.nodeName ? src.nodeName.toLowerCase() : ''\n\n            return col !== undefined || type == 'td' || type == 'th'\n              ? api.cell(src, col).data()\n              : api.row(src).data() || null\n          }\n\n          return api.data().toArray()\n        }\n\n        /**\n         * Get an array of the TR nodes that are used in the table's body. Note that you will\n         * typically want to use the '$' API method in preference to this as it is more\n         * flexible.\n         *  @param {int} [iRow] Optional row index for the TR element you want\n         *  @returns {array|node} If iRow is undefined, returns an array of all TR elements\n         *    in the table's body, or iRow is defined, just the TR element requested.\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *\n         *      // Get the nodes from the table\n         *      var nNodes = oTable.fnGetNodes( );\n         *    } );\n         */\n        this.fnGetNodes = function (iRow) {\n          var api = this.api(true)\n\n          return iRow !== undefined\n            ? api.row(iRow).node()\n            : api\n                .rows()\n                .nodes()\n                .flatten()\n                .toArray()\n        }\n\n        /**\n         * Get the array indexes of a particular cell from it's DOM element\n         * and column index including hidden columns\n         *  @param {node} node this can either be a TR, TD or TH in the table's body\n         *  @returns {int} If nNode is given as a TR, then a single index is returned, or\n         *    if given as a cell, an array of [row index, column index (visible),\n         *    column index (all)] is given.\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      $('#example tbody td').click( function () {\n         *        // Get the position of the current data from the node\n         *        var aPos = oTable.fnGetPosition( this );\n         *\n         *        // Get the data array for this row\n         *        var aData = oTable.fnGetData( aPos[0] );\n         *\n         *        // Update the data array and return the value\n         *        aData[ aPos[1] ] = 'clicked';\n         *        this.innerHTML = 'clicked';\n         *      } );\n         *\n         *      // Init DataTables\n         *      oTable = $('#example').dataTable();\n         *    } );\n         */\n        this.fnGetPosition = function (node) {\n          var api = this.api(true)\n          var nodeName = node.nodeName.toUpperCase()\n\n          if (nodeName == 'TR') {\n            return api.row(node).index()\n          } else if (nodeName == 'TD' || nodeName == 'TH') {\n            var cell = api.cell(node).index()\n\n            return [cell.row, cell.columnVisible, cell.column]\n          }\n          return null\n        }\n\n        /**\n         * Check to see if a row is 'open' or not.\n         *  @param {node} nTr the table row to check\n         *  @returns {boolean} true if the row is currently open, false otherwise\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable;\n         *\n         *      // 'open' an information row when a row is clicked on\n         *      $('#example tbody tr').click( function () {\n         *        if ( oTable.fnIsOpen(this) ) {\n         *          oTable.fnClose( this );\n         *        } else {\n         *          oTable.fnOpen( this, \"Temporary row opened\", \"info_row\" );\n         *        }\n         *      } );\n         *\n         *      oTable = $('#example').dataTable();\n         *    } );\n         */\n        this.fnIsOpen = function (nTr) {\n          return this.api(true)\n            .row(nTr)\n            .child.isShown()\n        }\n\n        /**\n         * This function will place a new row directly after a row which is currently\n         * on display on the page, with the HTML contents that is passed into the\n         * function. This can be used, for example, to ask for confirmation that a\n         * particular record should be deleted.\n         *  @param {node} nTr The table row to 'open'\n         *  @param {string|node|jQuery} mHtml The HTML to put into the row\n         *  @param {string} sClass Class to give the new TD cell\n         *  @returns {node} The row opened. Note that if the table row passed in as the\n         *    first parameter, is not found in the table, this method will silently\n         *    return.\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable;\n         *\n         *      // 'open' an information row when a row is clicked on\n         *      $('#example tbody tr').click( function () {\n         *        if ( oTable.fnIsOpen(this) ) {\n         *          oTable.fnClose( this );\n         *        } else {\n         *          oTable.fnOpen( this, \"Temporary row opened\", \"info_row\" );\n         *        }\n         *      } );\n         *\n         *      oTable = $('#example').dataTable();\n         *    } );\n         */\n        this.fnOpen = function (nTr, mHtml, sClass) {\n          return this.api(true)\n            .row(nTr)\n            .child(mHtml, sClass)\n            .show()\n            .child()[0]\n        }\n\n        /**\n         * Change the pagination - provides the internal logic for pagination in a simple API\n         * function. With this function you can have a DataTables table go to the next,\n         * previous, first or last pages.\n         *  @param {string|int} mAction Paging action to take: \"first\", \"previous\", \"next\" or \"last\"\n         *    or page number to jump to (integer), note that page 0 is the first page.\n         *  @param {bool} [bRedraw=true] Redraw the table or not\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *      oTable.fnPageChange( 'next' );\n         *    } );\n         */\n        this.fnPageChange = function (mAction, bRedraw) {\n          var api = this.api(true).page(mAction)\n\n          if (bRedraw === undefined || bRedraw) {\n            api.draw(false)\n          }\n        }\n\n        /**\n         * Show a particular column\n         *  @param {int} iCol The column whose display should be changed\n         *  @param {bool} bShow Show (true) or hide (false) the column\n         *  @param {bool} [bRedraw=true] Redraw the table or not\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *\n         *      // Hide the second column after initialisation\n         *      oTable.fnSetColumnVis( 1, false );\n         *    } );\n         */\n        this.fnSetColumnVis = function (iCol, bShow, bRedraw) {\n          var api = this.api(true)\n            .column(iCol)\n            .visible(bShow)\n\n          if (bRedraw === undefined || bRedraw) {\n            api.columns.adjust().draw()\n          }\n        }\n\n        /**\n         * Get the settings for a particular table for external manipulation\n         *  @returns {object} DataTables settings object. See\n         *    {@link DataTable.models.oSettings}\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *      var oSettings = oTable.fnSettings();\n         *\n         *      // Show an example parameter from the settings\n         *      alert( oSettings._iDisplayStart );\n         *    } );\n         */\n        this.fnSettings = function () {\n          return _fnSettingsFromNode(this[_ext.iApiIndex])\n        }\n\n        /**\n         * Sort the table by a particular column\n         *  @param {int} iCol the data index to sort on. Note that this will not match the\n         *    'display index' if you have hidden data entries\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *\n         *      // Sort immediately with columns 0 and 1\n         *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );\n         *    } );\n         */\n        this.fnSort = function (aaSort) {\n          this.api(true)\n            .order(aaSort)\n            .draw()\n        }\n\n        /**\n         * Attach a sort listener to an element for a given column\n         *  @param {node} nNode the element to attach the sort listener to\n         *  @param {int} iColumn the column that a click on this node will sort on\n         *  @param {function} [fnCallback] callback function when sort is run\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *\n         *      // Sort on column 1, when 'sorter' is clicked on\n         *      oTable.fnSortListener( document.getElementById('sorter'), 1 );\n         *    } );\n         */\n        this.fnSortListener = function (nNode, iColumn, fnCallback) {\n          this.api(true).order.listener(nNode, iColumn, fnCallback)\n        }\n\n        /**\n         * Update a table cell or row - this method will accept either a single value to\n         * update the cell with, an array of values with one element for each column or\n         * an object in the same format as the original data source. The function is\n         * self-referencing in order to make the multi column updates easier.\n         *  @param {object|array|string} mData Data to update the cell/row with\n         *  @param {node|int} mRow TR element you want to update or the aoData index\n         *  @param {int} [iColumn] The column to update, give as null or undefined to\n         *    update a whole row.\n         *  @param {bool} [bRedraw=true] Redraw the table or not\n         *  @param {bool} [bAction=true] Perform pre-draw actions or not\n         *  @returns {int} 0 on success, 1 on error\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell\n         *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], $('tbody tr')[0] ); // Row\n         *    } );\n         */\n        this.fnUpdate = function (mData, mRow, iColumn, bRedraw, bAction) {\n          var api = this.api(true)\n\n          if (iColumn === undefined || iColumn === null) {\n            api.row(mRow).data(mData)\n          } else {\n            api.cell(mRow, iColumn).data(mData)\n          }\n\n          if (bAction === undefined || bAction) {\n            api.columns.adjust()\n          }\n\n          if (bRedraw === undefined || bRedraw) {\n            api.draw()\n          }\n          return 0\n        }\n\n        /**\n         * Provide a common method for plug-ins to check the version of DataTables being used, in order\n         * to ensure compatibility.\n         *  @param {string} sVersion Version string to check for, in the format \"X.Y.Z\". Note that the\n         *    formats \"X\" and \"X.Y\" are also acceptable.\n         *  @returns {boolean} true if this version of DataTables is greater or equal to the required\n         *    version, or false if this version of DataTales is not suitable\n         *  @method\n         *  @dtopt API\n         *  @deprecated Since v1.10\n         *\n         *  @example\n         *    $(document).ready(function() {\n         *      var oTable = $('#example').dataTable();\n         *      alert( oTable.fnVersionCheck( '1.9.0' ) );\n         *    } );\n         */\n        this.fnVersionCheck = _ext.fnVersionCheck\n\n        var _that = this\n        var emptyInit = options === undefined\n        var len = this.length\n\n        if (emptyInit) {\n          options = {}\n        }\n\n        this.oApi = this.internal = _ext.internal\n\n        // Extend with old style plug-in API methods\n        for (var fn in DataTable.ext.internal) {\n          if (fn) {\n            this[fn] = _fnExternApiFunc(fn)\n          }\n        }\n\n        this.each(function () {\n          // For each initialisation we want to give it a clean initialisation\n          // object that can be bashed around\n          var o = {}\n          var oInit =\n            len > 1 // optimisation for single table case\n              ? _fnExtend(o, options, true)\n              : options\n\n          /*global oInit,_that,emptyInit*/\n          var i = 0,\n            iLen,\n            j,\n            jLen,\n            k,\n            kLen\n          var sId = this.getAttribute('id')\n          var bInitHandedOff = false\n          var defaults = DataTable.defaults\n\n          /* Sanity check */\n          if (this.nodeName.toLowerCase() != 'table') {\n            _fnLog(null, 0, 'Non-table node initialisation (' + this.nodeName + ')', 2)\n            return\n          }\n\n          /* Backwards compatibility for the defaults */\n          _fnCompatOpts(defaults)\n          _fnCompatCols(defaults.column)\n\n          /* Convert the camel-case defaults to Hungarian */\n          _fnCamelToHungarian(defaults, defaults, true)\n          _fnCamelToHungarian(defaults.column, defaults.column, true)\n\n          /* Setting up the initialisation object */\n          _fnCamelToHungarian(defaults, oInit)\n\n          /* Check to see if we are re-initialising a table */\n          var allSettings = DataTable.settings\n          for (i = 0, iLen = allSettings.length; i < iLen; i++) {\n            /* Base check on table node */\n            if (allSettings[i].nTable == this) {\n              var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve\n              var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy\n\n              if (emptyInit || bRetrieve) {\n                return allSettings[i].oInstance\n              } else if (bDestroy) {\n                allSettings[i].oInstance.fnDestroy()\n                break\n              } else {\n                _fnLog(allSettings[i], 0, 'Cannot reinitialise DataTable', 3)\n                return\n              }\n            }\n\n            /* If the element we are initialising has the same ID as a table which was previously\n             * initialised, but the table nodes don't match (from before) then we destroy the old\n             * instance by simply deleting it. This is under the assumption that the table has been\n             * destroyed by other methods. Anyone using non-id selectors will need to do this manually\n             */\n            if (allSettings[i].sTableId == this.id) {\n              allSettings.splice(i, 1)\n              break\n            }\n          }\n\n          /* Ensure the table has an ID - required for accessibility */\n          if (sId === null || sId === '') {\n            sId = 'DataTables_Table_' + DataTable.ext._unique++\n            this.id = sId\n          }\n\n          /* Create the settings object for this table and set some of the default parameters */\n          var oSettings = $.extend(true, {}, DataTable.models.oSettings, {\n            nTable: this,\n            oApi: _that.internal,\n            oInit: oInit,\n            sDestroyWidth: $(this)[0].style.width,\n            sInstance: sId,\n            sTableId: sId\n          })\n          allSettings.push(oSettings)\n\n          // Need to add the instance after the instance after the settings object has been added\n          // to the settings array, so we can self reference the table instance if more than one\n          oSettings.oInstance = _that.length === 1 ? _that : $(this).dataTable()\n\n          // Backwards compatibility, before we apply all the defaults\n          _fnCompatOpts(oInit)\n\n          if (oInit.oLanguage) {\n            _fnLanguageCompat(oInit.oLanguage)\n          }\n\n          // If the length menu is given, but the init display length is not, use the length menu\n          if (oInit.aLengthMenu && !oInit.iDisplayLength) {\n            oInit.iDisplayLength = $.isArray(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0]\n          }\n\n          // Apply the defaults and init options to make a single init object will all\n          // options defined from defaults and instance options.\n          oInit = _fnExtend($.extend(true, {}, defaults), oInit)\n\n          // Map the initialisation options onto the settings object\n          _fnMap(oSettings.oFeatures, oInit, [\n            'bPaginate',\n            'bLengthChange',\n            'bFilter',\n            'bSort',\n            'bSortMulti',\n            'bInfo',\n            'bProcessing',\n            'bAutoWidth',\n            'bSortClasses',\n            'bServerSide',\n            'bDeferRender'\n          ])\n          _fnMap(oSettings, oInit, [\n            'asStripeClasses',\n            'ajax',\n            'fnServerData',\n            'fnFormatNumber',\n            'sServerMethod',\n            'aaSorting',\n            'aaSortingFixed',\n            'aLengthMenu',\n            'sPaginationType',\n            'sAjaxSource',\n            'sAjaxDataProp',\n            'iStateDuration',\n            'sDom',\n            'bSortCellsTop',\n            'iTabIndex',\n            'fnStateLoadCallback',\n            'fnStateSaveCallback',\n            'renderer',\n            ['iCookieDuration', 'iStateDuration'], // backwards compat\n            ['oSearch', 'oPreviousSearch'],\n            ['aoSearchCols', 'aoPreSearchCols'],\n            ['iDisplayLength', '_iDisplayLength'],\n            ['bJQueryUI', 'bJUI']\n          ])\n          _fnMap(oSettings.oScroll, oInit, [\n            ['sScrollX', 'sX'],\n            ['sScrollXInner', 'sXInner'],\n            ['sScrollY', 'sY'],\n            ['bScrollCollapse', 'bCollapse']\n          ])\n          _fnMap(oSettings.oLanguage, oInit, 'fnInfoCallback')\n\n          /* Callback functions which are array driven */\n          _fnCallbackReg(oSettings, 'aoDrawCallback', oInit.fnDrawCallback, 'user')\n          _fnCallbackReg(oSettings, 'aoServerParams', oInit.fnServerParams, 'user')\n          _fnCallbackReg(oSettings, 'aoStateSaveParams', oInit.fnStateSaveParams, 'user')\n          _fnCallbackReg(oSettings, 'aoStateLoadParams', oInit.fnStateLoadParams, 'user')\n          _fnCallbackReg(oSettings, 'aoStateLoaded', oInit.fnStateLoaded, 'user')\n          _fnCallbackReg(oSettings, 'aoRowCallback', oInit.fnRowCallback, 'user')\n          _fnCallbackReg(oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow, 'user')\n          _fnCallbackReg(oSettings, 'aoHeaderCallback', oInit.fnHeaderCallback, 'user')\n          _fnCallbackReg(oSettings, 'aoFooterCallback', oInit.fnFooterCallback, 'user')\n          _fnCallbackReg(oSettings, 'aoInitComplete', oInit.fnInitComplete, 'user')\n          _fnCallbackReg(oSettings, 'aoPreDrawCallback', oInit.fnPreDrawCallback, 'user')\n\n          var oClasses = oSettings.oClasses\n\n          // @todo Remove in 1.11\n          if (oInit.bJQueryUI) {\n            /* Use the JUI classes object for display. You could clone the oStdClasses object if\n             * you want to have multiple tables with multiple independent classes\n             */\n            $.extend(oClasses, DataTable.ext.oJUIClasses, oInit.oClasses)\n\n            if (oInit.sDom === defaults.sDom && defaults.sDom === 'lfrtip') {\n              /* Set the DOM to use a layout suitable for jQuery UI's theming */\n              oSettings.sDom = '<\"H\"lfr>t<\"F\"ip>'\n            }\n\n            if (!oSettings.renderer) {\n              oSettings.renderer = 'jqueryui'\n            } else if ($.isPlainObject(oSettings.renderer) && !oSettings.renderer.header) {\n              oSettings.renderer.header = 'jqueryui'\n            }\n          } else {\n            $.extend(oClasses, DataTable.ext.classes, oInit.oClasses)\n          }\n          $(this).addClass(oClasses.sTable)\n\n          /* Calculate the scroll bar width and cache it for use later on */\n          if (oSettings.oScroll.sX !== '' || oSettings.oScroll.sY !== '') {\n            oSettings.oScroll.iBarWidth = _fnScrollBarWidth()\n          }\n          if (oSettings.oScroll.sX === true) {\n            // Easy initialisation of x-scrolling\n            oSettings.oScroll.sX = '100%'\n          }\n\n          if (oSettings.iInitDisplayStart === undefined) {\n            /* Display start point, taking into account the save saving */\n            oSettings.iInitDisplayStart = oInit.iDisplayStart\n            oSettings._iDisplayStart = oInit.iDisplayStart\n          }\n\n          if (oInit.iDeferLoading !== null) {\n            oSettings.bDeferLoading = true\n            var tmp = $.isArray(oInit.iDeferLoading)\n            oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading\n            oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading\n          }\n\n          /* Language definitions */\n          if (oInit.oLanguage.sUrl !== '') {\n            /* Get the language definitions from a file - because this Ajax call makes the language\n             * get async to the remainder of this function we use bInitHandedOff to indicate that\n             * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor\n             */\n            oSettings.oLanguage.sUrl = oInit.oLanguage.sUrl\n            $.getJSON(oSettings.oLanguage.sUrl, null, function (json) {\n              _fnLanguageCompat(json)\n              _fnCamelToHungarian(defaults.oLanguage, json)\n              $.extend(true, oSettings.oLanguage, oInit.oLanguage, json)\n              _fnInitialise(oSettings)\n            })\n            bInitHandedOff = true\n          } else {\n            $.extend(true, oSettings.oLanguage, oInit.oLanguage)\n          }\n\n          /*\n           * Stripes\n           */\n          if (oInit.asStripeClasses === null) {\n            oSettings.asStripeClasses = [oClasses.sStripeOdd, oClasses.sStripeEven]\n          }\n\n          /* Remove row stripe classes if they are already on the table row */\n          var stripeClasses = oSettings.asStripeClasses\n          var rowOne = $('tbody tr:eq(0)', this)\n          if (\n            $.inArray(\n              true,\n              $.map(stripeClasses, function (el, i) {\n                return rowOne.hasClass(el)\n              })\n            ) !== -1\n          ) {\n            $('tbody tr', this).removeClass(stripeClasses.join(' '))\n            oSettings.asDestroyStripes = stripeClasses.slice()\n          }\n\n          /*\n           * Columns\n           * See if we should load columns automatically or use defined ones\n           */\n          var anThs = []\n          var aoColumnsInit\n          var nThead = this.getElementsByTagName('thead')\n          if (nThead.length !== 0) {\n            _fnDetectHeader(oSettings.aoHeader, nThead[0])\n            anThs = _fnGetUniqueThs(oSettings)\n          }\n\n          /* If not given a column array, generate one with nulls */\n          if (oInit.aoColumns === null) {\n            aoColumnsInit = []\n            for (i = 0, iLen = anThs.length; i < iLen; i++) {\n              aoColumnsInit.push(null)\n            }\n          } else {\n            aoColumnsInit = oInit.aoColumns\n          }\n\n          /* Add the columns */\n          for (i = 0, iLen = aoColumnsInit.length; i < iLen; i++) {\n            _fnAddColumn(oSettings, anThs ? anThs[i] : null)\n          }\n\n          /* Apply the column definitions */\n          _fnApplyColumnDefs(oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {\n            _fnColumnOptions(oSettings, iCol, oDef)\n          })\n\n          /* HTML5 attribute detection - build an mData object automatically if the\n           * attributes are found\n           */\n          if (rowOne.length) {\n            var a = function (cell, name) {\n              return cell.getAttribute('data-' + name) ? name : null\n            }\n\n            $.each(_fnGetRowElements(oSettings, rowOne[0]).cells, function (i, cell) {\n              var col = oSettings.aoColumns[i]\n\n              if (col.mData === i) {\n                var sort = a(cell, 'sort') || a(cell, 'order')\n                var filter = a(cell, 'filter') || a(cell, 'search')\n\n                if (sort !== null || filter !== null) {\n                  col.mData = {\n                    _: i + '.display',\n                    sort: sort !== null ? i + '.@data-' + sort : undefined,\n                    type: sort !== null ? i + '.@data-' + sort : undefined,\n                    filter: filter !== null ? i + '.@data-' + filter : undefined\n                  }\n\n                  _fnColumnOptions(oSettings, i)\n                }\n              }\n            })\n          }\n\n          var features = oSettings.oFeatures\n\n          /* Must be done after everything which can be overridden by the state saving! */\n          if (oInit.bStateSave) {\n            features.bStateSave = true\n            _fnLoadState(oSettings, oInit)\n            _fnCallbackReg(oSettings, 'aoDrawCallback', _fnSaveState, 'state_save')\n          }\n\n          /*\n           * Sorting\n           * @todo For modularisation (1.11) this needs to do into a sort start up handler\n           */\n\n          // If aaSorting is not defined, then we use the first indicator in asSorting\n          // in case that has been altered, so the default sort reflects that option\n          if (oInit.aaSorting === undefined) {\n            var sorting = oSettings.aaSorting\n            for (i = 0, iLen = sorting.length; i < iLen; i++) {\n              sorting[i][1] = oSettings.aoColumns[i].asSorting[0]\n            }\n          }\n\n          /* Do a first pass on the sorting classes (allows any size changes to be taken into\n           * account, and also will apply sorting disabled classes if disabled\n           */\n          _fnSortingClasses(oSettings)\n\n          if (features.bSort) {\n            _fnCallbackReg(oSettings, 'aoDrawCallback', function () {\n              if (oSettings.bSorted) {\n                var aSort = _fnSortFlatten(oSettings)\n                var sortedColumns = {}\n\n                $.each(aSort, function (i, val) {\n                  sortedColumns[val.src] = val.dir\n                })\n\n                _fnCallbackFire(oSettings, null, 'order', [oSettings, aSort, sortedColumns])\n                _fnSortAria(oSettings)\n              }\n            })\n          }\n\n          _fnCallbackReg(\n            oSettings,\n            'aoDrawCallback',\n            function () {\n              if (oSettings.bSorted || _fnDataSource(oSettings) === 'ssp' || features.bDeferRender) {\n                _fnSortingClasses(oSettings)\n              }\n            },\n            'sc'\n          )\n\n          /*\n           * Final init\n           * Cache the header, body and footer as required, creating them if needed\n           */\n\n          /* Browser support detection */\n          _fnBrowserDetect(oSettings)\n\n          // Work around for Webkit bug 83867 - store the caption-side before removing from doc\n          var captions = $(this)\n            .children('caption')\n            .each(function () {\n              this._captionSide = $(this).css('caption-side')\n            })\n\n          var thead = $(this).children('thead')\n          if (thead.length === 0) {\n            thead = $('<thead/>').appendTo(this)\n          }\n          oSettings.nTHead = thead[0]\n\n          var tbody = $(this).children('tbody')\n          if (tbody.length === 0) {\n            tbody = $('<tbody/>').appendTo(this)\n          }\n          oSettings.nTBody = tbody[0]\n\n          var tfoot = $(this).children('tfoot')\n          if (\n            tfoot.length === 0 &&\n            captions.length > 0 &&\n            (oSettings.oScroll.sX !== '' || oSettings.oScroll.sY !== '')\n          ) {\n            // If we are a scrolling table, and no footer has been given, then we need to create\n            // a tfoot element for the caption element to be appended to\n            tfoot = $('<tfoot/>').appendTo(this)\n          }\n\n          if (tfoot.length === 0 || tfoot.children().length === 0) {\n            $(this).addClass(oClasses.sNoFooter)\n          } else if (tfoot.length > 0) {\n            oSettings.nTFoot = tfoot[0]\n            _fnDetectHeader(oSettings.aoFooter, oSettings.nTFoot)\n          }\n\n          /* Check if there is data passing into the constructor */\n          if (oInit.aaData) {\n            for (i = 0; i < oInit.aaData.length; i++) {\n              _fnAddData(oSettings, oInit.aaData[i])\n            }\n          } else if (oSettings.bDeferLoading || _fnDataSource(oSettings) == 'dom') {\n            /* Grab the data from the page - only do this when deferred loading or no Ajax\n             * source since there is no point in reading the DOM data if we are then going\n             * to replace it with Ajax data\n             */\n            _fnAddTr(oSettings, $(oSettings.nTBody).children('tr'))\n          }\n\n          /* Copy the data index array */\n          oSettings.aiDisplay = oSettings.aiDisplayMaster.slice()\n\n          /* Initialisation complete - table can be drawn */\n          oSettings.bInitialised = true\n\n          /* Check if we need to initialise the table (it might not have been handed off to the\n           * language processor)\n           */\n          if (bInitHandedOff === false) {\n            _fnInitialise(oSettings)\n          }\n        })\n        _that = null\n        return this\n      }\n\n      /**\n       * Computed structure of the DataTables API, defined by the options passed to\n       * `DataTable.Api.register()` when building the API.\n       *\n       * The structure is built in order to speed creation and extension of the Api\n       * objects since the extensions are effectively pre-parsed.\n       *\n       * The array is an array of objects with the following structure, where this\n       * base array represents the Api prototype base:\n       *\n       *     [\n       *       {\n       *         name:      'data'                -- string   - Property name\n       *         val:       function () {},       -- function - Api method (or undefined if just an object\n       *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result\n       *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property\n       *       },\n       *       {\n       *         name:     'row'\n       *         val:       {},\n       *         methodExt: [ ... ],\n       *         propExt:   [\n       *           {\n       *             name:      'data'\n       *             val:       function () {},\n       *             methodExt: [ ... ],\n       *             propExt:   [ ... ]\n       *           },\n       *           ...\n       *         ]\n       *       }\n       *     ]\n       *\n       * @type {Array}\n       * @ignore\n       */\n      var __apiStruct = []\n\n      /**\n       * `Array.prototype` reference.\n       *\n       * @type object\n       * @ignore\n       */\n      var __arrayProto = Array.prototype\n\n      /**\n       * Abstraction for `context` parameter of the `Api` constructor to allow it to\n       * take several different forms for ease of use.\n       *\n       * Each of the input parameter types will be converted to a DataTables settings\n       * object where possible.\n       *\n       * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one\n       *   of:\n       *\n       *   * `string` - jQuery selector. Any DataTables' matching the given selector\n       *     with be found and used.\n       *   * `node` - `TABLE` node which has already been formed into a DataTable.\n       *   * `jQuery` - A jQuery object of `TABLE` nodes.\n       *   * `object` - DataTables settings object\n       *   * `DataTables.Api` - API instance\n       * @return {array|null} Matching DataTables settings objects. `null` or\n       *   `undefined` is returned if no matching DataTable is found.\n       * @ignore\n       */\n      var _toSettings = function (mixed) {\n        var idx, jq\n        var settings = DataTable.settings\n        var tables = $.map(settings, function (el, i) {\n          return el.nTable\n        })\n\n        if (!mixed) {\n          return []\n        } else if (mixed.nTable && mixed.oApi) {\n          // DataTables settings object\n          return [mixed]\n        } else if (mixed.nodeName && mixed.nodeName.toLowerCase() === 'table') {\n          // Table node\n          idx = $.inArray(mixed, tables)\n          return idx !== -1 ? [settings[idx]] : null\n        } else if (mixed && typeof mixed.settings === 'function') {\n          return mixed.settings().toArray()\n        } else if (typeof mixed === 'string') {\n          // jQuery selector\n          jq = $(mixed)\n        } else if (mixed instanceof $) {\n          // jQuery object (also DataTables instance)\n          jq = mixed\n        }\n\n        if (jq) {\n          return jq\n            .map(function (i) {\n              idx = $.inArray(this, tables)\n              return idx !== -1 ? settings[idx] : null\n            })\n            .toArray()\n        }\n      }\n\n      /**\n       * DataTables API class - used to control and interface with  one or more\n       * DataTables enhanced tables.\n       *\n       * The API class is heavily based on jQuery, presenting a chainable interface\n       * that you can use to interact with tables. Each instance of the API class has\n       * a \"context\" - i.e. the tables that it will operate on. This could be a single\n       * table, all tables on a page or a sub-set thereof.\n       *\n       * Additionally the API is designed to allow you to easily work with the data in\n       * the tables, retrieving and manipulating it as required. This is done by\n       * presenting the API class as an array like interface. The contents of the\n       * array depend upon the actions requested by each method (for example\n       * `rows().nodes()` will return an array of nodes, while `rows().data()` will\n       * return an array of objects or arrays depending upon your table's\n       * configuration). The API object has a number of array like methods (`push`,\n       * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,\n       * `unique` etc) to assist your working with the data held in a table.\n       *\n       * Most methods (those which return an Api instance) are chainable, which means\n       * the return from a method call also has all of the methods available that the\n       * top level object had. For example, these two calls are equivalent:\n       *\n       *     // Not chained\n       *     api.row.add( {...} );\n       *     api.draw();\n       *\n       *     // Chained\n       *     api.row.add( {...} ).draw();\n       *\n       * @class DataTable.Api\n       * @param {array|object|string|jQuery} context DataTable identifier. This is\n       *   used to define which DataTables enhanced tables this API will operate on.\n       *   Can be one of:\n       *\n       *   * `string` - jQuery selector. Any DataTables' matching the given selector\n       *     with be found and used.\n       *   * `node` - `TABLE` node which has already been formed into a DataTable.\n       *   * `jQuery` - A jQuery object of `TABLE` nodes.\n       *   * `object` - DataTables settings object\n       * @param {array} [data] Data to initialise the Api instance with.\n       *\n       * @example\n       *   // Direct initialisation during DataTables construction\n       *   var api = $('#example').DataTable();\n       *\n       * @example\n       *   // Initialisation using a DataTables jQuery object\n       *   var api = $('#example').dataTable().api();\n       *\n       * @example\n       *   // Initialisation as a constructor\n       *   var api = new $.fn.DataTable.Api( 'table.dataTable' );\n       */\n      _Api = function (context, data) {\n        if (!this instanceof _Api) {\n          throw 'DT API must be constructed as a new object'\n          // or should it do the 'new' for the caller?\n          // return new _Api.apply( this, arguments );\n        }\n\n        var settings = []\n        var ctxSettings = function (o) {\n          var a = _toSettings(o)\n          if (a) {\n            settings.push.apply(settings, a)\n          }\n        }\n\n        if ($.isArray(context)) {\n          for (var i = 0, ien = context.length; i < ien; i++) {\n            ctxSettings(context[i])\n          }\n        } else {\n          ctxSettings(context)\n        }\n\n        // Remove duplicates\n        this.context = _unique(settings)\n\n        // Initial data\n        if (data) {\n          this.push.apply(this, data.toArray ? data.toArray() : data)\n        }\n\n        // selector\n        this.selector = {\n          rows: null,\n          cols: null,\n          opts: null\n        }\n\n        _Api.extend(this, this, __apiStruct)\n      }\n\n      DataTable.Api = _Api\n\n      _Api.prototype = /** @lends DataTables.Api */ {\n        /**\n         * Return a new Api instance, comprised of the data held in the current\n         * instance, join with the other array(s) and/or value(s).\n         *\n         * An alias for `Array.prototype.concat`.\n         *\n         * @type method\n         * @param {*} value1 Arrays and/or values to concatenate.\n         * @param {*} [...] Additional arrays and/or values to concatenate.\n         * @returns {DataTables.Api} New API instance, comprising of the combined\n         *   array.\n         */\n        concat: __arrayProto.concat,\n\n        context: [], // array of table settings objects\n\n        each: function (fn) {\n          for (var i = 0, ien = this.length; i < ien; i++) {\n            fn.call(this, this[i], i, this)\n          }\n\n          return this\n        },\n\n        eq: function (idx) {\n          var ctx = this.context\n\n          return ctx.length > idx ? new _Api(ctx[idx], this[idx]) : null\n        },\n\n        filter: function (fn) {\n          var a = []\n\n          if (__arrayProto.filter) {\n            a = __arrayProto.filter.call(this, fn, this)\n          } else {\n            // Compatibility for browsers without EMCA-252-5 (JS 1.6)\n            for (var i = 0, ien = this.length; i < ien; i++) {\n              if (fn.call(this, this[i], i, this)) {\n                a.push(this[i])\n              }\n            }\n          }\n\n          return new _Api(this.context, a)\n        },\n\n        flatten: function () {\n          var a = []\n          return new _Api(this.context, a.concat.apply(a, this.toArray()))\n        },\n\n        join: __arrayProto.join,\n\n        indexOf:\n          __arrayProto.indexOf ||\n          function (obj, start) {\n            for (var i = start || 0, ien = this.length; i < ien; i++) {\n              if (this[i] === obj) {\n                return i\n              }\n            }\n            return -1\n          },\n\n        // Internal only at the moment - relax?\n        iterator: function (flatten, type, fn) {\n          var a = [],\n            ret,\n            i,\n            ien,\n            j,\n            jen,\n            context = this.context,\n            rows,\n            items,\n            item,\n            selector = this.selector\n\n          // Argument shifting\n          if (typeof flatten === 'string') {\n            fn = type\n            type = flatten\n            flatten = false\n          }\n\n          for (i = 0, ien = context.length; i < ien; i++) {\n            if (type === 'table') {\n              ret = fn(context[i], i)\n\n              if (ret !== undefined) {\n                a.push(ret)\n              }\n            } else if (type === 'columns' || type === 'rows') {\n              // this has same length as context - one entry for each table\n              ret = fn(context[i], this[i], i)\n\n              if (ret !== undefined) {\n                a.push(ret)\n              }\n            } else if (type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell') {\n              // columns and rows share the same structure.\n              // 'this' is an array of column indexes for each context\n              items = this[i]\n\n              if (type === 'column-rows') {\n                rows = _selector_row_indexes(context[i], selector.opts)\n              }\n\n              for (j = 0, jen = items.length; j < jen; j++) {\n                item = items[j]\n\n                if (type === 'cell') {\n                  ret = fn(context[i], item.row, item.column, i, j)\n                } else {\n                  ret = fn(context[i], item, i, j, rows)\n                }\n\n                if (ret !== undefined) {\n                  a.push(ret)\n                }\n              }\n            }\n          }\n\n          if (a.length) {\n            var api = new _Api(context, flatten ? a.concat.apply([], a) : a)\n            var apiSelector = api.selector\n            apiSelector.rows = selector.rows\n            apiSelector.cols = selector.cols\n            apiSelector.opts = selector.opts\n            return api\n          }\n          return this\n        },\n\n        lastIndexOf:\n          __arrayProto.lastIndexOf ||\n          function (obj, start) {\n            // Bit cheeky...\n            return this.indexOf.apply(this.toArray.reverse(), arguments)\n          },\n\n        length: 0,\n\n        map: function (fn) {\n          var a = []\n\n          if (__arrayProto.map) {\n            a = __arrayProto.map.call(this, fn, this)\n          } else {\n            // Compatibility for browsers without EMCA-252-5 (JS 1.6)\n            for (var i = 0, ien = this.length; i < ien; i++) {\n              a.push(fn.call(this, this[i], i))\n            }\n          }\n\n          return new _Api(this.context, a)\n        },\n\n        pluck: function (prop) {\n          return this.map(function (el) {\n            return el[prop]\n          })\n        },\n\n        pop: __arrayProto.pop,\n\n        push: __arrayProto.push,\n\n        // Does not return an API instance\n        reduce:\n          __arrayProto.reduce ||\n          function (fn, init) {\n            return _fnReduce(this, fn, init, 0, this.length, 1)\n          },\n\n        reduceRight:\n          __arrayProto.reduceRight ||\n          function (fn, init) {\n            return _fnReduce(this, fn, init, this.length - 1, -1, -1)\n          },\n\n        reverse: __arrayProto.reverse,\n\n        // Object with rows, columns and opts\n        selector: null,\n\n        shift: __arrayProto.shift,\n\n        sort: __arrayProto.sort, // ? name - order?\n\n        splice: __arrayProto.splice,\n\n        toArray: function () {\n          return __arrayProto.slice.call(this)\n        },\n\n        to$: function () {\n          return $(this)\n        },\n\n        toJQuery: function () {\n          return $(this)\n        },\n\n        unique: function () {\n          return new _Api(this.context, _unique(this))\n        },\n\n        unshift: __arrayProto.unshift\n      }\n\n      _Api.extend = function (scope, obj, ext) {\n        // Only extend API instances and static properties of the API\n        if (!obj || (!(obj instanceof _Api) && !obj.__dt_wrapper)) {\n          return\n        }\n\n        var i,\n          ien,\n          j,\n          jen,\n          struct,\n          inner,\n          methodScoping = function (scope, fn, struc) {\n            return function () {\n              var ret = fn.apply(scope, arguments)\n\n              // Method extension\n              _Api.extend(ret, ret, struc.methodExt)\n              return ret\n            }\n          }\n\n        for (i = 0, ien = ext.length; i < ien; i++) {\n          struct = ext[i]\n\n          // Value\n          obj[struct.name] =\n            typeof struct.val === 'function'\n              ? methodScoping(scope, struct.val, struct)\n              : $.isPlainObject(struct.val)\n              ? {}\n              : struct.val\n\n          obj[struct.name].__dt_wrapper = true\n\n          // Property extension\n          _Api.extend(scope, obj[struct.name], struct.propExt)\n        }\n      }\n\n      // @todo - Is there need for an augment function?\n      // _Api.augment = function ( inst, name )\n      // {\n      // \t// Find src object in the structure from the name\n      // \tvar parts = name.split('.');\n\n      // \t_Api.extend( inst, obj );\n      // };\n\n      //     [\n      //       {\n      //         name:      'data'                -- string   - Property name\n      //         val:       function () {},       -- function - Api method (or undefined if just an object\n      //         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result\n      //         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property\n      //       },\n      //       {\n      //         name:     'row'\n      //         val:       {},\n      //         methodExt: [ ... ],\n      //         propExt:   [\n      //           {\n      //             name:      'data'\n      //             val:       function () {},\n      //             methodExt: [ ... ],\n      //             propExt:   [ ... ]\n      //           },\n      //           ...\n      //         ]\n      //       }\n      //     ]\n\n      _Api.register = _api_register = function (name, val) {\n        if ($.isArray(name)) {\n          for (var j = 0, jen = name.length; j < jen; j++) {\n            _Api.register(name[j], val)\n          }\n          return\n        }\n\n        var i,\n          ien,\n          heir = name.split('.'),\n          struct = __apiStruct,\n          key,\n          method\n\n        var find = function (src, name) {\n          for (var i = 0, ien = src.length; i < ien; i++) {\n            if (src[i].name === name) {\n              return src[i]\n            }\n          }\n          return null\n        }\n\n        for (i = 0, ien = heir.length; i < ien; i++) {\n          method = heir[i].indexOf('()') !== -1\n          key = method ? heir[i].replace('()', '') : heir[i]\n\n          var src = find(struct, key)\n          if (!src) {\n            src = {\n              name: key,\n              val: {},\n              methodExt: [],\n              propExt: []\n            }\n            struct.push(src)\n          }\n\n          if (i === ien - 1) {\n            src.val = val\n          } else {\n            struct = method ? src.methodExt : src.propExt\n          }\n        }\n      }\n\n      _Api.registerPlural = _api_registerPlural = function (pluralName, singularName, val) {\n        _Api.register(pluralName, val)\n\n        _Api.register(singularName, function () {\n          var ret = val.apply(this, arguments)\n\n          if (ret === this) {\n            // Returned item is the API instance that was passed in, return it\n            return this\n          } else if (ret instanceof _Api) {\n            // New API instance returned, want the value from the first item\n            // in the returned array for the singular result.\n            return ret.length\n              ? $.isArray(ret[0])\n                ? new _Api(ret.context, ret[0]) // Array results are 'enhanced'\n                : ret[0]\n              : undefined\n          }\n\n          // Non-API return - just fire it back\n          return ret\n        })\n      }\n\n      /**\n       * Selector for HTML tables. Apply the given selector to the give array of\n       * DataTables settings objects.\n       *\n       * @param {string|integer} [selector] jQuery selector string or integer\n       * @param  {array} Array of DataTables settings objects to be filtered\n       * @return {array}\n       * @ignore\n       */\n      var __table_selector = function (selector, a) {\n        // Integer is used to pick out a table by index\n        if (typeof selector === 'number') {\n          return [a[selector]]\n        }\n\n        // Perform a jQuery selector on the table nodes\n        var nodes = $.map(a, function (el, i) {\n          return el.nTable\n        })\n\n        return $(nodes)\n          .filter(selector)\n          .map(function (i) {\n            // Need to translate back from the table node to the settings\n            var idx = $.inArray(this, nodes)\n            return a[idx]\n          })\n          .toArray()\n      }\n\n      /**\n       * Context selector for the API's context (i.e. the tables the API instance\n       * refers to.\n       *\n       * @name    DataTable.Api#tables\n       * @param {string|integer} [selector] Selector to pick which tables the iterator\n       *   should operate on. If not given, all tables in the current context are\n       *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to\n       *   select multiple tables or as an integer to select a single table.\n       * @returns {DataTable.Api} Returns a new API instance if a selector is given.\n       */\n      _api_register('tables()', function (selector) {\n        // A new instance is created if there was a selector specified\n        return selector ? new _Api(__table_selector(selector, this.context)) : this\n      })\n\n      _api_register('table()', function (selector) {\n        var tables = this.tables(selector)\n        var ctx = tables.context\n\n        // Truncate to the first matched table\n        return ctx.length ? new _Api(ctx[0]) : tables\n      })\n\n      _api_registerPlural('tables().nodes()', 'table().node()', function () {\n        return this.iterator('table', function (ctx) {\n          return ctx.nTable\n        })\n      })\n\n      _api_registerPlural('tables().body()', 'table().body()', function () {\n        return this.iterator('table', function (ctx) {\n          return ctx.nTBody\n        })\n      })\n\n      _api_registerPlural('tables().header()', 'table().header()', function () {\n        return this.iterator('table', function (ctx) {\n          return ctx.nTHead\n        })\n      })\n\n      _api_registerPlural('tables().footer()', 'table().footer()', function () {\n        return this.iterator('table', function (ctx) {\n          return ctx.nTFoot\n        })\n      })\n\n      _api_registerPlural('tables().containers()', 'table().container()', function () {\n        return this.iterator('table', function (ctx) {\n          return ctx.nTableWrapper\n        })\n      })\n\n      /**\n       * Redraw the tables in the current context.\n       *\n       * @param {boolean} [reset=true] Reset (default) or hold the current paging\n       *   position. A full re-sort and re-filter is performed when this method is\n       *   called, which is why the pagination reset is the default action.\n       * @returns {DataTables.Api} this\n       */\n      _api_register('draw()', function (resetPaging) {\n        return this.iterator('table', function (settings) {\n          _fnReDraw(settings, resetPaging === false)\n        })\n      })\n      /**\n       * Set the current page.\n       *\n       * Note that if you attempt to show a page which does not exist, DataTables will\n       * not throw an error, but rather reset the paging.\n       *\n       * @param {integer|string} action The paging action to take. This can be one of:\n       *  * `integer` - The page index to jump to\n       *  * `string` - An action to take:\n       *    * `first` - Jump to first page.\n       *    * `next` - Jump to the next page\n       *    * `previous` - Jump to previous page\n       *    * `last` - Jump to the last page.\n       * @returns {DataTables.Api} this\n       */\n\n      /**\n       * Get the current page index.\n       *\n       * @return {integer} Current page index (zero based)\n       */ _api_register('page()', function (action) {\n        if (action === undefined) {\n          return this.page.info().page // not an expensive call\n        }\n\n        // else, have an action to take on all tables\n        return this.iterator('table', function (settings) {\n          _fnPageChange(settings, action)\n        })\n      })\n\n      /**\n       * Paging information for the first table in the current context.\n       *\n       * If you require paging information for another table, use the `table()` method\n       * with a suitable selector.\n       *\n       * @return {object} Object with the following properties set:\n       *  * `page` - Current page index (zero based - i.e. the first page is `0`)\n       *  * `pages` - Total number of pages\n       *  * `start` - Display index for the first record shown on the current page\n       *  * `end` - Display index for the last record shown on the current page\n       *  * `length` - Display length (number of records). Note that generally `start\n       *    + length = end`, but this is not always true, for example if there are\n       *    only 2 records to show on the final page, with a length of 10.\n       *  * `recordsTotal` - Full data set length\n       *  * `recordsDisplay` - Data set length once the current filtering criterion\n       *    are applied.\n       */\n      _api_register('page.info()', function (action) {\n        if (this.context.length === 0) {\n          return undefined\n        }\n\n        var settings = this.context[0],\n          start = settings._iDisplayStart,\n          len = settings._iDisplayLength,\n          visRecords = settings.fnRecordsDisplay(),\n          all = len === -1\n\n        return {\n          page: all ? 0 : Math.floor(start / len),\n          pages: all ? 1 : Math.ceil(visRecords / len),\n          start: start,\n          end: settings.fnDisplayEnd(),\n          length: len,\n          recordsTotal: settings.fnRecordsTotal(),\n          recordsDisplay: visRecords\n        }\n      })\n      /**\n       * Set the current page length.\n       *\n       * @param {integer} Page length to set. Use `-1` to show all records.\n       * @returns {DataTables.Api} this\n       */\n\n      /**\n       * Get the current page length.\n       *\n       * @return {integer} Current page length. Note `-1` indicates that all records\n       *   are to be shown.\n       */ _api_register('page.len()', function (len) {\n        // Note that we can't call this function 'length()' because `length`\n        // is a Javascript property of functions which defines how many arguments\n        // the function expects.\n        if (len === undefined) {\n          return this.context.length !== 0 ? this.context[0]._iDisplayLength : undefined\n        }\n\n        // else, set the page length\n        return this.iterator('table', function (settings) {\n          _fnLengthChange(settings, len)\n        })\n      })\n\n      var __reload = function (settings, holdPosition, callback) {\n        if (_fnDataSource(settings) == 'ssp') {\n          _fnReDraw(settings, holdPosition)\n        } else {\n          // Trigger xhr\n          _fnProcessingDisplay(settings, true)\n\n          _fnBuildAjax(settings, [], function (json) {\n            _fnClearTable(settings)\n\n            var data = _fnAjaxDataSrc(settings, json)\n            for (var i = 0, ien = data.length; i < ien; i++) {\n              _fnAddData(settings, data[i])\n            }\n\n            _fnReDraw(settings, holdPosition)\n            _fnProcessingDisplay(settings, false)\n          })\n        }\n\n        // Use the draw event to trigger a callback, regardless of if it is an async\n        // or sync draw\n        if (callback) {\n          var api = new _Api(settings)\n\n          api.one('draw', function () {\n            callback(api.ajax.json())\n          })\n        }\n      }\n\n      /**\n       * Get the JSON response from the last Ajax request that DataTables made to the\n       * server. Note that this returns the JSON from the first table in the current\n       * context.\n       *\n       * @return {object} JSON received from the server.\n       */\n      _api_register('ajax.json()', function () {\n        var ctx = this.context\n\n        if (ctx.length > 0) {\n          return ctx[0].json\n        }\n\n        // else return undefined;\n      })\n\n      /**\n       * Get the data submitted in the last Ajax request\n       */\n      _api_register('ajax.params()', function () {\n        var ctx = this.context\n\n        if (ctx.length > 0) {\n          return ctx[0].oAjaxData\n        }\n\n        // else return undefined;\n      })\n\n      /**\n       * Reload tables from the Ajax data source. Note that this function will\n       * automatically re-draw the table when the remote data has been loaded.\n       *\n       * @param {boolean} [reset=true] Reset (default) or hold the current paging\n       *   position. A full re-sort and re-filter is performed when this method is\n       *   called, which is why the pagination reset is the default action.\n       * @returns {DataTables.Api} this\n       */\n      _api_register('ajax.reload()', function (callback, resetPaging) {\n        return this.iterator('table', function (settings) {\n          __reload(settings, resetPaging === false, callback)\n        })\n      })\n      /**\n       * Set the Ajax URL. Note that this will set the URL for all tables in the\n       * current context.\n       *\n       * @param {string} url URL to set.\n       * @returns {DataTables.Api} this\n       */\n\n      /**\n       * Get the current Ajax URL. Note that this returns the URL from the first\n       * table in the current context.\n       *\n       * @return {string} Current Ajax source URL\n       */ _api_register('ajax.url()', function (url) {\n        var ctx = this.context\n\n        if (url === undefined) {\n          // get\n          if (ctx.length === 0) {\n            return undefined\n          }\n          ctx = ctx[0]\n\n          return ctx.ajax ? ($.isPlainObject(ctx.ajax) ? ctx.ajax.url : ctx.ajax) : ctx.sAjaxSource\n        }\n\n        // set\n        return this.iterator('table', function (settings) {\n          if ($.isPlainObject(settings.ajax)) {\n            settings.ajax.url = url\n          } else {\n            settings.ajax = url\n          }\n          // No need to consider sAjaxSource here since DataTables gives priority\n          // to `ajax` over `sAjaxSource`. So setting `ajax` here, renders any\n          // value of `sAjaxSource` redundant.\n        })\n      })\n\n      /**\n       * Load data from the newly set Ajax URL. Note that this method is only\n       * available when `ajax.url()` is used to set a URL. Additionally, this method\n       * has the same effect as calling `ajax.reload()` but is provided for\n       * convenience when setting a new URL. Like `ajax.reload()` it will\n       * automatically redraw the table once the remote data has been loaded.\n       *\n       * @returns {DataTables.Api} this\n       */\n      _api_register('ajax.url().load()', function (callback, resetPaging) {\n        // Same as a reload, but makes sense to present it for easy access after a\n        // url change\n        return this.iterator('table', function (ctx) {\n          __reload(ctx, resetPaging === false, callback)\n        })\n      })\n\n      var _selector_run = function (selector, select) {\n        var out = [],\n          res,\n          a,\n          i,\n          ien,\n          j,\n          jen\n\n        // Can't just check for isArray here, as an API or jQuery instance might be\n        // given with their array like look\n        if (!selector || typeof selector === 'string' || selector.length === undefined) {\n          selector = [selector]\n        }\n\n        for (i = 0, ien = selector.length; i < ien; i++) {\n          a = selector[i] && selector[i].split ? selector[i].split(',') : [selector[i]]\n\n          for (j = 0, jen = a.length; j < jen; j++) {\n            res = select(typeof a[j] === 'string' ? $.trim(a[j]) : a[j])\n\n            if (res && res.length) {\n              out.push.apply(out, res)\n            }\n          }\n        }\n\n        return out\n      }\n\n      var _selector_opts = function (opts) {\n        if (!opts) {\n          opts = {}\n        }\n\n        // Backwards compatibility for 1.9- which used the terminology filter rather\n        // than search\n        if (opts.filter && !opts.search) {\n          opts.search = opts.filter\n        }\n\n        return {\n          search: opts.search || 'none',\n          order: opts.order || 'current',\n          page: opts.page || 'all'\n        }\n      }\n\n      var _selector_first = function (inst) {\n        // Reduce the API instance to the first item found\n        for (var i = 0, ien = inst.length; i < ien; i++) {\n          if (inst[i].length > 0) {\n            // Assign the first element to the first item in the instance\n            // and truncate the instance and context\n            inst[0] = inst[i]\n            inst.length = 1\n            inst.context = [inst.context[i]]\n\n            return inst\n          }\n        }\n\n        // Not found - return an empty instance\n        inst.length = 0\n        return inst\n      }\n\n      var _selector_row_indexes = function (settings, opts) {\n        var i,\n          ien,\n          tmp,\n          a = [],\n          displayFiltered = settings.aiDisplay,\n          displayMaster = settings.aiDisplayMaster\n\n        var search = opts.search, // none, applied, removed\n          order = opts.order, // applied, current, index (original - compatibility with 1.9)\n          page = opts.page // all, current\n\n        if (_fnDataSource(settings) == 'ssp') {\n          // In server-side processing mode, most options are irrelevant since\n          // rows not shown don't exist and the index order is the applied order\n          // Removed is a special case - for consistency just return an empty\n          // array\n          return search === 'removed' ? [] : _range(0, displayMaster.length)\n        } else if (page == 'current') {\n          // Current page implies that order=current and fitler=applied, since it is\n          // fairly senseless otherwise, regardless of what order and search actually\n          // are\n          for (i = settings._iDisplayStart, ien = settings.fnDisplayEnd(); i < ien; i++) {\n            a.push(displayFiltered[i])\n          }\n        } else if (order == 'current' || order == 'applied') {\n          a =\n            search == 'none'\n              ? displayMaster.slice() // no search\n              : search == 'applied'\n              ? displayFiltered.slice() // applied search\n              : $.map(displayMaster, function (el, i) {\n                  // removed search\n                  return $.inArray(el, displayFiltered) === -1 ? el : null\n                })\n        } else if (order == 'index' || order == 'original') {\n          for (i = 0, ien = settings.aoData.length; i < ien; i++) {\n            if (search == 'none') {\n              a.push(i)\n            } else {\n              // applied | removed\n              tmp = $.inArray(i, displayFiltered)\n\n              if ((tmp === -1 && search == 'removed') || (tmp >= 0 && search == 'applied')) {\n                a.push(i)\n              }\n            }\n          }\n        }\n\n        return a\n      }\n\n      /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n       * Rows\n       *\n       * {}          - no selector - use all available rows\n       * {integer}   - row aoData index\n       * {node}      - TR node\n       * {string}    - jQuery selector to apply to the TR elements\n       * {array}     - jQuery array of nodes, or simply an array of TR nodes\n       *\n       */\n\n      var __row_selector = function (settings, selector, opts) {\n        return _selector_run(selector, function (sel) {\n          var selInt = _intVal(sel)\n\n          // Short cut - selector is a number and no options provided (default is\n          // all records, so no need to check if the index is in there, since it\n          // must be - dev error if the index doesn't exist).\n          if (selInt !== null && !opts) {\n            return [selInt]\n          }\n\n          var rows = _selector_row_indexes(settings, opts)\n\n          if (selInt !== null && $.inArray(selInt, rows) !== -1) {\n            // Selector - integer\n            return [selInt]\n          } else if (!sel) {\n            // Selector - none\n            return rows\n          }\n\n          // Get nodes in the order from the `rows` array (can't use `pluck`) @todo - use pluck_order\n          var nodes = []\n          for (var i = 0, ien = rows.length; i < ien; i++) {\n            nodes.push(settings.aoData[rows[i]].nTr)\n          }\n\n          if (sel.nodeName) {\n            // Selector - node\n            if ($.inArray(sel, nodes) !== -1) {\n              return [sel._DT_RowIndex] // sel is a TR node that is in the table\n              // and DataTables adds a prop for fast lookup\n            }\n          }\n\n          // Selector - jQuery selector string, array of nodes or jQuery object/\n          // As jQuery's .filter() allows jQuery objects to be passed in filter,\n          // it also allows arrays, so this will cope with all three options\n          return $(nodes)\n            .filter(sel)\n            .map(function () {\n              return this._DT_RowIndex\n            })\n            .toArray()\n        })\n      }\n\n      /**\n       *\n       */\n      _api_register('rows()', function (selector, opts) {\n        // argument shifting\n        if (selector === undefined) {\n          selector = ''\n        } else if ($.isPlainObject(selector)) {\n          opts = selector\n          selector = ''\n        }\n\n        opts = _selector_opts(opts)\n\n        var inst = this.iterator('table', function (settings) {\n          return __row_selector(settings, selector, opts)\n        })\n\n        // Want argument shifting here and in __row_selector?\n        inst.selector.rows = selector\n        inst.selector.opts = opts\n\n        return inst\n      })\n\n      _api_register('rows().nodes()', function () {\n        return this.iterator('row', function (settings, row) {\n          return settings.aoData[row].nTr || undefined\n        })\n      })\n\n      _api_register('rows().data()', function () {\n        return this.iterator(true, 'rows', function (settings, rows) {\n          return _pluck_order(settings.aoData, rows, '_aData')\n        })\n      })\n\n      _api_registerPlural('rows().cache()', 'row().cache()', function (type) {\n        return this.iterator('row', function (settings, row) {\n          var r = settings.aoData[row]\n          return type === 'search' ? r._aFilterData : r._aSortData\n        })\n      })\n\n      _api_registerPlural('rows().invalidate()', 'row().invalidate()', function (src) {\n        return this.iterator('row', function (settings, row) {\n          _fnInvalidateRow(settings, row, src)\n        })\n      })\n\n      _api_registerPlural('rows().indexes()', 'row().index()', function () {\n        return this.iterator('row', function (settings, row) {\n          return row\n        })\n      })\n\n      _api_registerPlural('rows().remove()', 'row().remove()', function () {\n        var that = this\n\n        return this.iterator('row', function (settings, row, thatIdx) {\n          var data = settings.aoData\n\n          data.splice(row, 1)\n\n          // Update the _DT_RowIndex parameter on all rows in the table\n          for (var i = 0, ien = data.length; i < ien; i++) {\n            if (data[i].nTr !== null) {\n              data[i].nTr._DT_RowIndex = i\n            }\n          }\n\n          // Remove the target row from the search array\n          var displayIndex = $.inArray(row, settings.aiDisplay)\n\n          // Delete from the display arrays\n          _fnDeleteIndex(settings.aiDisplayMaster, row)\n          _fnDeleteIndex(settings.aiDisplay, row)\n          _fnDeleteIndex(that[thatIdx], row, false) // maintain local indexes\n\n          // Check for an 'overflow' they case for displaying the table\n          _fnLengthOverflow(settings)\n        })\n      })\n\n      _api_register('rows.add()', function (rows) {\n        var newRows = this.iterator('table', function (settings) {\n          var row, i, ien\n          var out = []\n\n          for (i = 0, ien = rows.length; i < ien; i++) {\n            row = rows[i]\n\n            if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {\n              out.push(_fnAddTr(settings, row)[0])\n            } else {\n              out.push(_fnAddData(settings, row))\n            }\n          }\n\n          return out\n        })\n\n        // Return an Api.rows() extended instance, so rows().nodes() etc can be used\n        var modRows = this.rows(-1)\n        modRows.pop()\n        modRows.push.apply(modRows, newRows.toArray())\n\n        return modRows\n      })\n\n      /**\n       *\n       */\n      _api_register('row()', function (selector, opts) {\n        return _selector_first(this.rows(selector, opts))\n      })\n\n      _api_register('row().data()', function (data) {\n        var ctx = this.context\n\n        if (data === undefined) {\n          // Get\n          return ctx.length && this.length ? ctx[0].aoData[this[0]]._aData : undefined\n        }\n\n        // Set\n        ctx[0].aoData[this[0]]._aData = data\n\n        // Automatically invalidate\n        _fnInvalidateRow(ctx[0], this[0], 'data')\n\n        return this\n      })\n\n      _api_register('row().node()', function () {\n        var ctx = this.context\n\n        return ctx.length && this.length ? ctx[0].aoData[this[0]].nTr || null : null\n      })\n\n      _api_register('row.add()', function (row) {\n        // Allow a jQuery object to be passed in - only a single row is added from\n        // it though - the first element in the set\n        if (row instanceof $ && row.length) {\n          row = row[0]\n        }\n\n        var rows = this.iterator('table', function (settings) {\n          if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {\n            return _fnAddTr(settings, row)[0]\n          }\n          return _fnAddData(settings, row)\n        })\n\n        // Return an Api.rows() extended instance, with the newly added row selected\n        return this.row(rows[0])\n      })\n\n      var __details_add = function (ctx, row, data, klass) {\n        // Convert to array of TR elements\n        var rows = []\n        var addRow = function (r, k) {\n          // If we get a TR element, then just add it directly - up to the dev\n          // to add the correct number of columns etc\n          if (r.nodeName && r.nodeName.toLowerCase() === 'tr') {\n            rows.push(r)\n          } else {\n            // Otherwise create a row with a wrapper\n            var created = $('<tr><td/></tr>').addClass(k)\n            $('td', created)\n              .addClass(k)\n              .html(r)[0].colSpan = _fnVisbleColumns(ctx)\n\n            rows.push(created[0])\n          }\n        }\n\n        if ($.isArray(data) || data instanceof $) {\n          for (var i = 0, ien = data.length; i < ien; i++) {\n            addRow(data[i], klass)\n          }\n        } else {\n          addRow(data, klass)\n        }\n\n        if (row._details) {\n          row._details.remove()\n        }\n\n        row._details = $(rows)\n\n        // If the children were already shown, that state should be retained\n        if (row._detailsShow) {\n          row._details.insertAfter(row.nTr)\n        }\n      }\n\n      var __details_remove = function (api) {\n        var ctx = api.context\n\n        if (ctx.length && api.length) {\n          var row = ctx[0].aoData[api[0]]\n\n          if (row._details) {\n            row._details.remove()\n\n            row._detailsShow = undefined\n            row._details = undefined\n          }\n        }\n      }\n\n      var __details_display = function (api, show) {\n        var ctx = api.context\n\n        if (ctx.length && api.length) {\n          var row = ctx[0].aoData[api[0]]\n\n          if (row._details) {\n            row._detailsShow = show\n\n            if (show) {\n              row._details.insertAfter(row.nTr)\n            } else {\n              row._details.detach()\n            }\n\n            __details_events(ctx[0])\n          }\n        }\n      }\n\n      var __details_events = function (settings) {\n        var api = new _Api(settings)\n        var namespace = '.dt.DT_details'\n        var drawEvent = 'draw' + namespace\n        var colvisEvent = 'column-visibility' + namespace\n        var destroyEvent = 'destroy' + namespace\n        var data = settings.aoData\n\n        api.off(drawEvent + ' ' + colvisEvent + ' ' + destroyEvent)\n\n        if (_pluck(data, '_details').length > 0) {\n          // On each draw, insert the required elements into the document\n          api.on(drawEvent, function (e, ctx) {\n            if (settings !== ctx) {\n              return\n            }\n\n            api\n              .rows({ page: 'current' })\n              .eq(0)\n              .each(function (idx) {\n                // Internal data grab\n                var row = data[idx]\n\n                if (row._detailsShow) {\n                  row._details.insertAfter(row.nTr)\n                }\n              })\n          })\n\n          // Column visibility change - update the colspan\n          api.on(colvisEvent, function (e, ctx, idx, vis) {\n            if (settings !== ctx) {\n              return\n            }\n\n            // Update the colspan for the details rows (note, only if it already has\n            // a colspan)\n            var row,\n              visible = _fnVisbleColumns(ctx)\n\n            for (var i = 0, ien = data.length; i < ien; i++) {\n              row = data[i]\n\n              if (row._details) {\n                row._details.children('td[colspan]').attr('colspan', visible)\n              }\n            }\n          })\n\n          // Table destroyed - nuke any child rows\n          api.on(destroyEvent, function (e, ctx) {\n            if (settings !== ctx) {\n              return\n            }\n\n            for (var i = 0, ien = data.length; i < ien; i++) {\n              if (data[i]._details) {\n                __details_remove(data[i])\n              }\n            }\n          })\n        }\n      }\n\n      // Strings for the method names to help minification\n      var _emp = ''\n      var _child_obj = _emp + 'row().child'\n      var _child_mth = _child_obj + '()'\n\n      // data can be:\n      //  tr\n      //  string\n      //  jQuery or array of any of the above\n      _api_register(_child_mth, function (data, klass) {\n        var ctx = this.context\n\n        if (data === undefined) {\n          // get\n          return ctx.length && this.length ? ctx[0].aoData[this[0]]._details : undefined\n        } else if (data === true) {\n          // show\n          this.child.show()\n        } else if (data === false) {\n          // remove\n          __details_remove(this)\n        } else if (ctx.length && this.length) {\n          // set\n          __details_add(ctx[0], ctx[0].aoData[this[0]], data, klass)\n        }\n\n        return this\n      })\n\n      _api_register(\n        [\n          _child_obj + '.show()',\n          _child_mth + '.show()' // only when `child()` was called with parameters (without\n        ],\n        function (show) {\n          // it returns an object and this method is not executed)\n          __details_display(this, true)\n          return this\n        }\n      )\n\n      _api_register(\n        [\n          _child_obj + '.hide()',\n          _child_mth + '.hide()' // only when `child()` was called with parameters (without\n        ],\n        function () {\n          // it returns an object and this method is not executed)\n          __details_display(this, false)\n          return this\n        }\n      )\n\n      _api_register(\n        [\n          _child_obj + '.remove()',\n          _child_mth + '.remove()' // only when `child()` was called with parameters (without\n        ],\n        function () {\n          // it returns an object and this method is not executed)\n          __details_remove(this)\n          return this\n        }\n      )\n\n      _api_register(_child_obj + '.isShown()', function () {\n        var ctx = this.context\n\n        if (ctx.length && this.length) {\n          // _detailsShown as false or undefined will fall through to return false\n          return ctx[0].aoData[this[0]]._detailsShow || false\n        }\n        return false\n      })\n\n      /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n       * Columns\n       *\n       * {integer}           - column index (>=0 count from left, <0 count from right)\n       * \"{integer}:visIdx\"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)\n       * \"{integer}:visible\" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)\n       * \"{string}:name\"     - column name\n       * \"{string}\"          - jQuery selector on column header nodes\n       *\n       */\n\n      // can be an array of these items, comma separated list, or an array of comma\n      // separated lists\n\n      var __re_column_selector = /^(.+):(name|visIdx|visible)$/\n\n      var __column_selector = function (settings, selector, opts) {\n        var columns = settings.aoColumns,\n          names = _pluck(columns, 'sName'),\n          nodes = _pluck(columns, 'nTh')\n\n        return _selector_run(selector, function (s) {\n          var selInt = _intVal(s)\n\n          if (s === '') {\n            // All columns\n            return _range(columns.length)\n          } else if (selInt !== null) {\n            // Integer selector\n            return [\n              selInt >= 0\n                ? selInt // Count from left\n                : columns.length + selInt // Count from right (+ because its a negative value)\n            ]\n          } else {\n            var match = typeof s === 'string' ? s.match(__re_column_selector) : ''\n\n            if (match) {\n              switch (match[2]) {\n                case 'visIdx':\n                case 'visible':\n                  var idx = parseInt(match[1], 10)\n                  // Visible index given, convert to column index\n                  if (idx < 0) {\n                    // Counting from the right\n                    var visColumns = $.map(columns, function (col, i) {\n                      return col.bVisible ? i : null\n                    })\n                    return [visColumns[visColumns.length + idx]]\n                  }\n                  // Counting from the left\n                  return [_fnVisibleToColumnIndex(settings, idx)]\n\n                case 'name':\n                  // match by name. `names` is column index complete and in order\n                  return $.map(names, function (name, i) {\n                    return name === match[1] ? i : null\n                  })\n              }\n            } else {\n              // jQuery selector on the TH elements for the columns\n              return $(nodes)\n                .filter(s)\n                .map(function () {\n                  return $.inArray(this, nodes) // `nodes` is column index complete and in order\n                })\n                .toArray()\n            }\n          }\n        })\n      }\n\n      var __setColumnVis = function (settings, column, vis, recalc) {\n        var cols = settings.aoColumns,\n          col = cols[column],\n          data = settings.aoData,\n          row,\n          cells,\n          i,\n          ien,\n          tr\n\n        // Get\n        if (vis === undefined) {\n          return col.bVisible\n        }\n\n        // Set\n        // No change\n        if (col.bVisible === vis) {\n          return\n        }\n\n        if (vis) {\n          // Insert column\n          // Need to decide if we should use appendChild or insertBefore\n          var insertBefore = $.inArray(true, _pluck(cols, 'bVisible'), column + 1)\n\n          for (i = 0, ien = data.length; i < ien; i++) {\n            tr = data[i].nTr\n            cells = data[i].anCells\n\n            if (tr) {\n              // insertBefore can act like appendChild if 2nd arg is null\n              tr.insertBefore(cells[column], cells[insertBefore] || null)\n            }\n          }\n        } else {\n          // Remove column\n          $(_pluck(settings.aoData, 'anCells', column)).detach()\n        }\n\n        // Common actions\n        col.bVisible = vis\n        _fnDrawHead(settings, settings.aoHeader)\n        _fnDrawHead(settings, settings.aoFooter)\n\n        if (recalc === undefined || recalc) {\n          // Automatically adjust column sizing\n          _fnAdjustColumnSizing(settings)\n\n          // Realign columns for scrolling\n          if (settings.oScroll.sX || settings.oScroll.sY) {\n            _fnScrollDraw(settings)\n          }\n        }\n\n        _fnCallbackFire(settings, null, 'column-visibility', [settings, column, vis])\n\n        _fnSaveState(settings)\n      }\n\n      /**\n       *\n       */\n      _api_register('columns()', function (selector, opts) {\n        // argument shifting\n        if (selector === undefined) {\n          selector = ''\n        } else if ($.isPlainObject(selector)) {\n          opts = selector\n          selector = ''\n        }\n\n        opts = _selector_opts(opts)\n\n        var inst = this.iterator('table', function (settings) {\n          return __column_selector(settings, selector, opts)\n        })\n\n        // Want argument shifting here and in _row_selector?\n        inst.selector.cols = selector\n        inst.selector.opts = opts\n\n        return inst\n      })\n\n      /**\n       *\n       */\n      _api_registerPlural('columns().header()', 'column().header()', function (selector, opts) {\n        return this.iterator('column', function (settings, column) {\n          return settings.aoColumns[column].nTh\n        })\n      })\n\n      /**\n       *\n       */\n      _api_registerPlural('columns().footer()', 'column().footer()', function (selector, opts) {\n        return this.iterator('column', function (settings, column) {\n          return settings.aoColumns[column].nTf\n        })\n      })\n\n      /**\n       *\n       */\n      _api_registerPlural('columns().data()', 'column().data()', function () {\n        return this.iterator('column-rows', function (settings, column, i, j, rows) {\n          var a = []\n          for (var row = 0, ien = rows.length; row < ien; row++) {\n            a.push(_fnGetCellData(settings, rows[row], column, ''))\n          }\n          return a\n        })\n      })\n\n      _api_registerPlural('columns().cache()', 'column().cache()', function (type) {\n        return this.iterator('column-rows', function (settings, column, i, j, rows) {\n          return _pluck_order(settings.aoData, rows, type === 'search' ? '_aFilterData' : '_aSortData', column)\n        })\n      })\n\n      _api_registerPlural('columns().nodes()', 'column().nodes()', function () {\n        return this.iterator('column-rows', function (settings, column, i, j, rows) {\n          return _pluck_order(settings.aoData, rows, 'anCells', column)\n        })\n      })\n\n      _api_registerPlural('columns().visible()', 'column().visible()', function (vis, calc) {\n        return this.iterator('column', function (settings, column) {\n          return vis === undefined ? settings.aoColumns[column].bVisible : __setColumnVis(settings, column, vis, calc)\n        })\n      })\n\n      _api_registerPlural('columns().indexes()', 'column().index()', function (type) {\n        return this.iterator('column', function (settings, column) {\n          return type === 'visible' ? _fnColumnIndexToVisible(settings, column) : column\n        })\n      })\n\n      // _api_register( 'columns().show()', function () {\n      // \tvar selector = this.selector;\n      // \treturn this.columns( selector.cols, selector.opts ).visible( true );\n      // } );\n\n      // _api_register( 'columns().hide()', function () {\n      // \tvar selector = this.selector;\n      // \treturn this.columns( selector.cols, selector.opts ).visible( false );\n      // } );\n\n      _api_register('columns.adjust()', function () {\n        return this.iterator('table', function (settings) {\n          _fnAdjustColumnSizing(settings)\n        })\n      })\n\n      // Convert from one column index type, to another type\n      _api_register('column.index()', function (type, idx) {\n        if (this.context.length !== 0) {\n          var ctx = this.context[0]\n\n          if (type === 'fromVisible' || type === 'toData') {\n            return _fnVisibleToColumnIndex(ctx, idx)\n          } else if (type === 'fromData' || type === 'toVisible') {\n            return _fnColumnIndexToVisible(ctx, idx)\n          }\n        }\n      })\n\n      _api_register('column()', function (selector, opts) {\n        return _selector_first(this.columns(selector, opts))\n      })\n\n      var __cell_selector = function (settings, selector, opts) {\n        var data = settings.aoData\n        var rows = _selector_row_indexes(settings, opts)\n        var cells = _pluck_order(data, rows, 'anCells')\n        var allCells = $([].concat.apply([], cells))\n        var row\n        var columns = settings.aoColumns.length\n        var a, i, ien, j\n\n        return _selector_run(selector, function (s) {\n          if (s === null || s === undefined) {\n            // All cells\n            a = []\n\n            for (i = 0, ien = rows.length; i < ien; i++) {\n              row = rows[i]\n\n              for (j = 0; j < columns; j++) {\n                a.push({\n                  row: row,\n                  column: j\n                })\n              }\n            }\n\n            return a\n          } else if ($.isPlainObject(s)) {\n            return [s]\n          }\n\n          // jQuery filtered cells\n          return allCells\n            .filter(s)\n            .map(function (i, el) {\n              row = el.parentNode._DT_RowIndex\n\n              return {\n                row: row,\n                column: $.inArray(el, data[row].anCells)\n              }\n            })\n            .toArray()\n        })\n      }\n\n      _api_register('cells()', function (rowSelector, columnSelector, opts) {\n        // Argument shifting\n        if ($.isPlainObject(rowSelector)) {\n          // Indexes\n          if (typeof rowSelector.row !== undefined) {\n            opts = columnSelector\n            columnSelector = null\n          } else {\n            opts = rowSelector\n            rowSelector = null\n          }\n        }\n        if ($.isPlainObject(columnSelector)) {\n          opts = columnSelector\n          columnSelector = null\n        }\n\n        // Cell selector\n        if (columnSelector === null || columnSelector === undefined) {\n          return this.iterator('table', function (settings) {\n            return __cell_selector(settings, rowSelector, _selector_opts(opts))\n          })\n        }\n\n        // Row + column selector\n        var columns = this.columns(columnSelector, opts)\n        var rows = this.rows(rowSelector, opts)\n        var a, i, ien, j, jen\n\n        var cells = this.iterator('table', function (settings, idx) {\n          a = []\n\n          for (i = 0, ien = rows[idx].length; i < ien; i++) {\n            for (j = 0, jen = columns[idx].length; j < jen; j++) {\n              a.push({\n                row: rows[idx][i],\n                column: columns[idx][j]\n              })\n            }\n          }\n\n          return a\n        })\n\n        $.extend(cells.selector, {\n          cols: columnSelector,\n          rows: rowSelector,\n          opts: opts\n        })\n\n        return cells\n      })\n\n      _api_registerPlural('cells().nodes()', 'cell().node()', function () {\n        return this.iterator('cell', function (settings, row, column) {\n          return settings.aoData[row].anCells[column]\n        })\n      })\n\n      _api_register('cells().data()', function () {\n        return this.iterator('cell', function (settings, row, column) {\n          return _fnGetCellData(settings, row, column)\n        })\n      })\n\n      _api_registerPlural('cells().cache()', 'cell().cache()', function (type) {\n        type = type === 'search' ? '_aFilterData' : '_aSortData'\n\n        return this.iterator('cell', function (settings, row, column) {\n          return settings.aoData[row][type][column]\n        })\n      })\n\n      _api_registerPlural('cells().indexes()', 'cell().index()', function () {\n        return this.iterator('cell', function (settings, row, column) {\n          return {\n            row: row,\n            column: column,\n            columnVisible: _fnColumnIndexToVisible(settings, column)\n          }\n        })\n      })\n\n      _api_register(['cells().invalidate()', 'cell().invalidate()'], function (src) {\n        var selector = this.selector\n\n        // Use the rows method of the instance to perform the invalidation, rather\n        // than doing it here. This avoids needing to handle duplicate rows from\n        // the cells.\n        this.rows(selector.rows, selector.opts).invalidate(src)\n\n        return this\n      })\n\n      _api_register('cell()', function (rowSelector, columnSelector, opts) {\n        return _selector_first(this.cells(rowSelector, columnSelector, opts))\n      })\n\n      _api_register('cell().data()', function (data) {\n        var ctx = this.context\n        var cell = this[0]\n\n        if (data === undefined) {\n          // Get\n          return ctx.length && cell.length ? _fnGetCellData(ctx[0], cell[0].row, cell[0].column) : undefined\n        }\n\n        // Set\n        _fnSetCellData(ctx[0], cell[0].row, cell[0].column, data)\n        _fnInvalidateRow(ctx[0], cell[0].row, 'data', cell[0].column)\n\n        return this\n      })\n      /**\n       * Set the ordering for the table.\n       *\n       * @param {array} order 2D array of sorting information to be applied.\n       * @returns {DataTables.Api} this\n       */\n      /**\n       * Set the ordering for the table.\n       *\n       * @param {integer} order Column index to sort upon.\n       * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)\n       * @returns {DataTables.Api} this\n       */\n      /**\n       * Set the ordering for the table.\n       *\n       * @param {array} order 1D array of sorting information to be applied.\n       * @param {array} [...] Optional additional sorting conditions\n       * @returns {DataTables.Api} this\n       */\n\n      /**\n       * Get current ordering (sorting) that has been applied to the table.\n       *\n       * @returns {array} 2D array containing the sorting information for the first\n       *   table in the current context. Each element in the parent array represents\n       *   a column being sorted upon (i.e. multi-sorting with two columns would have\n       *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is\n       *   the column index that the sorting condition applies to, the second is the\n       *   direction of the sort (`desc` or `asc`) and, optionally, the third is the\n       *   index of the sorting order from the `column.sorting` initialisation array.\n       */ _api_register('order()', function (order, dir) {\n        var ctx = this.context\n\n        if (order === undefined) {\n          // get\n          return ctx.length !== 0 ? ctx[0].aaSorting : undefined\n        }\n\n        // set\n        if (typeof order === 'number') {\n          // Simple column / direction passed in\n          order = [[order, dir]]\n        } else if (!$.isArray(order[0])) {\n          // Arguments passed in (list of 1D arrays)\n          order = Array.prototype.slice.call(arguments)\n        }\n        // otherwise a 2D array was passed in\n\n        return this.iterator('table', function (settings) {\n          settings.aaSorting = order.slice()\n        })\n      })\n\n      /**\n       * Attach a sort listener to an element for a given column\n       *\n       * @param {node|jQuery|string} node Identifier for the element(s) to attach the\n       *   listener to. This can take the form of a single DOM node, a jQuery\n       *   collection of nodes or a jQuery selector which will identify the node(s).\n       * @param {integer} column the column that a click on this node will sort on\n       * @param {function} [callback] callback function when sort is run\n       * @returns {DataTables.Api} this\n       */\n      _api_register('order.listener()', function (node, column, callback) {\n        return this.iterator('table', function (settings) {\n          _fnSortAttachListener(settings, node, column, callback)\n        })\n      })\n\n      // Order by the selected column(s)\n      _api_register(['columns().order()', 'column().order()'], function (dir) {\n        var that = this\n\n        return this.iterator('table', function (settings, i) {\n          var sort = []\n\n          $.each(that[i], function (j, col) {\n            sort.push([col, dir])\n          })\n\n          settings.aaSorting = sort\n        })\n      })\n\n      _api_register('search()', function (input, regex, smart, caseInsen) {\n        var ctx = this.context\n\n        if (input === undefined) {\n          // get\n          return ctx.length !== 0 ? ctx[0].oPreviousSearch.sSearch : undefined\n        }\n\n        // set\n        return this.iterator('table', function (settings) {\n          if (!settings.oFeatures.bFilter) {\n            return\n          }\n\n          _fnFilterComplete(\n            settings,\n            $.extend({}, settings.oPreviousSearch, {\n              sSearch: input + '',\n              bRegex: regex === null ? false : regex,\n              bSmart: smart === null ? true : smart,\n              bCaseInsensitive: caseInsen === null ? true : caseInsen\n            }),\n            1\n          )\n        })\n      })\n\n      _api_registerPlural('columns().search()', 'column().search()', function (input, regex, smart, caseInsen) {\n        return this.iterator('column', function (settings, column) {\n          var preSearch = settings.aoPreSearchCols\n\n          if (input === undefined) {\n            // get\n            return preSearch[column].sSearch\n          }\n\n          // set\n          if (!settings.oFeatures.bFilter) {\n            return\n          }\n\n          $.extend(preSearch[column], {\n            sSearch: input + '',\n            bRegex: regex === null ? false : regex,\n            bSmart: smart === null ? true : smart,\n            bCaseInsensitive: caseInsen === null ? true : caseInsen\n          })\n\n          _fnFilterComplete(settings, settings.oPreviousSearch, 1)\n        })\n      })\n\n      /*\n       * State API methods\n       */\n\n      _api_register('state()', function () {\n        return this.context.length ? this.context[0].oSavedState : null\n      })\n\n      _api_register('state.clear()', function () {\n        return this.iterator('table', function (settings) {\n          // Save an empty object\n          settings.fnStateSaveCallback.call(settings.oInstance, settings, {})\n        })\n      })\n\n      _api_register('state.loaded()', function () {\n        return this.context.length ? this.context[0].oLoadedState : null\n      })\n\n      _api_register('state.save()', function () {\n        return this.iterator('table', function (settings) {\n          _fnSaveState(settings)\n        })\n      })\n\n      /**\n       * Provide a common method for plug-ins to check the version of DataTables being\n       * used, in order to ensure compatibility.\n       *\n       *  @param {string} version Version string to check for, in the format \"X.Y.Z\".\n       *    Note that the formats \"X\" and \"X.Y\" are also acceptable.\n       *  @returns {boolean} true if this version of DataTables is greater or equal to\n       *    the required version, or false if this version of DataTales is not\n       *    suitable\n       *  @static\n       *  @dtopt API-Static\n       *\n       *  @example\n       *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );\n       */\n      DataTable.versionCheck = DataTable.fnVersionCheck = function (version) {\n        var aThis = DataTable.version.split('.')\n        var aThat = version.split('.')\n        var iThis, iThat\n\n        for (var i = 0, iLen = aThat.length; i < iLen; i++) {\n          iThis = parseInt(aThis[i], 10) || 0\n          iThat = parseInt(aThat[i], 10) || 0\n\n          // Parts are the same, keep comparing\n          if (iThis === iThat) {\n            continue\n          }\n\n          // Parts are different, return immediately\n          return iThis > iThat\n        }\n\n        return true\n      }\n\n      /**\n       * Check if a `<table>` node is a DataTable table already or not.\n       *\n       *  @param {node|jquery|string} table Table node, jQuery object or jQuery\n       *      selector for the table to test. Note that if more than more than one\n       *      table is passed on, only the first will be checked\n       *  @returns {boolean} true the table given is a DataTable, or false otherwise\n       *  @static\n       *  @dtopt API-Static\n       *\n       *  @example\n       *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {\n       *      $('#example').dataTable();\n       *    }\n       */\n      DataTable.isDataTable = DataTable.fnIsDataTable = function (table) {\n        var t = $(table).get(0)\n        var is = false\n\n        $.each(DataTable.settings, function (i, o) {\n          if (o.nTable === t || o.nScrollHead === t || o.nScrollFoot === t) {\n            is = true\n          }\n        })\n\n        return is\n      }\n\n      /**\n       * Get all DataTable tables that have been initialised - optionally you can\n       * select to get only currently visible tables.\n       *\n       *  @param {boolean} [visible=false] Flag to indicate if you want all (default)\n       *    or visible tables only.\n       *  @returns {array} Array of `table` nodes (not DataTable instances) which are\n       *    DataTables\n       *  @static\n       *  @dtopt API-Static\n       *\n       *  @example\n       *    $.each( $.fn.dataTable.tables(true), function () {\n       *      $(table).DataTable().columns.adjust();\n       *    } );\n       */\n      DataTable.tables = DataTable.fnTables = function (visible) {\n        return jQuery.map(DataTable.settings, function (o) {\n          if (!visible || (visible && $(o.nTable).is(':visible'))) {\n            return o.nTable\n          }\n        })\n      }\n\n      /**\n       * Convert from camel case parameters to Hungarian notation. This is made public\n       * for the extensions to provide the same ability as DataTables core to accept\n       * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase\n       * parameters.\n       *\n       *  @param {object} src The model object which holds all parameters that can be\n       *    mapped.\n       *  @param {object} user The object to convert from camel case to Hungarian.\n       *  @param {boolean} force When set to `true`, properties which already have a\n       *    Hungarian value in the `user` object will be overwritten. Otherwise they\n       *    won't be.\n       */\n      DataTable.camelToHungarian = _fnCamelToHungarian\n\n      /**\n       *\n       */\n      _api_register('$()', function (selector, opts) {\n        var rows = this.rows(opts).nodes(), // Get all rows\n          jqRows = $(rows)\n\n        return $([].concat(jqRows.filter(selector).toArray(), jqRows.find(selector).toArray()))\n      })\n\n      // jQuery functions to operate on the tables\n      $.each(['on', 'one', 'off'], function (i, key) {\n        _api_register(key + '()', function (/* event, handler */) {\n          var args = Array.prototype.slice.call(arguments)\n\n          // Add the `dt` namespace automatically if it isn't already present\n          if (!args[0].match(/\\.dt\\b/)) {\n            args[0] += '.dt'\n          }\n\n          var inst = $(this.tables().nodes())\n          inst[key].apply(inst, args)\n          return this\n        })\n      })\n\n      _api_register('clear()', function () {\n        return this.iterator('table', function (settings) {\n          _fnClearTable(settings)\n        })\n      })\n\n      _api_register('settings()', function () {\n        return new _Api(this.context, this.context)\n      })\n\n      _api_register('data()', function () {\n        return this.iterator('table', function (settings) {\n          return _pluck(settings.aoData, '_aData')\n        }).flatten()\n      })\n\n      _api_register('destroy()', function (remove) {\n        remove = remove || false\n\n        return this.iterator('table', function (settings) {\n          var orig = settings.nTableWrapper.parentNode\n          var classes = settings.oClasses\n          var table = settings.nTable\n          var tbody = settings.nTBody\n          var thead = settings.nTHead\n          var tfoot = settings.nTFoot\n          var jqTable = $(table)\n          var jqTbody = $(tbody)\n          var jqWrapper = $(settings.nTableWrapper)\n          var rows = $.map(settings.aoData, function (r) {\n            return r.nTr\n          })\n          var i, ien\n\n          // Flag to note that the table is currently being destroyed - no action\n          // should be taken\n          settings.bDestroying = true\n\n          // Fire off the destroy callbacks for plug-ins etc\n          _fnCallbackFire(settings, 'aoDestroyCallback', 'destroy', [settings])\n\n          // If not being removed from the document, make all columns visible\n          if (!remove) {\n            new _Api(settings).columns().visible(true)\n          }\n\n          // Blitz all `DT` namespaced events (these are internal events, the\n          // lowercase, `dt` events are user subscribed and they are responsible\n          // for removing them\n          jqWrapper\n            .unbind('.DT')\n            .find(':not(tbody *)')\n            .unbind('.DT')\n          $(window).unbind('.DT-' + settings.sInstance)\n\n          // When scrolling we had to break the table up - restore it\n          if (table != thead.parentNode) {\n            jqTable.children('thead').detach()\n            jqTable.append(thead)\n          }\n\n          if (tfoot && table != tfoot.parentNode) {\n            jqTable.children('tfoot').detach()\n            jqTable.append(tfoot)\n          }\n\n          // Remove the DataTables generated nodes, events and classes\n          jqTable.detach()\n          jqWrapper.detach()\n\n          settings.aaSorting = []\n          settings.aaSortingFixed = []\n          _fnSortingClasses(settings)\n\n          $(rows).removeClass(settings.asStripeClasses.join(' '))\n\n          $('th, td', thead).removeClass(\n            classes.sSortable + ' ' + classes.sSortableAsc + ' ' + classes.sSortableDesc + ' ' + classes.sSortableNone\n          )\n\n          if (settings.bJUI) {\n            $('th span.' + classes.sSortIcon + ', td span.' + classes.sSortIcon, thead).detach()\n            $('th, td', thead).each(function () {\n              var wrapper = $('div.' + classes.sSortJUIWrapper, this)\n              $(this).append(wrapper.contents())\n              wrapper.detach()\n            })\n          }\n\n          if (!remove && orig) {\n            // insertBefore acts like appendChild if !arg[1]\n            orig.insertBefore(table, settings.nTableReinsertBefore)\n          }\n\n          // Add the TR elements back into the table in their original order\n          jqTbody.children().detach()\n          jqTbody.append(rows)\n\n          // Restore the width of the original table - was read from the style property,\n          // so we can restore directly to that\n          jqTable.css('width', settings.sDestroyWidth).removeClass(classes.sTable)\n\n          // If the were originally stripe classes - then we add them back here.\n          // Note this is not fool proof (for example if not all rows had stripe\n          // classes - but it's a good effort without getting carried away\n          ien = settings.asDestroyStripes.length\n\n          if (ien) {\n            jqTbody.children().each(function (i) {\n              $(this).addClass(settings.asDestroyStripes[i % ien])\n            })\n          }\n\n          /* Remove the settings object from the settings array */\n          var idx = $.inArray(settings, DataTable.settings)\n          if (idx !== -1) {\n            DataTable.settings.splice(idx, 1)\n          }\n        })\n      })\n\n      /**\n       * Version string for plug-ins to check compatibility. Allowed format is\n       * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used\n       * only for non-release builds. See http://semver.org/ for more information.\n       *  @member\n       *  @type string\n       *  @default Version number\n       */\n      DataTable.version = '1.10.2'\n\n      /**\n       * Private data store, containing all of the settings objects that are\n       * created for the tables on a given page.\n       *\n       * Note that the `DataTable.settings` object is aliased to\n       * `jQuery.fn.dataTableExt` through which it may be accessed and\n       * manipulated, or `jQuery.fn.dataTable.settings`.\n       *  @member\n       *  @type array\n       *  @default []\n       *  @private\n       */\n      DataTable.settings = []\n\n      /**\n       * Object models container, for the various models that DataTables has\n       * available to it. These models define the objects that are used to hold\n       * the active state and configuration of the table.\n       *  @namespace\n       */\n      DataTable.models = {}\n\n      /**\n       * Template object for the way in which DataTables holds information about\n       * search information for the global filter and individual column filters.\n       *  @namespace\n       */\n      DataTable.models.oSearch = {\n        /**\n         * Flag to indicate if the filtering should be case insensitive or not\n         *  @type boolean\n         *  @default true\n         */\n        bCaseInsensitive: true,\n\n        /**\n         * Applied search term\n         *  @type string\n         *  @default <i>Empty string</i>\n         */\n        sSearch: '',\n\n        /**\n         * Flag to indicate if the search term should be interpreted as a\n         * regular expression (true) or not (false) and therefore and special\n         * regex characters escaped.\n         *  @type boolean\n         *  @default false\n         */\n        bRegex: false,\n\n        /**\n         * Flag to indicate if DataTables is to use its smart filtering or not.\n         *  @type boolean\n         *  @default true\n         */\n        bSmart: true\n      }\n\n      /**\n       * Template object for the way in which DataTables holds information about\n       * each individual row. This is the object format used for the settings\n       * aoData array.\n       *  @namespace\n       */\n      DataTable.models.oRow = {\n        /**\n         * TR element for the row\n         *  @type node\n         *  @default null\n         */\n        nTr: null,\n\n        /**\n         * Array of TD elements for each row. This is null until the row has been\n         * created.\n         *  @type array nodes\n         *  @default []\n         */\n        anCells: null,\n\n        /**\n         * Data object from the original data source for the row. This is either\n         * an array if using the traditional form of DataTables, or an object if\n         * using mData options. The exact type will depend on the passed in\n         * data from the data source, or will be an array if using DOM a data\n         * source.\n         *  @type array|object\n         *  @default []\n         */\n        _aData: [],\n\n        /**\n         * Sorting data cache - this array is ostensibly the same length as the\n         * number of columns (although each index is generated only as it is\n         * needed), and holds the data that is used for sorting each column in the\n         * row. We do this cache generation at the start of the sort in order that\n         * the formatting of the sort data need be done only once for each cell\n         * per sort. This array should not be read from or written to by anything\n         * other than the master sorting methods.\n         *  @type array\n         *  @default null\n         *  @private\n         */\n        _aSortData: null,\n\n        /**\n         * Per cell filtering data cache. As per the sort data cache, used to\n         * increase the performance of the filtering in DataTables\n         *  @type array\n         *  @default null\n         *  @private\n         */\n        _aFilterData: null,\n\n        /**\n         * Filtering data cache. This is the same as the cell filtering cache, but\n         * in this case a string rather than an array. This is easily computed with\n         * a join on `_aFilterData`, but is provided as a cache so the join isn't\n         * needed on every search (memory traded for performance)\n         *  @type array\n         *  @default null\n         *  @private\n         */\n        _sFilterRow: null,\n\n        /**\n         * Cache of the class name that DataTables has applied to the row, so we\n         * can quickly look at this variable rather than needing to do a DOM check\n         * on className for the nTr property.\n         *  @type string\n         *  @default <i>Empty string</i>\n         *  @private\n         */\n        _sRowStripe: '',\n\n        /**\n         * Denote if the original data source was from the DOM, or the data source\n         * object. This is used for invalidating data, so DataTables can\n         * automatically read data from the original source, unless uninstructed\n         * otherwise.\n         *  @type string\n         *  @default null\n         *  @private\n         */\n        src: null\n      }\n\n      /**\n       * Template object for the column information object in DataTables. This object\n       * is held in the settings aoColumns array and contains all the information that\n       * DataTables needs about each individual column.\n       *\n       * Note that this object is related to {@link DataTable.defaults.column}\n       * but this one is the internal data store for DataTables's cache of columns.\n       * It should NOT be manipulated outside of DataTables. Any configuration should\n       * be done through the initialisation options.\n       *  @namespace\n       */\n      DataTable.models.oColumn = {\n        /**\n         * Column index. This could be worked out on-the-fly with $.inArray, but it\n         * is faster to just hold it as a variable\n         *  @type integer\n         *  @default null\n         */\n        idx: null,\n\n        /**\n         * A list of the columns that sorting should occur on when this column\n         * is sorted. That this property is an array allows multi-column sorting\n         * to be defined for a column (for example first name / last name columns\n         * would benefit from this). The values are integers pointing to the\n         * columns to be sorted on (typically it will be a single integer pointing\n         * at itself, but that doesn't need to be the case).\n         *  @type array\n         */\n        aDataSort: null,\n\n        /**\n         * Define the sorting directions that are applied to the column, in sequence\n         * as the column is repeatedly sorted upon - i.e. the first value is used\n         * as the sorting direction when the column if first sorted (clicked on).\n         * Sort it again (click again) and it will move on to the next index.\n         * Repeat until loop.\n         *  @type array\n         */\n        asSorting: null,\n\n        /**\n         * Flag to indicate if the column is searchable, and thus should be included\n         * in the filtering or not.\n         *  @type boolean\n         */\n        bSearchable: null,\n\n        /**\n         * Flag to indicate if the column is sortable or not.\n         *  @type boolean\n         */\n        bSortable: null,\n\n        /**\n         * Flag to indicate if the column is currently visible in the table or not\n         *  @type boolean\n         */\n        bVisible: null,\n\n        /**\n         * Store for manual type assignment using the `column.type` option. This\n         * is held in store so we can manipulate the column's `sType` property.\n         *  @type string\n         *  @default null\n         *  @private\n         */\n        _sManualType: null,\n\n        /**\n         * Flag to indicate if HTML5 data attributes should be used as the data\n         * source for filtering or sorting. True is either are.\n         *  @type boolean\n         *  @default false\n         *  @private\n         */\n        _bAttrSrc: false,\n\n        /**\n         * Developer definable function that is called whenever a cell is created (Ajax source,\n         * etc) or processed for input (DOM source). This can be used as a compliment to mRender\n         * allowing you to modify the DOM element (add background colour for example) when the\n         * element is available.\n         *  @type function\n         *  @param {element} nTd The TD node that has been created\n         *  @param {*} sData The Data for the cell\n         *  @param {array|object} oData The data for the whole row\n         *  @param {int} iRow The row index for the aoData data store\n         *  @default null\n         */\n        fnCreatedCell: null,\n\n        /**\n         * Function to get data from a cell in a column. You should <b>never</b>\n         * access data directly through _aData internally in DataTables - always use\n         * the method attached to this property. It allows mData to function as\n         * required. This function is automatically assigned by the column\n         * initialisation method\n         *  @type function\n         *  @param {array|object} oData The data array/object for the array\n         *    (i.e. aoData[]._aData)\n         *  @param {string} sSpecific The specific data type you want to get -\n         *    'display', 'type' 'filter' 'sort'\n         *  @returns {*} The data for the cell from the given row's data\n         *  @default null\n         */\n        fnGetData: null,\n\n        /**\n         * Function to set data for a cell in the column. You should <b>never</b>\n         * set the data directly to _aData internally in DataTables - always use\n         * this method. It allows mData to function as required. This function\n         * is automatically assigned by the column initialisation method\n         *  @type function\n         *  @param {array|object} oData The data array/object for the array\n         *    (i.e. aoData[]._aData)\n         *  @param {*} sValue Value to set\n         *  @default null\n         */\n        fnSetData: null,\n\n        /**\n         * Property to read the value for the cells in the column from the data\n         * source array / object. If null, then the default content is used, if a\n         * function is given then the return from the function is used.\n         *  @type function|int|string|null\n         *  @default null\n         */\n        mData: null,\n\n        /**\n         * Partner property to mData which is used (only when defined) to get\n         * the data - i.e. it is basically the same as mData, but without the\n         * 'set' option, and also the data fed to it is the result from mData.\n         * This is the rendering method to match the data method of mData.\n         *  @type function|int|string|null\n         *  @default null\n         */\n        mRender: null,\n\n        /**\n         * Unique header TH/TD element for this column - this is what the sorting\n         * listener is attached to (if sorting is enabled.)\n         *  @type node\n         *  @default null\n         */\n        nTh: null,\n\n        /**\n         * Unique footer TH/TD element for this column (if there is one). Not used\n         * in DataTables as such, but can be used for plug-ins to reference the\n         * footer for each column.\n         *  @type node\n         *  @default null\n         */\n        nTf: null,\n\n        /**\n         * The class to apply to all TD elements in the table's TBODY for the column\n         *  @type string\n         *  @default null\n         */\n        sClass: null,\n\n        /**\n         * When DataTables calculates the column widths to assign to each column,\n         * it finds the longest string in each column and then constructs a\n         * temporary table and reads the widths from that. The problem with this\n         * is that \"mmm\" is much wider then \"iiii\", but the latter is a longer\n         * string - thus the calculation can go wrong (doing it properly and putting\n         * it into an DOM object and measuring that is horribly(!) slow). Thus as\n         * a \"work around\" we provide this option. It will append its value to the\n         * text that is found to be the longest string for the column - i.e. padding.\n         *  @type string\n         */\n        sContentPadding: null,\n\n        /**\n         * Allows a default value to be given for a column's data, and will be used\n         * whenever a null data source is encountered (this can be because mData\n         * is set to null, or because the data source itself is null).\n         *  @type string\n         *  @default null\n         */\n        sDefaultContent: null,\n\n        /**\n         * Name for the column, allowing reference to the column by name as well as\n         * by index (needs a lookup to work by name).\n         *  @type string\n         */\n        sName: null,\n\n        /**\n         * Custom sorting data type - defines which of the available plug-ins in\n         * afnSortData the custom sorting will use - if any is defined.\n         *  @type string\n         *  @default std\n         */\n        sSortDataType: 'std',\n\n        /**\n         * Class to be applied to the header element when sorting on this column\n         *  @type string\n         *  @default null\n         */\n        sSortingClass: null,\n\n        /**\n         * Class to be applied to the header element when sorting on this column -\n         * when jQuery UI theming is used.\n         *  @type string\n         *  @default null\n         */\n        sSortingClassJUI: null,\n\n        /**\n         * Title of the column - what is seen in the TH element (nTh).\n         *  @type string\n         */\n        sTitle: null,\n\n        /**\n         * Column sorting and filtering type\n         *  @type string\n         *  @default null\n         */\n        sType: null,\n\n        /**\n         * Width of the column\n         *  @type string\n         *  @default null\n         */\n        sWidth: null,\n\n        /**\n         * Width of the column when it was first \"encountered\"\n         *  @type string\n         *  @default null\n         */\n        sWidthOrig: null\n      }\n\n      /*\n       * Developer note: The properties of the object below are given in Hungarian\n       * notation, that was used as the interface for DataTables prior to v1.10, however\n       * from v1.10 onwards the primary interface is camel case. In order to avoid\n       * breaking backwards compatibility utterly with this change, the Hungarian\n       * version is still, internally the primary interface, but is is not documented\n       * - hence the @name tags in each doc comment. This allows a Javascript function\n       * to create a map from Hungarian notation to camel case (going the other direction\n       * would require each property to be listed, which would at around 3K to the size\n       * of DataTables, while this method is about a 0.5K hit.\n       *\n       * Ultimately this does pave the way for Hungarian notation to be dropped\n       * completely, but that is a massive amount of work and will break current\n       * installs (therefore is on-hold until v2).\n       */\n\n      /**\n       * Initialisation options that can be given to DataTables at initialisation\n       * time.\n       *  @namespace\n       */\n      DataTable.defaults = {\n        /**\n         * An array of data to use for the table, passed in at initialisation which\n         * will be used in preference to any data which is already in the DOM. This is\n         * particularly useful for constructing tables purely in Javascript, for\n         * example with a custom Ajax call.\n         *  @type array\n         *  @default null\n         *\n         *  @dtopt Option\n         *  @name DataTable.defaults.data\n         *\n         *  @example\n         *    // Using a 2D array data source\n         *    $(document).ready( function () {\n         *      $('#example').dataTable( {\n         *        \"data\": [\n         *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],\n         *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],\n         *        ],\n         *        \"columns\": [\n         *          { \"title\": \"Engine\" },\n         *          { \"title\": \"Browser\" },\n         *          { \"title\": \"Platform\" },\n         *          { \"title\": \"Version\" },\n         *          { \"title\": \"Grade\" }\n         *        ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Using an array of objects as a data source (`data`)\n         *    $(document).ready( function () {\n         *      $('#example').dataTable( {\n         *        \"data\": [\n         *          {\n         *            \"engine\":   \"Trident\",\n         *            \"browser\":  \"Internet Explorer 4.0\",\n         *            \"platform\": \"Win 95+\",\n         *            \"version\":  4,\n         *            \"grade\":    \"X\"\n         *          },\n         *          {\n         *            \"engine\":   \"Trident\",\n         *            \"browser\":  \"Internet Explorer 5.0\",\n         *            \"platform\": \"Win 95+\",\n         *            \"version\":  5,\n         *            \"grade\":    \"C\"\n         *          }\n         *        ],\n         *        \"columns\": [\n         *          { \"title\": \"Engine\",   \"data\": \"engine\" },\n         *          { \"title\": \"Browser\",  \"data\": \"browser\" },\n         *          { \"title\": \"Platform\", \"data\": \"platform\" },\n         *          { \"title\": \"Version\",  \"data\": \"version\" },\n         *          { \"title\": \"Grade\",    \"data\": \"grade\" }\n         *        ]\n         *      } );\n         *    } );\n         */\n        aaData: null,\n\n        /**\n         * If ordering is enabled, then DataTables will perform a first pass sort on\n         * initialisation. You can define which column(s) the sort is performed\n         * upon, and the sorting direction, with this variable. The `sorting` array\n         * should contain an array for each column to be sorted initially containing\n         * the column's index and a direction string ('asc' or 'desc').\n         *  @type array\n         *  @default [[0,'asc']]\n         *\n         *  @dtopt Option\n         *  @name DataTable.defaults.order\n         *\n         *  @example\n         *    // Sort by 3rd column first, and then 4th column\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"order\": [[2,'asc'], [3,'desc']]\n         *      } );\n         *    } );\n         *\n         *    // No initial sorting\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"order\": []\n         *      } );\n         *    } );\n         */\n        aaSorting: [[0, 'asc']],\n\n        /**\n         * This parameter is basically identical to the `sorting` parameter, but\n         * cannot be overridden by user interaction with the table. What this means\n         * is that you could have a column (visible or hidden) which the sorting\n         * will always be forced on first - any sorting after that (from the user)\n         * will then be performed as required. This can be useful for grouping rows\n         * together.\n         *  @type array\n         *  @default null\n         *\n         *  @dtopt Option\n         *  @name DataTable.defaults.orderFixed\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"orderFixed\": [[0,'asc']]\n         *      } );\n         *    } )\n         */\n        aaSortingFixed: [],\n\n        /**\n         * DataTables can be instructed to load data to display in the table from a\n         * Ajax source. This option defines how that Ajax call is made and where to.\n         *\n         * The `ajax` property has three different modes of operation, depending on\n         * how it is defined. These are:\n         *\n         * * `string` - Set the URL from where the data should be loaded from.\n         * * `object` - Define properties for `jQuery.ajax`.\n         * * `function` - Custom data get function\n         *\n         * `string`\n         * --------\n         *\n         * As a string, the `ajax` property simply defines the URL from which\n         * DataTables will load data.\n         *\n         * `object`\n         * --------\n         *\n         * As an object, the parameters in the object are passed to\n         * [jQuery.ajax](http://api.jquery.com/jQuery.ajax/) allowing fine control\n         * of the Ajax request. DataTables has a number of default parameters which\n         * you can override using this option. Please refer to the jQuery\n         * documentation for a full description of the options available, although\n         * the following parameters provide additional options in DataTables or\n         * require special consideration:\n         *\n         * * `data` - As with jQuery, `data` can be provided as an object, but it\n         *   can also be used as a function to manipulate the data DataTables sends\n         *   to the server. The function takes a single parameter, an object of\n         *   parameters with the values that DataTables has readied for sending. An\n         *   object may be returned which will be merged into the DataTables\n         *   defaults, or you can add the items to the object that was passed in and\n         *   not return anything from the function. This supersedes `fnServerParams`\n         *   from DataTables 1.9-.\n         *\n         * * `dataSrc` - By default DataTables will look for the property `data` (or\n         *   `aaData` for compatibility with DataTables 1.9-) when obtaining data\n         *   from an Ajax source or for server-side processing - this parameter\n         *   allows that property to be changed. You can use Javascript dotted\n         *   object notation to get a data source for multiple levels of nesting, or\n         *   it my be used as a function. As a function it takes a single parameter,\n         *   the JSON returned from the server, which can be manipulated as\n         *   required, with the returned value being that used by DataTables as the\n         *   data source for the table. This supersedes `sAjaxDataProp` from\n         *   DataTables 1.9-.\n         *\n         * * `success` - Should not be overridden it is used internally in\n         *   DataTables. To manipulate / transform the data returned by the server\n         *   use `ajax.dataSrc`, or use `ajax` as a function (see below).\n         *\n         * `function`\n         * ----------\n         *\n         * As a function, making the Ajax call is left up to yourself allowing\n         * complete control of the Ajax request. Indeed, if desired, a method other\n         * than Ajax could be used to obtain the required data, such as Web storage\n         * or an AIR database.\n         *\n         * The function is given four parameters and no return is required. The\n         * parameters are:\n         *\n         * 1. _object_ - Data to send to the server\n         * 2. _function_ - Callback function that must be executed when the required\n         *    data has been obtained. That data should be passed into the callback\n         *    as the only parameter\n         * 3. _object_ - DataTables settings object for the table\n         *\n         * Note that this supersedes `fnServerData` from DataTables 1.9-.\n         *\n         *  @type string|object|function\n         *  @default null\n         *\n         *  @dtopt Option\n         *  @name DataTable.defaults.ajax\n         *  @since 1.10.0\n         *\n         * @example\n         *   // Get JSON data from a file via Ajax.\n         *   // Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).\n         *   $('#example').dataTable( {\n         *     \"ajax\": \"data.json\"\n         *   } );\n         *\n         * @example\n         *   // Get JSON data from a file via Ajax, using `dataSrc` to change\n         *   // `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)\n         *   $('#example').dataTable( {\n         *     \"ajax\": {\n         *       \"url\": \"data.json\",\n         *       \"dataSrc\": \"tableData\"\n         *     }\n         *   } );\n         *\n         * @example\n         *   // Get JSON data from a file via Ajax, using `dataSrc` to read data\n         *   // from a plain array rather than an array in an object\n         *   $('#example').dataTable( {\n         *     \"ajax\": {\n         *       \"url\": \"data.json\",\n         *       \"dataSrc\": \"\"\n         *     }\n         *   } );\n         *\n         * @example\n         *   // Manipulate the data returned from the server - add a link to data\n         *   // (note this can, should, be done using `render` for the column - this\n         *   // is just a simple example of how the data can be manipulated).\n         *   $('#example').dataTable( {\n         *     \"ajax\": {\n         *       \"url\": \"data.json\",\n         *       \"dataSrc\": function ( json ) {\n         *         for ( var i=0, ien=json.length ; i<ien ; i++ ) {\n         *           json[i][0] = '<a href=\"/message/'+json[i][0]+'>View message</a>';\n         *         }\n         *         return json;\n         *       }\n         *     }\n         *   } );\n         *\n         * @example\n         *   // Add data to the request\n         *   $('#example').dataTable( {\n         *     \"ajax\": {\n         *       \"url\": \"data.json\",\n         *       \"data\": function ( d ) {\n         *         return {\n         *           \"extra_search\": $('#extra').val()\n         *         };\n         *       }\n         *     }\n         *   } );\n         *\n         * @example\n         *   // Send request as POST\n         *   $('#example').dataTable( {\n         *     \"ajax\": {\n         *       \"url\": \"data.json\",\n         *       \"type\": \"POST\"\n         *     }\n         *   } );\n         *\n         * @example\n         *   // Get the data from localStorage (could interface with a form for\n         *   // adding, editing and removing rows).\n         *   $('#example').dataTable( {\n         *     \"ajax\": function (data, callback, settings) {\n         *       callback(\n         *         JSON.parse( localStorage.getItem('dataTablesData') )\n         *       );\n         *     }\n         *   } );\n         */\n        ajax: null,\n\n        /**\n         * This parameter allows you to readily specify the entries in the length drop\n         * down menu that DataTables shows when pagination is enabled. It can be\n         * either a 1D array of options which will be used for both the displayed\n         * option and the value, or a 2D array which will use the array in the first\n         * position as the value, and the array in the second position as the\n         * displayed options (useful for language strings such as 'All').\n         *\n         * Note that the `pageLength` property will be automatically set to the\n         * first value given in this array, unless `pageLength` is also provided.\n         *  @type array\n         *  @default [ 10, 25, 50, 100 ]\n         *\n         *  @dtopt Option\n         *  @name DataTable.defaults.lengthMenu\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"lengthMenu\": [[10, 25, 50, -1], [10, 25, 50, \"All\"]]\n         *      } );\n         *    } );\n         */\n        aLengthMenu: [10, 25, 50, 100],\n\n        /**\n         * The `columns` option in the initialisation parameter allows you to define\n         * details about the way individual columns behave. For a full list of\n         * column options that can be set, please see\n         * {@link DataTable.defaults.column}. Note that if you use `columns` to\n         * define your columns, you must have an entry in the array for every single\n         * column that you have in your table (these can be null if you don't which\n         * to specify any options).\n         *  @member\n         *\n         *  @name DataTable.defaults.column\n         */\n        aoColumns: null,\n\n        /**\n         * Very similar to `columns`, `columnDefs` allows you to target a specific\n         * column, multiple columns, or all columns, using the `targets` property of\n         * each object in the array. This allows great flexibility when creating\n         * tables, as the `columnDefs` arrays can be of any length, targeting the\n         * columns you specifically want. `columnDefs` may use any of the column\n         * options available: {@link DataTable.defaults.column}, but it _must_\n         * have `targets` defined in each object in the array. Values in the `targets`\n         * array may be:\n         *   <ul>\n         *     <li>a string - class name will be matched on the TH for the column</li>\n         *     <li>0 or a positive integer - column index counting from the left</li>\n         *     <li>a negative integer - column index counting from the right</li>\n         *     <li>the string \"_all\" - all columns (i.e. assign a default)</li>\n         *   </ul>\n         *  @member\n         *\n         *  @name DataTable.defaults.columnDefs\n         */\n        aoColumnDefs: null,\n\n        /**\n         * Basically the same as `search`, this parameter defines the individual column\n         * filtering state at initialisation time. The array must be of the same size\n         * as the number of columns, and each element be an object with the parameters\n         * `search` and `escapeRegex` (the latter is optional). 'null' is also\n         * accepted and the default will be used.\n         *  @type array\n         *  @default []\n         *\n         *  @dtopt Option\n         *  @name DataTable.defaults.searchCols\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"searchCols\": [\n         *          null,\n         *          { \"search\": \"My filter\" },\n         *          null,\n         *          { \"search\": \"^[0-9]\", \"escapeRegex\": false }\n         *        ]\n         *      } );\n         *    } )\n         */\n        aoSearchCols: [],\n\n        /**\n         * An array of CSS classes that should be applied to displayed rows. This\n         * array may be of any length, and DataTables will apply each class\n         * sequentially, looping when required.\n         *  @type array\n         *  @default null <i>Will take the values determined by the `oClasses.stripe*`\n         *    options</i>\n         *\n         *  @dtopt Option\n         *  @name DataTable.defaults.stripeClasses\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"stripeClasses\": [ 'strip1', 'strip2', 'strip3' ]\n         *      } );\n         *    } )\n         */\n        asStripeClasses: null,\n\n        /**\n         * Enable or disable automatic column width calculation. This can be disabled\n         * as an optimisation (it takes some time to calculate the widths) if the\n         * tables widths are passed in using `columns`.\n         *  @type boolean\n         *  @default true\n         *\n         *  @dtopt Features\n         *  @name DataTable.defaults.autoWidth\n         *\n         *  @example\n         *    $(document).ready( function () {\n         *      $('#example').dataTable( {\n         *        \"autoWidth\": false\n         *      } );\n         *    } );\n         */\n        bAutoWidth: true,\n\n        /**\n         * Deferred rendering can provide DataTables with a huge speed boost when you\n         * are using an Ajax or JS data source for the table. This option, when set to\n         * true, will cause DataTables to defer the creation of the table elements for\n         * each row until they are needed for a draw - saving a significant amount of\n         * time.\n         *  @type boolean\n         *  @default false\n         *\n         *  @dtopt Features\n         *  @name DataTable.defaults.deferRender\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"ajax\": \"sources/arrays.txt\",\n         *        \"deferRender\": true\n         *      } );\n         *    } );\n         */\n        bDeferRender: false,\n\n        /**\n         * Replace a DataTable which matches the given selector and replace it with\n         * one which has the properties of the new initialisation object passed. If no\n         * table matches the selector, then the new DataTable will be constructed as\n         * per normal.\n         *  @type boolean\n         *  @default false\n         *\n         *  @dtopt Options\n         *  @name DataTable.defaults.destroy\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"srollY\": \"200px\",\n         *        \"paginate\": false\n         *      } );\n         *\n         *      // Some time later....\n         *      $('#example').dataTable( {\n         *        \"filter\": false,\n         *        \"destroy\": true\n         *      } );\n         *    } );\n         */\n        bDestroy: false,\n\n        /**\n         * Enable or disable filtering of data. Filtering in DataTables is \"smart\" in\n         * that it allows the end user to input multiple words (space separated) and\n         * will match a row containing those words, even if not in the order that was\n         * specified (this allow matching across multiple columns). Note that if you\n         * wish to use filtering in DataTables this must remain 'true' - to remove the\n         * default filtering input box and retain filtering abilities, please use\n         * {@link DataTable.defaults.dom}.\n         *  @type boolean\n         *  @default true\n         *\n         *  @dtopt Features\n         *  @name DataTable.defaults.searching\n         *\n         *  @example\n         *    $(document).ready( function () {\n         *      $('#example').dataTable( {\n         *        \"searching\": false\n         *      } );\n         *    } );\n         */\n        bFilter: true,\n\n        /**\n         * Enable or disable the table information display. This shows information\n         * about the data that is currently visible on the page, including information\n         * about filtered data if that action is being performed.\n         *  @type boolean\n         *  @default true\n         *\n         *  @dtopt Features\n         *  @name DataTable.defaults.info\n         *\n         *  @example\n         *    $(document).ready( function () {\n         *      $('#example').dataTable( {\n         *        \"info\": false\n         *      } );\n         *    } );\n         */\n        bInfo: true,\n\n        /**\n         * Enable jQuery UI ThemeRoller support (required as ThemeRoller requires some\n         * slightly different and additional mark-up from what DataTables has\n         * traditionally used).\n         *  @type boolean\n         *  @default false\n         *\n         *  @dtopt Features\n         *  @name DataTable.defaults.jQueryUI\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"jQueryUI\": true\n         *      } );\n         *    } );\n         */\n        bJQueryUI: false,\n\n        /**\n         * Allows the end user to select the size of a formatted page from a select\n         * menu (sizes are 10, 25, 50 and 100). Requires pagination (`paginate`).\n         *  @type boolean\n         *  @default true\n         *\n         *  @dtopt Features\n         *  @name DataTable.defaults.lengthChange\n         *\n         *  @example\n         *    $(document).ready( function () {\n         *      $('#example').dataTable( {\n         *        \"lengthChange\": false\n         *      } );\n         *    } );\n         */\n        bLengthChange: true,\n\n        /**\n         * Enable or disable pagination.\n         *  @type boolean\n         *  @default true\n         *\n         *  @dtopt Features\n         *  @name DataTable.defaults.paging\n         *\n         *  @example\n         *    $(document).ready( function () {\n         *      $('#example').dataTable( {\n         *        \"paging\": false\n         *      } );\n         *    } );\n         */\n        bPaginate: true,\n\n        /**\n         * Enable or disable the display of a 'processing' indicator when the table is\n         * being processed (e.g. a sort). This is particularly useful for tables with\n         * large amounts of data where it can take a noticeable amount of time to sort\n         * the entries.\n         *  @type boolean\n         *  @default false\n         *\n         *  @dtopt Features\n         *  @name DataTable.defaults.processing\n         *\n         *  @example\n         *    $(document).ready( function () {\n         *      $('#example').dataTable( {\n         *        \"processing\": true\n         *      } );\n         *    } );\n         */\n        bProcessing: false,\n\n        /**\n         * Retrieve the DataTables object for the given selector. Note that if the\n         * table has already been initialised, this parameter will cause DataTables\n         * to simply return the object that has already been set up - it will not take\n         * account of any changes you might have made to the initialisation object\n         * passed to DataTables (setting this parameter to true is an acknowledgement\n         * that you understand this). `destroy` can be used to reinitialise a table if\n         * you need.\n         *  @type boolean\n         *  @default false\n         *\n         *  @dtopt Options\n         *  @name DataTable.defaults.retrieve\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      initTable();\n         *      tableActions();\n         *    } );\n         *\n         *    function initTable ()\n         *    {\n         *      return $('#example').dataTable( {\n         *        \"scrollY\": \"200px\",\n         *        \"paginate\": false,\n         *        \"retrieve\": true\n         *      } );\n         *    }\n         *\n         *    function tableActions ()\n         *    {\n         *      var table = initTable();\n         *      // perform API operations with oTable\n         *    }\n         */\n        bRetrieve: false,\n\n        /**\n         * When vertical (y) scrolling is enabled, DataTables will force the height of\n         * the table's viewport to the given height at all times (useful for layout).\n         * However, this can look odd when filtering data down to a small data set,\n         * and the footer is left \"floating\" further down. This parameter (when\n         * enabled) will cause DataTables to collapse the table's viewport down when\n         * the result set will fit within the given Y height.\n         *  @type boolean\n         *  @default false\n         *\n         *  @dtopt Options\n         *  @name DataTable.defaults.scrollCollapse\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"scrollY\": \"200\",\n         *        \"scrollCollapse\": true\n         *      } );\n         *    } );\n         */\n        bScrollCollapse: false,\n\n        /**\n         * Configure DataTables to use server-side processing. Note that the\n         * `ajax` parameter must also be given in order to give DataTables a\n         * source to obtain the required data for each draw.\n         *  @type boolean\n         *  @default false\n         *\n         *  @dtopt Features\n         *  @dtopt Server-side\n         *  @name DataTable.defaults.serverSide\n         *\n         *  @example\n         *    $(document).ready( function () {\n         *      $('#example').dataTable( {\n         *        \"serverSide\": true,\n         *        \"ajax\": \"xhr.php\"\n         *      } );\n         *    } );\n         */\n        bServerSide: false,\n\n        /**\n         * Enable or disable sorting of columns. Sorting of individual columns can be\n         * disabled by the `sortable` option for each column.\n         *  @type boolean\n         *  @default true\n         *\n         *  @dtopt Features\n         *  @name DataTable.defaults.ordering\n         *\n         *  @example\n         *    $(document).ready( function () {\n         *      $('#example').dataTable( {\n         *        \"ordering\": false\n         *      } );\n         *    } );\n         */\n        bSort: true,\n\n        /**\n         * Enable or display DataTables' ability to sort multiple columns at the\n         * same time (activated by shift-click by the user).\n         *  @type boolean\n         *  @default true\n         *\n         *  @dtopt Options\n         *  @name DataTable.defaults.orderMulti\n         *\n         *  @example\n         *    // Disable multiple column sorting ability\n         *    $(document).ready( function () {\n         *      $('#example').dataTable( {\n         *        \"orderMulti\": false\n         *      } );\n         *    } );\n         */\n        bSortMulti: true,\n\n        /**\n         * Allows control over whether DataTables should use the top (true) unique\n         * cell that is found for a single column, or the bottom (false - default).\n         * This is useful when using complex headers.\n         *  @type boolean\n         *  @default false\n         *\n         *  @dtopt Options\n         *  @name DataTable.defaults.orderCellsTop\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"orderCellsTop\": true\n         *      } );\n         *    } );\n         */\n        bSortCellsTop: false,\n\n        /**\n         * Enable or disable the addition of the classes `sorting\\_1`, `sorting\\_2` and\n         * `sorting\\_3` to the columns which are currently being sorted on. This is\n         * presented as a feature switch as it can increase processing time (while\n         * classes are removed and added) so for large data sets you might want to\n         * turn this off.\n         *  @type boolean\n         *  @default true\n         *\n         *  @dtopt Features\n         *  @name DataTable.defaults.orderClasses\n         *\n         *  @example\n         *    $(document).ready( function () {\n         *      $('#example').dataTable( {\n         *        \"orderClasses\": false\n         *      } );\n         *    } );\n         */\n        bSortClasses: true,\n\n        /**\n         * Enable or disable state saving. When enabled HTML5 `localStorage` will be\n         * used to save table display information such as pagination information,\n         * display length, filtering and sorting. As such when the end user reloads\n         * the page the display display will match what thy had previously set up.\n         *\n         * Due to the use of `localStorage` the default state saving is not supported\n         * in IE6 or 7. If state saving is required in those browsers, use\n         * `stateSaveCallback` to provide a storage solution such as cookies.\n         *  @type boolean\n         *  @default false\n         *\n         *  @dtopt Features\n         *  @name DataTable.defaults.stateSave\n         *\n         *  @example\n         *    $(document).ready( function () {\n         *      $('#example').dataTable( {\n         *        \"stateSave\": true\n         *      } );\n         *    } );\n         */\n        bStateSave: false,\n\n        /**\n         * This function is called when a TR element is created (and all TD child\n         * elements have been inserted), or registered if using a DOM source, allowing\n         * manipulation of the TR element (adding classes etc).\n         *  @type function\n         *  @param {node} row \"TR\" element for the current row\n         *  @param {array} data Raw data array for this row\n         *  @param {int} dataIndex The index of this row in the internal aoData array\n         *\n         *  @dtopt Callbacks\n         *  @name DataTable.defaults.createdRow\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"createdRow\": function( row, data, dataIndex ) {\n         *          // Bold the grade for all 'A' grade browsers\n         *          if ( data[4] == \"A\" )\n         *          {\n         *            $('td:eq(4)', row).html( '<b>A</b>' );\n         *          }\n         *        }\n         *      } );\n         *    } );\n         */\n        fnCreatedRow: null,\n\n        /**\n         * This function is called on every 'draw' event, and allows you to\n         * dynamically modify any aspect you want about the created DOM.\n         *  @type function\n         *  @param {object} settings DataTables settings object\n         *\n         *  @dtopt Callbacks\n         *  @name DataTable.defaults.drawCallback\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"drawCallback\": function( settings ) {\n         *          alert( 'DataTables has redrawn the table' );\n         *        }\n         *      } );\n         *    } );\n         */\n        fnDrawCallback: null,\n\n        /**\n         * Identical to fnHeaderCallback() but for the table footer this function\n         * allows you to modify the table footer on every 'draw' event.\n         *  @type function\n         *  @param {node} foot \"TR\" element for the footer\n         *  @param {array} data Full table data (as derived from the original HTML)\n         *  @param {int} start Index for the current display starting point in the\n         *    display array\n         *  @param {int} end Index for the current display ending point in the\n         *    display array\n         *  @param {array int} display Index array to translate the visual position\n         *    to the full data array\n         *\n         *  @dtopt Callbacks\n         *  @name DataTable.defaults.footerCallback\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"footerCallback\": function( tfoot, data, start, end, display ) {\n         *          tfoot.getElementsByTagName('th')[0].innerHTML = \"Starting index is \"+start;\n         *        }\n         *      } );\n         *    } )\n         */\n        fnFooterCallback: null,\n\n        /**\n         * When rendering large numbers in the information element for the table\n         * (i.e. \"Showing 1 to 10 of 57 entries\") DataTables will render large numbers\n         * to have a comma separator for the 'thousands' units (e.g. 1 million is\n         * rendered as \"1,000,000\") to help readability for the end user. This\n         * function will override the default method DataTables uses.\n         *  @type function\n         *  @member\n         *  @param {int} toFormat number to be formatted\n         *  @returns {string} formatted string for DataTables to show the number\n         *\n         *  @dtopt Callbacks\n         *  @name DataTable.defaults.formatNumber\n         *\n         *  @example\n         *    // Format a number using a single quote for the separator (note that\n         *    // this can also be done with the language.thousands option)\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"formatNumber\": function ( toFormat ) {\n         *          return toFormat.toString().replace(\n         *            /\\B(?=(\\d{3})+(?!\\d))/g, \"'\"\n         *          );\n         *        };\n         *      } );\n         *    } );\n         */\n        fnFormatNumber: function (toFormat) {\n          return toFormat.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, this.oLanguage.sThousands)\n        },\n\n        /**\n         * This function is called on every 'draw' event, and allows you to\n         * dynamically modify the header row. This can be used to calculate and\n         * display useful information about the table.\n         *  @type function\n         *  @param {node} head \"TR\" element for the header\n         *  @param {array} data Full table data (as derived from the original HTML)\n         *  @param {int} start Index for the current display starting point in the\n         *    display array\n         *  @param {int} end Index for the current display ending point in the\n         *    display array\n         *  @param {array int} display Index array to translate the visual position\n         *    to the full data array\n         *\n         *  @dtopt Callbacks\n         *  @name DataTable.defaults.headerCallback\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"fheaderCallback\": function( head, data, start, end, display ) {\n         *          head.getElementsByTagName('th')[0].innerHTML = \"Displaying \"+(end-start)+\" records\";\n         *        }\n         *      } );\n         *    } )\n         */\n        fnHeaderCallback: null,\n\n        /**\n         * The information element can be used to convey information about the current\n         * state of the table. Although the internationalisation options presented by\n         * DataTables are quite capable of dealing with most customisations, there may\n         * be times where you wish to customise the string further. This callback\n         * allows you to do exactly that.\n         *  @type function\n         *  @param {object} oSettings DataTables settings object\n         *  @param {int} start Starting position in data for the draw\n         *  @param {int} end End position in data for the draw\n         *  @param {int} max Total number of rows in the table (regardless of\n         *    filtering)\n         *  @param {int} total Total number of rows in the data set, after filtering\n         *  @param {string} pre The string that DataTables has formatted using it's\n         *    own rules\n         *  @returns {string} The string to be displayed in the information element.\n         *\n         *  @dtopt Callbacks\n         *  @name DataTable.defaults.infoCallback\n         *\n         *  @example\n         *    $('#example').dataTable( {\n         *      \"infoCallback\": function( settings, start, end, max, total, pre ) {\n         *        return start +\" to \"+ end;\n         *      }\n         *    } );\n         */\n        fnInfoCallback: null,\n\n        /**\n         * Called when the table has been initialised. Normally DataTables will\n         * initialise sequentially and there will be no need for this function,\n         * however, this does not hold true when using external language information\n         * since that is obtained using an async XHR call.\n         *  @type function\n         *  @param {object} settings DataTables settings object\n         *  @param {object} json The JSON object request from the server - only\n         *    present if client-side Ajax sourced data is used\n         *\n         *  @dtopt Callbacks\n         *  @name DataTable.defaults.initComplete\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"initComplete\": function(settings, json) {\n         *          alert( 'DataTables has finished its initialisation.' );\n         *        }\n         *      } );\n         *    } )\n         */\n        fnInitComplete: null,\n\n        /**\n         * Called at the very start of each table draw and can be used to cancel the\n         * draw by returning false, any other return (including undefined) results in\n         * the full draw occurring).\n         *  @type function\n         *  @param {object} settings DataTables settings object\n         *  @returns {boolean} False will cancel the draw, anything else (including no\n         *    return) will allow it to complete.\n         *\n         *  @dtopt Callbacks\n         *  @name DataTable.defaults.preDrawCallback\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"preDrawCallback\": function( settings ) {\n         *          if ( $('#test').val() == 1 ) {\n         *            return false;\n         *          }\n         *        }\n         *      } );\n         *    } );\n         */\n        fnPreDrawCallback: null,\n\n        /**\n         * This function allows you to 'post process' each row after it have been\n         * generated for each table draw, but before it is rendered on screen. This\n         * function might be used for setting the row class name etc.\n         *  @type function\n         *  @param {node} row \"TR\" element for the current row\n         *  @param {array} data Raw data array for this row\n         *  @param {int} displayIndex The display index for the current table draw\n         *  @param {int} displayIndexFull The index of the data in the full list of\n         *    rows (after filtering)\n         *\n         *  @dtopt Callbacks\n         *  @name DataTable.defaults.rowCallback\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"rowCallback\": function( row, data, displayIndex, displayIndexFull ) {\n         *          // Bold the grade for all 'A' grade browsers\n         *          if ( data[4] == \"A\" ) {\n         *            $('td:eq(4)', row).html( '<b>A</b>' );\n         *          }\n         *        }\n         *      } );\n         *    } );\n         */\n        fnRowCallback: null,\n\n        /**\n         * __Deprecated__ The functionality provided by this parameter has now been\n         * superseded by that provided through `ajax`, which should be used instead.\n         *\n         * This parameter allows you to override the default function which obtains\n         * the data from the server so something more suitable for your application.\n         * For example you could use POST data, or pull information from a Gears or\n         * AIR database.\n         *  @type function\n         *  @member\n         *  @param {string} source HTTP source to obtain the data from (`ajax`)\n         *  @param {array} data A key/value pair object containing the data to send\n         *    to the server\n         *  @param {function} callback to be called on completion of the data get\n         *    process that will draw the data on the page.\n         *  @param {object} settings DataTables settings object\n         *\n         *  @dtopt Callbacks\n         *  @dtopt Server-side\n         *  @name DataTable.defaults.serverData\n         *\n         *  @deprecated 1.10. Please use `ajax` for this functionality now.\n         */\n        fnServerData: null,\n\n        /**\n         * __Deprecated__ The functionality provided by this parameter has now been\n         * superseded by that provided through `ajax`, which should be used instead.\n         *\n         *  It is often useful to send extra data to the server when making an Ajax\n         * request - for example custom filtering information, and this callback\n         * function makes it trivial to send extra information to the server. The\n         * passed in parameter is the data set that has been constructed by\n         * DataTables, and you can add to this or modify it as you require.\n         *  @type function\n         *  @param {array} data Data array (array of objects which are name/value\n         *    pairs) that has been constructed by DataTables and will be sent to the\n         *    server. In the case of Ajax sourced data with server-side processing\n         *    this will be an empty array, for server-side processing there will be a\n         *    significant number of parameters!\n         *  @returns {undefined} Ensure that you modify the data array passed in,\n         *    as this is passed by reference.\n         *\n         *  @dtopt Callbacks\n         *  @dtopt Server-side\n         *  @name DataTable.defaults.serverParams\n         *\n         *  @deprecated 1.10. Please use `ajax` for this functionality now.\n         */\n        fnServerParams: null,\n\n        /**\n         * Load the table state. With this function you can define from where, and how, the\n         * state of a table is loaded. By default DataTables will load from `localStorage`\n         * but you might wish to use a server-side database or cookies.\n         *  @type function\n         *  @member\n         *  @param {object} settings DataTables settings object\n         *  @return {object} The DataTables state object to be loaded\n         *\n         *  @dtopt Callbacks\n         *  @name DataTable.defaults.stateLoadCallback\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"stateSave\": true,\n         *        \"stateLoadCallback\": function (settings) {\n         *          var o;\n         *\n         *          // Send an Ajax request to the server to get the data. Note that\n         *          // this is a synchronous request.\n         *          $.ajax( {\n         *            \"url\": \"/state_load\",\n         *            \"async\": false,\n         *            \"dataType\": \"json\",\n         *            \"success\": function (json) {\n         *              o = json;\n         *            }\n         *          } );\n         *\n         *          return o;\n         *        }\n         *      } );\n         *    } );\n         */\n        fnStateLoadCallback: function (settings) {\n          try {\n            return JSON.parse(\n              (settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(\n                'DataTables_' + settings.sInstance + '_' + location.pathname\n              )\n            )\n          } catch (e) {}\n        },\n\n        /**\n         * Callback which allows modification of the saved state prior to loading that state.\n         * This callback is called when the table is loading state from the stored data, but\n         * prior to the settings object being modified by the saved state. Note that for\n         * plug-in authors, you should use the `stateLoadParams` event to load parameters for\n         * a plug-in.\n         *  @type function\n         *  @param {object} settings DataTables settings object\n         *  @param {object} data The state object that is to be loaded\n         *\n         *  @dtopt Callbacks\n         *  @name DataTable.defaults.stateLoadParams\n         *\n         *  @example\n         *    // Remove a saved filter, so filtering is never loaded\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"stateSave\": true,\n         *        \"stateLoadParams\": function (settings, data) {\n         *          data.oSearch.sSearch = \"\";\n         *        }\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Disallow state loading by returning false\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"stateSave\": true,\n         *        \"stateLoadParams\": function (settings, data) {\n         *          return false;\n         *        }\n         *      } );\n         *    } );\n         */\n        fnStateLoadParams: null,\n\n        /**\n         * Callback that is called when the state has been loaded from the state saving method\n         * and the DataTables settings object has been modified as a result of the loaded state.\n         *  @type function\n         *  @param {object} settings DataTables settings object\n         *  @param {object} data The state object that was loaded\n         *\n         *  @dtopt Callbacks\n         *  @name DataTable.defaults.stateLoaded\n         *\n         *  @example\n         *    // Show an alert with the filtering value that was saved\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"stateSave\": true,\n         *        \"stateLoaded\": function (settings, data) {\n         *          alert( 'Saved filter was: '+data.oSearch.sSearch );\n         *        }\n         *      } );\n         *    } );\n         */\n        fnStateLoaded: null,\n\n        /**\n         * Save the table state. This function allows you to define where and how the state\n         * information for the table is stored By default DataTables will use `localStorage`\n         * but you might wish to use a server-side database or cookies.\n         *  @type function\n         *  @member\n         *  @param {object} settings DataTables settings object\n         *  @param {object} data The state object to be saved\n         *\n         *  @dtopt Callbacks\n         *  @name DataTable.defaults.stateSaveCallback\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"stateSave\": true,\n         *        \"stateSaveCallback\": function (settings, data) {\n         *          // Send an Ajax request to the server with the state object\n         *          $.ajax( {\n         *            \"url\": \"/state_save\",\n         *            \"data\": data,\n         *            \"dataType\": \"json\",\n         *            \"method\": \"POST\"\n         *            \"success\": function () {}\n         *          } );\n         *        }\n         *      } );\n         *    } );\n         */\n        fnStateSaveCallback: function (settings, data) {\n          try {\n            ;(settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(\n              'DataTables_' + settings.sInstance + '_' + location.pathname,\n              JSON.stringify(data)\n            )\n          } catch (e) {}\n        },\n\n        /**\n         * Callback which allows modification of the state to be saved. Called when the table\n         * has changed state a new state save is required. This method allows modification of\n         * the state saving object prior to actually doing the save, including addition or\n         * other state properties or modification. Note that for plug-in authors, you should\n         * use the `stateSaveParams` event to save parameters for a plug-in.\n         *  @type function\n         *  @param {object} settings DataTables settings object\n         *  @param {object} data The state object to be saved\n         *\n         *  @dtopt Callbacks\n         *  @name DataTable.defaults.stateSaveParams\n         *\n         *  @example\n         *    // Remove a saved filter, so filtering is never saved\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"stateSave\": true,\n         *        \"stateSaveParams\": function (settings, data) {\n         *          data.oSearch.sSearch = \"\";\n         *        }\n         *      } );\n         *    } );\n         */\n        fnStateSaveParams: null,\n\n        /**\n         * Duration for which the saved state information is considered valid. After this period\n         * has elapsed the state will be returned to the default.\n         * Value is given in seconds.\n         *  @type int\n         *  @default 7200 <i>(2 hours)</i>\n         *\n         *  @dtopt Options\n         *  @name DataTable.defaults.stateDuration\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"stateDuration\": 60*60*24; // 1 day\n         *      } );\n         *    } )\n         */\n        iStateDuration: 7200,\n\n        /**\n         * When enabled DataTables will not make a request to the server for the first\n         * page draw - rather it will use the data already on the page (no sorting etc\n         * will be applied to it), thus saving on an XHR at load time. `deferLoading`\n         * is used to indicate that deferred loading is required, but it is also used\n         * to tell DataTables how many records there are in the full table (allowing\n         * the information element and pagination to be displayed correctly). In the case\n         * where a filtering is applied to the table on initial load, this can be\n         * indicated by giving the parameter as an array, where the first element is\n         * the number of records available after filtering and the second element is the\n         * number of records without filtering (allowing the table information element\n         * to be shown correctly).\n         *  @type int | array\n         *  @default null\n         *\n         *  @dtopt Options\n         *  @name DataTable.defaults.deferLoading\n         *\n         *  @example\n         *    // 57 records available in the table, no filtering applied\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"serverSide\": true,\n         *        \"ajax\": \"scripts/server_processing.php\",\n         *        \"deferLoading\": 57\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // 57 records after filtering, 100 without filtering (an initial filter applied)\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"serverSide\": true,\n         *        \"ajax\": \"scripts/server_processing.php\",\n         *        \"deferLoading\": [ 57, 100 ],\n         *        \"search\": {\n         *          \"search\": \"my_filter\"\n         *        }\n         *      } );\n         *    } );\n         */\n        iDeferLoading: null,\n\n        /**\n         * Number of rows to display on a single page when using pagination. If\n         * feature enabled (`lengthChange`) then the end user will be able to override\n         * this to a custom setting using a pop-up menu.\n         *  @type int\n         *  @default 10\n         *\n         *  @dtopt Options\n         *  @name DataTable.defaults.pageLength\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"pageLength\": 50\n         *      } );\n         *    } )\n         */\n        iDisplayLength: 10,\n\n        /**\n         * Define the starting point for data display when using DataTables with\n         * pagination. Note that this parameter is the number of records, rather than\n         * the page number, so if you have 10 records per page and want to start on\n         * the third page, it should be \"20\".\n         *  @type int\n         *  @default 0\n         *\n         *  @dtopt Options\n         *  @name DataTable.defaults.displayStart\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"displayStart\": 20\n         *      } );\n         *    } )\n         */\n        iDisplayStart: 0,\n\n        /**\n         * By default DataTables allows keyboard navigation of the table (sorting, paging,\n         * and filtering) by adding a `tabindex` attribute to the required elements. This\n         * allows you to tab through the controls and press the enter key to activate them.\n         * The tabindex is default 0, meaning that the tab follows the flow of the document.\n         * You can overrule this using this parameter if you wish. Use a value of -1 to\n         * disable built-in keyboard navigation.\n         *  @type int\n         *  @default 0\n         *\n         *  @dtopt Options\n         *  @name DataTable.defaults.tabIndex\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"tabIndex\": 1\n         *      } );\n         *    } );\n         */\n        iTabIndex: 0,\n\n        /**\n         * Classes that DataTables assigns to the various components and features\n         * that it adds to the HTML table. This allows classes to be configured\n         * during initialisation in addition to through the static\n         * {@link DataTable.ext.oStdClasses} object).\n         *  @namespace\n         *  @name DataTable.defaults.classes\n         */\n        oClasses: {},\n\n        /**\n         * All strings that DataTables uses in the user interface that it creates\n         * are defined in this object, allowing you to modified them individually or\n         * completely replace them all as required.\n         *  @namespace\n         *  @name DataTable.defaults.language\n         */\n        oLanguage: {\n          /**\n           * Strings that are used for WAI-ARIA labels and controls only (these are not\n           * actually visible on the page, but will be read by screenreaders, and thus\n           * must be internationalised as well).\n           *  @namespace\n           *  @name DataTable.defaults.language.aria\n           */\n          oAria: {\n            /**\n             * ARIA label that is added to the table headers when the column may be\n             * sorted ascending by activing the column (click or return when focused).\n             * Note that the column header is prefixed to this string.\n             *  @type string\n             *  @default : activate to sort column ascending\n             *\n             *  @dtopt Language\n             *  @name DataTable.defaults.language.aria.sortAscending\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"language\": {\n             *          \"aria\": {\n             *            \"sortAscending\": \" - click/return to sort ascending\"\n             *          }\n             *        }\n             *      } );\n             *    } );\n             */\n            sSortAscending: ': activate to sort column ascending',\n\n            /**\n             * ARIA label that is added to the table headers when the column may be\n             * sorted descending by activing the column (click or return when focused).\n             * Note that the column header is prefixed to this string.\n             *  @type string\n             *  @default : activate to sort column ascending\n             *\n             *  @dtopt Language\n             *  @name DataTable.defaults.language.aria.sortDescending\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"language\": {\n             *          \"aria\": {\n             *            \"sortDescending\": \" - click/return to sort descending\"\n             *          }\n             *        }\n             *      } );\n             *    } );\n             */\n            sSortDescending: ': activate to sort column descending'\n          },\n\n          /**\n           * Pagination string used by DataTables for the built-in pagination\n           * control types.\n           *  @namespace\n           *  @name DataTable.defaults.language.paginate\n           */\n          oPaginate: {\n            /**\n             * Text to use when using the 'full_numbers' type of pagination for the\n             * button to take the user to the first page.\n             *  @type string\n             *  @default First\n             *\n             *  @dtopt Language\n             *  @name DataTable.defaults.language.paginate.first\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"language\": {\n             *          \"paginate\": {\n             *            \"first\": \"First page\"\n             *          }\n             *        }\n             *      } );\n             *    } );\n             */\n            sFirst: 'First',\n\n            /**\n             * Text to use when using the 'full_numbers' type of pagination for the\n             * button to take the user to the last page.\n             *  @type string\n             *  @default Last\n             *\n             *  @dtopt Language\n             *  @name DataTable.defaults.language.paginate.last\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"language\": {\n             *          \"paginate\": {\n             *            \"last\": \"Last page\"\n             *          }\n             *        }\n             *      } );\n             *    } );\n             */\n            sLast: 'Last',\n\n            /**\n             * Text to use for the 'next' pagination button (to take the user to the\n             * next page).\n             *  @type string\n             *  @default Next\n             *\n             *  @dtopt Language\n             *  @name DataTable.defaults.language.paginate.next\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"language\": {\n             *          \"paginate\": {\n             *            \"next\": \"Next page\"\n             *          }\n             *        }\n             *      } );\n             *    } );\n             */\n            sNext: 'Next',\n\n            /**\n             * Text to use for the 'previous' pagination button (to take the user to\n             * the previous page).\n             *  @type string\n             *  @default Previous\n             *\n             *  @dtopt Language\n             *  @name DataTable.defaults.language.paginate.previous\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"language\": {\n             *          \"paginate\": {\n             *            \"previous\": \"Previous page\"\n             *          }\n             *        }\n             *      } );\n             *    } );\n             */\n            sPrevious: 'Previous'\n          },\n\n          /**\n           * This string is shown in preference to `zeroRecords` when the table is\n           * empty of data (regardless of filtering). Note that this is an optional\n           * parameter - if it is not given, the value of `zeroRecords` will be used\n           * instead (either the default or given value).\n           *  @type string\n           *  @default No data available in table\n           *\n           *  @dtopt Language\n           *  @name DataTable.defaults.language.emptyTable\n           *\n           *  @example\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"emptyTable\": \"No data available in table\"\n           *        }\n           *      } );\n           *    } );\n           */\n          sEmptyTable: 'No data available in table',\n\n          /**\n           * This string gives information to the end user about the information\n           * that is current on display on the page. The following tokens can be\n           * used in the string and will be dynamically replaced as the table\n           * display updates. This tokens can be placed anywhere in the string, or\n           * removed as needed by the language requires:\n           *\n           * * `\\_START\\_` - Display index of the first record on the current page\n           * * `\\_END\\_` - Display index of the last record on the current page\n           * * `\\_TOTAL\\_` - Number of records in the table after filtering\n           * * `\\_MAX\\_` - Number of records in the table without filtering\n           * * `\\_PAGE\\_` - Current page number\n           * * `\\_PAGES\\_` - Total number of pages of data in the table\n           *\n           *  @type string\n           *  @default Showing _START_ to _END_ of _TOTAL_ entries\n           *\n           *  @dtopt Language\n           *  @name DataTable.defaults.language.info\n           *\n           *  @example\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"info\": \"Showing page _PAGE_ of _PAGES_\"\n           *        }\n           *      } );\n           *    } );\n           */\n          sInfo: 'Showing _START_ to _END_ of _TOTAL_ entries',\n\n          /**\n           * Display information string for when the table is empty. Typically the\n           * format of this string should match `info`.\n           *  @type string\n           *  @default Showing 0 to 0 of 0 entries\n           *\n           *  @dtopt Language\n           *  @name DataTable.defaults.language.infoEmpty\n           *\n           *  @example\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"infoEmpty\": \"No entries to show\"\n           *        }\n           *      } );\n           *    } );\n           */\n          sInfoEmpty: 'Showing 0 to 0 of 0 entries',\n\n          /**\n           * When a user filters the information in a table, this string is appended\n           * to the information (`info`) to give an idea of how strong the filtering\n           * is. The variable _MAX_ is dynamically updated.\n           *  @type string\n           *  @default (filtered from _MAX_ total entries)\n           *\n           *  @dtopt Language\n           *  @name DataTable.defaults.language.infoFiltered\n           *\n           *  @example\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"infoFiltered\": \" - filtering from _MAX_ records\"\n           *        }\n           *      } );\n           *    } );\n           */\n          sInfoFiltered: '(filtered from _MAX_ total entries)',\n\n          /**\n           * If can be useful to append extra information to the info string at times,\n           * and this variable does exactly that. This information will be appended to\n           * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are\n           * being used) at all times.\n           *  @type string\n           *  @default <i>Empty string</i>\n           *\n           *  @dtopt Language\n           *  @name DataTable.defaults.language.infoPostFix\n           *\n           *  @example\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"infoPostFix\": \"All records shown are derived from real information.\"\n           *        }\n           *      } );\n           *    } );\n           */\n          sInfoPostFix: '',\n\n          /**\n           * This decimal place operator is a little different from the other\n           * language options since DataTables doesn't output floating point\n           * numbers, so it won't ever use this for display of a number. Rather,\n           * what this parameter does is modify the sort methods of the table so\n           * that numbers which are in a format which has a character other than\n           * a period (`.`) as a decimal place will be sorted numerically.\n           *\n           * Note that numbers with different decimal places cannot be shown in\n           * the same table and still be sortable, the table must be consistent.\n           * However, multiple different tables on the page can use different\n           * decimal place characters.\n           *  @type string\n           *  @default\n           *\n           *  @dtopt Language\n           *  @name DataTable.defaults.language.decimal\n           *\n           *  @example\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"decimal\": \",\"\n           *          \"thousands\": \".\"\n           *        }\n           *      } );\n           *    } );\n           */\n          sDecimal: '',\n\n          /**\n           * DataTables has a build in number formatter (`formatNumber`) which is\n           * used to format large numbers that are used in the table information.\n           * By default a comma is used, but this can be trivially changed to any\n           * character you wish with this parameter.\n           *  @type string\n           *  @default ,\n           *\n           *  @dtopt Language\n           *  @name DataTable.defaults.language.thousands\n           *\n           *  @example\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"thousands\": \"'\"\n           *        }\n           *      } );\n           *    } );\n           */\n          sThousands: ',',\n\n          /**\n           * Detail the action that will be taken when the drop down menu for the\n           * pagination length option is changed. The '_MENU_' variable is replaced\n           * with a default select list of 10, 25, 50 and 100, and can be replaced\n           * with a custom select box if required.\n           *  @type string\n           *  @default Show _MENU_ entries\n           *\n           *  @dtopt Language\n           *  @name DataTable.defaults.language.lengthMenu\n           *\n           *  @example\n           *    // Language change only\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"lengthMenu\": \"Display _MENU_ records\"\n           *        }\n           *      } );\n           *    } );\n           *\n           *  @example\n           *    // Language and options change\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"lengthMenu\": 'Display <select>'+\n           *            '<option value=\"10\">10</option>'+\n           *            '<option value=\"20\">20</option>'+\n           *            '<option value=\"30\">30</option>'+\n           *            '<option value=\"40\">40</option>'+\n           *            '<option value=\"50\">50</option>'+\n           *            '<option value=\"-1\">All</option>'+\n           *            '</select> records'\n           *        }\n           *      } );\n           *    } );\n           */\n          sLengthMenu: 'Show _MENU_ entries',\n\n          /**\n           * When using Ajax sourced data and during the first draw when DataTables is\n           * gathering the data, this message is shown in an empty row in the table to\n           * indicate to the end user the the data is being loaded. Note that this\n           * parameter is not used when loading data by server-side processing, just\n           * Ajax sourced data with client-side processing.\n           *  @type string\n           *  @default Loading...\n           *\n           *  @dtopt Language\n           *  @name DataTable.defaults.language.loadingRecords\n           *\n           *  @example\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"loadingRecords\": \"Please wait - loading...\"\n           *        }\n           *      } );\n           *    } );\n           */\n          sLoadingRecords: 'Loading...',\n\n          /**\n           * Text which is displayed when the table is processing a user action\n           * (usually a sort command or similar).\n           *  @type string\n           *  @default Processing...\n           *\n           *  @dtopt Language\n           *  @name DataTable.defaults.language.processing\n           *\n           *  @example\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"processing\": \"DataTables is currently busy\"\n           *        }\n           *      } );\n           *    } );\n           */\n          sProcessing: 'Processing...',\n\n          /**\n           * Details the actions that will be taken when the user types into the\n           * filtering input text box. The variable \"_INPUT_\", if used in the string,\n           * is replaced with the HTML text box for the filtering input allowing\n           * control over where it appears in the string. If \"_INPUT_\" is not given\n           * then the input box is appended to the string automatically.\n           *  @type string\n           *  @default Search:\n           *\n           *  @dtopt Language\n           *  @name DataTable.defaults.language.search\n           *\n           *  @example\n           *    // Input text box will be appended at the end automatically\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"search\": \"Filter records:\"\n           *        }\n           *      } );\n           *    } );\n           *\n           *  @example\n           *    // Specify where the filter should appear\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"search\": \"Apply filter _INPUT_ to table\"\n           *        }\n           *      } );\n           *    } );\n           */\n          sSearch: 'Search:',\n\n          /**\n           * Assign a `placeholder` attribute to the search `input` element\n           *  @type string\n           *  @default\n           *\n           *  @dtopt Language\n           *  @name DataTable.defaults.language.searchPlaceholder\n           */\n          sSearchPlaceholder: '',\n\n          /**\n           * All of the language information can be stored in a file on the\n           * server-side, which DataTables will look up if this parameter is passed.\n           * It must store the URL of the language file, which is in a JSON format,\n           * and the object has the same properties as the oLanguage object in the\n           * initialiser object (i.e. the above parameters). Please refer to one of\n           * the example language files to see how this works in action.\n           *  @type string\n           *  @default <i>Empty string - i.e. disabled</i>\n           *\n           *  @dtopt Language\n           *  @name DataTable.defaults.language.url\n           *\n           *  @example\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"url\": \"http://www.sprymedia.co.uk/dataTables/lang.txt\"\n           *        }\n           *      } );\n           *    } );\n           */\n          sUrl: '',\n\n          /**\n           * Text shown inside the table records when the is no information to be\n           * displayed after filtering. `emptyTable` is shown when there is simply no\n           * information in the table at all (regardless of filtering).\n           *  @type string\n           *  @default No matching records found\n           *\n           *  @dtopt Language\n           *  @name DataTable.defaults.language.zeroRecords\n           *\n           *  @example\n           *    $(document).ready( function() {\n           *      $('#example').dataTable( {\n           *        \"language\": {\n           *          \"zeroRecords\": \"No records to display\"\n           *        }\n           *      } );\n           *    } );\n           */\n          sZeroRecords: 'No matching records found'\n        },\n\n        /**\n         * This parameter allows you to have define the global filtering state at\n         * initialisation time. As an object the `search` parameter must be\n         * defined, but all other parameters are optional. When `regex` is true,\n         * the search string will be treated as a regular expression, when false\n         * (default) it will be treated as a straight string. When `smart`\n         * DataTables will use it's smart filtering methods (to word match at\n         * any point in the data), when false this will not be done.\n         *  @namespace\n         *  @extends DataTable.models.oSearch\n         *\n         *  @dtopt Options\n         *  @name DataTable.defaults.search\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"search\": {\"search\": \"Initial search\"}\n         *      } );\n         *    } )\n         */\n        oSearch: $.extend({}, DataTable.models.oSearch),\n\n        /**\n         * __Deprecated__ The functionality provided by this parameter has now been\n         * superseded by that provided through `ajax`, which should be used instead.\n         *\n         * By default DataTables will look for the property `data` (or `aaData` for\n         * compatibility with DataTables 1.9-) when obtaining data from an Ajax\n         * source or for server-side processing - this parameter allows that\n         * property to be changed. You can use Javascript dotted object notation to\n         * get a data source for multiple levels of nesting.\n         *  @type string\n         *  @default data\n         *\n         *  @dtopt Options\n         *  @dtopt Server-side\n         *  @name DataTable.defaults.ajaxDataProp\n         *\n         *  @deprecated 1.10. Please use `ajax` for this functionality now.\n         */\n        sAjaxDataProp: 'data',\n\n        /**\n         * __Deprecated__ The functionality provided by this parameter has now been\n         * superseded by that provided through `ajax`, which should be used instead.\n         *\n         * You can instruct DataTables to load data from an external\n         * source using this parameter (use aData if you want to pass data in you\n         * already have). Simply provide a url a JSON object can be obtained from.\n         *  @type string\n         *  @default null\n         *\n         *  @dtopt Options\n         *  @dtopt Server-side\n         *  @name DataTable.defaults.ajaxSource\n         *\n         *  @deprecated 1.10. Please use `ajax` for this functionality now.\n         */\n        sAjaxSource: null,\n\n        /**\n         * This initialisation variable allows you to specify exactly where in the\n         * DOM you want DataTables to inject the various controls it adds to the page\n         * (for example you might want the pagination controls at the top of the\n         * table). DIV elements (with or without a custom class) can also be added to\n         * aid styling. The follow syntax is used:\n         *   <ul>\n         *     <li>The following options are allowed:\n         *       <ul>\n         *         <li>'l' - Length changing</li>\n         *         <li>'f' - Filtering input</li>\n         *         <li>'t' - The table!</li>\n         *         <li>'i' - Information</li>\n         *         <li>'p' - Pagination</li>\n         *         <li>'r' - pRocessing</li>\n         *       </ul>\n         *     </li>\n         *     <li>The following constants are allowed:\n         *       <ul>\n         *         <li>'H' - jQueryUI theme \"header\" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>\n         *         <li>'F' - jQueryUI theme \"footer\" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>\n         *       </ul>\n         *     </li>\n         *     <li>The following syntax is expected:\n         *       <ul>\n         *         <li>'&lt;' and '&gt;' - div elements</li>\n         *         <li>'&lt;\"class\" and '&gt;' - div with a class</li>\n         *         <li>'&lt;\"#id\" and '&gt;' - div with an ID</li>\n         *       </ul>\n         *     </li>\n         *     <li>Examples:\n         *       <ul>\n         *         <li>'&lt;\"wrapper\"flipt&gt;'</li>\n         *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>\n         *       </ul>\n         *     </li>\n         *   </ul>\n         *  @type string\n         *  @default lfrtip <i>(when `jQueryUI` is false)</i> <b>or</b>\n         *    <\"H\"lfr>t<\"F\"ip> <i>(when `jQueryUI` is true)</i>\n         *\n         *  @dtopt Options\n         *  @name DataTable.defaults.dom\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"dom\": '&lt;\"top\"i&gt;rt&lt;\"bottom\"flp&gt;&lt;\"clear\"&gt;'\n         *      } );\n         *    } );\n         */\n        sDom: 'lfrtip',\n\n        /**\n         * DataTables features four different built-in options for the buttons to\n         * display for pagination control:\n         *\n         * * `simple` - 'Previous' and 'Next' buttons only\n         * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers\n         * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons\n         * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus\n         *   page numbers\n         *\n         * Further methods can be added using {@link DataTable.ext.oPagination}.\n         *  @type string\n         *  @default simple_numbers\n         *\n         *  @dtopt Options\n         *  @name DataTable.defaults.pagingType\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"pagingType\": \"full_numbers\"\n         *      } );\n         *    } )\n         */\n        sPaginationType: 'simple_numbers',\n\n        /**\n         * Enable horizontal scrolling. When a table is too wide to fit into a\n         * certain layout, or you have a large number of columns in the table, you\n         * can enable x-scrolling to show the table in a viewport, which can be\n         * scrolled. This property can be `true` which will allow the table to\n         * scroll horizontally when needed, or any CSS unit, or a number (in which\n         * case it will be treated as a pixel measurement). Setting as simply `true`\n         * is recommended.\n         *  @type boolean|string\n         *  @default <i>blank string - i.e. disabled</i>\n         *\n         *  @dtopt Features\n         *  @name DataTable.defaults.scrollX\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"scrollX\": true,\n         *        \"scrollCollapse\": true\n         *      } );\n         *    } );\n         */\n        sScrollX: '',\n\n        /**\n         * This property can be used to force a DataTable to use more width than it\n         * might otherwise do when x-scrolling is enabled. For example if you have a\n         * table which requires to be well spaced, this parameter is useful for\n         * \"over-sizing\" the table, and thus forcing scrolling. This property can by\n         * any CSS unit, or a number (in which case it will be treated as a pixel\n         * measurement).\n         *  @type string\n         *  @default <i>blank string - i.e. disabled</i>\n         *\n         *  @dtopt Options\n         *  @name DataTable.defaults.scrollXInner\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"scrollX\": \"100%\",\n         *        \"scrollXInner\": \"110%\"\n         *      } );\n         *    } );\n         */\n        sScrollXInner: '',\n\n        /**\n         * Enable vertical scrolling. Vertical scrolling will constrain the DataTable\n         * to the given height, and enable scrolling for any data which overflows the\n         * current viewport. This can be used as an alternative to paging to display\n         * a lot of data in a small area (although paging and scrolling can both be\n         * enabled at the same time). This property can be any CSS unit, or a number\n         * (in which case it will be treated as a pixel measurement).\n         *  @type string\n         *  @default <i>blank string - i.e. disabled</i>\n         *\n         *  @dtopt Features\n         *  @name DataTable.defaults.scrollY\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"scrollY\": \"200px\",\n         *        \"paginate\": false\n         *      } );\n         *    } );\n         */\n        sScrollY: '',\n\n        /**\n         * __Deprecated__ The functionality provided by this parameter has now been\n         * superseded by that provided through `ajax`, which should be used instead.\n         *\n         * Set the HTTP method that is used to make the Ajax call for server-side\n         * processing or Ajax sourced data.\n         *  @type string\n         *  @default GET\n         *\n         *  @dtopt Options\n         *  @dtopt Server-side\n         *  @name DataTable.defaults.serverMethod\n         *\n         *  @deprecated 1.10. Please use `ajax` for this functionality now.\n         */\n        sServerMethod: 'GET',\n\n        /**\n         * DataTables makes use of renderers when displaying HTML elements for\n         * a table. These renderers can be added or modified by plug-ins to\n         * generate suitable mark-up for a site. For example the Bootstrap\n         * integration plug-in for DataTables uses a paging button renderer to\n         * display pagination buttons in the mark-up required by Bootstrap.\n         *\n         * For further information about the renderers available see\n         * DataTable.ext.renderer\n         *  @type string|object\n         *  @default null\n         *\n         *  @name DataTable.defaults.renderer\n         *\n         */\n        renderer: null\n      }\n\n      _fnHungarianMap(DataTable.defaults)\n\n      /*\n       * Developer note - See note in model.defaults.js about the use of Hungarian\n       * notation and camel case.\n       */\n\n      /**\n       * Column options that can be given to DataTables at initialisation time.\n       *  @namespace\n       */\n      DataTable.defaults.column = {\n        /**\n         * Define which column(s) an order will occur on for this column. This\n         * allows a column's ordering to take multiple columns into account when\n         * doing a sort or use the data from a different column. For example first\n         * name / last name columns make sense to do a multi-column sort over the\n         * two columns.\n         *  @type array|int\n         *  @default null <i>Takes the value of the column index automatically</i>\n         *\n         *  @name DataTable.defaults.column.orderData\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Using `columnDefs`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [\n         *          { \"orderData\": [ 0, 1 ], \"targets\": [ 0 ] },\n         *          { \"orderData\": [ 1, 0 ], \"targets\": [ 1 ] },\n         *          { \"orderData\": 2, \"targets\": [ 2 ] }\n         *        ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Using `columns`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columns\": [\n         *          { \"orderData\": [ 0, 1 ] },\n         *          { \"orderData\": [ 1, 0 ] },\n         *          { \"orderData\": 2 },\n         *          null,\n         *          null\n         *        ]\n         *      } );\n         *    } );\n         */\n        aDataSort: null,\n        iDataSort: -1,\n\n        /**\n         * You can control the default ordering direction, and even alter the\n         * behaviour of the sort handler (i.e. only allow ascending ordering etc)\n         * using this parameter.\n         *  @type array\n         *  @default [ 'asc', 'desc' ]\n         *\n         *  @name DataTable.defaults.column.orderSequence\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Using `columnDefs`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [\n         *          { \"orderSequence\": [ \"asc\" ], \"targets\": [ 1 ] },\n         *          { \"orderSequence\": [ \"desc\", \"asc\", \"asc\" ], \"targets\": [ 2 ] },\n         *          { \"orderSequence\": [ \"desc\" ], \"targets\": [ 3 ] }\n         *        ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Using `columns`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columns\": [\n         *          null,\n         *          { \"orderSequence\": [ \"asc\" ] },\n         *          { \"orderSequence\": [ \"desc\", \"asc\", \"asc\" ] },\n         *          { \"orderSequence\": [ \"desc\" ] },\n         *          null\n         *        ]\n         *      } );\n         *    } );\n         */\n        asSorting: ['asc', 'desc'],\n\n        /**\n         * Enable or disable filtering on the data in this column.\n         *  @type boolean\n         *  @default true\n         *\n         *  @name DataTable.defaults.column.searchable\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Using `columnDefs`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [\n         *          { \"searchable\": false, \"targets\": [ 0 ] }\n         *        ] } );\n         *    } );\n         *\n         *  @example\n         *    // Using `columns`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columns\": [\n         *          { \"searchable\": false },\n         *          null,\n         *          null,\n         *          null,\n         *          null\n         *        ] } );\n         *    } );\n         */\n        bSearchable: true,\n\n        /**\n         * Enable or disable ordering on this column.\n         *  @type boolean\n         *  @default true\n         *\n         *  @name DataTable.defaults.column.orderable\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Using `columnDefs`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [\n         *          { \"orderable\": false, \"targets\": [ 0 ] }\n         *        ] } );\n         *    } );\n         *\n         *  @example\n         *    // Using `columns`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columns\": [\n         *          { \"orderable\": false },\n         *          null,\n         *          null,\n         *          null,\n         *          null\n         *        ] } );\n         *    } );\n         */\n        bSortable: true,\n\n        /**\n         * Enable or disable the display of this column.\n         *  @type boolean\n         *  @default true\n         *\n         *  @name DataTable.defaults.column.visible\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Using `columnDefs`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [\n         *          { \"visible\": false, \"targets\": [ 0 ] }\n         *        ] } );\n         *    } );\n         *\n         *  @example\n         *    // Using `columns`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columns\": [\n         *          { \"visible\": false },\n         *          null,\n         *          null,\n         *          null,\n         *          null\n         *        ] } );\n         *    } );\n         */\n        bVisible: true,\n\n        /**\n         * Developer definable function that is called whenever a cell is created (Ajax source,\n         * etc) or processed for input (DOM source). This can be used as a compliment to mRender\n         * allowing you to modify the DOM element (add background colour for example) when the\n         * element is available.\n         *  @type function\n         *  @param {element} td The TD node that has been created\n         *  @param {*} cellData The Data for the cell\n         *  @param {array|object} rowData The data for the whole row\n         *  @param {int} row The row index for the aoData data store\n         *  @param {int} col The column index for aoColumns\n         *\n         *  @name DataTable.defaults.column.createdCell\n         *  @dtopt Columns\n         *\n         *  @example\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [ {\n         *          \"targets\": [3],\n         *          \"createdCell\": function (td, cellData, rowData, row, col) {\n         *            if ( cellData == \"1.7\" ) {\n         *              $(td).css('color', 'blue')\n         *            }\n         *          }\n         *        } ]\n         *      });\n         *    } );\n         */\n        fnCreatedCell: null,\n\n        /**\n         * This parameter has been replaced by `data` in DataTables to ensure naming\n         * consistency. `dataProp` can still be used, as there is backwards\n         * compatibility in DataTables for this option, but it is strongly\n         * recommended that you use `data` in preference to `dataProp`.\n         *  @name DataTable.defaults.column.dataProp\n         */\n\n        /**\n         * This property can be used to read data from any data source property,\n         * including deeply nested objects / properties. `data` can be given in a\n         * number of different ways which effect its behaviour:\n         *\n         * * `integer` - treated as an array index for the data source. This is the\n         *   default that DataTables uses (incrementally increased for each column).\n         * * `string` - read an object property from the data source. There are\n         *   three 'special' options that can be used in the string to alter how\n         *   DataTables reads the data from the source object:\n         *    * `.` - Dotted Javascript notation. Just as you use a `.` in\n         *      Javascript to read from nested objects, so to can the options\n         *      specified in `data`. For example: `browser.version` or\n         *      `browser.name`. If your object parameter name contains a period, use\n         *      `\\\\` to escape it - i.e. `first\\\\.name`.\n         *    * `[]` - Array notation. DataTables can automatically combine data\n         *      from and array source, joining the data with the characters provided\n         *      between the two brackets. For example: `name[, ]` would provide a\n         *      comma-space separated list from the source array. If no characters\n         *      are provided between the brackets, the original array source is\n         *      returned.\n         *    * `()` - Function notation. Adding `()` to the end of a parameter will\n         *      execute a function of the name given. For example: `browser()` for a\n         *      simple function on the data source, `browser.version()` for a\n         *      function in a nested property or even `browser().version` to get an\n         *      object property if the function called returns an object. Note that\n         *      function notation is recommended for use in `render` rather than\n         *      `data` as it is much simpler to use as a renderer.\n         * * `null` - use the original data source for the row rather than plucking\n         *   data directly from it. This action has effects on two other\n         *   initialisation options:\n         *    * `defaultContent` - When null is given as the `data` option and\n         *      `defaultContent` is specified for the column, the value defined by\n         *      `defaultContent` will be used for the cell.\n         *    * `render` - When null is used for the `data` option and the `render`\n         *      option is specified for the column, the whole data source for the\n         *      row is used for the renderer.\n         * * `function` - the function given will be executed whenever DataTables\n         *   needs to set or get the data for a cell in the column. The function\n         *   takes three parameters:\n         *    * Parameters:\n         *      * `{array|object}` The data source for the row\n         *      * `{string}` The type call data requested - this will be 'set' when\n         *        setting data or 'filter', 'display', 'type', 'sort' or undefined\n         *        when gathering data. Note that when `undefined` is given for the\n         *        type DataTables expects to get the raw data for the object back<\n         *      * `{*}` Data to set when the second parameter is 'set'.\n         *    * Return:\n         *      * The return value from the function is not required when 'set' is\n         *        the type of call, but otherwise the return is what will be used\n         *        for the data requested.\n         *\n         * Note that `data` is a getter and setter option. If you just require\n         * formatting of data for output, you will likely want to use `render` which\n         * is simply a getter and thus simpler to use.\n         *\n         * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The\n         * name change reflects the flexibility of this property and is consistent\n         * with the naming of mRender. If 'mDataProp' is given, then it will still\n         * be used by DataTables, as it automatically maps the old name to the new\n         * if required.\n         *\n         *  @type string|int|function|null\n         *  @default null <i>Use automatically calculated column index</i>\n         *\n         *  @name DataTable.defaults.column.data\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Read table data from objects\n         *    // JSON structure for each row:\n         *    //   {\n         *    //      \"engine\": {value},\n         *    //      \"browser\": {value},\n         *    //      \"platform\": {value},\n         *    //      \"version\": {value},\n         *    //      \"grade\": {value}\n         *    //   }\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"ajaxSource\": \"sources/objects.txt\",\n         *        \"columns\": [\n         *          { \"data\": \"engine\" },\n         *          { \"data\": \"browser\" },\n         *          { \"data\": \"platform\" },\n         *          { \"data\": \"version\" },\n         *          { \"data\": \"grade\" }\n         *        ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Read information from deeply nested objects\n         *    // JSON structure for each row:\n         *    //   {\n         *    //      \"engine\": {value},\n         *    //      \"browser\": {value},\n         *    //      \"platform\": {\n         *    //         \"inner\": {value}\n         *    //      },\n         *    //      \"details\": [\n         *    //         {value}, {value}\n         *    //      ]\n         *    //   }\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"ajaxSource\": \"sources/deep.txt\",\n         *        \"columns\": [\n         *          { \"data\": \"engine\" },\n         *          { \"data\": \"browser\" },\n         *          { \"data\": \"platform.inner\" },\n         *          { \"data\": \"platform.details.0\" },\n         *          { \"data\": \"platform.details.1\" }\n         *        ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Using `data` as a function to provide different information for\n         *    // sorting, filtering and display. In this case, currency (price)\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [ {\n         *          \"targets\": [ 0 ],\n         *          \"data\": function ( source, type, val ) {\n         *            if (type === 'set') {\n         *              source.price = val;\n         *              // Store the computed dislay and filter values for efficiency\n         *              source.price_display = val==\"\" ? \"\" : \"$\"+numberFormat(val);\n         *              source.price_filter  = val==\"\" ? \"\" : \"$\"+numberFormat(val)+\" \"+val;\n         *              return;\n         *            }\n         *            else if (type === 'display') {\n         *              return source.price_display;\n         *            }\n         *            else if (type === 'filter') {\n         *              return source.price_filter;\n         *            }\n         *            // 'sort', 'type' and undefined all just use the integer\n         *            return source.price;\n         *          }\n         *        } ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Using default content\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [ {\n         *          \"targets\": [ 0 ],\n         *          \"data\": null,\n         *          \"defaultContent\": \"Click to edit\"\n         *        } ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Using array notation - outputting a list from an array\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [ {\n         *          \"targets\": [ 0 ],\n         *          \"data\": \"name[, ]\"\n         *        } ]\n         *      } );\n         *    } );\n         *\n         */\n        mData: null,\n\n        /**\n         * This property is the rendering partner to `data` and it is suggested that\n         * when you want to manipulate data for display (including filtering,\n         * sorting etc) without altering the underlying data for the table, use this\n         * property. `render` can be considered to be the the read only companion to\n         * `data` which is read / write (then as such more complex). Like `data`\n         * this option can be given in a number of different ways to effect its\n         * behaviour:\n         *\n         * * `integer` - treated as an array index for the data source. This is the\n         *   default that DataTables uses (incrementally increased for each column).\n         * * `string` - read an object property from the data source. There are\n         *   three 'special' options that can be used in the string to alter how\n         *   DataTables reads the data from the source object:\n         *    * `.` - Dotted Javascript notation. Just as you use a `.` in\n         *      Javascript to read from nested objects, so to can the options\n         *      specified in `data`. For example: `browser.version` or\n         *      `browser.name`. If your object parameter name contains a period, use\n         *      `\\\\` to escape it - i.e. `first\\\\.name`.\n         *    * `[]` - Array notation. DataTables can automatically combine data\n         *      from and array source, joining the data with the characters provided\n         *      between the two brackets. For example: `name[, ]` would provide a\n         *      comma-space separated list from the source array. If no characters\n         *      are provided between the brackets, the original array source is\n         *      returned.\n         *    * `()` - Function notation. Adding `()` to the end of a parameter will\n         *      execute a function of the name given. For example: `browser()` for a\n         *      simple function on the data source, `browser.version()` for a\n         *      function in a nested property or even `browser().version` to get an\n         *      object property if the function called returns an object.\n         * * `object` - use different data for the different data types requested by\n         *   DataTables ('filter', 'display', 'type' or 'sort'). The property names\n         *   of the object is the data type the property refers to and the value can\n         *   defined using an integer, string or function using the same rules as\n         *   `render` normally does. Note that an `_` option _must_ be specified.\n         *   This is the default value to use if you haven't specified a value for\n         *   the data type requested by DataTables.\n         * * `function` - the function given will be executed whenever DataTables\n         *   needs to set or get the data for a cell in the column. The function\n         *   takes three parameters:\n         *    * Parameters:\n         *      * {array|object} The data source for the row (based on `data`)\n         *      * {string} The type call data requested - this will be 'filter',\n         *        'display', 'type' or 'sort'.\n         *      * {array|object} The full data source for the row (not based on\n         *        `data`)\n         *    * Return:\n         *      * The return value from the function is what will be used for the\n         *        data requested.\n         *\n         *  @type string|int|function|object|null\n         *  @default null Use the data source value.\n         *\n         *  @name DataTable.defaults.column.render\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Create a comma separated list from an array of objects\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"ajaxSource\": \"sources/deep.txt\",\n         *        \"columns\": [\n         *          { \"data\": \"engine\" },\n         *          { \"data\": \"browser\" },\n         *          {\n         *            \"data\": \"platform\",\n         *            \"render\": \"[, ].name\"\n         *          }\n         *        ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Execute a function to obtain data\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [ {\n         *          \"targets\": [ 0 ],\n         *          \"data\": null, // Use the full data source object for the renderer's source\n         *          \"render\": \"browserName()\"\n         *        } ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // As an object, extracting different data for the different types\n         *    // This would be used with a data source such as:\n         *    //   { \"phone\": 5552368, \"phone_filter\": \"5552368 555-2368\", \"phone_display\": \"555-2368\" }\n         *    // Here the `phone` integer is used for sorting and type detection, while `phone_filter`\n         *    // (which has both forms) is used for filtering for if a user inputs either format, while\n         *    // the formatted phone number is the one that is shown in the table.\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [ {\n         *          \"targets\": [ 0 ],\n         *          \"data\": null, // Use the full data source object for the renderer's source\n         *          \"render\": {\n         *            \"_\": \"phone\",\n         *            \"filter\": \"phone_filter\",\n         *            \"display\": \"phone_display\"\n         *          }\n         *        } ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Use as a function to create a link from the data source\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [ {\n         *          \"targets\": [ 0 ],\n         *          \"data\": \"download_link\",\n         *          \"render\": function ( data, type, full ) {\n         *            return '<a href=\"'+data+'\">Download</a>';\n         *          }\n         *        } ]\n         *      } );\n         *    } );\n         */\n        mRender: null,\n\n        /**\n         * Change the cell type created for the column - either TD cells or TH cells. This\n         * can be useful as TH cells have semantic meaning in the table body, allowing them\n         * to act as a header for a row (you may wish to add scope='row' to the TH elements).\n         *  @type string\n         *  @default td\n         *\n         *  @name DataTable.defaults.column.cellType\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Make the first column use TH cells\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [ {\n         *          \"targets\": [ 0 ],\n         *          \"cellType\": \"th\"\n         *        } ]\n         *      } );\n         *    } );\n         */\n        sCellType: 'td',\n\n        /**\n         * Class to give to each cell in this column.\n         *  @type string\n         *  @default <i>Empty string</i>\n         *\n         *  @name DataTable.defaults.column.class\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Using `columnDefs`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [\n         *          { \"class\": \"my_class\", \"targets\": [ 0 ] }\n         *        ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Using `columns`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columns\": [\n         *          { \"class\": \"my_class\" },\n         *          null,\n         *          null,\n         *          null,\n         *          null\n         *        ]\n         *      } );\n         *    } );\n         */\n        sClass: '',\n\n        /**\n         * When DataTables calculates the column widths to assign to each column,\n         * it finds the longest string in each column and then constructs a\n         * temporary table and reads the widths from that. The problem with this\n         * is that \"mmm\" is much wider then \"iiii\", but the latter is a longer\n         * string - thus the calculation can go wrong (doing it properly and putting\n         * it into an DOM object and measuring that is horribly(!) slow). Thus as\n         * a \"work around\" we provide this option. It will append its value to the\n         * text that is found to be the longest string for the column - i.e. padding.\n         * Generally you shouldn't need this!\n         *  @type string\n         *  @default <i>Empty string<i>\n         *\n         *  @name DataTable.defaults.column.contentPadding\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Using `columns`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columns\": [\n         *          null,\n         *          null,\n         *          null,\n         *          {\n         *            \"contentPadding\": \"mmm\"\n         *          }\n         *        ]\n         *      } );\n         *    } );\n         */\n        sContentPadding: '',\n\n        /**\n         * Allows a default value to be given for a column's data, and will be used\n         * whenever a null data source is encountered (this can be because `data`\n         * is set to null, or because the data source itself is null).\n         *  @type string\n         *  @default null\n         *\n         *  @name DataTable.defaults.column.defaultContent\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Using `columnDefs`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [\n         *          {\n         *            \"data\": null,\n         *            \"defaultContent\": \"Edit\",\n         *            \"targets\": [ -1 ]\n         *          }\n         *        ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Using `columns`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columns\": [\n         *          null,\n         *          null,\n         *          null,\n         *          {\n         *            \"data\": null,\n         *            \"defaultContent\": \"Edit\"\n         *          }\n         *        ]\n         *      } );\n         *    } );\n         */\n        sDefaultContent: null,\n\n        /**\n         * This parameter is only used in DataTables' server-side processing. It can\n         * be exceptionally useful to know what columns are being displayed on the\n         * client side, and to map these to database fields. When defined, the names\n         * also allow DataTables to reorder information from the server if it comes\n         * back in an unexpected order (i.e. if you switch your columns around on the\n         * client-side, your server-side code does not also need updating).\n         *  @type string\n         *  @default <i>Empty string</i>\n         *\n         *  @name DataTable.defaults.column.name\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Using `columnDefs`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [\n         *          { \"name\": \"engine\", \"targets\": [ 0 ] },\n         *          { \"name\": \"browser\", \"targets\": [ 1 ] },\n         *          { \"name\": \"platform\", \"targets\": [ 2 ] },\n         *          { \"name\": \"version\", \"targets\": [ 3 ] },\n         *          { \"name\": \"grade\", \"targets\": [ 4 ] }\n         *        ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Using `columns`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columns\": [\n         *          { \"name\": \"engine\" },\n         *          { \"name\": \"browser\" },\n         *          { \"name\": \"platform\" },\n         *          { \"name\": \"version\" },\n         *          { \"name\": \"grade\" }\n         *        ]\n         *      } );\n         *    } );\n         */\n        sName: '',\n\n        /**\n         * Defines a data source type for the ordering which can be used to read\n         * real-time information from the table (updating the internally cached\n         * version) prior to ordering. This allows ordering to occur on user\n         * editable elements such as form inputs.\n         *  @type string\n         *  @default std\n         *\n         *  @name DataTable.defaults.column.orderDataType\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Using `columnDefs`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [\n         *          { \"orderDataType\": \"dom-text\", \"targets\": [ 2, 3 ] },\n         *          { \"type\": \"numeric\", \"targets\": [ 3 ] },\n         *          { \"orderDataType\": \"dom-select\", \"targets\": [ 4 ] },\n         *          { \"orderDataType\": \"dom-checkbox\", \"targets\": [ 5 ] }\n         *        ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Using `columns`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columns\": [\n         *          null,\n         *          null,\n         *          { \"orderDataType\": \"dom-text\" },\n         *          { \"orderDataType\": \"dom-text\", \"type\": \"numeric\" },\n         *          { \"orderDataType\": \"dom-select\" },\n         *          { \"orderDataType\": \"dom-checkbox\" }\n         *        ]\n         *      } );\n         *    } );\n         */\n        sSortDataType: 'std',\n\n        /**\n         * The title of this column.\n         *  @type string\n         *  @default null <i>Derived from the 'TH' value for this column in the\n         *    original HTML table.</i>\n         *\n         *  @name DataTable.defaults.column.title\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Using `columnDefs`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [\n         *          { \"title\": \"My column title\", \"targets\": [ 0 ] }\n         *        ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Using `columns`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columns\": [\n         *          { \"title\": \"My column title\" },\n         *          null,\n         *          null,\n         *          null,\n         *          null\n         *        ]\n         *      } );\n         *    } );\n         */\n        sTitle: null,\n\n        /**\n         * The type allows you to specify how the data for this column will be\n         * ordered. Four types (string, numeric, date and html (which will strip\n         * HTML tags before ordering)) are currently available. Note that only date\n         * formats understood by Javascript's Date() object will be accepted as type\n         * date. For example: \"Mar 26, 2008 5:03 PM\". May take the values: 'string',\n         * 'numeric', 'date' or 'html' (by default). Further types can be adding\n         * through plug-ins.\n         *  @type string\n         *  @default null <i>Auto-detected from raw data</i>\n         *\n         *  @name DataTable.defaults.column.type\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Using `columnDefs`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [\n         *          { \"type\": \"html\", \"targets\": [ 0 ] }\n         *        ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Using `columns`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columns\": [\n         *          { \"type\": \"html\" },\n         *          null,\n         *          null,\n         *          null,\n         *          null\n         *        ]\n         *      } );\n         *    } );\n         */\n        sType: null,\n\n        /**\n         * Defining the width of the column, this parameter may take any CSS value\n         * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not\n         * been given a specific width through this interface ensuring that the table\n         * remains readable.\n         *  @type string\n         *  @default null <i>Automatic</i>\n         *\n         *  @name DataTable.defaults.column.width\n         *  @dtopt Columns\n         *\n         *  @example\n         *    // Using `columnDefs`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columnDefs\": [\n         *          { \"width\": \"20%\", \"targets\": [ 0 ] }\n         *        ]\n         *      } );\n         *    } );\n         *\n         *  @example\n         *    // Using `columns`\n         *    $(document).ready( function() {\n         *      $('#example').dataTable( {\n         *        \"columns\": [\n         *          { \"width\": \"20%\" },\n         *          null,\n         *          null,\n         *          null,\n         *          null\n         *        ]\n         *      } );\n         *    } );\n         */\n        sWidth: null\n      }\n\n      _fnHungarianMap(DataTable.defaults.column)\n\n      /**\n       * DataTables settings object - this holds all the information needed for a\n       * given table, including configuration, data and current application of the\n       * table options. DataTables does not have a single instance for each DataTable\n       * with the settings attached to that instance, but rather instances of the\n       * DataTable \"class\" are created on-the-fly as needed (typically by a\n       * $().dataTable() call) and the settings object is then applied to that\n       * instance.\n       *\n       * Note that this object is related to {@link DataTable.defaults} but this\n       * one is the internal data store for DataTables's cache of columns. It should\n       * NOT be manipulated outside of DataTables. Any configuration should be done\n       * through the initialisation options.\n       *  @namespace\n       *  @todo Really should attach the settings object to individual instances so we\n       *    don't need to create new instances on each $().dataTable() call (if the\n       *    table already exists). It would also save passing oSettings around and\n       *    into every single function. However, this is a very significant\n       *    architecture change for DataTables and will almost certainly break\n       *    backwards compatibility with older installations. This is something that\n       *    will be done in 2.0.\n       */\n      DataTable.models.oSettings = {\n        /**\n         * Primary features of DataTables and their enablement state.\n         *  @namespace\n         */\n        oFeatures: {\n          /**\n           * Flag to say if DataTables should automatically try to calculate the\n           * optimum table and columns widths (true) or not (false).\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type boolean\n           */\n          bAutoWidth: null,\n\n          /**\n           * Delay the creation of TR and TD elements until they are actually\n           * needed by a driven page draw. This can give a significant speed\n           * increase for Ajax source and Javascript source data, but makes no\n           * difference at all fro DOM and server-side processing tables.\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type boolean\n           */\n          bDeferRender: null,\n\n          /**\n           * Enable filtering on the table or not. Note that if this is disabled\n           * then there is no filtering at all on the table, including fnFilter.\n           * To just remove the filtering input use sDom and remove the 'f' option.\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type boolean\n           */\n          bFilter: null,\n\n          /**\n           * Table information element (the 'Showing x of y records' div) enable\n           * flag.\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type boolean\n           */\n          bInfo: null,\n\n          /**\n           * Present a user control allowing the end user to change the page size\n           * when pagination is enabled.\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type boolean\n           */\n          bLengthChange: null,\n\n          /**\n           * Pagination enabled or not. Note that if this is disabled then length\n           * changing must also be disabled.\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type boolean\n           */\n          bPaginate: null,\n\n          /**\n           * Processing indicator enable flag whenever DataTables is enacting a\n           * user request - typically an Ajax request for server-side processing.\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type boolean\n           */\n          bProcessing: null,\n\n          /**\n           * Server-side processing enabled flag - when enabled DataTables will\n           * get all data from the server for every draw - there is no filtering,\n           * sorting or paging done on the client-side.\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type boolean\n           */\n          bServerSide: null,\n\n          /**\n           * Sorting enablement flag.\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type boolean\n           */\n          bSort: null,\n\n          /**\n           * Multi-column sorting\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type boolean\n           */\n          bSortMulti: null,\n\n          /**\n           * Apply a class to the columns which are being sorted to provide a\n           * visual highlight or not. This can slow things down when enabled since\n           * there is a lot of DOM interaction.\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type boolean\n           */\n          bSortClasses: null,\n\n          /**\n           * State saving enablement flag.\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type boolean\n           */\n          bStateSave: null\n        },\n\n        /**\n         * Scrolling settings for a table.\n         *  @namespace\n         */\n        oScroll: {\n          /**\n           * When the table is shorter in height than sScrollY, collapse the\n           * table container down to the height of the table (when true).\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type boolean\n           */\n          bCollapse: null,\n\n          /**\n           * Width of the scrollbar for the web-browser's platform. Calculated\n           * during table initialisation.\n           *  @type int\n           *  @default 0\n           */\n          iBarWidth: 0,\n\n          /**\n           * Viewport width for horizontal scrolling. Horizontal scrolling is\n           * disabled if an empty string.\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type string\n           */\n          sX: null,\n\n          /**\n           * Width to expand the table to when using x-scrolling. Typically you\n           * should not need to use this.\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type string\n           *  @deprecated\n           */\n          sXInner: null,\n\n          /**\n           * Viewport height for vertical scrolling. Vertical scrolling is disabled\n           * if an empty string.\n           * Note that this parameter will be set by the initialisation routine. To\n           * set a default use {@link DataTable.defaults}.\n           *  @type string\n           */\n          sY: null\n        },\n\n        /**\n         * Language information for the table.\n         *  @namespace\n         *  @extends DataTable.defaults.oLanguage\n         */\n        oLanguage: {\n          /**\n           * Information callback function. See\n           * {@link DataTable.defaults.fnInfoCallback}\n           *  @type function\n           *  @default null\n           */\n          fnInfoCallback: null\n        },\n\n        /**\n         * Browser support parameters\n         *  @namespace\n         */\n        oBrowser: {\n          /**\n           * Indicate if the browser incorrectly calculates width:100% inside a\n           * scrolling element (IE6/7)\n           *  @type boolean\n           *  @default false\n           */\n          bScrollOversize: false,\n\n          /**\n           * Determine if the vertical scrollbar is on the right or left of the\n           * scrolling container - needed for rtl language layout, although not\n           * all browsers move the scrollbar (Safari).\n           *  @type boolean\n           *  @default false\n           */\n          bScrollbarLeft: false\n        },\n\n        ajax: null,\n\n        /**\n         * Array referencing the nodes which are used for the features. The\n         * parameters of this object match what is allowed by sDom - i.e.\n         *   <ul>\n         *     <li>'l' - Length changing</li>\n         *     <li>'f' - Filtering input</li>\n         *     <li>'t' - The table!</li>\n         *     <li>'i' - Information</li>\n         *     <li>'p' - Pagination</li>\n         *     <li>'r' - pRocessing</li>\n         *   </ul>\n         *  @type array\n         *  @default []\n         */\n        aanFeatures: [],\n\n        /**\n         * Store data information - see {@link DataTable.models.oRow} for detailed\n         * information.\n         *  @type array\n         *  @default []\n         */\n        aoData: [],\n\n        /**\n         * Array of indexes which are in the current display (after filtering etc)\n         *  @type array\n         *  @default []\n         */\n        aiDisplay: [],\n\n        /**\n         * Array of indexes for display - no filtering\n         *  @type array\n         *  @default []\n         */\n        aiDisplayMaster: [],\n\n        /**\n         * Store information about each column that is in use\n         *  @type array\n         *  @default []\n         */\n        aoColumns: [],\n\n        /**\n         * Store information about the table's header\n         *  @type array\n         *  @default []\n         */\n        aoHeader: [],\n\n        /**\n         * Store information about the table's footer\n         *  @type array\n         *  @default []\n         */\n        aoFooter: [],\n\n        /**\n         * Store the applied global search information in case we want to force a\n         * research or compare the old search to a new one.\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @namespace\n         *  @extends DataTable.models.oSearch\n         */\n        oPreviousSearch: {},\n\n        /**\n         * Store the applied search for each column - see\n         * {@link DataTable.models.oSearch} for the format that is used for the\n         * filtering information for each column.\n         *  @type array\n         *  @default []\n         */\n        aoPreSearchCols: [],\n\n        /**\n         * Sorting that is applied to the table. Note that the inner arrays are\n         * used in the following manner:\n         * <ul>\n         *   <li>Index 0 - column number</li>\n         *   <li>Index 1 - current sorting direction</li>\n         * </ul>\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type array\n         *  @todo These inner arrays should really be objects\n         */\n        aaSorting: null,\n\n        /**\n         * Sorting that is always applied to the table (i.e. prefixed in front of\n         * aaSorting).\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type array\n         *  @default []\n         */\n        aaSortingFixed: [],\n\n        /**\n         * Classes to use for the striping of a table.\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type array\n         *  @default []\n         */\n        asStripeClasses: null,\n\n        /**\n         * If restoring a table - we should restore its striping classes as well\n         *  @type array\n         *  @default []\n         */\n        asDestroyStripes: [],\n\n        /**\n         * If restoring a table - we should restore its width\n         *  @type int\n         *  @default 0\n         */\n        sDestroyWidth: 0,\n\n        /**\n         * Callback functions array for every time a row is inserted (i.e. on a draw).\n         *  @type array\n         *  @default []\n         */\n        aoRowCallback: [],\n\n        /**\n         * Callback functions for the header on each draw.\n         *  @type array\n         *  @default []\n         */\n        aoHeaderCallback: [],\n\n        /**\n         * Callback function for the footer on each draw.\n         *  @type array\n         *  @default []\n         */\n        aoFooterCallback: [],\n\n        /**\n         * Array of callback functions for draw callback functions\n         *  @type array\n         *  @default []\n         */\n        aoDrawCallback: [],\n\n        /**\n         * Array of callback functions for row created function\n         *  @type array\n         *  @default []\n         */\n        aoRowCreatedCallback: [],\n\n        /**\n         * Callback functions for just before the table is redrawn. A return of\n         * false will be used to cancel the draw.\n         *  @type array\n         *  @default []\n         */\n        aoPreDrawCallback: [],\n\n        /**\n         * Callback functions for when the table has been initialised.\n         *  @type array\n         *  @default []\n         */\n        aoInitComplete: [],\n\n        /**\n         * Callbacks for modifying the settings to be stored for state saving, prior to\n         * saving state.\n         *  @type array\n         *  @default []\n         */\n        aoStateSaveParams: [],\n\n        /**\n         * Callbacks for modifying the settings that have been stored for state saving\n         * prior to using the stored values to restore the state.\n         *  @type array\n         *  @default []\n         */\n        aoStateLoadParams: [],\n\n        /**\n         * Callbacks for operating on the settings object once the saved state has been\n         * loaded\n         *  @type array\n         *  @default []\n         */\n        aoStateLoaded: [],\n\n        /**\n         * Cache the table ID for quick access\n         *  @type string\n         *  @default <i>Empty string</i>\n         */\n        sTableId: '',\n\n        /**\n         * The TABLE node for the main table\n         *  @type node\n         *  @default null\n         */\n        nTable: null,\n\n        /**\n         * Permanent ref to the thead element\n         *  @type node\n         *  @default null\n         */\n        nTHead: null,\n\n        /**\n         * Permanent ref to the tfoot element - if it exists\n         *  @type node\n         *  @default null\n         */\n        nTFoot: null,\n\n        /**\n         * Permanent ref to the tbody element\n         *  @type node\n         *  @default null\n         */\n        nTBody: null,\n\n        /**\n         * Cache the wrapper node (contains all DataTables controlled elements)\n         *  @type node\n         *  @default null\n         */\n        nTableWrapper: null,\n\n        /**\n         * Indicate if when using server-side processing the loading of data\n         * should be deferred until the second draw.\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type boolean\n         *  @default false\n         */\n        bDeferLoading: false,\n\n        /**\n         * Indicate if all required information has been read in\n         *  @type boolean\n         *  @default false\n         */\n        bInitialised: false,\n\n        /**\n         * Information about open rows. Each object in the array has the parameters\n         * 'nTr' and 'nParent'\n         *  @type array\n         *  @default []\n         */\n        aoOpenRows: [],\n\n        /**\n         * Dictate the positioning of DataTables' control elements - see\n         * {@link DataTable.model.oInit.sDom}.\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type string\n         *  @default null\n         */\n        sDom: null,\n\n        /**\n         * Which type of pagination should be used.\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type string\n         *  @default two_button\n         */\n        sPaginationType: 'two_button',\n\n        /**\n         * The state duration (for `stateSave`) in seconds.\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type int\n         *  @default 0\n         */\n        iStateDuration: 0,\n\n        /**\n         * Array of callback functions for state saving. Each array element is an\n         * object with the following parameters:\n         *   <ul>\n         *     <li>function:fn - function to call. Takes two parameters, oSettings\n         *       and the JSON string to save that has been thus far created. Returns\n         *       a JSON string to be inserted into a json object\n         *       (i.e. '\"param\": [ 0, 1, 2]')</li>\n         *     <li>string:sName - name of callback</li>\n         *   </ul>\n         *  @type array\n         *  @default []\n         */\n        aoStateSave: [],\n\n        /**\n         * Array of callback functions for state loading. Each array element is an\n         * object with the following parameters:\n         *   <ul>\n         *     <li>function:fn - function to call. Takes two parameters, oSettings\n         *       and the object stored. May return false to cancel state loading</li>\n         *     <li>string:sName - name of callback</li>\n         *   </ul>\n         *  @type array\n         *  @default []\n         */\n        aoStateLoad: [],\n\n        /**\n         * State that was saved. Useful for back reference\n         *  @type object\n         *  @default null\n         */\n        oSavedState: null,\n\n        /**\n         * State that was loaded. Useful for back reference\n         *  @type object\n         *  @default null\n         */\n        oLoadedState: null,\n\n        /**\n         * Source url for AJAX data for the table.\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type string\n         *  @default null\n         */\n        sAjaxSource: null,\n\n        /**\n         * Property from a given object from which to read the table data from. This\n         * can be an empty string (when not server-side processing), in which case\n         * it is  assumed an an array is given directly.\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type string\n         */\n        sAjaxDataProp: null,\n\n        /**\n         * Note if draw should be blocked while getting data\n         *  @type boolean\n         *  @default true\n         */\n        bAjaxDataGet: true,\n\n        /**\n         * The last jQuery XHR object that was used for server-side data gathering.\n         * This can be used for working with the XHR information in one of the\n         * callbacks\n         *  @type object\n         *  @default null\n         */\n        jqXHR: null,\n\n        /**\n         * JSON returned from the server in the last Ajax request\n         *  @type object\n         *  @default undefined\n         */\n        json: undefined,\n\n        /**\n         * Data submitted as part of the last Ajax request\n         *  @type object\n         *  @default undefined\n         */\n        oAjaxData: undefined,\n\n        /**\n         * Function to get the server-side data.\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type function\n         */\n        fnServerData: null,\n\n        /**\n         * Functions which are called prior to sending an Ajax request so extra\n         * parameters can easily be sent to the server\n         *  @type array\n         *  @default []\n         */\n        aoServerParams: [],\n\n        /**\n         * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if\n         * required).\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type string\n         */\n        sServerMethod: null,\n\n        /**\n         * Format numbers for display.\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type function\n         */\n        fnFormatNumber: null,\n\n        /**\n         * List of options that can be used for the user selectable length menu.\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type array\n         *  @default []\n         */\n        aLengthMenu: null,\n\n        /**\n         * Counter for the draws that the table does. Also used as a tracker for\n         * server-side processing\n         *  @type int\n         *  @default 0\n         */\n        iDraw: 0,\n\n        /**\n         * Indicate if a redraw is being done - useful for Ajax\n         *  @type boolean\n         *  @default false\n         */\n        bDrawing: false,\n\n        /**\n         * Draw index (iDraw) of the last error when parsing the returned data\n         *  @type int\n         *  @default -1\n         */\n        iDrawError: -1,\n\n        /**\n         * Paging display length\n         *  @type int\n         *  @default 10\n         */\n        _iDisplayLength: 10,\n\n        /**\n         * Paging start point - aiDisplay index\n         *  @type int\n         *  @default 0\n         */\n        _iDisplayStart: 0,\n\n        /**\n         * Server-side processing - number of records in the result set\n         * (i.e. before filtering), Use fnRecordsTotal rather than\n         * this property to get the value of the number of records, regardless of\n         * the server-side processing setting.\n         *  @type int\n         *  @default 0\n         *  @private\n         */\n        _iRecordsTotal: 0,\n\n        /**\n         * Server-side processing - number of records in the current display set\n         * (i.e. after filtering). Use fnRecordsDisplay rather than\n         * this property to get the value of the number of records, regardless of\n         * the server-side processing setting.\n         *  @type boolean\n         *  @default 0\n         *  @private\n         */\n        _iRecordsDisplay: 0,\n\n        /**\n         * Flag to indicate if jQuery UI marking and classes should be used.\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type boolean\n         */\n        bJUI: null,\n\n        /**\n         * The classes to use for the table\n         *  @type object\n         *  @default {}\n         */\n        oClasses: {},\n\n        /**\n         * Flag attached to the settings object so you can check in the draw\n         * callback if filtering has been done in the draw. Deprecated in favour of\n         * events.\n         *  @type boolean\n         *  @default false\n         *  @deprecated\n         */\n        bFiltered: false,\n\n        /**\n         * Flag attached to the settings object so you can check in the draw\n         * callback if sorting has been done in the draw. Deprecated in favour of\n         * events.\n         *  @type boolean\n         *  @default false\n         *  @deprecated\n         */\n        bSorted: false,\n\n        /**\n         * Indicate that if multiple rows are in the header and there is more than\n         * one unique cell per column, if the top one (true) or bottom one (false)\n         * should be used for sorting / title by DataTables.\n         * Note that this parameter will be set by the initialisation routine. To\n         * set a default use {@link DataTable.defaults}.\n         *  @type boolean\n         */\n        bSortCellsTop: null,\n\n        /**\n         * Initialisation object that is used for the table\n         *  @type object\n         *  @default null\n         */\n        oInit: null,\n\n        /**\n         * Destroy callback functions - for plug-ins to attach themselves to the\n         * destroy so they can clean up markup and events.\n         *  @type array\n         *  @default []\n         */\n        aoDestroyCallback: [],\n\n        /**\n         * Get the number of records in the current record set, before filtering\n         *  @type function\n         */\n        fnRecordsTotal: function () {\n          return _fnDataSource(this) == 'ssp' ? this._iRecordsTotal * 1 : this.aiDisplayMaster.length\n        },\n\n        /**\n         * Get the number of records in the current record set, after filtering\n         *  @type function\n         */\n        fnRecordsDisplay: function () {\n          return _fnDataSource(this) == 'ssp' ? this._iRecordsDisplay * 1 : this.aiDisplay.length\n        },\n\n        /**\n         * Get the display end point - aiDisplay index\n         *  @type function\n         */\n        fnDisplayEnd: function () {\n          var len = this._iDisplayLength,\n            start = this._iDisplayStart,\n            calc = start + len,\n            records = this.aiDisplay.length,\n            features = this.oFeatures,\n            paginate = features.bPaginate\n\n          if (features.bServerSide) {\n            return paginate === false || len === -1 ? start + records : Math.min(start + len, this._iRecordsDisplay)\n          } else {\n            return !paginate || calc > records || len === -1 ? records : calc\n          }\n        },\n\n        /**\n         * The DataTables object for this table\n         *  @type object\n         *  @default null\n         */\n        oInstance: null,\n\n        /**\n         * Unique identifier for each instance of the DataTables object. If there\n         * is an ID on the table node, then it takes that value, otherwise an\n         * incrementing internal counter is used.\n         *  @type string\n         *  @default null\n         */\n        sInstance: null,\n\n        /**\n         * tabindex attribute value that is added to DataTables control elements, allowing\n         * keyboard navigation of the table and its controls.\n         */\n        iTabIndex: 0,\n\n        /**\n         * DIV container for the footer scrolling table if scrolling\n         */\n        nScrollHead: null,\n\n        /**\n         * DIV container for the footer scrolling table if scrolling\n         */\n        nScrollFoot: null,\n\n        /**\n         * Last applied sort\n         *  @type array\n         *  @default []\n         */\n        aLastSort: [],\n\n        /**\n         * Stored plug-in instances\n         *  @type object\n         *  @default {}\n         */\n        oPlugins: {}\n      }\n\n      /**\n       * Extension object for DataTables that is used to provide all extension\n       * options.\n       *\n       * Note that the `DataTable.ext` object is available through\n       * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is\n       * also aliased to `jQuery.fn.dataTableExt` for historic reasons.\n       *  @namespace\n       *  @extends DataTable.models.ext\n       */\n\n      /**\n       * DataTables extensions\n       *\n       * This namespace acts as a collection area for plug-ins that can be used to\n       * extend DataTables capabilities. Indeed many of the build in methods\n       * use this method to provide their own capabilities (sorting methods for\n       * example).\n       *\n       * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy\n       * reasons\n       *\n       *  @namespace\n       */\n      DataTable.ext = _ext = {\n        /**\n         * Element class names\n         *\n         *  @type object\n         *  @default {}\n         */\n        classes: {},\n\n        /**\n         * Error reporting.\n         *\n         * How should DataTables report an error. Can take the value 'alert' or\n         * 'throw'\n         *\n         *  @type string\n         *  @default alert\n         */\n        errMode: 'alert',\n\n        /**\n         * Feature plug-ins.\n         *\n         * This is an array of objects which describe the feature plug-ins that are\n         * available to DataTables. These feature plug-ins are then available for\n         * use through the `dom` initialisation option.\n         *\n         * Each feature plug-in is described by an object which must have the\n         * following properties:\n         *\n         * * `fnInit` - function that is used to initialise the plug-in,\n         * * `cFeature` - a character so the feature can be enabled by the `dom`\n         *   instillation option. This is case sensitive.\n         *\n         * The `fnInit` function has the following input parameters:\n         *\n         * 1. `{object}` DataTables settings object: see\n         *    {@link DataTable.models.oSettings}\n         *\n         * And the following return is expected:\n         *\n         * * {node|null} The element which contains your feature. Note that the\n         *   return may also be void if your plug-in does not require to inject any\n         *   DOM elements into DataTables control (`dom`) - for example this might\n         *   be useful when developing a plug-in which allows table control via\n         *   keyboard entry\n         *\n         *  @type array\n         *\n         *  @example\n         *    $.fn.dataTable.ext.features.push( {\n         *      \"fnInit\": function( oSettings ) {\n         *        return new TableTools( { \"oDTSettings\": oSettings } );\n         *      },\n         *      \"cFeature\": \"T\"\n         *    } );\n         */\n        feature: [],\n\n        /**\n         * Row searching.\n         *\n         * This method of searching is complimentary to the default type based\n         * searching, and a lot more comprehensive as it allows you complete control\n         * over the searching logic. Each element in this array is a function\n         * (parameters described below) that is called for every row in the table,\n         * and your logic decides if it should be included in the searching data set\n         * or not.\n         *\n         * Searching functions have the following input parameters:\n         *\n         * 1. `{object}` DataTables settings object: see\n         *    {@link DataTable.models.oSettings}\n         * 2. `{array|object}` Data for the row to be processed (same as the\n         *    original format that was passed in as the data source, or an array\n         *    from a DOM data source\n         * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which\n         *    can be useful to retrieve the `TR` element if you need DOM interaction.\n         *\n         * And the following return is expected:\n         *\n         * * {boolean} Include the row in the searched result set (true) or not\n         *   (false)\n         *\n         * Note that as with the main search ability in DataTables, technically this\n         * is \"filtering\", since it is subtractive. However, for consistency in\n         * naming we call it searching here.\n         *\n         *  @type array\n         *  @default []\n         *\n         *  @example\n         *    // The following example shows custom search being applied to the\n         *    // fourth column (i.e. the data[3] index) based on two input values\n         *    // from the end-user, matching the data in a certain range.\n         *    $.fn.dataTable.ext.search.push(\n         *      function( settings, data, dataIndex ) {\n         *        var min = document.getElementById('min').value * 1;\n         *        var max = document.getElementById('max').value * 1;\n         *        var version = data[3] == \"-\" ? 0 : data[3]*1;\n         *\n         *        if ( min == \"\" && max == \"\" ) {\n         *          return true;\n         *        }\n         *        else if ( min == \"\" && version < max ) {\n         *          return true;\n         *        }\n         *        else if ( min < version && \"\" == max ) {\n         *          return true;\n         *        }\n         *        else if ( min < version && version < max ) {\n         *          return true;\n         *        }\n         *        return false;\n         *      }\n         *    );\n         */\n        search: [],\n\n        /**\n         * Internal functions, exposed for used in plug-ins.\n         *\n         * Please note that you should not need to use the internal methods for\n         * anything other than a plug-in (and even then, try to avoid if possible).\n         * The internal function may change between releases.\n         *\n         *  @type object\n         *  @default {}\n         */\n        internal: {},\n\n        /**\n         * Legacy configuration options. Enable and disable legacy options that\n         * are available in DataTables.\n         *\n         *  @type object\n         */\n        legacy: {\n          /**\n           * Enable / disable DataTables 1.9 compatible server-side processing\n           * requests\n           *\n           *  @type boolean\n           *  @default null\n           */\n          ajax: null\n        },\n\n        /**\n         * Pagination plug-in methods.\n         *\n         * Each entry in this object is a function and defines which buttons should\n         * be shown by the pagination rendering method that is used for the table:\n         * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the\n         * buttons are displayed in the document, while the functions here tell it\n         * what buttons to display. This is done by returning an array of button\n         * descriptions (what each button will do).\n         *\n         * Pagination types (the four built in options and any additional plug-in\n         * options defined here) can be used through the `paginationType`\n         * initialisation parameter.\n         *\n         * The functions defined take two parameters:\n         *\n         * 1. `{int} page` The current page index\n         * 2. `{int} pages` The number of pages in the table\n         *\n         * Each function is expected to return an array where each element of the\n         * array can be one of:\n         *\n         * * `first` - Jump to first page when activated\n         * * `last` - Jump to last page when activated\n         * * `previous` - Show previous page when activated\n         * * `next` - Show next page when activated\n         * * `{int}` - Show page of the index given\n         * * `{array}` - A nested array containing the above elements to add a\n         *   containing 'DIV' element (might be useful for styling).\n         *\n         * Note that DataTables v1.9- used this object slightly differently whereby\n         * an object with two functions would be defined for each plug-in. That\n         * ability is still supported by DataTables 1.10+ to provide backwards\n         * compatibility, but this option of use is now decremented and no longer\n         * documented in DataTables 1.10+.\n         *\n         *  @type object\n         *  @default {}\n         *\n         *  @example\n         *    // Show previous, next and current page buttons only\n         *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {\n         *      return [ 'previous', page, 'next' ];\n         *    };\n         */\n        pager: {},\n\n        renderer: {\n          pageButton: {},\n          header: {}\n        },\n\n        /**\n         * Ordering plug-ins - custom data source\n         *\n         * The extension options for ordering of data available here is complimentary\n         * to the default type based ordering that DataTables typically uses. It\n         * allows much greater control over the the data that is being used to\n         * order a column, but is necessarily therefore more complex.\n         *\n         * This type of ordering is useful if you want to do ordering based on data\n         * live from the DOM (for example the contents of an 'input' element) rather\n         * than just the static string that DataTables knows of.\n         *\n         * The way these plug-ins work is that you create an array of the values you\n         * wish to be ordering for the column in question and then return that\n         * array. The data in the array much be in the index order of the rows in\n         * the table (not the currently ordering order!). Which order data gathering\n         * function is run here depends on the `dt-init columns.orderDataType`\n         * parameter that is used for the column (if any).\n         *\n         * The functions defined take two parameters:\n         *\n         * 1. `{object}` DataTables settings object: see\n         *    {@link DataTable.models.oSettings}\n         * 2. `{int}` Target column index\n         *\n         * Each function is expected to return an array:\n         *\n         * * `{array}` Data for the column to be ordering upon\n         *\n         *  @type array\n         *\n         *  @example\n         *    // Ordering using `input` node values\n         *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )\n         *    {\n         *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {\n         *        return $('input', td).val();\n         *      } );\n         *    }\n         */\n        order: {},\n\n        /**\n         * Type based plug-ins.\n         *\n         * Each column in DataTables has a type assigned to it, either by automatic\n         * detection or by direct assignment using the `type` option for the column.\n         * The type of a column will effect how it is ordering and search (plug-ins\n         * can also make use of the column type if required).\n         *\n         * @namespace\n         */\n        type: {\n          /**\n           * Type detection functions.\n           *\n           * The functions defined in this object are used to automatically detect\n           * a column's type, making initialisation of DataTables super easy, even\n           * when complex data is in the table.\n           *\n           * The functions defined take two parameters:\n           *\n           *  1. `{*}` Data from the column cell to be analysed\n           *  2. `{settings}` DataTables settings object. This can be used to\n           *     perform context specific type detection - for example detection\n           *     based on language settings such as using a comma for a decimal\n           *     place. Generally speaking the options from the settings will not\n           *     be required\n           *\n           * Each function is expected to return:\n           *\n           * * `{string|null}` Data type detected, or null if unknown (and thus\n           *   pass it on to the other type detection functions.\n           *\n           *  @type array\n           *\n           *  @example\n           *    // Currency type detection plug-in:\n           *    $.fn.dataTable.ext.type.detect.push(\n           *      function ( data, settings ) {\n           *        // Check the numeric part\n           *        if ( ! $.isNumeric( data.substring(1) ) ) {\n           *          return null;\n           *        }\n           *\n           *        // Check prefixed by currency\n           *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {\n           *          return 'currency';\n           *        }\n           *        return null;\n           *      }\n           *    );\n           */\n          detect: [],\n\n          /**\n           * Type based search formatting.\n           *\n           * The type based searching functions can be used to pre-format the\n           * data to be search on. For example, it can be used to strip HTML\n           * tags or to de-format telephone numbers for numeric only searching.\n           *\n           * Note that is a search is not defined for a column of a given type,\n           * no search formatting will be performed.\n           *\n           * Pre-processing of searching data plug-ins - When you assign the sType\n           * for a column (or have it automatically detected for you by DataTables\n           * or a type detection plug-in), you will typically be using this for\n           * custom sorting, but it can also be used to provide custom searching\n           * by allowing you to pre-processing the data and returning the data in\n           * the format that should be searched upon. This is done by adding\n           * functions this object with a parameter name which matches the sType\n           * for that target column. This is the corollary of <i>afnSortData</i>\n           * for searching data.\n           *\n           * The functions defined take a single parameter:\n           *\n           *  1. `{*}` Data from the column cell to be prepared for searching\n           *\n           * Each function is expected to return:\n           *\n           * * `{string|null}` Formatted string that will be used for the searching.\n           *\n           *  @type object\n           *  @default {}\n           *\n           *  @example\n           *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {\n           *      return d.replace(/\\n/g,\" \").replace( /<.*?>/g, \"\" );\n           *    }\n           */\n          search: {},\n\n          /**\n           * Type based ordering.\n           *\n           * The column type tells DataTables what ordering to apply to the table\n           * when a column is sorted upon. The order for each type that is defined,\n           * is defined by the functions available in this object.\n           *\n           * Each ordering option can be described by three properties added to\n           * this object:\n           *\n           * * `{type}-pre` - Pre-formatting function\n           * * `{type}-asc` - Ascending order function\n           * * `{type}-desc` - Descending order function\n           *\n           * All three can be used together, only `{type}-pre` or only\n           * `{type}-asc` and `{type}-desc` together. It is generally recommended\n           * that only `{type}-pre` is used, as this provides the optimal\n           * implementation in terms of speed, although the others are provided\n           * for compatibility with existing Javascript sort functions.\n           *\n           * `{type}-pre`: Functions defined take a single parameter:\n           *\n           *  1. `{*}` Data from the column cell to be prepared for ordering\n           *\n           * And return:\n           *\n           * * `{*}` Data to be sorted upon\n           *\n           * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort\n           * functions, taking two parameters:\n           *\n           *  1. `{*}` Data to compare to the second parameter\n           *  2. `{*}` Data to compare to the first parameter\n           *\n           * And returning:\n           *\n           * * `{*}` Ordering match: <0 if first parameter should be sorted lower\n           *   than the second parameter, ===0 if the two parameters are equal and\n           *   >0 if the first parameter should be sorted height than the second\n           *   parameter.\n           *\n           *  @type object\n           *  @default {}\n           *\n           *  @example\n           *    // Numeric ordering of formatted numbers with a pre-formatter\n           *    $.extend( $.fn.dataTable.ext.type.order, {\n           *      \"string-pre\": function(x) {\n           *        a = (a === \"-\" || a === \"\") ? 0 : a.replace( /[^\\d\\-\\.]/g, \"\" );\n           *        return parseFloat( a );\n           *      }\n           *    } );\n           *\n           *  @example\n           *    // Case-sensitive string ordering, with no pre-formatting method\n           *    $.extend( $.fn.dataTable.ext.order, {\n           *      \"string-case-asc\": function(x,y) {\n           *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));\n           *      },\n           *      \"string-case-desc\": function(x,y) {\n           *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));\n           *      }\n           *    } );\n           */\n          order: {}\n        },\n\n        /**\n         * Unique DataTables instance counter\n         *\n         * @type int\n         * @private\n         */\n        _unique: 0,\n\n        //\n        // Depreciated\n        // The following properties are retained for backwards compatiblity only.\n        // The should not be used in new projects and will be removed in a future\n        // version\n        //\n\n        /**\n         * Version check function.\n         *  @type function\n         *  @depreciated Since 1.10\n         */\n        fnVersionCheck: DataTable.fnVersionCheck,\n\n        /**\n         * Index for what 'this' index API functions should use\n         *  @type int\n         *  @deprecated Since v1.10\n         */\n        iApiIndex: 0,\n\n        /**\n         * jQuery UI class container\n         *  @type object\n         *  @deprecated Since v1.10\n         */\n        oJUIClasses: {},\n\n        /**\n         * Software version\n         *  @type string\n         *  @deprecated Since v1.10\n         */\n        sVersion: DataTable.version\n      }\n\n      //\n      // Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts\n      //\n      $.extend(_ext, {\n        afnFiltering: _ext.search,\n        aTypes: _ext.type.detect,\n        ofnSearch: _ext.type.search,\n        oSort: _ext.type.order,\n        afnSortData: _ext.order,\n        aoFeatures: _ext.feature,\n        oApi: _ext.internal,\n        oStdClasses: _ext.classes,\n        oPagination: _ext.pager\n      })\n\n      $.extend(DataTable.ext.classes, {\n        sTable: 'dataTable',\n        sNoFooter: 'no-footer',\n\n        /* Paging buttons */\n        sPageButton: 'paginate_button',\n        sPageButtonActive: 'current',\n        sPageButtonDisabled: 'disabled',\n\n        /* Striping classes */\n        sStripeOdd: 'odd',\n        sStripeEven: 'even',\n\n        /* Empty row */\n        sRowEmpty: 'dataTables_empty',\n\n        /* Features */\n        sWrapper: 'dataTables_wrapper',\n        sFilter: 'dataTables_filter',\n        sInfo: 'dataTables_info',\n        sPaging: 'dataTables_paginate paging_' /* Note that the type is postfixed */,\n        sLength: 'dataTables_length',\n        sProcessing: 'dataTables_processing',\n\n        /* Sorting */\n        sSortAsc: 'sorting_asc',\n        sSortDesc: 'sorting_desc',\n        sSortable: 'sorting' /* Sortable in both directions */,\n        sSortableAsc: 'sorting_asc_disabled',\n        sSortableDesc: 'sorting_desc_disabled',\n        sSortableNone: 'sorting_disabled',\n        sSortColumn: 'sorting_' /* Note that an int is postfixed for the sorting order */,\n\n        /* Filtering */\n        sFilterInput: '',\n\n        /* Page length */\n        sLengthSelect: '',\n\n        /* Scrolling */\n        sScrollWrapper: 'dataTables_scroll',\n        sScrollHead: 'dataTables_scrollHead',\n        sScrollHeadInner: 'dataTables_scrollHeadInner',\n        sScrollBody: 'dataTables_scrollBody',\n        sScrollFoot: 'dataTables_scrollFoot',\n        sScrollFootInner: 'dataTables_scrollFootInner',\n\n        /* Misc */\n        sHeaderTH: '',\n        sFooterTH: '',\n\n        // Deprecated\n        sSortJUIAsc: '',\n        sSortJUIDesc: '',\n        sSortJUI: '',\n        sSortJUIAscAllowed: '',\n        sSortJUIDescAllowed: '',\n        sSortJUIWrapper: '',\n        sSortIcon: '',\n        sJUIHeader: '',\n        sJUIFooter: ''\n      })\n      ;(function () {\n        // Reused strings for better compression. Closure compiler appears to have a\n        // weird edge case where it is trying to expand strings rather than use the\n        // variable version. This results in about 200 bytes being added, for very\n        // little preference benefit since it this run on script load only.\n        var _empty = ''\n        _empty = ''\n\n        var _stateDefault = _empty + 'ui-state-default'\n        var _sortIcon = _empty + 'css_right ui-icon ui-icon-'\n        var _headerFooter = _empty + 'fg-toolbar ui-toolbar ui-widget-header ui-helper-clearfix'\n\n        $.extend(DataTable.ext.oJUIClasses, DataTable.ext.classes, {\n          /* Full numbers paging buttons */\n          sPageButton: 'fg-button ui-button ' + _stateDefault,\n          sPageButtonActive: 'ui-state-disabled',\n          sPageButtonDisabled: 'ui-state-disabled',\n\n          /* Features */\n          sPaging:\n            'dataTables_paginate fg-buttonset ui-buttonset fg-buttonset-multi ' +\n            'ui-buttonset-multi paging_' /* Note that the type is postfixed */,\n\n          /* Sorting */\n          sSortAsc: _stateDefault + ' sorting_asc',\n          sSortDesc: _stateDefault + ' sorting_desc',\n          sSortable: _stateDefault + ' sorting',\n          sSortableAsc: _stateDefault + ' sorting_asc_disabled',\n          sSortableDesc: _stateDefault + ' sorting_desc_disabled',\n          sSortableNone: _stateDefault + ' sorting_disabled',\n          sSortJUIAsc: _sortIcon + 'triangle-1-n',\n          sSortJUIDesc: _sortIcon + 'triangle-1-s',\n          sSortJUI: _sortIcon + 'carat-2-n-s',\n          sSortJUIAscAllowed: _sortIcon + 'carat-1-n',\n          sSortJUIDescAllowed: _sortIcon + 'carat-1-s',\n          sSortJUIWrapper: 'DataTables_sort_wrapper',\n          sSortIcon: 'DataTables_sort_icon',\n\n          /* Scrolling */\n          sScrollHead: 'dataTables_scrollHead ' + _stateDefault,\n          sScrollFoot: 'dataTables_scrollFoot ' + _stateDefault,\n\n          /* Misc */\n          sHeaderTH: _stateDefault,\n          sFooterTH: _stateDefault,\n          sJUIHeader: _headerFooter + ' ui-corner-tl ui-corner-tr',\n          sJUIFooter: _headerFooter + ' ui-corner-bl ui-corner-br'\n        })\n      })()\n\n      var extPagination = DataTable.ext.pager\n\n      function _numbers (page, pages) {\n        var numbers = [],\n          buttons = extPagination.numbers_length,\n          half = Math.floor(buttons / 2),\n          i = 1\n\n        if (pages <= buttons) {\n          numbers = _range(0, pages)\n        } else if (page <= half) {\n          numbers = _range(0, buttons - 2)\n          numbers.push('ellipsis')\n          numbers.push(pages - 1)\n        } else if (page >= pages - 1 - half) {\n          numbers = _range(pages - (buttons - 2), pages)\n          numbers.splice(0, 0, 'ellipsis') // no unshift in ie6\n          numbers.splice(0, 0, 0)\n        } else {\n          numbers = _range(page - 1, page + 2)\n          numbers.push('ellipsis')\n          numbers.push(pages - 1)\n          numbers.splice(0, 0, 'ellipsis')\n          numbers.splice(0, 0, 0)\n        }\n\n        numbers.DT_el = 'span'\n        return numbers\n      }\n\n      $.extend(extPagination, {\n        simple: function (page, pages) {\n          return ['previous', 'next']\n        },\n\n        full: function (page, pages) {\n          return ['first', 'previous', 'next', 'last']\n        },\n\n        simple_numbers: function (page, pages) {\n          return ['previous', _numbers(page, pages), 'next']\n        },\n\n        full_numbers: function (page, pages) {\n          return ['first', 'previous', _numbers(page, pages), 'next', 'last']\n        },\n\n        // For testing and plug-ins to use\n        _numbers: _numbers,\n        numbers_length: 7\n      })\n\n      $.extend(true, DataTable.ext.renderer, {\n        pageButton: {\n          _: function (settings, host, idx, buttons, page, pages) {\n            var classes = settings.oClasses\n            var lang = settings.oLanguage.oPaginate\n            var btnDisplay,\n              btnClass,\n              counter = 0\n\n            var attach = function (container, buttons) {\n              var i, ien, node, button\n              var clickHandler = function (e) {\n                _fnPageChange(settings, e.data.action, true)\n              }\n\n              for (i = 0, ien = buttons.length; i < ien; i++) {\n                button = buttons[i]\n\n                if ($.isArray(button)) {\n                  var inner = $('<' + (button.DT_el || 'div') + '/>').appendTo(container)\n                  attach(inner, button)\n                } else {\n                  btnDisplay = ''\n                  btnClass = ''\n\n                  switch (button) {\n                    case 'ellipsis':\n                      container.append('<span>&hellip;</span>')\n                      break\n\n                    case 'first':\n                      btnDisplay = lang.sFirst\n                      btnClass = button + (page > 0 ? '' : ' ' + classes.sPageButtonDisabled)\n                      break\n\n                    case 'previous':\n                      btnDisplay = lang.sPrevious\n                      btnClass = button + (page > 0 ? '' : ' ' + classes.sPageButtonDisabled)\n                      break\n\n                    case 'next':\n                      btnDisplay = lang.sNext\n                      btnClass = button + (page < pages - 1 ? '' : ' ' + classes.sPageButtonDisabled)\n                      break\n\n                    case 'last':\n                      btnDisplay = lang.sLast\n                      btnClass = button + (page < pages - 1 ? '' : ' ' + classes.sPageButtonDisabled)\n                      break\n\n                    default:\n                      btnDisplay = button + 1\n                      btnClass = page === button ? classes.sPageButtonActive : ''\n                      break\n                  }\n\n                  if (btnDisplay) {\n                    node = $('<a>', {\n                      class: classes.sPageButton + ' ' + btnClass,\n                      'aria-controls': settings.sTableId,\n                      'data-dt-idx': counter,\n                      tabindex: settings.iTabIndex,\n                      id: idx === 0 && typeof button === 'string' ? settings.sTableId + '_' + button : null\n                    })\n                      .html(btnDisplay)\n                      .appendTo(container)\n\n                    _fnBindAction(node, { action: button }, clickHandler)\n\n                    counter++\n                  }\n                }\n              }\n            }\n\n            // IE9 throws an 'unknown error' if document.activeElement is used\n            // inside an iframe or frame. Try / catch the error. Not good for\n            // accessibility, but neither are frames.\n            try {\n              // Because this approach is destroying and recreating the paging\n              // elements, focus is lost on the select button which is bad for\n              // accessibility. So we want to restore focus once the draw has\n              // completed\n              var activeEl = $(document.activeElement).data('dt-idx')\n\n              attach($(host).empty(), buttons)\n\n              if (activeEl !== null) {\n                $(host)\n                  .find('[data-dt-idx=' + activeEl + ']')\n                  .focus()\n              }\n            } catch (e) {}\n          }\n        }\n      })\n\n      var __numericReplace = function (d, decimalPlace, re1, re2) {\n        if (!d || d === '-') {\n          return -Infinity\n        }\n\n        // If a decimal place other than `.` is used, it needs to be given to the\n        // function so we can detect it and replace with a `.` which is the only\n        // decimal place Javascript recognises - it is not locale aware.\n        if (decimalPlace) {\n          d = _numToDecimal(d, decimalPlace)\n        }\n\n        if (d.replace) {\n          if (re1) {\n            d = d.replace(re1, '')\n          }\n\n          if (re2) {\n            d = d.replace(re2, '')\n          }\n        }\n\n        return d * 1\n      }\n\n      // Add the numeric 'deformatting' functions for sorting. This is done in a\n      // function to provide an easy ability for the language options to add\n      // additional methods if a non-period decimal place is used.\n      function _addNumericSort (decimalPlace) {\n        $.each(\n          {\n            // Plain numbers\n            num: function (d) {\n              return __numericReplace(d, decimalPlace)\n            },\n\n            // Formatted numbers\n            'num-fmt': function (d) {\n              return __numericReplace(d, decimalPlace, _re_formatted_numeric)\n            },\n\n            // HTML numeric\n            'html-num': function (d) {\n              return __numericReplace(d, decimalPlace, _re_html)\n            },\n\n            // HTML numeric, formatted\n            'html-num-fmt': function (d) {\n              return __numericReplace(d, decimalPlace, _re_html, _re_formatted_numeric)\n            }\n          },\n          function (key, fn) {\n            _ext.type.order[key + decimalPlace + '-pre'] = fn\n          }\n        )\n      }\n\n      // Default sort methods\n      $.extend(_ext.type.order, {\n        // Dates\n        'date-pre': function (d) {\n          return Date.parse(d) || 0\n        },\n\n        // html\n        'html-pre': function (a) {\n          return _empty(a) ? '' : a.replace ? a.replace(/<.*?>/g, '').toLowerCase() : a + ''\n        },\n\n        // string\n        'string-pre': function (a) {\n          // This is a little complex, but faster than always calling toString,\n          // http://jsperf.com/tostring-v-check\n          return _empty(a) ? '' : typeof a === 'string' ? a.toLowerCase() : !a.toString ? '' : a.toString()\n        },\n\n        // string-asc and -desc are retained only for compatibility with the old\n        // sort methods\n        'string-asc': function (x, y) {\n          return x < y ? -1 : x > y ? 1 : 0\n        },\n\n        'string-desc': function (x, y) {\n          return x < y ? 1 : x > y ? -1 : 0\n        }\n      })\n\n      // Numeric sorting types - order doesn't matter here\n      _addNumericSort('')\n\n      // Built in type detection. See model.ext.aTypes for information about\n      // what is required from this methods.\n      $.extend(DataTable.ext.type.detect, [\n        // Plain numbers - first since V8 detects some plain numbers as dates\n        // e.g. Date.parse('55') (but not all, e.g. Date.parse('22')...).\n        function (d, settings) {\n          var decimal = settings.oLanguage.sDecimal\n          return _isNumber(d, decimal) ? 'num' + decimal : null\n        },\n\n        // Dates (only those recognised by the browser's Date.parse)\n        function (d, settings) {\n          // V8 will remove any unknown characters at the start and end of the\n          // expression, leading to false matches such as `$245.12` or `10%` being\n          // a valid date. See forum thread 18941 for detail.\n          if (d && (!_re_date_start.test(d) || !_re_date_end.test(d))) {\n            return null\n          }\n          var parsed = Date.parse(d)\n          return (parsed !== null && !isNaN(parsed)) || _empty(d) ? 'date' : null\n        },\n\n        // Formatted numbers\n        function (d, settings) {\n          var decimal = settings.oLanguage.sDecimal\n          return _isNumber(d, decimal, true) ? 'num-fmt' + decimal : null\n        },\n\n        // HTML numeric\n        function (d, settings) {\n          var decimal = settings.oLanguage.sDecimal\n          return _htmlNumeric(d, decimal) ? 'html-num' + decimal : null\n        },\n\n        // HTML numeric, formatted\n        function (d, settings) {\n          var decimal = settings.oLanguage.sDecimal\n          return _htmlNumeric(d, decimal, true) ? 'html-num-fmt' + decimal : null\n        },\n\n        // HTML (this is strict checking - there must be html)\n        function (d, settings) {\n          return _empty(d) || (typeof d === 'string' && d.indexOf('<') !== -1) ? 'html' : null\n        }\n      ])\n\n      // Filter formatting functions. See model.ext.ofnSearch for information about\n      // what is required from these methods.\n\n      $.extend(DataTable.ext.type.search, {\n        html: function (data) {\n          return _empty(data)\n            ? data\n            : typeof data === 'string'\n            ? data.replace(_re_new_lines, ' ').replace(_re_html, '')\n            : ''\n        },\n\n        string: function (data) {\n          return _empty(data) ? data : typeof data === 'string' ? data.replace(_re_new_lines, ' ') : data\n        }\n      })\n\n      $.extend(true, DataTable.ext.renderer, {\n        header: {\n          _: function (settings, cell, column, classes) {\n            // No additional mark-up required\n            // Attach a sort listener to update on sort - note that using the\n            // `DT` namespace will allow the event to be removed automatically\n            // on destroy, while the `dt` namespaced event is the one we are\n            // listening for\n            $(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {\n              if (settings !== ctx) {\n                // need to check this this is the host\n                return // table, not a nested one\n              }\n\n              var colIdx = column.idx\n\n              cell\n                .removeClass(column.sSortingClass + ' ' + classes.sSortAsc + ' ' + classes.sSortDesc)\n                .addClass(\n                  columns[colIdx] == 'asc'\n                    ? classes.sSortAsc\n                    : columns[colIdx] == 'desc'\n                    ? classes.sSortDesc\n                    : column.sSortingClass\n                )\n            })\n          },\n\n          jqueryui: function (settings, cell, column, classes) {\n            var colIdx = column.idx\n\n            $('<div/>')\n              .addClass(classes.sSortJUIWrapper)\n              .append(cell.contents())\n              .append($('<span/>').addClass(classes.sSortIcon + ' ' + column.sSortingClassJUI))\n              .appendTo(cell)\n\n            // Attach a sort listener to update on sort\n            $(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {\n              if (settings !== ctx) {\n                return\n              }\n\n              cell\n                .removeClass(classes.sSortAsc + ' ' + classes.sSortDesc)\n                .addClass(\n                  columns[colIdx] == 'asc'\n                    ? classes.sSortAsc\n                    : columns[colIdx] == 'desc'\n                    ? classes.sSortDesc\n                    : column.sSortingClass\n                )\n\n              cell\n                .find('span.' + classes.sSortIcon)\n                .removeClass(\n                  classes.sSortJUIAsc +\n                    ' ' +\n                    classes.sSortJUIDesc +\n                    ' ' +\n                    classes.sSortJUI +\n                    ' ' +\n                    classes.sSortJUIAscAllowed +\n                    ' ' +\n                    classes.sSortJUIDescAllowed\n                )\n                .addClass(\n                  columns[colIdx] == 'asc'\n                    ? classes.sSortJUIAsc\n                    : columns[colIdx] == 'desc'\n                    ? classes.sSortJUIDesc\n                    : column.sSortingClassJUI\n                )\n            })\n          }\n        }\n      })\n\n      /*\n       * Public helper functions. These aren't used internally by DataTables, or\n       * called by any of the options passed into DataTables, but they can be used\n       * externally by developers working with DataTables. They are helper functions\n       * to make working with DataTables a little bit easier.\n       */\n\n      /**\n       * Helpers for `columns.render`.\n       *\n       * The options defined here can be used with the `columns.render` initialisation\n       * option to provide a display renderer. The following functions are defined:\n       *\n       * * `number` - Will format numeric data (defined by `columns.data`) for\n       *   display, retaining the original unformatted data for sorting and filtering.\n       *   It takes 4 parameters:\n       *   * `string` - Thousands grouping separator\n       *   * `string` - Decimal point indicator\n       *   * `integer` - Number of decimal points to show\n       *   * `string` (optional) - Prefix.\n       *\n       * @example\n       *   // Column definition using the number renderer\n       *   {\n       *     data: \"salary\",\n       *     render: $.fn.dataTable.render.number( '\\'', '.', 0, '$' )\n       *   }\n       *\n       * @namespace\n       */\n      DataTable.render = {\n        number: function (thousands, decimal, precision, prefix) {\n          return {\n            display: function (d) {\n              var negative = d < 0 ? '-' : ''\n              d = Math.abs(parseFloat(d))\n\n              var intPart = parseInt(d, 10)\n              var floatPart = precision ? decimal + (d - intPart).toFixed(precision).substring(2) : ''\n\n              return (\n                negative + (prefix || '') + intPart.toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, thousands) + floatPart\n              )\n            }\n          }\n        }\n      }\n\n      /*\n       * This is really a good bit rubbish this method of exposing the internal methods\n       * publicly... - To be fixed in 2.0 using methods on the prototype\n       */\n\n      /**\n       * Create a wrapper function for exporting an internal functions to an external API.\n       *  @param {string} fn API function name\n       *  @returns {function} wrapped function\n       *  @memberof DataTable#internal\n       */\n      function _fnExternApiFunc (fn) {\n        return function () {\n          var args = [_fnSettingsFromNode(this[DataTable.ext.iApiIndex])].concat(Array.prototype.slice.call(arguments))\n          return DataTable.ext.internal[fn].apply(this, args)\n        }\n      }\n\n      /**\n       * Reference to internal functions for use by plug-in developers. Note that\n       * these methods are references to internal functions and are considered to be\n       * private. If you use these methods, be aware that they are liable to change\n       * between versions.\n       *  @namespace\n       */\n      $.extend(DataTable.ext.internal, {\n        _fnExternApiFunc: _fnExternApiFunc,\n        _fnBuildAjax: _fnBuildAjax,\n        _fnAjaxUpdate: _fnAjaxUpdate,\n        _fnAjaxParameters: _fnAjaxParameters,\n        _fnAjaxUpdateDraw: _fnAjaxUpdateDraw,\n        _fnAjaxDataSrc: _fnAjaxDataSrc,\n        _fnAddColumn: _fnAddColumn,\n        _fnColumnOptions: _fnColumnOptions,\n        _fnAdjustColumnSizing: _fnAdjustColumnSizing,\n        _fnVisibleToColumnIndex: _fnVisibleToColumnIndex,\n        _fnColumnIndexToVisible: _fnColumnIndexToVisible,\n        _fnVisbleColumns: _fnVisbleColumns,\n        _fnGetColumns: _fnGetColumns,\n        _fnColumnTypes: _fnColumnTypes,\n        _fnApplyColumnDefs: _fnApplyColumnDefs,\n        _fnHungarianMap: _fnHungarianMap,\n        _fnCamelToHungarian: _fnCamelToHungarian,\n        _fnLanguageCompat: _fnLanguageCompat,\n        _fnBrowserDetect: _fnBrowserDetect,\n        _fnAddData: _fnAddData,\n        _fnAddTr: _fnAddTr,\n        _fnNodeToDataIndex: _fnNodeToDataIndex,\n        _fnNodeToColumnIndex: _fnNodeToColumnIndex,\n        _fnGetCellData: _fnGetCellData,\n        _fnSetCellData: _fnSetCellData,\n        _fnSplitObjNotation: _fnSplitObjNotation,\n        _fnGetObjectDataFn: _fnGetObjectDataFn,\n        _fnSetObjectDataFn: _fnSetObjectDataFn,\n        _fnGetDataMaster: _fnGetDataMaster,\n        _fnClearTable: _fnClearTable,\n        _fnDeleteIndex: _fnDeleteIndex,\n        _fnInvalidateRow: _fnInvalidateRow,\n        _fnGetRowElements: _fnGetRowElements,\n        _fnCreateTr: _fnCreateTr,\n        _fnBuildHead: _fnBuildHead,\n        _fnDrawHead: _fnDrawHead,\n        _fnDraw: _fnDraw,\n        _fnReDraw: _fnReDraw,\n        _fnAddOptionsHtml: _fnAddOptionsHtml,\n        _fnDetectHeader: _fnDetectHeader,\n        _fnGetUniqueThs: _fnGetUniqueThs,\n        _fnFeatureHtmlFilter: _fnFeatureHtmlFilter,\n        _fnFilterComplete: _fnFilterComplete,\n        _fnFilterCustom: _fnFilterCustom,\n        _fnFilterColumn: _fnFilterColumn,\n        _fnFilter: _fnFilter,\n        _fnFilterCreateSearch: _fnFilterCreateSearch,\n        _fnEscapeRegex: _fnEscapeRegex,\n        _fnFilterData: _fnFilterData,\n        _fnFeatureHtmlInfo: _fnFeatureHtmlInfo,\n        _fnUpdateInfo: _fnUpdateInfo,\n        _fnInfoMacros: _fnInfoMacros,\n        _fnInitialise: _fnInitialise,\n        _fnInitComplete: _fnInitComplete,\n        _fnLengthChange: _fnLengthChange,\n        _fnFeatureHtmlLength: _fnFeatureHtmlLength,\n        _fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,\n        _fnPageChange: _fnPageChange,\n        _fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,\n        _fnProcessingDisplay: _fnProcessingDisplay,\n        _fnFeatureHtmlTable: _fnFeatureHtmlTable,\n        _fnScrollDraw: _fnScrollDraw,\n        _fnApplyToChildren: _fnApplyToChildren,\n        _fnCalculateColumnWidths: _fnCalculateColumnWidths,\n        _fnThrottle: _fnThrottle,\n        _fnConvertToWidth: _fnConvertToWidth,\n        _fnScrollingWidthAdjust: _fnScrollingWidthAdjust,\n        _fnGetWidestNode: _fnGetWidestNode,\n        _fnGetMaxLenString: _fnGetMaxLenString,\n        _fnStringToCss: _fnStringToCss,\n        _fnScrollBarWidth: _fnScrollBarWidth,\n        _fnSortFlatten: _fnSortFlatten,\n        _fnSort: _fnSort,\n        _fnSortAria: _fnSortAria,\n        _fnSortListener: _fnSortListener,\n        _fnSortAttachListener: _fnSortAttachListener,\n        _fnSortingClasses: _fnSortingClasses,\n        _fnSortData: _fnSortData,\n        _fnSaveState: _fnSaveState,\n        _fnLoadState: _fnLoadState,\n        _fnSettingsFromNode: _fnSettingsFromNode,\n        _fnLog: _fnLog,\n        _fnMap: _fnMap,\n        _fnBindAction: _fnBindAction,\n        _fnCallbackReg: _fnCallbackReg,\n        _fnCallbackFire: _fnCallbackFire,\n        _fnLengthOverflow: _fnLengthOverflow,\n        _fnRenderer: _fnRenderer,\n        _fnDataSource: _fnDataSource,\n        _fnRowAttributes: _fnRowAttributes,\n        _fnCalculateEnd: function () {} // Used by a lot of plug-ins, but redundant\n        // in 1.10, so this dead-end function is\n        // added to prevent errors\n      })\n\n      // jQuery access\n      $.fn.dataTable = DataTable\n\n      // Legacy aliases\n      $.fn.dataTableSettings = DataTable.settings\n      $.fn.dataTableExt = DataTable.ext\n\n      // With a capital `D` we return a DataTables API instance rather than a\n      // jQuery object\n      $.fn.DataTable = function (opts) {\n        return $(this)\n          .dataTable(opts)\n          .api()\n      }\n\n      // All properties that are available to $.fn.dataTable should also be\n      // available on $.fn.DataTable\n      $.each(DataTable, function (prop, val) {\n        $.fn.DataTable[prop] = val\n      })\n\n      // Information about events fired by DataTables - for documentation.\n      /**\n       * Draw event, fired whenever the table is redrawn on the page, at the same\n       * point as fnDrawCallback. This may be useful for binding events or\n       * performing calculations when the table is altered at all.\n       *  @name DataTable#draw.dt\n       *  @event\n       *  @param {event} e jQuery event object\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n       */\n\n      /**\n       * Search event, fired when the searching applied to the table (using the\n       * built-in global search, or column filters) is altered.\n       *  @name DataTable#search.dt\n       *  @event\n       *  @param {event} e jQuery event object\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n       */\n\n      /**\n       * Page change event, fired when the paging of the table is altered.\n       *  @name DataTable#page.dt\n       *  @event\n       *  @param {event} e jQuery event object\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n       */\n\n      /**\n       * Order event, fired when the ordering applied to the table is altered.\n       *  @name DataTable#order.dt\n       *  @event\n       *  @param {event} e jQuery event object\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n       */\n\n      /**\n       * DataTables initialisation complete event, fired when the table is fully\n       * drawn, including Ajax data loaded, if Ajax data is required.\n       *  @name DataTable#init.dt\n       *  @event\n       *  @param {event} e jQuery event object\n       *  @param {object} oSettings DataTables settings object\n       *  @param {object} json The JSON object request from the server - only\n       *    present if client-side Ajax sourced data is used</li></ol>\n       */\n\n      /**\n       * State save event, fired when the table has changed state a new state save\n       * is required. This event allows modification of the state saving object\n       * prior to actually doing the save, including addition or other state\n       * properties (for plug-ins) or modification of a DataTables core property.\n       *  @name DataTable#stateSaveParams.dt\n       *  @event\n       *  @param {event} e jQuery event object\n       *  @param {object} oSettings DataTables settings object\n       *  @param {object} json The state information to be saved\n       */\n\n      /**\n       * State load event, fired when the table is loading state from the stored\n       * data, but prior to the settings object being modified by the saved state\n       * - allowing modification of the saved state is required or loading of\n       * state for a plug-in.\n       *  @name DataTable#stateLoadParams.dt\n       *  @event\n       *  @param {event} e jQuery event object\n       *  @param {object} oSettings DataTables settings object\n       *  @param {object} json The saved state information\n       */\n\n      /**\n       * State loaded event, fired when state has been loaded from stored data and\n       * the settings object has been modified by the loaded data.\n       *  @name DataTable#stateLoaded.dt\n       *  @event\n       *  @param {event} e jQuery event object\n       *  @param {object} oSettings DataTables settings object\n       *  @param {object} json The saved state information\n       */\n\n      /**\n       * Processing event, fired when DataTables is doing some kind of processing\n       * (be it, order, searcg or anything else). It can be used to indicate to\n       * the end user that there is something happening, or that something has\n       * finished.\n       *  @name DataTable#processing.dt\n       *  @event\n       *  @param {event} e jQuery event object\n       *  @param {object} oSettings DataTables settings object\n       *  @param {boolean} bShow Flag for if DataTables is doing processing or not\n       */\n\n      /**\n       * Ajax (XHR) event, fired whenever an Ajax request is completed from a\n       * request to made to the server for new data. This event is called before\n       * DataTables processed the returned data, so it can also be used to pre-\n       * process the data returned from the server, if needed.\n       *\n       * Note that this trigger is called in `fnServerData`, if you override\n       * `fnServerData` and which to use this event, you need to trigger it in you\n       * success function.\n       *  @name DataTable#xhr.dt\n       *  @event\n       *  @param {event} e jQuery event object\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n       *  @param {object} json JSON returned from the server\n       *\n       *  @example\n       *     // Use a custom property returned from the server in another DOM element\n       *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {\n       *       $('#status').html( json.status );\n       *     } );\n       *\n       *  @example\n       *     // Pre-process the data returned from the server\n       *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {\n       *       for ( var i=0, ien=json.aaData.length ; i<ien ; i++ ) {\n       *         json.aaData[i].sum = json.aaData[i].one + json.aaData[i].two;\n       *       }\n       *       // Note no return - manipulate the data directly in the JSON object.\n       *     } );\n       */\n\n      /**\n       * Destroy event, fired when the DataTable is destroyed by calling fnDestroy\n       * or passing the bDestroy:true parameter in the initialisation object. This\n       * can be used to remove bound events, added DOM nodes, etc.\n       *  @name DataTable#destroy.dt\n       *  @event\n       *  @param {event} e jQuery event object\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n       */\n\n      /**\n       * Page length change event, fired when number of records to show on each\n       * page (the length) is changed.\n       *  @name DataTable#length.dt\n       *  @event\n       *  @param {event} e jQuery event object\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n       *  @param {integer} len New length\n       */\n\n      /**\n       * Column sizing has changed.\n       *  @name DataTable#column-sizing.dt\n       *  @event\n       *  @param {event} e jQuery event object\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n       */\n\n      /**\n       * Column visibility has changed.\n       *  @name DataTable#column-visibility.dt\n       *  @event\n       *  @param {event} e jQuery event object\n       *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n       *  @param {int} column Column index\n       *  @param {bool} vis `false` if column now hidden, or `true` if visible\n       */\n\n      return $.fn.dataTable\n    }\n  )\n})(window, document)\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\")))\n\n//# sourceURL=webpack:///./src/public/js/vendor/datatables/jquery.dataTables.js?");

/***/ }),

/***/ "./src/public/js/vendor/metricsgraphics/metricsgraphics.min.js":
/*!*********************************************************************!*\
  !*** ./src/public/js/vendor/metricsgraphics/metricsgraphics.min.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(jQuery, $, global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(function (t, e) {\n   true\n    ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! d3 */ \"./src/public/js/vendor/d3/d3.min.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (e),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n    : undefined\n})(this, function (E) {\n  'use strict'\n  var c =\n    'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator\n      ? function (t) {\n          return typeof t\n        }\n      : function (t) {\n          return t && 'function' == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype\n            ? 'symbol'\n            : typeof t\n        }\n  function k () {\n    return 'undefined' != typeof jQuery || 'undefined' != typeof $\n  }\n  function i (t, e) {\n    return (\n      t[e.x_accessor] >= e.processed.min_x &&\n      t[e.x_accessor] <= e.processed.max_x &&\n      t[e.y_accessor] >= e.processed.min_y &&\n      t[e.y_accessor] <= e.processed.max_y\n    )\n  }\n  function u (t) {\n    return '[object Array]' === Object.prototype.toString.call(t)\n  }\n  function a (t) {\n    var e = t.map(function (t) {\n      return !0 === u(t) && 0 < t.length\n    })\n    return E.sum(e) === t.length\n  }\n  function n (t) {\n    var e = t.map(function (t) {\n      return !0 == ((e = t), '[object Object]' === Object.prototype.toString.call(e))\n      var e\n    })\n    return E.sum(e) === t.length\n  }\n  function e (t) {\n    return (u((e = t)) && 0 === e.length) || n(t)\n    var e\n  }\n  function w (t) {\n    return t.height - t.bottom\n  }\n  function v (t) {\n    return w(t) - t.buffer\n  }\n  function M (t) {\n    return t.top\n  }\n  function b (t) {\n    return M(t) + t.buffer\n  }\n  function G (t) {\n    return t.left\n  }\n  function Y (t) {\n    return G(t) + t.buffer\n  }\n  function A (t) {\n    return t.width - t.right\n  }\n  function P (t) {\n    return A(t) - t.buffer\n  }\n  function _ (t) {\n    t.exit().remove()\n  }\n  function D (t, e) {\n    t.selectAll(e).remove()\n  }\n  function S (t, e) {\n    return t.append('g').classed(e, !0)\n  }\n  function r (t, e) {\n    var r = O(t.target),\n      a = h(t.data),\n      n = r.selectAll('line.' + e).data(a)\n    return (\n      n\n        .enter()\n        .append('line')\n        .attr('class', e)\n        .attr('opacity', 0.3),\n      _(n),\n      _(n),\n      n\n    )\n  }\n  function m (t, e, r) {\n    e.color_accessor\n      ? (t.attr('stroke', e.scalefns.colorf), t.classed(r, !1))\n      : (t.attr('stroke', null), t.classed(r, !0))\n  }\n  function l (t, e) {\n    e &&\n      t.attr({\n        dy: 0,\n        transform: function () {\n          var t = E.select(this)\n          return 'rotate(' + e + ' ' + t.attr('x') + ',' + t.attr('y') + ')'\n        }\n      })\n  }\n  function g (t) {\n    if (!(t = t.node())) return !1\n    for (var e = 0; e < t.length; e++) if (o(t[e], t)) return !0\n    return !1\n  }\n  function o (t, e) {\n    for (var r = t.getBoundingClientRect(), a = 0; a < e.length; a++)\n      if (e[a] != t) {\n        var n = e[a].getBoundingClientRect()\n        if (r.top === n.top && !(n.left > r.right || n.right < r.left)) return !0\n      }\n    return !1\n  }\n  function s (t, e) {\n    var r = h(t.data)\n    return 'string' == typeof (r = r[0][t[e + '_accessor']]) ? 'categorical' : 'numerical'\n  }\n  function O (t) {\n    return E.select(t).select('svg')\n  }\n  function h (t) {\n    var e = []\n    return e.concat.apply(e, t)\n  }\n  function z (t) {\n    if ('string' == typeof t) return F(t)\n    if (t instanceof window.HTMLElement) {\n      var e = t.getAttribute('data-mg-uid')\n      return (\n        e ||\n          (void 0 === MG._next_elem_id && (MG._next_elem_id = 0),\n          (e = 'mg-' + MG._next_elem_id++),\n          t.setAttribute('data-mg-uid', e)),\n        e\n      )\n    }\n    return console.warn('The specified target should be a string or an HTMLElement.', t), F(t)\n  }\n  function F (t) {\n    return t.replace(/[^a-zA-Z0-9 _-]+/g, '').replace(/ +?/g, '')\n  }\n  function d (t, e) {\n    return Number(\n      E.select(t)\n        .style(e)\n        .replace(/px/g, '')\n    )\n  }\n  function f (t) {\n    return d(t, 'width')\n  }\n  ;(('undefined' == typeof window ? global : window).MG = { version: '2.11' }),\n    (MG.convert = {}),\n    (MG.convert.date = function (t, e, r) {\n      r = void 0 === r ? '%Y-%m-%d' : r\n      var a = E.timeParse(r)\n      return (t = t.map(function (t) {\n        return (t[e] = a(t[e].trim())), t\n      }))\n    }),\n    (MG.convert.number = function (t, e) {\n      return (t = t.map(function (t) {\n        return (t[e] = Number(t[e])), t\n      }))\n    }),\n    (MG.time_format = function (t, e) {\n      return t ? E.utcFormat(e) : E.timeFormat(e)\n    })\n  var t = function (t, e, r) {\n    var a = {}\n    if (null === t) return t\n    if (Array.prototype.forEach && t.forEach === Array.prototype.forEach) t.forEach(e, r)\n    else if (t.length === +t.length) {\n      for (var n = 0, o = t.length; n < o; n++) if (e.call(r, t[n], n, t) === a) return\n    } else for (var i in t) if (e.call(r, t[i], i, t) === a) return\n    return t\n  }\n  function p (r) {\n    return (\n      t(Array.prototype.slice.call(arguments, 1), function (t) {\n        if (t) for (var e in t) void 0 === r[e] && (r[e] = t[e])\n      }),\n      r\n    )\n  }\n  function x (t) {\n    return '[object Date]' === Object.prototype.toString.call(t)\n  }\n  function y (t) {\n    return Array.isArray ? Array.isArray(t) : '[object Array]' === Object.prototype.toString.call(t)\n  }\n  function C (t) {\n    return '[object Function]' === Object.prototype.toString.call(t)\n  }\n  function T (t, e) {\n    var r,\n      a = [],\n      n = []\n    for (r = 0; r < e.length; r++) a[e[r]] = !0\n    for (r = 0; r < t.length; r++) a[t[r]] || n.push(t[r])\n    return n\n  }\n  function R (t, e) {\n    console.warn('Deprecation: ' + t + (e ? '. This feature will be removed in ' + e + '.' : ' the near future.')),\n      console.trace()\n  }\n  function L (t, e, r) {\n    var a,\n      n = 0\n    for (\n      t.textContent = e, a = t.getBBox();\n      a.width > r && ((t.textContent = e.slice(0, --n) + '...'), (a = t.getBBox()), '...' !== t.textContent);\n\n    );\n  }\n  function j (t) {\n    var e = O(t.target)\n    if ((e.select('.mg-header').remove(), t.target && t.title)) {\n      var r = e\n        .insert('text')\n        .attr('class', 'mg-header')\n        .attr('x', t.center_title_full_width ? t.width / 2 : (t.width + t.left - t.right) / 2)\n        .attr('y', t.title_y_position)\n        .attr('text-anchor', 'middle')\n        .attr('dy', '0.55em')\n      if (\n        (r\n          .append('tspan')\n          .attr('class', 'mg-chart-title')\n          .text(t.title),\n        t.show_tooltips && t.description && k())\n      ) {\n        r.append('tspan')\n          .attr('class', 'mg-chart-description')\n          .attr('dx', '0.3em')\n          .text('')\n        var a = $(r.node())\n        a.popover({\n          html: !0,\n          animation: !1,\n          placement: 'top',\n          content: t.description,\n          container: t.target,\n          trigger: 'manual',\n          template:\n            '<div class=\"popover mg-popover\"><div class=\"arrow\"></div><div class=\"popover-inner\"><h3 class=\"popover-title\"></h3><div class=\"popover-content\"><p></p></div></div></div>'\n        })\n          .on('mouseenter', function () {\n            E.selectAll(t.target)\n              .selectAll('.mg-popover')\n              .remove(),\n              $(this).popover('show'),\n              $(\n                E.select(t.target)\n                  .select('.popover')\n                  .node()\n              ).on('mouseleave', function () {\n                a.popover('hide')\n              })\n          })\n          .on('mouseleave', function () {\n            setTimeout(function () {\n              $('.popover:hover').length || a.popover('hide')\n            }, 120)\n          })\n      } else\n        t.show_tooltips &&\n          t.description &&\n          'undefined' == typeof $ &&\n          (t.error = 'In order to enable tooltips, please make sure you include jQuery.')\n    }\n    t.error && Xe(t)\n  }\n  function X (e, t, r, a, n) {\n    e.scalefns[t] = function (t) {\n      return void 0 === n ? e.scales[r](t[a]) : e.scales[r](t[a]) + n\n    }\n  }\n  function U (t, e) {\n    return 'bottom' === t || 'top' === t ? [Y(e), P(e)] : 'left' === t || 'right' === t ? [v(e), e.top] : void 0\n  }\n  function N (t, e) {\n    return E.set(\n      t.map(function (t) {\n        return t[e]\n      })\n    ).values()\n  }\n  function B (e) {\n    var t\n    return (\n      null === e.color_domain\n        ? 'number' === e.color_type\n          ? (t = E.extent(e.data[0], function (t) {\n              return t[e.color_accessor]\n            }))\n          : 'category' === e.color_type && (t = N(e.data[0], e.color_accessor))\n        : (t = e.color_domain),\n      t\n    )\n  }\n  function I (t) {\n    return null === t.color_range ? ('number' === t.color_type ? ['blue', 'red'] : null) : t.color_range\n  }\n  function H (t, e, r) {\n    var a = xt(t),\n      n = a.secondary(t.processed.min_x, t.processed.max_x)\n    0 === n.length && (n = [t.scales.X.ticks(t.xax_count)[0]])\n    var o,\n      i,\n      s,\n      c = S(r, 'mg-year-marker')\n    'default' === a.timeframe &&\n      t.show_year_markers &&\n      ((o = t),\n      (i = c),\n      (s = n),\n      a.yformat,\n      i\n        .selectAll('.mg-year-marker')\n        .data(s)\n        .enter()\n        .append('line')\n        .attr('x1', function (t) {\n          return o.scales.X(t).toFixed(2)\n        })\n        .attr('x2', function (t) {\n          return o.scales.X(t).toFixed(2)\n        })\n        .attr('y1', M(o))\n        .attr('y2', w(o))),\n      'years' != a.tick_diff_timeframe &&\n        (function (t, e, r, a, n) {\n          var o,\n            i,\n            s,\n            c,\n            l,\n            u = e.position,\n            d = e.namespace,\n            f = t.scales[d.toUpperCase()],\n            p = E.select(t.target)\n              .select('.mg-x-axis text')\n              .node()\n              .getBoundingClientRect()\n          'top' === u &&\n            ((o = function (t, e) {\n              return f(t).toFixed(2)\n            }),\n            (i = M(t) - (7 * t.xax_tick_length) / 3 - p.height),\n            (s = '.50em'),\n            (c = 'middle'),\n            (l = function (t) {\n              return n(new Date(t))\n            }))\n          'bottom' === u &&\n            ((o = function (t, e) {\n              return f(t).toFixed(2)\n            }),\n            (i = w(t) + (7 * t.xax_tick_length) / 3 + 0.8 * p.height),\n            (s = '.50em'),\n            (c = 'middle'),\n            (l = function (t) {\n              return n(new Date(t))\n            }))\n          r.selectAll('.mg-year-marker')\n            .data(a)\n            .enter()\n            .append('text')\n            .attr('x', o)\n            .attr('y', i)\n            .attr('dy', s)\n            .attr('text-anchor', c)\n            .text(l)\n        })(t, e, c, n, a.yformat)\n  }\n  function q (t, a, e) {\n    var r,\n      n,\n      o,\n      i,\n      s,\n      c,\n      l,\n      u = e.namespace,\n      d = ((r = a),\n      (o = (n = e).position),\n      (i = n.namespace),\n      (s = r[i + 'ax_tick_length']),\n      (c = r.scales[i.toUpperCase()]),\n      (l = {}),\n      'left' === o &&\n        ((l.x = G(r) - (3 * s) / 2),\n        (l.y = function (t) {\n          return c(t).toFixed(2)\n        }),\n        (l.dx = -3),\n        (l.dy = '.35em'),\n        (l.textAnchor = 'end'),\n        (l.text = function (t) {\n          return J(r)(t)\n        })),\n      'right' === o &&\n        ((l.x = A(r) + (3 * s) / 2),\n        (l.y = function (t) {\n          return c(t).toFixed(2)\n        }),\n        (l.dx = 3),\n        (l.dy = '.35em'),\n        (l.textAnchor = 'start'),\n        (l.text = function (t) {\n          return J(r)(t)\n        })),\n      'top' === o &&\n        ((l.x = function (t) {\n          return c(t).toFixed(2)\n        }),\n        (l.y = (M(r) - (7 * s) / 3).toFixed(2)),\n        (l.dx = 0),\n        (l.dy = '0em'),\n        (l.textAnchor = 'middle'),\n        (l.text = function (t) {\n          return ht(r)(t)\n        })),\n      'bottom' === o &&\n        ((l.x = function (t) {\n          return c(t).toFixed(2)\n        }),\n        (l.y = (w(r) + (7 * s) / 3).toFixed(2)),\n        (l.dx = 0),\n        (l.dy = '.50em'),\n        (l.textAnchor = 'middle'),\n        (l.text = function (t) {\n          return ht(r)(t)\n        })),\n      l),\n      f = a.processed[u + '_ticks'],\n      p = t\n        .selectAll('.mg-yax-labels')\n        .data(f)\n        .enter()\n        .append('text')\n        .attr('x', d.x)\n        .attr('dx', d.dx)\n        .attr('y', d.y)\n        .attr('dy', d.dy)\n        .attr('text-anchor', d.textAnchor)\n        .text(d.text)\n    ;('x' == u &&\n      (a.time_series && a.european_clock\n        ? (p\n            .append('tspan')\n            .classed('mg-european-hours', !0)\n            .text(function (t, e) {\n              var r = new Date(t)\n              return 0 === e ? E.timeFormat('%H')(r) : ''\n            }),\n          p\n            .append('tspan')\n            .classed('mg-european-minutes-seconds', !0)\n            .text(function (t, e) {\n              var r = new Date(t)\n              return ':' + a.processed.xax_format(r)\n            }))\n        : p.text(function (t) {\n            return a.xax_units + a.processed.xax_format(t)\n          }),\n      a.time_series && (a.show_years || a.show_secondary_x_label) && H(a, e, t)),\n    g(p)) &&\n      (p\n        .filter(function (t, e) {\n          return (e + 1) % 2 == 0\n        })\n        .remove(),\n      O(a.target)\n        .selectAll('.mg-' + u + 'ax-ticks')\n        .filter(function (t, e) {\n          return (e + 1) % 2 == 0\n        })\n        .remove())\n  }\n  function V (t, e, r) {\n    var a,\n      n,\n      o,\n      i,\n      s,\n      c,\n      l,\n      u,\n      d = r.namespace,\n      f = e.processed[d + '_ticks'].length,\n      p = ((a = e),\n      (o = (n = r).namespace),\n      (i = n.position),\n      (s = a.processed[o + '_ticks'].length),\n      (c = a.processed[o + '_ticks']),\n      (l = a.scales[o.toUpperCase()]),\n      (u = {}),\n      'left' === i && ((u.x1 = G(a)), (u.x2 = G(a)), (u.y1 = l(c[0]).toFixed(2)), (u.y2 = l(c[s - 1]).toFixed(2))),\n      'right' === i && ((u.x1 = A(a)), (u.x2 = A(a)), (u.y1 = l(c[0]).toFixed(2)), (u.y2 = l(c[s - 1]).toFixed(2))),\n      'top' === i && ((u.x1 = G(a)), (u.x2 = A(a)), (u.y1 = M(a)), (u.y2 = M(a))),\n      'bottom' === i && ((u.x1 = G(a)), (u.x2 = A(a)), (u.y1 = w(a)), (u.y2 = w(a))),\n      ('left' !== i && 'right' !== i) ||\n        (a.axes_not_compact\n          ? ((u.y1 = w(a)), (u.y2 = M(a)))\n          : s && ((u.y1 = l(c[0]).toFixed(2)), (u.y2 = l(c[s - 1]).toFixed(2)))),\n      u)\n    e[d + '_extended_ticks'] ||\n      e[d + '_extended_ticks'] ||\n      !f ||\n      t\n        .append('line')\n        .attr('x1', p.x1)\n        .attr('x2', p.x2)\n        .attr('y1', p.y1)\n        .attr('y2', p.y2)\n  }\n  function W (t, e) {\n    t.rug_buffer_size = 'point' === t.chart_type ? t.buffer / 2 : (2 * t.buffer) / 3\n    var r,\n      a,\n      n,\n      o,\n      i,\n      s,\n      c,\n      l,\n      u,\n      d,\n      f = ((r = t),\n      (a = 'mg-' + e.namespace + '-rug'),\n      (n = O(r.target)),\n      (o = h(r.data)),\n      (i = n.selectAll('line.' + a).data(o))\n        .enter()\n        .append('svg:line')\n        .attr('class', a)\n        .attr('opacity', 0.3),\n      _(i),\n      _(i),\n      i),\n      p = ((s = t),\n      (l = (c = e).position),\n      (u = c.namespace),\n      (d = {}),\n      'left' === l &&\n        ((d.x1 = G(s) + 1),\n        (d.x2 = G(s) + s.rug_buffer_size),\n        (d.y1 = s.scalefns[u + 'f']),\n        (d.y2 = s.scalefns[u + 'f'])),\n      'right' === l &&\n        ((d.x1 = A(s) - 1),\n        (d.x2 = A(s) - s.rug_buffer_size),\n        (d.y1 = s.scalefns[u + 'f']),\n        (d.y2 = s.scalefns[u + 'f'])),\n      'top' === l &&\n        ((d.x1 = s.scalefns[u + 'f']),\n        (d.x2 = s.scalefns[u + 'f']),\n        (d.y1 = M(s) + 1),\n        (d.y2 = M(s) + s.rug_buffer_size)),\n      'bottom' === l &&\n        ((d.x1 = s.scalefns[u + 'f']),\n        (d.x2 = s.scalefns[u + 'f']),\n        (d.y1 = w(s) - 1),\n        (d.y2 = w(s) - s.rug_buffer_size)),\n      d)\n    f\n      .attr('x1', p.x1)\n      .attr('x2', p.x2)\n      .attr('y1', p.y1)\n      .attr('y2', p.y2),\n      m(f, t, 'mg-' + e.namespace + '-rug-mono')\n  }\n  function Q (p, _) {\n    var m = _.namespace,\n      t = 'mg-' + m + '-axis',\n      g = p.scales[m.toUpperCase()],\n      e = p.scales[(m + 'group').toUpperCase()],\n      h = m + 'group_accessor',\n      r = O(p.target)\n    D(r, '.' + t)\n    var x,\n      y = S(r, t)\n    ;(e.domain && e.domain() ? e.domain() : ['1']).forEach(function (t) {\n      var e,\n        r,\n        a,\n        n,\n        o,\n        i,\n        s,\n        c,\n        l,\n        u,\n        d = ((e = p),\n        (a = t),\n        (n = (r = _).namespace),\n        (o = r.position),\n        (i = e.scales[n.toUpperCase()]),\n        (s = e.scales[(n + 'group').toUpperCase()]),\n        (c = { cat: {}, group: {} }),\n        'left' === o &&\n          ((c.cat.x = Y(e) - e.buffer),\n          (c.cat.y = function (t) {\n            return s(a) + i(t) + i.bandwidth() / 2\n          }),\n          (c.cat.dy = '.35em'),\n          (c.cat.textAnchor = 'end'),\n          (c.group.x = Y(e) - e.buffer),\n          (c.group.y = s(a) + (s.bandwidth ? s.bandwidth() / 2 : 0)),\n          (c.group.dy = '.35em'),\n          (c.group.textAnchor = (e['rotate_' + n + '_labels'], 'end'))),\n        'right' === o &&\n          ((c.cat.x = P(e) - e.buffer),\n          (c.cat.y = function (t) {\n            return s(a) + i(t) + i.bandwidth() / 2\n          }),\n          (c.cat.dy = '.35em'),\n          (c.cat.textAnchor = 'start'),\n          (c.group.x = P(e) - e.buffer),\n          (c.group.y = s(a) + (s.bandwidth ? s.bandwidth() / 2 : 0)),\n          (c.group.dy = '.35em'),\n          (c.group.textAnchor = 'start')),\n        'top' === o &&\n          ((c.cat.x = function (t) {\n            return s(a) + i(t) + i.bandwidth() / 2\n          }),\n          (c.cat.y = b(e) + e.buffer),\n          (c.cat.dy = '.35em'),\n          (c.cat.textAnchor = e['rotate_' + n + '_labels'] ? 'start' : 'middle'),\n          (c.group.x = s(a) + (s.bandwidth ? s.bandwidth() / 2 : 0)),\n          (c.group.y = b(e) + e.buffer),\n          (c.group.dy = '.35em'),\n          (c.group.textAnchor = e['rotate_' + n + '_labels'] ? 'start' : 'middle')),\n        'bottom' === o &&\n          ((c.cat.x = function (t) {\n            return s(a) + i(t) + i.bandwidth() / 2\n          }),\n          (c.cat.y = v(e) + e.buffer),\n          (c.cat.dy = '.35em'),\n          (c.cat.textAnchor = e['rotate_' + n + '_labels'] ? 'start' : 'middle'),\n          (c.group.x = s(a) + (s.bandwidth ? s.bandwidth() / 2 - i.bandwidth() / 2 : 0)),\n          (c.group.y = v(e) + e.buffer),\n          (c.group.dy = '.35em'),\n          (c.group.textAnchor = e['rotate_' + n + '_labels'] ? 'start' : 'middle')),\n        c)\n      if (((x = S(y, 'mg-group-' + F(t))), null !== p[h]))\n        var f = x\n          .append('text')\n          .classed('mg-barplot-group-label', !0)\n          .attr('x', d.group.x)\n          .attr('y', d.group.y)\n          .attr('dy', d.group.dy)\n          .attr('text-anchor', d.group.textAnchor)\n          .text(t)\n      else\n        f = x\n          .selectAll('text')\n          .data(g.domain())\n          .enter()\n          .append('text')\n          .attr('x', d.cat.x)\n          .attr('y', d.cat.y)\n          .attr('dy', d.cat.dy)\n          .attr('text-anchor', d.cat.textAnchor)\n          .text(String)\n      p['rotate_' + m + '_labels'] &&\n        ((l = f),\n        (u = p['rotate_' + m + '_labels']) &&\n          l.attr('transform', function () {\n            var t = E.select(this)\n            return 'rotate(' + u + ' ' + t.attr('x') + ',' + t.attr('y') + ')'\n          }))\n    })\n  }\n  ;(MG.merge_with_defaults = p),\n    (MG.clone = function (t) {\n      var e, r\n      if (null === t || 'object' !== (void 0 === t ? 'undefined' : c(t))) return t\n      if (x(t)) return (e = new Date()).setTime(t.getTime()), e\n      if (y(t)) {\n        e = []\n        for (var a = 0, n = t.length; a < n; a++) e[a] = MG.clone(t[a])\n        return e\n      }\n      if (((r = t), '[object Object]' === Object.prototype.toString.call(r))) {\n        for (var o in ((e = {}), t)) t.hasOwnProperty(o) && (e[o] = MG.clone(t[o]))\n        return e\n      }\n      throw new Error(\"Unable to copy obj! Its type isn't supported.\")\n    }),\n    (MG.arr_diff = T),\n    (MG.warn_deprecation = R),\n    (MG.truncate_text = L),\n    (MG.wrap_text = function (t, i, s, c) {\n      t.each(function () {\n        for (\n          var t,\n            e = E.select(this),\n            r = e\n              .text()\n              .split(s || /\\s+/)\n              .reverse(),\n            a = [],\n            n = 0,\n            o = (e.attr('y'),\n            e\n              .text(null)\n              .append('tspan')\n              .attr('x', 0)\n              .attr('y', '0em')\n              .attr(c || {}));\n          (t = r.pop());\n\n        )\n          a.push(t),\n            o.text(a.join(' ')),\n            (null === i || o.node().getComputedTextLength() > i) &&\n              (a.pop(),\n              o.text(a.join(' ')),\n              (a = [t]),\n              (o = e\n                .append('tspan')\n                .attr('x', 0)\n                .attr('y', 1.1 * ++n + 0 + 'em')\n                .attr(c || {})\n                .text(t)))\n      })\n    }),\n    (MG.register = function (t, e, r) {\n      MG.charts[t] = { descriptor: e, defaults: r || {} }\n    }),\n    (MG._hooks = {}),\n    (MG.add_hook = function (t, e, r) {\n      var a\n      if (\n        (MG._hooks[t] || (MG._hooks[t] = []),\n        0 <\n          (a = MG._hooks[t]).filter(function (t) {\n            return t.func === e\n          }).length)\n      )\n        throw 'That function is already registered.'\n      a.push({ func: e, context: r })\n    }),\n    (MG.call_hook = function (t) {\n      var r,\n        e = MG._hooks[t],\n        a = [].slice.apply(arguments, [1])\n      return (\n        e &&\n          e.forEach(function (t) {\n            if (t.func) {\n              var e = r || a\n              e && e.constructor !== Array && (e = [e]), (e = [].concat.apply([], e)), (r = t.func.apply(t.context, e))\n            }\n          }),\n        r || a\n      )\n    }),\n    (MG.globals = {}),\n    (MG.deprecations = {\n      rollover_callback: { replacement: 'mouseover', version: '2.0' },\n      rollout_callback: { replacement: 'mouseout', version: '2.0' },\n      x_rollover_format: { replacement: 'x_mouseover', version: '2.10' },\n      y_rollover_format: { replacement: 'y_mouseover', version: '2.10' },\n      show_years: { replacement: 'show_secondary_x_label', version: '2.1' },\n      xax_start_at_min: { replacement: 'axes_not_compact', version: '2.7' },\n      interpolate_tension: { replacement: 'interpolate', version: '2.10' }\n    }),\n    (MG.globals.link = !1),\n    (MG.globals.version = '1.1'),\n    (MG.charts = {}),\n    (MG.data_graphic = function (t) {\n      var e = {\n        missing_is_zero: !1,\n        missing_is_hidden: !1,\n        missing_is_hidden_accessor: null,\n        legend: '',\n        legend_target: '',\n        error: '',\n        animate_on_load: !1,\n        top: 65,\n        title_y_position: 10,\n        center_title_full_width: !1,\n        bottom: 45,\n        right: 10,\n        left: 50,\n        buffer: 8,\n        width: 350,\n        height: 220,\n        full_width: !1,\n        full_height: !1,\n        small_height_threshold: 120,\n        small_width_threshold: 160,\n        xax_count: 6,\n        xax_tick_length: 5,\n        axes_not_compact: !0,\n        yax_count: 3,\n        yax_tick_length: 5,\n        x_extended_ticks: !1,\n        y_extended_ticks: !1,\n        y_scale_type: 'linear',\n        max_x: null,\n        max_y: null,\n        min_x: null,\n        min_y: null,\n        min_y_from_data: !1,\n        point_size: 2.5,\n        active_point_on_lines: !1,\n        active_point_accessor: 'active',\n        active_point_size: 2,\n        points_always_visible: !1,\n        x_accessor: 'date',\n        xax_units: '',\n        x_label: '',\n        x_sort: !0,\n        x_axis: !0,\n        y_axis: !0,\n        x_axis_position: 'bottom',\n        y_axis_position: 'left',\n        x_axis_type: null,\n        y_axis_type: null,\n        ygroup_accessor: null,\n        xgroup_accessor: null,\n        y_padding_percentage: 0.05,\n        y_outer_padding_percentage: 0.1,\n        ygroup_padding_percentage: 0.25,\n        ygroup_outer_padding_percentage: 0,\n        x_padding_percentage: 0.05,\n        x_outer_padding_percentage: 0.1,\n        xgroup_padding_percentage: 0.25,\n        xgroup_outer_padding_percentage: 0,\n        y_categorical_show_guides: !1,\n        x_categorical_show_guide: !1,\n        rotate_x_labels: 0,\n        rotate_y_labels: 0,\n        y_accessor: 'value',\n        y_label: '',\n        yax_units: '',\n        yax_units_append: !1,\n        x_rug: !1,\n        y_rug: !1,\n        mouseover_align: 'right',\n        x_mouseover: null,\n        y_mouseover: null,\n        transition_on_update: !0,\n        mouseover: null,\n        click: null,\n        show_rollover_text: !0,\n        show_confidence_band: null,\n        xax_format: null,\n        area: !0,\n        flip_area_under_y_value: null,\n        chart_type: 'line',\n        data: [],\n        decimals: 2,\n        format: 'count',\n        inflator: 10 / 9,\n        linked: !1,\n        linked_format: '%Y-%m-%d',\n        list: !1,\n        baselines: null,\n        markers: null,\n        scalefns: {},\n        scales: {},\n        utc_time: !1,\n        european_clock: !1,\n        show_year_markers: !1,\n        show_secondary_x_label: !0,\n        target: '#viz',\n        interpolate: E.curveCatmullRom.alpha(0),\n        custom_line_color_map: [],\n        colors: null,\n        max_data_size: null,\n        aggregate_rollover: !1,\n        show_tooltips: !0,\n        showActivePoint: !0,\n        brush: null,\n        zoom_target: null,\n        brushing_selection_changed: null\n      }\n      MG.call_hook('global.defaults', e), t || (t = {})\n      var r = MG.charts[t.chart_type || e.chart_type]\n      for (var a in (p(t, r.defaults, e), t.list && ((t.x_accessor = 0), (t.y_accessor = 1)), MG.deprecations))\n        if (t.hasOwnProperty(a)) {\n          var n = MG.deprecations[a],\n            o = 'Use of `args.' + a + '` has been deprecated',\n            i = n.replacement\n          if (\n            (i &&\n              (t[i]\n                ? (o +=\n                    '. The replacement - `args.' +\n                    i +\n                    '` - has already been defined. This definition will be discarded.')\n                : (t[i] = t[a])),\n            n.warned)\n          )\n            continue\n          ;(n.warned = !0), i && (o += ' in favor of `args.' + i + '`'), R(o, n.version)\n        }\n      return MG.call_hook('global.before_init', t), new r.descriptor(t), t.data\n    }),\n    k() &&\n      ((function (m) {\n        var g = function (t, e) {\n          ;(this.type = null),\n            (this.options = null),\n            (this.enabled = null),\n            (this.timeout = null),\n            (this.hoverState = null),\n            (this.$element = null),\n            (this.inState = null),\n            this.init('tooltip', t, e)\n        }\n        ;(g.VERSION = '3.3.5'),\n          (g.TRANSITION_DURATION = 150),\n          (g.DEFAULTS = {\n            animation: !0,\n            placement: 'top',\n            selector: !1,\n            template:\n              '<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>',\n            trigger: 'hover focus',\n            title: '',\n            delay: 0,\n            html: !1,\n            container: !1,\n            viewport: { selector: 'body', padding: 0 }\n          }),\n          (g.prototype.init = function (t, e, r) {\n            if (\n              ((this.enabled = !0),\n              (this.type = t),\n              (this.$element = m(e)),\n              (this.options = this.getOptions(r)),\n              (this.$viewport =\n                this.options.viewport &&\n                m(\n                  m.isFunction(this.options.viewport)\n                    ? this.options.viewport.call(this, this.$element)\n                    : this.options.viewport.selector || this.options.viewport\n                )),\n              (this.inState = { click: !1, hover: !1, focus: !1 }),\n              this.$element[0] instanceof document.constructor && !this.options.selector)\n            )\n              throw new Error(\n                '`selector` option must be specified when initializing ' + this.type + ' on the window.document object!'\n              )\n            for (var a = this.options.trigger.split(' '), n = a.length; n--; ) {\n              var o = a[n]\n              if ('click' == o)\n                this.$element.on('click.' + this.type, this.options.selector, m.proxy(this.toggle, this))\n              else if ('manual' != o) {\n                var i = 'hover' == o ? 'mouseenter' : 'focusin',\n                  s = 'hover' == o ? 'mouseleave' : 'focusout'\n                this.$element.on(i + '.' + this.type, this.options.selector, m.proxy(this.enter, this)),\n                  this.$element.on(s + '.' + this.type, this.options.selector, m.proxy(this.leave, this))\n              }\n            }\n            this.options.selector\n              ? (this._options = m.extend({}, this.options, { trigger: 'manual', selector: '' }))\n              : this.fixTitle()\n          }),\n          (g.prototype.getDefaults = function () {\n            return g.DEFAULTS\n          }),\n          (g.prototype.getOptions = function (t) {\n            return (\n              (t = m.extend({}, this.getDefaults(), this.$element.data(), t)).delay &&\n                'number' == typeof t.delay &&\n                (t.delay = { show: t.delay, hide: t.delay }),\n              t\n            )\n          }),\n          (g.prototype.getDelegateOptions = function () {\n            var r = {},\n              a = this.getDefaults()\n            return (\n              this._options &&\n                m.each(this._options, function (t, e) {\n                  a[t] != e && (r[t] = e)\n                }),\n              r\n            )\n          }),\n          (g.prototype.enter = function (t) {\n            var e = t instanceof this.constructor ? t : m(t.currentTarget).data('bs.' + this.type)\n            if (\n              (e ||\n                ((e = new this.constructor(t.currentTarget, this.getDelegateOptions())),\n                m(t.currentTarget).data('bs.' + this.type, e)),\n              t instanceof m.Event && (e.inState['focusin' == t.type ? 'focus' : 'hover'] = !0),\n              e.tip().hasClass('in') || 'in' == e.hoverState)\n            )\n              e.hoverState = 'in'\n            else {\n              if ((clearTimeout(e.timeout), (e.hoverState = 'in'), !e.options.delay || !e.options.delay.show))\n                return e.show()\n              e.timeout = setTimeout(function () {\n                'in' == e.hoverState && e.show()\n              }, e.options.delay.show)\n            }\n          }),\n          (g.prototype.isInStateTrue = function () {\n            for (var t in this.inState) if (this.inState[t]) return !0\n            return !1\n          }),\n          (g.prototype.leave = function (t) {\n            var e = t instanceof this.constructor ? t : m(t.currentTarget).data('bs.' + this.type)\n            if (\n              (e ||\n                ((e = new this.constructor(t.currentTarget, this.getDelegateOptions())),\n                m(t.currentTarget).data('bs.' + this.type, e)),\n              t instanceof m.Event && (e.inState['focusout' == t.type ? 'focus' : 'hover'] = !1),\n              !e.isInStateTrue())\n            ) {\n              if ((clearTimeout(e.timeout), (e.hoverState = 'out'), !e.options.delay || !e.options.delay.hide))\n                return e.hide()\n              e.timeout = setTimeout(function () {\n                'out' == e.hoverState && e.hide()\n              }, e.options.delay.hide)\n            }\n          }),\n          (g.prototype.show = function () {\n            var t = m.Event('show.bs.' + this.type)\n            if (this.hasContent() && this.enabled) {\n              this.$element.trigger(t)\n              var e = m.contains(this.$element[0].ownerDocument.documentElement, this.$element[0])\n              if (t.isDefaultPrevented() || !e) return\n              var r = this,\n                a = this.tip(),\n                n = this.getUID(this.type)\n              this.setContent(),\n                a.attr('id', n),\n                this.$element.attr('aria-describedby', n),\n                this.options.animation && a.addClass('fade')\n              var o =\n                  'function' == typeof this.options.placement\n                    ? this.options.placement.call(this, a[0], this.$element[0])\n                    : this.options.placement,\n                i = /\\s?auto?\\s?/i,\n                s = i.test(o)\n              s && (o = o.replace(i, '') || 'top'),\n                a\n                  .detach()\n                  .css({ top: 0, left: 0, display: 'block' })\n                  .addClass(o)\n                  .data('bs.' + this.type, this),\n                this.options.container ? a.appendTo(this.options.container) : a.insertAfter(this.$element),\n                this.$element.trigger('inserted.bs.' + this.type)\n              var c = this.getPosition(),\n                l = a[0].offsetWidth,\n                u = a[0].offsetHeight\n              if (s) {\n                var d = o,\n                  f = this.getPosition(this.$viewport)\n                ;(o =\n                  'bottom' == o && c.bottom + u > f.bottom\n                    ? 'top'\n                    : 'top' == o && c.top - u < f.top\n                    ? 'bottom'\n                    : 'right' == o && c.right + l > f.width\n                    ? 'left'\n                    : 'left' == o && c.left - l < f.left\n                    ? 'right'\n                    : o),\n                  a.removeClass(d).addClass(o)\n              }\n              var p = this.getCalculatedOffset(o, c, l, u)\n              this.applyPlacement(p, o)\n              var _ = function () {\n                var t = r.hoverState\n                r.$element.trigger('shown.bs.' + r.type), (r.hoverState = null), 'out' == t && r.leave(r)\n              }\n              m.support.transition && this.$tip.hasClass('fade')\n                ? a.one('bsTransitionEnd', _).emulateTransitionEnd(g.TRANSITION_DURATION)\n                : _()\n            }\n          }),\n          (g.prototype.applyPlacement = function (t, e) {\n            var r = this.tip(),\n              a = r[0].offsetWidth,\n              n = r[0].offsetHeight,\n              o = parseInt(r.css('margin-top'), 10),\n              i = parseInt(r.css('margin-left'), 10)\n            isNaN(o) && (o = 0),\n              isNaN(i) && (i = 0),\n              (t.top += o),\n              (t.left += i),\n              m.offset.setOffset(\n                r[0],\n                m.extend(\n                  {\n                    using: function (t) {\n                      r.css({ top: Math.round(t.top), left: Math.round(t.left) })\n                    }\n                  },\n                  t\n                ),\n                0\n              ),\n              r.addClass('in')\n            var s = r[0].offsetWidth,\n              c = r[0].offsetHeight\n            'top' == e && c != n && (t.top = t.top + n - c)\n            var l = this.getViewportAdjustedDelta(e, t, s, c)\n            l.left ? (t.left += l.left) : (t.top += l.top)\n            var u = /top|bottom/.test(e),\n              d = u ? 2 * l.left - a + s : 2 * l.top - n + c,\n              f = u ? 'offsetWidth' : 'offsetHeight'\n            r.offset(t), this.replaceArrow(d, r[0][f], u)\n          }),\n          (g.prototype.replaceArrow = function (t, e, r) {\n            this.arrow()\n              .css(r ? 'left' : 'top', 50 * (1 - t / e) + '%')\n              .css(r ? 'top' : 'left', '')\n          }),\n          (g.prototype.setContent = function () {\n            var t = this.tip(),\n              e = this.getTitle()\n            t.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](e),\n              t.removeClass('fade in top bottom left right')\n          }),\n          (g.prototype.hide = function (t) {\n            var e = this,\n              r = m(this.$tip),\n              a = m.Event('hide.bs.' + this.type)\n            function n () {\n              'in' != e.hoverState && r.detach(),\n                e.$element.removeAttr('aria-describedby').trigger('hidden.bs.' + e.type),\n                t && t()\n            }\n            if ((this.$element.trigger(a), !a.isDefaultPrevented()))\n              return (\n                r.removeClass('in'),\n                m.support.transition && r.hasClass('fade')\n                  ? r.one('bsTransitionEnd', n).emulateTransitionEnd(g.TRANSITION_DURATION)\n                  : n(),\n                (this.hoverState = null),\n                this\n              )\n          }),\n          (g.prototype.fixTitle = function () {\n            var t = this.$element\n            ;(t.attr('title') || 'string' != typeof t.attr('data-original-title')) &&\n              t.attr('data-original-title', t.attr('title') || '').attr('title', '')\n          }),\n          (g.prototype.hasContent = function () {\n            return this.getTitle()\n          }),\n          (g.prototype.getPosition = function (t) {\n            var e = (t = t || this.$element)[0],\n              r = 'BODY' == e.tagName,\n              a = e.getBoundingClientRect()\n            null == a.width && (a = m.extend({}, a, { width: a.right - a.left, height: a.bottom - a.top }))\n            var n = r ? { top: 0, left: 0 } : t.offset(),\n              o = { scroll: r ? document.documentElement.scrollTop || document.body.scrollTop : t.scrollTop() },\n              i = r ? { width: m(window).width(), height: m(window).height() } : null\n            return m.extend({}, a, o, i, n)\n          }),\n          (g.prototype.getCalculatedOffset = function (t, e, r, a) {\n            return 'bottom' == t\n              ? { top: e.top + e.height, left: e.left + e.width / 2 - r / 2 }\n              : 'top' == t\n              ? { top: e.top - a, left: e.left + e.width / 2 - r / 2 }\n              : 'left' == t\n              ? { top: e.top + e.height / 2 - a / 2, left: e.left - r }\n              : { top: e.top + e.height / 2 - a / 2, left: e.left + e.width }\n          }),\n          (g.prototype.getViewportAdjustedDelta = function (t, e, r, a) {\n            var n = { top: 0, left: 0 }\n            if (!this.$viewport) return n\n            var o = (this.options.viewport && this.options.viewport.padding) || 0,\n              i = this.getPosition(this.$viewport)\n            if (/right|left/.test(t)) {\n              var s = e.top - o - i.scroll,\n                c = e.top + o - i.scroll + a\n              s < i.top ? (n.top = i.top - s) : c > i.top + i.height && (n.top = i.top + i.height - c)\n            } else {\n              var l = e.left - o,\n                u = e.left + o + r\n              l < i.left ? (n.left = i.left - l) : u > i.right && (n.left = i.left + i.width - u)\n            }\n            return n\n          }),\n          (g.prototype.getTitle = function () {\n            var t = this.$element,\n              e = this.options\n            return t.attr('data-original-title') || ('function' == typeof e.title ? e.title.call(t[0]) : e.title)\n          }),\n          (g.prototype.getUID = function (t) {\n            for (; (t += ~~(1e6 * Math.random())), document.getElementById(t); );\n            return t\n          }),\n          (g.prototype.tip = function () {\n            if (!this.$tip && ((this.$tip = m(this.options.template)), 1 != this.$tip.length))\n              throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!')\n            return this.$tip\n          }),\n          (g.prototype.arrow = function () {\n            return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))\n          }),\n          (g.prototype.enable = function () {\n            this.enabled = !0\n          }),\n          (g.prototype.disable = function () {\n            this.enabled = !1\n          }),\n          (g.prototype.toggleEnabled = function () {\n            this.enabled = !this.enabled\n          }),\n          (g.prototype.toggle = function (t) {\n            var e = this\n            t &&\n              ((e = m(t.currentTarget).data('bs.' + this.type)) ||\n                ((e = new this.constructor(t.currentTarget, this.getDelegateOptions())),\n                m(t.currentTarget).data('bs.' + this.type, e))),\n              t\n                ? ((e.inState.click = !e.inState.click), e.isInStateTrue() ? e.enter(e) : e.leave(e))\n                : e.tip().hasClass('in')\n                ? e.leave(e)\n                : e.enter(e)\n          }),\n          (g.prototype.destroy = function () {\n            var t = this\n            clearTimeout(this.timeout),\n              this.hide(function () {\n                t.$element.off('.' + t.type).removeData('bs.' + t.type),\n                  t.$tip && t.$tip.detach(),\n                  (t.$tip = null),\n                  (t.$arrow = null),\n                  (t.$viewport = null)\n              })\n          })\n        var t = m.fn.tooltip\n        ;(m.fn.tooltip = function (a) {\n          return this.each(function () {\n            var t = m(this),\n              e = t.data('bs.tooltip'),\n              r = 'object' == (void 0 === a ? 'undefined' : c(a)) && a\n            ;(!e && /destroy|hide/.test(a)) ||\n              (e || t.data('bs.tooltip', (e = new g(this, r))), 'string' == typeof a && e[a]())\n          })\n        }),\n          (m.fn.tooltip.Constructor = g),\n          (m.fn.tooltip.noConflict = function () {\n            return (m.fn.tooltip = t), this\n          })\n      })(jQuery),\n      (function (n) {\n        var o = function (t, e) {\n          this.init('popover', t, e)\n        }\n        if (!n.fn.tooltip) throw new Error('Popover requires tooltip.js')\n        ;(o.VERSION = '3.3.5'),\n          (o.DEFAULTS = n.extend({}, n.fn.tooltip.Constructor.DEFAULTS, {\n            placement: 'right',\n            trigger: 'click',\n            content: '',\n            template:\n              '<div class=\"popover\" role=\"tooltip\"><div class=\"arrow\"></div><h3 class=\"popover-title\"></h3><div class=\"popover-content\"></div></div>'\n          })),\n          (((o.prototype = n.extend(\n            {},\n            n.fn.tooltip.Constructor.prototype\n          )).constructor = o).prototype.getDefaults = function () {\n            return o.DEFAULTS\n          }),\n          (o.prototype.setContent = function () {\n            var t = this.tip(),\n              e = this.getTitle(),\n              r = this.getContent()\n            t.find('.popover-title')[this.options.html ? 'html' : 'text'](e),\n              t\n                .find('.popover-content')\n                .children()\n                .detach()\n                .end()\n                [this.options.html ? ('string' == typeof r ? 'html' : 'append') : 'text'](r),\n              t.removeClass('fade top bottom left right in'),\n              t.find('.popover-title').html() || t.find('.popover-title').hide()\n          }),\n          (o.prototype.hasContent = function () {\n            return this.getTitle() || this.getContent()\n          }),\n          (o.prototype.getContent = function () {\n            var t = this.$element,\n              e = this.options\n            return t.attr('data-content') || ('function' == typeof e.content ? e.content.call(t[0]) : e.content)\n          }),\n          (o.prototype.arrow = function () {\n            return (this.$arrow = this.$arrow || this.tip().find('.arrow'))\n          })\n        var t = n.fn.popover\n        ;(n.fn.popover = function (a) {\n          return this.each(function () {\n            var t = n(this),\n              e = t.data('bs.popover'),\n              r = 'object' == (void 0 === a ? 'undefined' : c(a)) && a\n            ;(!e && /destroy|hide/.test(a)) ||\n              (e || t.data('bs.popover', (e = new o(this, r))), 'string' == typeof a && e[a]())\n          })\n        }),\n          (n.fn.popover.Constructor = o),\n          (n.fn.popover.noConflict = function () {\n            return (n.fn.popover = t), this\n          })\n      })(jQuery)),\n    (MG.chart_title = j),\n    (MG.scale_factory = function (o) {\n      var i = { use_inflator: !1, zero_bottom: !1, scaleType: 'numerical' }\n      return (\n        (this.namespace = function (t) {\n          return (\n            (i.namespace = t),\n            (i.namespace_accessor_name = i.namespace + '_accessor'),\n            (i.scale_name = i.namespace.toUpperCase()),\n            (i.scalefn_name = i.namespace + 'f'),\n            this\n          )\n        }),\n        (this.scaleName = function (t) {\n          return (i.scale_name = t.toUpperCase()), (i.scalefn_name = t + 'f'), this\n        }),\n        (this.inflateDomain = function (t) {\n          return (i.use_inflator = t), this\n        }),\n        (this.zeroBottom = function (t) {\n          return (i.zero_bottom = t), this\n        }),\n        (this.numericalDomainFromData = function () {\n          var t,\n            e = []\n          0 < arguments.length && (e = arguments)\n          for (var r = 0; r < o.data.length; r++) 0 < o.data[r].length && (t = o.data[r])\n          ;(i.is_time_series = !!x(t[0][o[i.namespace_accessor_name]])),\n            X(o, i.scalefn_name, i.scale_name, o[i.namespace_accessor_name]),\n            (function (t, e, r) {\n              var a = e.namespace,\n                n = e.namespace_accessor_name,\n                o = e.use_inflator,\n                i = e.zero_bottom,\n                s = t[n],\n                c = h(t.data)\n                  .map(function (t) {\n                    return t[s]\n                  })\n                  .concat(h(r))\n              'log' === t[a + '_scale_type'] &&\n                (c = c.filter(function (t) {\n                  return 0 < t\n                }))\n              var l = E.extent(c),\n                u = l[0],\n                d = l[1]\n              i &&\n                !t['min_' + a + '_from_data'] &&\n                0 < u &&\n                !e.is_time_series &&\n                (u = 'log' === t[a + '_scale_type'] ? 1 : 0),\n                'log' !== t[a + '_scale_type'] && u < 0 && !e.is_time_series && (u -= (u - u * t.inflator) * o),\n                e.is_time_series || (d = d < 0 ? d + (d - d * t.inflator) * o : d * (o ? t.inflator : 1)),\n                (u = null != t['min_' + a] ? t['min_' + a] : u),\n                (d = null != t['max_' + a] ? t['max_' + a] : d),\n                u === d &&\n                  null == t['min_' + a] &&\n                  null == t['max_' + a] &&\n                  (x(u)\n                    ? (d = new Date(MG.clone(u).setDate(u.getDate() + 1)))\n                    : 'number' == typeof u && ((d = u + 1), (t.xax_count = 2))),\n                (t.processed['min_' + a] = u),\n                (t.processed['max_' + a] = d),\n                t.processed['zoom_' + a] &&\n                  ((t.processed['min_' + a] = t.processed['zoom_' + a][0]),\n                  (t.processed['max_' + a] = t.processed['zoom_' + a][1])),\n                MG.call_hook('x_axis.process_min_max', t, t.processed.min_x, t.processed.max_x),\n                MG.call_hook('y_axis.process_min_max', t, t.processed.min_y, t.processed.max_y)\n            })(o, i, e, i.use_inflator)\n          var a = o.utc_time ? E.scaleUtc() : E.scaleTime()\n          return (\n            (o.scales[i.scale_name] = i.is_time_series\n              ? a\n              : C(o[i.namespace + '_scale_type'])\n              ? o.y_scale_type()\n              : 'log' === o[i.namespace + '_scale_type']\n              ? E.scaleLog()\n              : E.scaleLinear()),\n            o.scales[i.scale_name].domain([o.processed['min_' + i.namespace], o.processed['max_' + i.namespace]]),\n            (i.scaleType = 'numerical'),\n            this\n          )\n        }),\n        (this.categoricalDomain = function (t) {\n          return (\n            (o.scales[i.scale_name] = E.scaleOrdinal().domain(t)),\n            X(o, i.scalefn_name, i.scale_name, o[i.namespace_accessor_name]),\n            this\n          )\n        }),\n        (this.categoricalDomainFromData = function () {\n          var t = h(o.data)\n          return (\n            (i.categoricalVariables = E.set(\n              t.map(function (t) {\n                return t[o[i.namespace_accessor_name]]\n              })\n            ).values()),\n            (o.scales[i.scale_name] = E.scaleBand().domain(i.categoricalVariables)),\n            (i.scaleType = 'categorical'),\n            this\n          )\n        }),\n        (this.numericalRange = function (t) {\n          return 'string' == typeof t ? o.scales[i.scale_name].range(U(t, o)) : o.scales[i.scale_name].range(t), this\n        }),\n        (this.categoricalRangeBands = function (t, e) {\n          void 0 === e && (e = !1)\n          var r = i.namespace,\n            a = o[r + '_padding_percentage'],\n            n = o[r + '_outer_padding_percentage']\n          return (\n            'string' == typeof t\n              ? o.scales[i.scale_name]\n                  .range(U(t, o))\n                  .paddingInner(a)\n                  .paddingOuter(n)\n              : o.scales[i.scale_name]\n                  .range(t)\n                  .paddingInner(a)\n                  .paddingOuter(n),\n            X(\n              o,\n              i.scalefn_name,\n              i.scale_name,\n              o[i.namespace_accessor_name],\n              e ? o.scales[i.scale_name].bandwidth() / 2 : 0\n            ),\n            this\n          )\n        }),\n        (this.categoricalRange = function (t) {\n          return o.scales[i.scale_name].range(t), X(o, i.scalefn_name, i.scale_name, o[i.namespace_accessor_name]), this\n        }),\n        (this.categoricalColorRange = function () {\n          return (\n            (o.scales[i.scale_name] =\n              10 < o.scales[i.scale_name].domain().length\n                ? E.scaleOrdinal(E.schemeCategory20)\n                : E.scaleOrdinal(E.schemeCategory10)),\n            o.scales[i.scale_name].domain(i.categoricalVariables),\n            X(o, i.scalefn_name, i.scale_name, o[i.namespace_accessor_name]),\n            this\n          )\n        }),\n        (this.clamp = function (t) {\n          return o.scales[i.scale_name].clamp(t), this\n        }),\n        this\n      )\n    })\n  var Z = {}\n  function K (t) {\n    if (t.y_rug) {\n      t.rug_buffer_size = 'point' === t.chart_type ? t.buffer / 2 : (2 * t.buffer) / 3\n      var e = r(t, 'mg-y-rug')\n      e\n        .attr('x1', t.left + 1)\n        .attr('x2', t.left + t.rug_buffer_size)\n        .attr('y1', t.scalefns.yf)\n        .attr('y2', t.scalefns.yf),\n        m(e, t, 'mg-y-rug-mono')\n    }\n  }\n  function J (r) {\n    var t = r.yax_format\n    if (!t) {\n      var a = r.decimals\n      'count' === r.format\n        ? (1 < r.processed.y_ticks.length &&\n            (a = Math.max(\n              0,\n              -Math.floor(Math.log(Math.abs(r.processed.y_ticks[1] - r.processed.y_ticks[0])) / Math.LN10)\n            )),\n          (t = function (t) {\n            var e\n            return (\n              (e = 0 !== a ? E.format(',.' + a + 'f') : t < 1e3 ? E.format(',.0f') : E.format(',.2s')),\n              r.yax_units_append ? e(t) + r.yax_units : r.yax_units + e(t)\n            )\n          }))\n        : (t = function (t) {\n            return E.format('.0%')(t)\n          })\n    }\n    return t\n  }\n  function tt (t) {\n    var e = O(t.target),\n      r = t.scales.X.domain()\n    if (r[0] <= 0 && 0 <= r[1]) {\n      var a = t.scales.Y.range(),\n        n = t.categorical_groups.length\n          ? t.scales.YGROUP(t.categorical_groups[t.categorical_groups.length - 1])\n          : t.scales.YGROUP()\n      e.append('svg:line')\n        .attr('x1', t.scales.X(0))\n        .attr('x2', t.scales.X(0))\n        .attr('y1', a[0] + b(t))\n        .attr('y2', a[a.length - 1] + n)\n        .attr('stroke', 'black')\n        .attr('opacity', 0.2)\n    }\n  }\n  function et (t, e) {\n    e.y_label &&\n      t\n        .append('text')\n        .attr('class', 'label')\n        .attr('x', function () {\n          return -1 * (b(e) + (v(e) - b(e)) / 2)\n        })\n        .attr('y', function () {\n          return e.left / 2\n        })\n        .attr('dy', '-1.2em')\n        .attr('text-anchor', 'middle')\n        .text(function (t) {\n          return e.y_label\n        })\n        .attr('transform', function (t) {\n          return 'rotate(-90)'\n        })\n  }\n  function rt (t) {\n    t.processed || (t.processed = {})\n    var e = O(t.target)\n    if (\n      (MG.call_hook('y_axis.process_min_max', t, t.processed.min_y, t.processed.max_y), D(e, '.mg-y-axis'), !t.y_axis)\n    )\n      return this\n    var r,\n      a,\n      n,\n      o,\n      i,\n      s,\n      c,\n      l,\n      u,\n      d = S(e, 'mg-y-axis')\n    return (\n      et(d, t),\n      ke(t, 'y'),\n      (r = d),\n      (i = (a = t).processed.y_ticks.length),\n      a.x_extended_ticks ||\n        a.y_extended_ticks ||\n        !i ||\n        (a.axes_not_compact && 'bar' !== a.chart_type\n          ? ((n = a.height - a.bottom), (o = a.top))\n          : i\n          ? ((n = a.scales.Y(a.processed.y_ticks[0]).toFixed(2)),\n            (o = a.scales.Y(a.processed.y_ticks[i - 1]).toFixed(2)))\n          : (o = n = 0),\n        r\n          .append('line')\n          .attr('x1', a.left)\n          .attr('x2', a.left)\n          .attr('y1', n)\n          .attr('y2', o)),\n      (s = t),\n      d\n        .selectAll('.mg-yax-ticks')\n        .data(s.processed.y_ticks)\n        .enter()\n        .append('line')\n        .classed('mg-extended-yax-ticks', s.y_extended_ticks)\n        .attr('x1', s.left)\n        .attr('x2', function () {\n          return s.y_extended_ticks ? s.width - s.right : s.left - s.yax_tick_length\n        })\n        .attr('y1', function (t) {\n          return s.scales.Y(t).toFixed(2)\n        })\n        .attr('y2', function (t) {\n          return s.scales.Y(t).toFixed(2)\n        }),\n      (c = d),\n      (u = J((l = t))),\n      c\n        .selectAll('.mg-yax-labels')\n        .data(l.processed.y_ticks)\n        .enter()\n        .append('text')\n        .attr('x', l.left - (3 * l.yax_tick_length) / 2)\n        .attr('dx', -3)\n        .attr('y', function (t) {\n          return l.scales.Y(t).toFixed(2)\n        })\n        .attr('dy', '.35em')\n        .attr('text-anchor', 'end')\n        .text(function (t) {\n          return u(t)\n        }),\n      t.y_rug && K(t),\n      this\n    )\n  }\n  function at (o) {\n    var t = O(o.target)\n    D(t, '.mg-y-axis')\n    var i,\n      s = S(t, 'mg-y-axis')\n    ;(o.categorical_groups.length ? o.categorical_groups : ['1']).forEach(function (t) {\n      var e, r, a, n\n      ;((i = S(s, 'mg-group-' + F(t))), null !== o.ygroup_accessor)\n        ? ((a = t),\n          (n = o),\n          i\n            .append('svg:text')\n            .classed('mg-barplot-group-label', !0)\n            .attr('x', n.left - n.buffer)\n            .attr('y', n.scales.YGROUP(a) + n.scales.YGROUP.bandwidth() / 2)\n            .attr('dy', '.35em')\n            .attr('text-anchor', 'end')\n            .text(a))\n        : l(\n            ((e = t),\n            (r = o),\n            i\n              .selectAll('text')\n              .data(r.scales.Y.domain())\n              .enter()\n              .append('svg:text')\n              .attr('x', r.left - r.buffer)\n              .attr('y', function (t) {\n                return r.scales.YGROUP(e) + r.scales.Y(t) + r.scales.Y.bandwidth() / 2\n              })\n              .attr('dy', '.35em')\n              .attr('text-anchor', 'end')\n              .text(String)),\n            o.rotate_y_labels\n          )\n    })\n  }\n  function nt (t) {\n    if (t.x_rug) {\n      t.rug_buffer_size = 'point' === t.chart_type ? t.buffer / 2 : t.buffer\n      var e = r(t, 'mg-x-rug')\n      e\n        .attr('x1', t.scalefns.xf)\n        .attr('x2', t.scalefns.xf)\n        .attr('y1', t.height - t.bottom - t.rug_buffer_size)\n        .attr('y2', t.height - t.bottom),\n        m(e, t, 'mg-x-rug-mono')\n    }\n  }\n  function ot (t) {\n    var e,\n      r,\n      a,\n      n = O(t.target)\n    if (\n      ((e = t).processed || (e.processed = {}),\n      (a = (r = t).chart_type),\n      r.processed.xax_format ||\n        (r.xax_format\n          ? (r.processed.xax_format = r.xax_format)\n          : 'line' === a || 'point' === a || 'histogram' === a\n          ? (r.processed.xax_format = ht(r))\n          : 'bar' === a && (r.processed.xax_format = ct(r))),\n      D(n, '.mg-x-axis'),\n      !t.x_axis)\n    )\n      return this\n    var o,\n      i,\n      s,\n      c,\n      l,\n      u,\n      d,\n      f,\n      p,\n      _,\n      m = S(n, 'mg-x-axis')\n    return (\n      (o = m),\n      ke((i = t), 'x'),\n      (l = o),\n      (u = (c = i).scales.X.ticks(c.xax_count).length - 1),\n      c.x_extended_ticks ||\n        l\n          .append('line')\n          .attr('x1', function () {\n            return 0 === c.xax_count\n              ? Y(c)\n              : c.axes_not_compact && 'bar' !== c.chart_type\n              ? c.left\n              : c.scales.X(c.scales.X.ticks(c.xax_count)[0]).toFixed(2)\n          })\n          .attr('x2', function () {\n            return 0 === c.xax_count || (c.axes_not_compact && 'bar' !== c.chart_type)\n              ? A(c)\n              : c.scales.X(c.scales.X.ticks(c.xax_count)[u]).toFixed(2)\n          })\n          .attr('y1', c.height - c.bottom)\n          .attr('y2', c.height - c.bottom),\n      (s = i),\n      o\n        .selectAll('.mg-xax-ticks')\n        .data(s.processed.x_ticks)\n        .enter()\n        .append('line')\n        .attr('x1', function (t) {\n          return s.scales.X(t).toFixed(2)\n        })\n        .attr('x2', function (t) {\n          return s.scales.X(t).toFixed(2)\n        })\n        .attr('y1', s.height - s.bottom)\n        .attr('y2', function () {\n          return s.x_extended_ticks ? s.top : s.height - s.bottom + s.xax_tick_length\n        })\n        .attr('class', function () {\n          if (s.x_extended_ticks) return 'mg-extended-xax-ticks'\n        })\n        .classed('mg-xax-ticks', !0),\n      (function (a, t) {\n        var e = t\n          .selectAll('.mg-xax-labels')\n          .data(a.processed.x_ticks)\n          .enter()\n          .append('text')\n          .attr('x', function (t) {\n            return a.scales.X(t).toFixed(2)\n          })\n          .attr('y', (a.height - a.bottom + (7 * a.xax_tick_length) / 3).toFixed(2))\n          .attr('dy', '.50em')\n          .attr('text-anchor', 'middle')\n        if (\n          (a.time_series && a.european_clock\n            ? (e\n                .append('tspan')\n                .classed('mg-european-hours', !0)\n                .text(function (t, e) {\n                  var r = new Date(t)\n                  return 0 === e ? E.timeFormat('%H')(r) : ''\n                }),\n              e\n                .append('tspan')\n                .classed('mg-european-minutes-seconds', !0)\n                .text(function (t, e) {\n                  var r = new Date(t)\n                  return ':' + a.processed.xax_format(r)\n                }))\n            : e.text(function (t) {\n                return a.xax_units + a.processed.xax_format(t)\n              }),\n          g(e))\n        ) {\n          e.filter(function (t, e) {\n            return (e + 1) % 2 == 0\n          }).remove()\n          var r = O(a.target)\n          r.selectAll('.mg-xax-ticks')\n            .filter(function (t, e) {\n              return (e + 1) % 2 == 0\n            })\n            .remove()\n        }\n      })((f = t), (d = m)),\n      (_ = d),\n      (p = f).time_series &&\n        (p.show_years || p.show_secondary_x_label) &&\n        (function (t, e) {\n          var r = xt(t),\n            a = r.secondary(t.processed.min_x, t.processed.max_x)\n          if (0 === a.length) {\n            var n = t.scales.X.ticks(t.xax_count)[0]\n            a = [n]\n          }\n          var o,\n            i,\n            s,\n            c,\n            l,\n            u,\n            d,\n            f = S(e, 'mg-year-marker')\n          'default' === r.timeframe &&\n            t.show_year_markers &&\n            ((o = t),\n            (i = f),\n            (s = a),\n            r.yformat,\n            i\n              .selectAll('.mg-year-marker')\n              .data(s)\n              .enter()\n              .append('line')\n              .attr('x1', function (t) {\n                return o.scales.X(t).toFixed(2)\n              })\n              .attr('x2', function (t) {\n                return o.scales.X(t).toFixed(2)\n              })\n              .attr('y1', M(o))\n              .attr('y2', w(o))),\n            'years' != r.tick_diff_time_frame &&\n              ((c = t),\n              (l = f),\n              (u = a),\n              (d = r.yformat),\n              l\n                .selectAll('.mg-year-marker')\n                .data(u)\n                .enter()\n                .append('text')\n                .attr('x', function (t, e) {\n                  return c.scales.X(t).toFixed(2)\n                })\n                .attr('y', function () {\n                  var t = E.select(c.target)\n                    .select('.mg-x-axis text')\n                    .node()\n                    .getBoundingClientRect()\n                  return w(c) + (7 * c.xax_tick_length) / 3 + 0.8 * t.height\n                })\n                .attr('dy', '.50em')\n                .attr('text-anchor', 'middle')\n                .text(function (t) {\n                  return d(new Date(t))\n                }))\n        })(p, _),\n      t.x_label && st(m, t),\n      t.x_rug && nt(t),\n      this\n    )\n  }\n  function B (e) {\n    var t\n    return (\n      null === e.color_domain\n        ? 'number' === e.color_type\n          ? (t = E.extent(e.data[0], function (t) {\n              return t[e.color_accessor]\n            }))\n          : 'category' === e.color_type &&\n            (t = E.set(\n              e.data[0].map(function (t) {\n                return t[e.color_accessor]\n              })\n            ).values()).sort()\n        : (t = e.color_domain),\n      t\n    )\n  }\n  function I (t) {\n    return null === t.color_range ? ('number' === t.color_type ? ['blue', 'red'] : null) : t.color_range\n  }\n  function it (t) {\n    return null === t.size_range ? [1, 5] : t.size_range\n  }\n  function st (t, e) {\n    e.x_label &&\n      t\n        .append('text')\n        .attr('class', 'label')\n        .attr('x', function () {\n          return Y(e) + (P(e) - Y(e)) / 2\n        })\n        .attr('dx', null != e.x_label_nudge_x ? e.x_label_nudge_x : 0)\n        .attr('y', function () {\n          var t = E.select(e.target)\n            .select('.mg-x-axis text')\n            .node()\n            .getBoundingClientRect()\n          return w(e) + e.xax_tick_length * (7 / 3) + 0.8 * t.height + 10\n        })\n        .attr('dy', '.5em')\n        .attr('text-anchor', 'middle')\n        .text(function (t) {\n          return e.x_label\n        })\n  }\n  function ct (r) {\n    return function (t) {\n      if (t < 1 && -1 < t && 0 !== t) return r.xax_units + t.toFixed(r.decimals)\n      var e = E.format(',.0f')\n      return r.xax_units + e(t)\n    }\n  }\n  function lt (t) {\n    var e\n    return (\n      ut(t)\n        ? (e = 'millis')\n        : dt(t)\n        ? (e = 'seconds')\n        : ft(t)\n        ? (e = 'less-than-a-day')\n        : pt(t)\n        ? (e = 'four-days')\n        : _t(t)\n        ? (e = 'many-days')\n        : mt(t)\n        ? (e = 'many-months')\n        : (e = 365 <= t / 86400 ? 'years' : 'default'),\n      e\n    )\n  }\n  function ut (t) {\n    return t < 1\n  }\n  function dt (t) {\n    return t < 60\n  }\n  function ft (t) {\n    return t / 3600 < 24\n  }\n  function pt (t) {\n    return t / 3600 < 96\n  }\n  function _t (t) {\n    return t / 86400 < 60\n  }\n  function mt (t) {\n    return t / 86400 < 365\n  }\n  function gt (t) {\n    if (t.time_series) {\n      var e = (t.processed.max_x - t.processed.min_x) / 1e3,\n        r = (t.processed.x_ticks[1] - t.processed.x_ticks[0]) / 1e3\n      ;(t.processed.x_time_frame = lt(e)),\n        (t.processed.x_tick_diff_time_frame = lt(r)),\n        (t.processed.main_x_time_format = ((a = t.utc_time),\n        ut((n = r))\n          ? MG.time_format(a, '%M:%S.%L')\n          : dt(n)\n          ? MG.time_format(a, '%M:%S')\n          : ft(n)\n          ? MG.time_format(a, '%H:%M')\n          : pt(n) || _t(n)\n          ? MG.time_format(a, '%b %d')\n          : mt(n)\n          ? MG.time_format(a, '%b')\n          : MG.time_format(a, '%Y')))\n    }\n    var a, n\n  }\n  function ht (r) {\n    if (r.xax_format) return r.xax_format\n    var t = h(r.processed.original_data || r.data)[0],\n      a = t[r.processed.original_x_accessor || r.x_accessor]\n    return (\n      void 0 === a && (a = t),\n      function (t) {\n        return (\n          gt(r),\n          x(a)\n            ? r.processed.main_x_time_format(new Date(t))\n            : 'number' == typeof a\n            ? ((e = t % 1 != 0 ? E.format(',.' + r.decimals + 'f') : t < 1e3 ? E.format(',.0f') : E.format(',.2s')),\n              r.xax_units + e(t))\n            : r.xax_units + t\n        )\n        var e\n      }\n    )\n  }\n  function xt (t) {\n    var e = { timeframe: t.processed.x_time_frame, tick_diff_timeframe: t.processed.x_tick_diff_time_frame }\n    switch (e.timeframe) {\n      case 'millis':\n      case 'seconds':\n        ;(e.secondary = E.timeDays),\n          t.european_clock\n            ? (e.yformat = MG.time_format(t.utc_time, '%b %d'))\n            : (e.yformat = MG.time_format(t.utc_time, '%I %p'))\n        break\n      case 'less-than-a-day':\n      case 'four-days':\n        ;(e.secondary = E.timeDays), (e.yformat = MG.time_format(t.utc_time, '%b %d'))\n        break\n      case 'many-days':\n      case 'many-months':\n        ;(e.secondary = E.timeYears), (e.yformat = MG.time_format(t.utc_time, '%Y'))\n        break\n      default:\n        ;(e.secondary = E.timeYears), (e.yformat = MG.time_format(t.utc_time, '%Y'))\n    }\n    return e\n  }\n  function yt (t) {\n    var e = parseInt(t.width)\n    t.full_width && (e = f(t.target)), 'categorical' === t.x_axis_type && null === e && (e = Dt(t, 'x')), (t.width = e)\n  }\n  function vt (t) {\n    var e = parseInt(t.height)\n    t.full_height && (e = d(t.target, 'height')),\n      'categorical' === t.y_axis_type && null === e && (e = Dt(t, 'y')),\n      (t.height = e)\n  }\n  function bt (t, e) {\n    ;((!t.selectAll('.mg-main-line').empty() && 'line' !== e.chart_type) ||\n      (!t.selectAll('.mg-points').empty() && 'point' !== e.chart_type) ||\n      (!t.selectAll('.mg-histogram').empty() && 'histogram' !== e.chart_type) ||\n      (!t.selectAll('.mg-barplot').empty() && 'bar' !== e.chart_type)) &&\n      t.remove()\n  }\n  function wt (t, e) {\n    return (\n      O(e.target).empty() &&\n        (t = E.select(e.target)\n          .append('svg')\n          .classed('linked', e.linked)\n          .attr('width', e.width)\n          .attr('height', e.height)),\n      t\n    )\n  }\n  function kt (t, e) {\n    e.width !== Number(t.attr('width')) && t.attr('width', e.width),\n      e.height !== Number(t.attr('height')) && t.attr('height', e.height)\n  }\n  function Mt (t, e) {\n    t.attr('viewBox', '0 0 ' + e.width + ' ' + e.height),\n      (e.full_width || e.full_height) && t.attr('preserveAspectRatio', 'xMinYMin meet')\n  }\n  function Gt (t, e) {\n    t.empty() &&\n      console.warn(\n        'The specified target element \"' +\n          e.target +\n          '\" could not be found in the page. The chart will not be rendered.'\n      )\n  }\n  function At (t, e) {\n    var r,\n      a,\n      n,\n      o = 'x' === e ? t.width : t.height\n    !(function (t, e) {\n      var r = t[e + 'group_accessor']\n      if (((t.categorical_groups = []), r)) {\n        var a = t.data[0]\n        t.categorical_groups = E.set(\n          a.map(function (t) {\n            return t[r]\n          })\n        ).values()\n      }\n    })(t, e),\n      (function (t, e) {\n        var r = t[e + 'group_accessor']\n        if (((t.total_bars = t.data[0].length), r)) {\n          var a = ((n = t.data[0]),\n          (o = r),\n          n\n            .map(function (t) {\n              return t[o]\n            })\n            .reduce(function (t, e) {\n              return (t[e] = t[e] + 1 || 1), t\n            }, {}))\n          ;(a = E.max(\n            Object.keys(a).map(function (t) {\n              return a[t]\n            })\n          )),\n            (t.bars_per_group = a)\n        } else t.bars_per_group = t.data[0].length\n        var n, o\n      })(t, e),\n      (function (t, e, r) {\n        var a = e + 'group_height'\n        if (r) {\n          var n =\n            'y' === e\n              ? (t.height - t.top - t.bottom - 2 * t.buffer) / (t.categorical_groups.length || 1)\n              : (t.width - t.left - t.right - 2 * t.buffer) / (t.categorical_groups.length || 1)\n          t[a] = n\n        } else {\n          var o = (1 + t[e + '_padding_percentage']) * t.bar_thickness\n          t[a] = t.bars_per_group * o + 2 * t[e + '_outer_padding_percentage'] * o\n        }\n      })(t, e, o),\n      o &&\n        ((n = (r = t)[(a = e) + 'group_height'] / (r.bars_per_group + r[a + '_outer_padding_percentage'])),\n        (r.bar_thickness = n - n * r[a + '_padding_percentage']))\n  }\n  function Dt (t, e) {\n    return (\n      t[e + 'group_height'] * (t.categorical_groups.length || 1) +\n      ('y' === e ? t.top + t.bottom + 2 * t.buffer : t.left + t.right + 2 * t.buffer) +\n      t.categorical_groups.length *\n        t[e + 'group_height'] *\n        (t[e + 'group_padding_percentage'] + t[e + 'group_outer_padding_percentage'])\n    )\n  }\n  function Ot (t) {\n    var e\n    ;(e = t = t) || (e = {}),\n      e.processed || (e.processed = {}),\n      (t = e = p(e, { target: null, title: null, description: null }))\n    var r = E.select(t.target)\n    Gt(r, t)\n    var a,\n      n,\n      o,\n      i,\n      s,\n      c,\n      l,\n      u = r.selectAll('svg')\n    return (\n      'categorical' === t.y_axis_type && At(t, 'y'),\n      'categorical' === t.x_axis_type && At(t, 'x'),\n      (n = (a = t).chart_type),\n      a.processed.xax_format ||\n        (a.xax_format\n          ? (a.processed.xax_format = a.xax_format)\n          : 'line' === n || 'point' === n || 'histogram' === n\n          ? (a.processed.xax_format = ht(a))\n          : 'bar' === n && (a.processed.xax_format = ct(a))),\n      (i = h((o = t).processed.original_data || o.data)[0]),\n      (o.time_series = x(i[o.processed.original_x_accessor || o.x_accessor])),\n      yt(t),\n      vt(t),\n      bt(u, t),\n      (u = wt(u, t)),\n      (c = t),\n      (s = u).selectAll('.mg-clip-path').remove(),\n      s\n        .append('defs')\n        .attr('class', 'mg-clip-path')\n        .append('clipPath')\n        .attr('id', 'mg-plot-window-' + z(c.target))\n        .append('svg:rect')\n        .attr('x', G(c))\n        .attr('y', M(c))\n        .attr('width', c.width - c.left - c.right - c.buffer)\n        .attr('height', c.height - c.top - c.bottom - c.buffer + 1),\n      kt(u, t),\n      Mt(u, t),\n      (l = u).classed('mg-missing', !1),\n      l.selectAll('.mg-missing-text').remove(),\n      l.selectAll('.mg-missing-pane').remove(),\n      j(t),\n      (function (t, e) {\n        var r = 0\n        if (t.selectAll('.mg-main-line').nodes().length >= e.data.length)\n          if (0 < e.custom_line_color_map.length) {\n            var a = T(\n              (function (t) {\n                for (var e = new Array(t), r = 0; r < e.length; r++) e[r] = r + 1\n                return e\n              })(e.max_data_size),\n              e.custom_line_color_map\n            )\n            for (r = 0; r < a.length; r++) t.selectAll('.mg-main-line.mg-line' + a[r] + '-color').remove()\n          } else {\n            var n = e.data.length\n            for (r = t.selectAll('.mg-main-line').nodes() ? t.selectAll('.mg-main-line').nodes().length : 0; n < r; r--)\n              t.selectAll('.mg-main-line.mg-line' + r + '-color').remove()\n          }\n      })(u, t),\n      this\n    )\n  }\n  function zt (t) {\n    return t.label\n  }\n  function Ft (e) {\n    return function (t) {\n      return e.scales.X(t[e.x_accessor]) >= Y(e) && e.scales.X(t[e.x_accessor]) <= P(e)\n    }\n  }\n  function Ct (e) {\n    return function (t) {\n      return e.scales.X(t[e.x_accessor])\n    }\n  }\n  function Tt (t) {\n    var e = t.scales.Y\n    return function (t) {\n      return e(t.value).toFixed(2)\n    }\n  }\n  function Rt (t, e, r, a, n, o) {\n    var i\n    t && (n((i = a.append('g').attr('class', e)), r), o(i, r))\n  }\n  function Et (t, e) {\n    var r,\n      a = ((r = Ct(e)),\n      function (t) {\n        return r(t).toFixed(2)\n      })\n    t.selectAll('.mg-markers')\n      .data(e.markers.filter(Ft(e)))\n      .enter()\n      .append('line')\n      .attr('x1', a)\n      .attr('x2', a)\n      .attr('y1', e.top)\n      .attr('y2', v(e))\n      .attr('class', function (t) {\n        return t.lineclass\n      })\n      .attr('stroke-dasharray', '3,1')\n  }\n  function Yt (t, e) {\n    t\n      .selectAll('.mg-markers')\n      .data(e.markers.filter(Ft(e)))\n      .enter()\n      .append('text')\n      .attr('class', function (t) {\n        return t.textclass || ''\n      })\n      .classed('mg-marker-text', !0)\n      .attr('x', Ct(e))\n      .attr('y', 'bottom' === e.x_axis_position ? 0.95 * M(e) : w(e) + e.buffer)\n      .attr('text-anchor', 'middle')\n      .text(zt)\n      .each(function (t) {\n        t.click &&\n          E.select(this)\n            .style('cursor', 'pointer')\n            .on('click', t.click),\n          t.mouseover &&\n            E.select(this)\n              .style('cursor', 'pointer')\n              .on('mouseover', t.mouseover),\n          t.mouseout &&\n            E.select(this)\n              .style('cursor', 'pointer')\n              .on('mouseout', t.mouseout)\n      }),\n      (function (t, e) {\n        if (t && 1 != t.length)\n          for (var r = 0; r < t.length; r++)\n            if (o(t[r], t)) {\n              var a = E.select(t[r]),\n                n = +a.attr('y')\n              n + 8 >= e.top && (n = e.top - 16), a.attr('y', n)\n            }\n      })(t.selectAll('.mg-marker-text').nodes(), e)\n  }\n  function $t (t, e) {\n    var r = Tt(e)\n    t.selectAll('.mg-baselines')\n      .data(e.baselines)\n      .enter()\n      .append('line')\n      .attr('x1', Y(e))\n      .attr('x2', P(e))\n      .attr('y1', r)\n      .attr('y2', r)\n  }\n  function Pt (t, e) {\n    var r = Tt(e)\n    t.selectAll('.mg-baselines')\n      .data(e.baselines)\n      .enter()\n      .append('text')\n      .attr('x', P(e))\n      .attr('y', r)\n      .attr('dy', -3)\n      .attr('text-anchor', 'end')\n      .text(zt)\n  }\n  function St (t) {\n    var e,\n      r,\n      a,\n      n,\n      o,\n      i = O(t.target)\n    return (\n      (e = i).selectAll('.mg-markers').remove(),\n      e.selectAll('.mg-baselines').remove(),\n      (a = i),\n      Rt((r = t).markers, 'mg-markers', r, a, Et, Yt),\n      (o = i),\n      Rt((n = t).baselines, 'mg-baselines', n, o, $t, Pt),\n      this\n    )\n  }\n  function Lt (t) {\n    t.selectAll('.mg-active-datapoint-container')\n      .selectAll('*')\n      .remove()\n  }\n  function jt (t, e) {\n    t.select('.mg-active-datapoint').remove()\n    var r,\n      a = 'right' === e.mouseover_align ? 'end' : 'left' === e.mouseover_align ? 'start' : 'middle',\n      n =\n        'right' === e.mouseover_align\n          ? P(e)\n          : 'left' === e.mouseover_align\n          ? Y(e)\n          : (e.width - e.left - e.right) / 2 + e.left,\n      o = t\n        .select('.mg-active-datapoint-container')\n        .append('text')\n        .attr('class', 'mg-active-datapoint')\n        .attr('xml:space', 'preserve')\n        .attr('text-anchor', a),\n      i = 0.75,\n      s = 'bottom' === e.x_axis_position ? M(e) * i : w(e) + 3 * e.buffer\n    e.markers &&\n      t.selectAll('.mg-marker-text').each(function () {\n        r ? r !== E.select(this).attr('y') && (i = 0.56) : (r = E.select(this).attr('y'))\n      })\n    o.attr('transform', 'translate(' + n + ',' + s + ')')\n  }\n  function Xt (t, e) {\n    jt(e.svg, t)\n    var r,\n      a,\n      o = {\n        row_number: 0,\n        rargs: e,\n        mouseover_row: function (t) {\n          return (\n            (o.row_number += 1),\n            (e = o.row_number),\n            (r = o.text_container),\n            (a = t),\n            (n = r\n              .append('tspan')\n              .attr('x', 0)\n              .attr('y', 1.1 * e + 'em')),\n            {\n              rargs: a,\n              text: function (t) {\n                return (\n                  (e = t),\n                  {\n                    bold: function () {\n                      return r.attr('font-weight', 'bold')\n                    },\n                    font_size: function (t) {\n                      return r.attr('font-size', t)\n                    },\n                    x: function (t) {\n                      return r.attr('x', t)\n                    },\n                    y: function (t) {\n                      return r.attr('y', t)\n                    },\n                    elem: (r = n.append('tspan').text(e))\n                  }\n                )\n                var e, r\n              }\n            }\n          )\n          var e, r, a, n\n        },\n        text_container: ((r = e.svg), (a = r.select('.mg-active-datapoint')), a.selectAll('*').remove(), a)\n      }\n    return o\n  }\n  ;(Z.categorical = function (t, e) {\n    e.namespace\n    Q(t, e),\n      (function (d, t) {\n        var f,\n          p,\n          _,\n          m,\n          e = t.namespace,\n          g = (d.scalefns[e + 'f'], d.scalefns[e + 'groupf'], d.scales[(e + 'group').toUpperCase()]),\n          h = d.scales[e.toUpperCase()],\n          x = t.position,\n          r = O(d.target),\n          a = g.domain && g.domain() ? g.domain() : [null]\n        D(r, '.mg-category-guides')\n        var y = S(r, 'mg-category-guides')\n        a.forEach(function (e) {\n          h.domain().forEach(function (t) {\n            ;('left' !== x && 'right' !== x) ||\n              ((f = Y(d)), (p = P(d)), (_ = h(t) + g(e) + h.bandwidth() / 2), (m = h(t) + g(e) + h.bandwidth() / 2)),\n              ('top' !== x && 'bottom' !== x) ||\n                ((f = h(t) + g(e) + (h.bandwidth() / 2) * (null === e)),\n                (p = h(t) + g(e) + (h.bandwidth() / 2) * (null === e)),\n                (_ = v(d)),\n                (m = b(d))),\n              y\n                .append('line')\n                .attr('x1', f)\n                .attr('x2', p)\n                .attr('y1', _)\n                .attr('y2', m)\n                .attr('stroke-dasharray', '2,1')\n          })\n          var t,\n            r,\n            a,\n            n,\n            o,\n            i,\n            s,\n            c,\n            l = g(e) + h(h.domain()[0]) + (h.bandwidth() / 2) * (null === e || ('top' !== x && 'bottom' != x)),\n            u =\n              g(e) +\n              h(h.domain()[h.domain().length - 1]) +\n              (h.bandwidth() / 2) * (null === e || ('top' !== x && 'bottom' != x))\n          ;('left' !== x && 'right' !== x) ||\n            ((t = Y(d)), (r = Y(d)), (a = l), (n = u), (o = P(d)), (i = P(d)), (s = l), (c = u)),\n            ('bottom' !== x && 'top' !== x) ||\n              ((t = l), (r = u), (a = v(d)), (n = v(d)), (o = l), (i = u), (s = b(d)), (c = b(d))),\n            y\n              .append('line')\n              .attr('x1', t)\n              .attr('x2', r)\n              .attr('y1', a)\n              .attr('y2', n)\n              .attr('stroke-dasharray', '2,1'),\n            y\n              .append('line')\n              .attr('x1', o)\n              .attr('x2', i)\n              .attr('y1', s)\n              .attr('y2', c)\n              .attr('stroke-dasharray', '2,1')\n        })\n      })(t, e)\n  }),\n    (Z.numerical = function (t, e) {\n      var r = e.namespace,\n        a = r + '_axis',\n        n = 'mg-' + r + '-axis',\n        o = O(t.target)\n      if ((D(o, '.' + n), !t[a])) return this\n      var i,\n        s,\n        c,\n        l,\n        u,\n        d,\n        f,\n        p,\n        _,\n        m,\n        g,\n        h,\n        x,\n        y,\n        v,\n        b = S(o, n)\n      return (\n        (function (t, e) {\n          var r = t[e + '_accessor'],\n            a = t.scales[e.toUpperCase()].ticks(t[e + 'ax_count']),\n            n = t.processed['max_' + e]\n          function o (t) {\n            return 1e3 === t ? 3 : 1e6 === t ? 7 : Math.log(t) / Math.LN10\n          }\n          'log' === t[e + '_scale_type'] &&\n            (a = a.filter(function (t) {\n              return Math.abs(o(t)) % 1 < 1e-6 || Math.abs(o(t)) % 1 > 1 - 1e-6\n            }))\n          var i = a.length,\n            s = !0\n          t.data.forEach(function (t, e) {\n            t.forEach(function (t, e) {\n              if (t[r] % 1 != 0) return (s = !1)\n            })\n          }),\n            s &&\n              n < i &&\n              'count' === t.format &&\n              (a = a.filter(function (t) {\n                return t % 1 == 0\n              })),\n            (t.processed[e + '_ticks'] = a)\n        })(t, r),\n        V(b, t, e),\n        (i = b),\n        (s = t),\n        (p = (c = e).namespace),\n        (_ = c.position),\n        (m = s.scales[p.toUpperCase()]),\n        (g = s.processed[p + '_ticks']),\n        (h = 'mg-' + p + 'ax-ticks'),\n        (x = 'mg-extended-' + p + 'ax-ticks'),\n        (y = s[p + '_extended_ticks']),\n        (v = s[p + 'ax_tick_length']),\n        'left' === _ &&\n          ((l = G(s)),\n          (u = y ? A(s) : G(s) - v),\n          (d = function (t) {\n            return m(t).toFixed(2)\n          }),\n          (f = function (t) {\n            return m(t).toFixed(2)\n          })),\n        'right' === _ &&\n          ((l = A(s)),\n          (u = y ? G(s) : A(s) + v),\n          (d = function (t) {\n            return m(t).toFixed(2)\n          }),\n          (f = function (t) {\n            return m(t).toFixed(2)\n          })),\n        'top' === _ &&\n          ((l = function (t) {\n            return m(t).toFixed(2)\n          }),\n          (u = function (t) {\n            return m(t).toFixed(2)\n          }),\n          (d = M(s)),\n          (f = y ? w(s) : M(s) - v)),\n        'bottom' === _ &&\n          ((l = function (t) {\n            return m(t).toFixed(2)\n          }),\n          (u = function (t) {\n            return m(t).toFixed(2)\n          }),\n          (d = w(s)),\n          (f = y ? M(s) : w(s) + v)),\n        i\n          .selectAll('.' + h)\n          .data(g)\n          .enter()\n          .append('line')\n          .classed(x, y)\n          .attr('x1', l)\n          .attr('x2', u)\n          .attr('y1', d)\n          .attr('y2', f),\n        q(b, t, e),\n        t[r + '_label'] && e.label(o.select('.mg-' + r + '-axis'), t),\n        t[r + '_rug'] && W(t, e),\n        t.show_bar_zero && tt(t),\n        this\n      )\n    }),\n    (MG.axis_factory = function (t) {\n      var e = { type: 'numerical' }\n      return (\n        (this.namespace = function (t) {\n          return (e.namespace = t), this\n        }),\n        (this.rug = function (t) {\n          return (e.rug = t), this\n        }),\n        (this.label = function (t) {\n          return (e.label = t), this\n        }),\n        (this.type = function (t) {\n          return (e.type = t), this\n        }),\n        (this.position = function (t) {\n          return (e.position = t), this\n        }),\n        (this.zeroLine = function (t) {\n          return (e.zeroLine = t), this\n        }),\n        (this.draw = function () {\n          return Z[e.type](t, e), this\n        }),\n        this\n      )\n    }),\n    (MG.y_rug = K),\n    (MG.y_axis = rt),\n    (MG.y_axis_categorical = function (t) {\n      return (\n        t.y_axis &&\n          (at(t),\n          t.show_bar_zero && tt(t),\n          t.ygroup_accessor &&\n            ((r = O((e = t).target)),\n            (a = e.scales.YGROUP.domain())[0],\n            a[a.length - 1],\n            r\n              .select('.mg-category-guides')\n              .selectAll('mg-group-lines')\n              .data(a)\n              .enter()\n              .append('line')\n              .attr('x1', Y(e))\n              .attr('x2', Y(e))\n              .attr('y1', function (t) {\n                return e.scales.YGROUP(t)\n              })\n              .attr('y2', function (t) {\n                return e.scales.YGROUP(t) + e.ygroup_height\n              })\n              .attr('stroke-width', 1)),\n          t.y_categorical_show_guides &&\n            ((o = O((n = t).target)),\n            (i = []),\n            n.data[0].forEach(function (t) {\n              ;-1 === i.indexOf(t[n.y_accessor]) &&\n                o\n                  .select('.mg-category-guides')\n                  .append('line')\n                  .attr('x1', Y(n))\n                  .attr('x2', P(n))\n                  .attr('y1', n.scalefns.yf(t) + n.scalefns.ygroupf(t))\n                  .attr('y2', n.scalefns.yf(t) + n.scalefns.ygroupf(t))\n                  .attr('stroke-dasharray', '2,1')\n            }))),\n        this\n      )\n      var e, r, a, n, o, i\n    }),\n    (MG.x_rug = nt),\n    (MG.x_axis = ot),\n    (MG.x_axis_categorical = function (t) {\n      var e = O(t.target),\n        r = 0\n      'bar' === t.chart_type && (r = t.buffer + 5),\n        mg_add_categorical_scale(t, 'X', t.categorical_variables.reverse(), t.left, P(t) - r),\n        X(t, 'xf', 'X', 'value'),\n        D(e, '.mg-x-axis')\n      var a = S(e, 'mg-x-axis')\n      return (\n        t.x_axis &&\n          ((n = a),\n          (o = t),\n          (i = r),\n          (s = n\n            .selectAll('text')\n            .data(o.categorical_variables)\n            .enter()\n            .append('text')),\n          s\n            .attr('x', function (t) {\n              return o.scales.X(t) + o.scales.X.bandwidth() / 2 + o.buffer * o.bar_outer_padding_percentage + i / 2\n            })\n            .attr('y', v(o))\n            .attr('dy', '.35em')\n            .attr('text-anchor', 'middle')\n            .text(String),\n          o.truncate_x_labels &&\n            s.each(function (t, e) {\n              var r = o.scales.X.bandwidth()\n              L(this, t, r)\n            }),\n          l(s, o.rotate_x_labels)),\n        this\n      )\n      var n, o, i, s\n    }),\n    (MG.init = Ot),\n    (MG.markers = St)\n  var Ut = function (n, o) {\n      return function (a) {\n        return ['x', 'y'].every(function (t) {\n          return (\n            !(t in o) || ((e = a[n[t + '_accessor']]), (r = o[t]), e > Math.min(r[0], r[1]) && e < Math.max(r[0], r[1]))\n          )\n          var e, r\n        })\n      }\n    },\n    Nt = function (e, r) {\n      var t = e.processed.raw_data || e.data\n      'raw_data' in e.processed ||\n        ((e.processed.raw_domain = { x: e.scales.X.domain(), y: e.scales.Y.domain() }), (e.processed.raw_data = t)),\n        'point' === e.chart_type &&\n          (a(t)\n            ? (e.data = t.map(function (t) {\n                return t.filter(Ut(e, r))\n              }))\n            : (e.data = t.filter(Ut(e, r)))),\n        ['x', 'y'].forEach(function (t) {\n          t in r ? (e.processed['zoom_' + t] = r[t]) : delete e.processed['zoom_' + t]\n        }),\n        e.processed.subplot &&\n          (r !== e.processed.raw_domain\n            ? MG.create_brushing_pattern(e.processed.subplot, It(e.processed.subplot, r))\n            : MG.remove_brushing_pattern(e.processed.subplot)),\n        new MG.charts[e.chart_type || defaults.chart_type].descriptor(e)\n    },\n    Bt = function (r, a) {\n      return ['x', 'y'].reduce(function (t, e) {\n        return (\n          e in a &&\n            ((t[e] = a[e].map(function (t) {\n              return +r.scales[e.toUpperCase()].invert(t)\n            })),\n            'y' === e && t[e].reverse()),\n          t\n        )\n      }, {})\n    },\n    It = function (r, a) {\n      return ['x', 'y'].reduce(function (t, e) {\n        return (\n          e in a &&\n            ((t[e] = a[e].map(function (t) {\n              return +r.scales[e.toUpperCase()](t)\n            })),\n            'y' === e && t[e].reverse()),\n          t\n        )\n      }, {})\n    }\n  ;(MG.convert_range_to_domain = Bt),\n    (MG.zoom_to_data_domain = Nt),\n    (MG.zoom_to_data_range = function (t, e) {\n      var r = Bt(t, e)\n      Nt(t, r)\n    }),\n    (MG.zoom_to_raw_range = function (t) {\n      'raw_domain' in t.processed &&\n        (Nt(t, t.processed.raw_domain), delete t.processed.raw_domain, delete t.processed.raw_data)\n    })\n  var Ht = function (t) {\n      return E.select(t.target)\n        .select('.mg-extent')\n        .size()\n        ? E.select(t.target).select('.mg-extent')\n        : E.select(t.target)\n            .select('.mg-rollover-rect, .mg-voronoi')\n            .insert('g', '*')\n            .classed('mg-brush', !0)\n            .append('rect')\n            .classed('mg-extent', !0)\n    },\n    qt = function (t, e) {\n      var r = e.x[0],\n        a = e.x[1] - e.x[0],\n        n = e.y[0],\n        o = e.y[1] - e.y[0]\n      Ht(t)\n        .attr('x', r)\n        .attr('width', a)\n        .attr('y', n)\n        .attr('height', o)\n        .attr('opacity', 1)\n    },\n    Vt = function (t) {\n      Ht(t)\n        .attr('width', 0)\n        .attr('height', 0)\n        .attr('opacity', 0)\n    }\n  ;(MG.add_brush_function = function (t) {\n    if ('categorical' === t.x_axis_type || 'categorical' === t.y_axis_type)\n      return console.warn('The option \"brush\" does not support axis type \"categorical\" currently.')\n    t.zoom_target || (t.zoom_target = t), t.zoom_target !== t && (t.zoom_target.processed.subplot = t)\n    var i,\n      r,\n      s,\n      a,\n      e,\n      c,\n      n,\n      o,\n      l,\n      u,\n      d = void 0\n    switch (t.brush) {\n      case 'x':\n        d = { x: !0, y: !1 }\n        break\n      case 'y':\n        d = { x: !1, y: !0 }\n        break\n      case 'xy':\n        d = { x: !0, y: !0 }\n        break\n      default:\n        d = { x: !0, y: !0 }\n    }\n    ;(r = (i = t).zoom_target),\n      (s = d),\n      (a = E.select(i.target).select('svg')),\n      (e = a.select('.mg-rollover-rect, .mg-voronoi')),\n      (c = e.node()),\n      (o = n = !1),\n      (l = []),\n      (u = function () {\n        var t = i.left,\n          e = i.width - i.right - i.buffer,\n          r = i.top,\n          a = i.height - i.bottom - i.buffer,\n          n = E.mouse(c),\n          o = {}\n        return (\n          (o.x = s.x ? [Math.max(t, Math.min(l[0], n[0])), Math.min(e, Math.max(l[0], n[0]))] : [t, e]),\n          (o.y = s.y ? [Math.max(r, Math.min(l[1], n[1])), Math.min(a, Math.max(l[1], n[1]))] : [r, a]),\n          o\n        )\n      }),\n      e.classed('mg-brush-container', !0),\n      e.on('mousedown.' + i.target, function () {\n        ;(n = !(o = !0)), (l = E.mouse(c)), a.classed('mg-brushed', !1), a.classed('mg-brushing-in-progress', !0), Vt(i)\n      }),\n      E.select(document).on('mousemove.' + i.target, function () {\n        o && ((n = !0), e.classed('mg-brushing', !0), qt(i, u()))\n      }),\n      E.select(document).on('mouseup.' + i.target, function () {\n        if (o) {\n          ;(o = !1), a.classed('mg-brushing-in-progress', !1)\n          var t = u()\n          if (n)\n            if (((n = !1), r === i))\n              MG.zoom_to_data_range(r, t), a.select('.mg-rollover-rect, .mg-voronoi').classed('mg-brushed', !0)\n            else {\n              var e = MG.convert_range_to_domain(i, t)\n              MG.zoom_to_data_domain(r, e)\n            }\n          else MG.zoom_to_raw_range(r)\n          C(i.brushing_selection_changed) && i.brushing_selection_changed(i, t)\n        }\n      })\n  }),\n    (MG.create_brushing_pattern = qt),\n    (MG.remove_brushing_pattern = Vt)\n  var Wt = new function () {\n    var t,\n      i = []\n    function s () {\n      i.forEach(function (t) {\n        var e = E.select(t).select('svg')\n        if (!e.empty() && (0 < e.node().parentNode.offsetWidth || 0 < e.node().parentNode.offsetHeight)) {\n          var r = 0 !== e.attr('width') ? e.attr('height') / e.attr('width') : 0,\n            a = f(t)\n          e.attr('width', a), e.attr('height', r * a)\n        }\n      })\n    }\n    return (\n      'undefined' != typeof MutationObserver\n        ? (t = MutationObserver)\n        : 'undefined' != typeof WebKitMutationObserver && (t = WebKitMutationObserver),\n      {\n        add_target: function (n) {\n          if ((0 === i.length && window.addEventListener('resize', s, !0), -1 === i.indexOf(n) && (i.push(n), t))) {\n            var o = new t(function (t) {\n              var e,\n                r,\n                a = E.select(n).node()\n              ;(a &&\n                !t.some(function (t) {\n                  for (var e = 0; e < t.removedNodes.length; e++) if (t.removedNodes[e] === a) return !0\n                })) ||\n                (o.disconnect(),\n                (e = n),\n                -1 !== (r = i.indexOf(e)) && i.splice(r, 1),\n                0 === i.length && window.removeEventListener('resize', s, !0))\n            })\n            o.observe(E.select(n).node().parentNode, { childList: !0 })\n          }\n        }\n      }\n    )\n  }()\n  function Qt (t) {\n    var e\n    ;((e = t).full_width || e.full_height) && Wt.add_target(e.target)\n  }\n  k() &&\n    (function (s) {\n      if ('function' == typeof s().dropdown) return\n      var c = '[data-toggle=\"dropdown\"]',\n        a = function (t) {\n          s(t).on('click.bs.dropdown', this.toggle)\n        }\n      function o (a) {\n        ;(a && 3 === a.which) ||\n          (s('.dropdown-backdrop').remove(),\n          s(c).each(function () {\n            var t = s(this),\n              e = l(t),\n              r = { relatedTarget: this }\n            e.hasClass('open') &&\n              (e.trigger((a = s.Event('hide.bs.dropdown', r))),\n              a.isDefaultPrevented() ||\n                (t.attr('aria-expanded', 'false'), e.removeClass('open').trigger('hidden.bs.dropdown', r)))\n          }))\n      }\n      function l (t) {\n        var e = t.attr('data-target')\n        e || (e = (e = t.attr('href')) && /#[A-Za-z]/.test(e) && e.replace(/.*(?=#[^\\s]*$)/, ''))\n        var r = e && s(e)\n        return r && r.length ? r : t.parent()\n      }\n      ;(a.VERSION = '3.3.1'),\n        (a.prototype.toggle = function (t) {\n          var e = s(this)\n          if (!e.is('.disabled, :disabled')) {\n            var r = l(e),\n              a = r.hasClass('open')\n            if ((o(), !a)) {\n              'ontouchstart' in document.documentElement &&\n                !r.closest('.navbar-nav').length &&\n                s('<div class=\"dropdown-backdrop\"/>')\n                  .insertAfter(s(this))\n                  .on('click', o)\n              var n = { relatedTarget: this }\n              if ((r.trigger((t = s.Event('show.bs.dropdown', n))), t.isDefaultPrevented())) return\n              e.trigger('focus').attr('aria-expanded', 'true'), r.toggleClass('open').trigger('shown.bs.dropdown', n)\n            }\n            return !1\n          }\n        }),\n        (a.prototype.keydown = function (t) {\n          if (/(38|40|27|32)/.test(t.which) && !/input|textarea/i.test(t.target.tagName)) {\n            var e = s(this)\n            if ((t.preventDefault(), t.stopPropagation(), !e.is('.disabled, :disabled'))) {\n              var r = l(e),\n                a = r.hasClass('open')\n              if ((!a && 27 != t.which) || (a && 27 == t.which))\n                return 27 == t.which && r.find(c).trigger('focus'), e.trigger('click')\n              var n = ' li:not(.divider):visible a',\n                o = r.find('[role=\"menu\"]' + n + ', [role=\"listbox\"]' + n)\n              if (o.length) {\n                var i = o.index(t.target)\n                38 == t.which && 0 < i && i--,\n                  40 == t.which && i < o.length - 1 && i++,\n                  ~i || (i = 0),\n                  o.eq(i).trigger('focus')\n              }\n            }\n          }\n        })\n      var t = s.fn.dropdown\n      ;(s.fn.dropdown = function (r) {\n        return this.each(function () {\n          var t = s(this),\n            e = t.data('bs.dropdown')\n          e || t.data('bs.dropdown', (e = new a(this))), 'string' == typeof r && e[r].call(t)\n        })\n      }),\n        (s.fn.dropdown.Constructor = a),\n        (s.fn.dropdown.noConflict = function () {\n          return (s.fn.dropdown = t), this\n        }),\n        s(document)\n          .on('click.bs.dropdown.data-api', o)\n          .on('click.bs.dropdown.data-api', '.dropdown form', function (t) {\n            t.stopPropagation()\n          })\n          .on('click.bs.dropdown.data-api', c, a.prototype.toggle)\n          .on('keydown.bs.dropdown.data-api', c, a.prototype.keydown)\n          .on('keydown.bs.dropdown.data-api', '[role=\"menu\"]', a.prototype.keydown)\n          .on('keydown.bs.dropdown.data-api', '[role=\"listbox\"]', a.prototype.keydown)\n    })(jQuery),\n    (MG.button_layout = function (t) {\n      return (\n        (this.target = t),\n        (this.feature_set = {}),\n        (this.public_name = {}),\n        (this.sorters = {}),\n        (this.manual = []),\n        (this.manual_map = {}),\n        (this.manual_callback = {}),\n        (this._strip_punctuation = function (t) {\n          return t.replace(/[^a-zA-Z0-9 _]+/g, '').replace(/ +?/g, '')\n        }),\n        (this.data = function (t) {\n          return (this._data = t), this\n        }),\n        (this.manual_button = function (t, e, r) {\n          return (\n            (this.feature_set[t] = e),\n            (this.manual_map[this._strip_punctuation(t)] = t),\n            (this.manual_callback[t] = r),\n            this\n          )\n        }),\n        (this.button = function (t) {\n          return (\n            1 < arguments.length && (this.public_name[t] = arguments[1]),\n            2 < arguments.length && (this.sorters[t] = arguments[2]),\n            (this.feature_set[t] = []),\n            this\n          )\n        }),\n        (this.callback = function (t) {\n          return (this._callback = t), this\n        }),\n        (this.display = function () {\n          var e,\n            t,\n            r,\n            a,\n            n = this._callback,\n            o = this.manual_callback,\n            i = this.manual_map\n          r = Object.keys(this.feature_set)\n          var s,\n            c = function (t) {\n              return e[t]\n            }\n          for (s = 0; s < this._data.length; s++) {\n            ;(e = this._data[s]), (t = r.map(c))\n            for (var l = 0; l < r.length; l++)\n              (a = r[l]), -1 === this.feature_set[a].indexOf(t[l]) && this.feature_set[a].push(t[l])\n          }\n          for (a in this.feature_set) this.sorters.hasOwnProperty(a) && this.feature_set[a].sort(this.sorters[a])\n          $(this.target).empty(), $(this.target).append(\"<div class='col-lg-12 segments text-center'></div>\")\n          var u = function () {\n            var t,\n              e = $(this).data('key'),\n              r = $(this).data('feature')\n            return (\n              $('.' + r + '-btns button.btn span.title').html(e),\n              i.hasOwnProperty(r) ? ((t = i[r]), o[t](e)) : n(r, e),\n              !1\n            )\n          }\n          for (var d in this.feature_set) {\n            for (\n              r = this.feature_set[d],\n                $(this.target + ' div.segments').append(\n                  '<div class=\"btn-group ' +\n                    this._strip_punctuation(d) +\n                    '-btns text-left\"><button type=\"button\" class=\"btn btn-default btn-lg dropdown-toggle\" data-toggle=\"dropdown\"><span class=\\'which-button\\'>' +\n                    (this.public_name.hasOwnProperty(d) ? this.public_name[d] : d) +\n                    \"</span><span class='title'>\" +\n                    (this.manual_callback.hasOwnProperty(d) ? this.feature_set[d][0] : 'all') +\n                    '</span><span class=\"caret\"></span></button><ul class=\"dropdown-menu\" role=\"menu\">' +\n                    (this.manual_callback.hasOwnProperty(d)\n                      ? ''\n                      : '<li><a href=\"#\" data-feature=\"' + d + '\" data-key=\"all\">All</a></li>') +\n                    (this.manual_callback.hasOwnProperty(d) ? '' : '<li class=\"divider\"></li>') +\n                    '</ul></div>'\n                ),\n                s = 0;\n              s < r.length;\n              s++\n            )\n              'all' !== r[s] &&\n                void 0 !== r[s] &&\n                $(this.target + ' div.' + this._strip_punctuation(d) + '-btns ul.dropdown-menu').append(\n                  '<li><a href=\"#\" data-feature=\"' +\n                    this._strip_punctuation(d) +\n                    '\" data-key=\"' +\n                    r[s] +\n                    '\">' +\n                    r[s] +\n                    '</a></li>'\n                )\n            $('.' + this._strip_punctuation(d) + '-btns .dropdown-menu li a').on('click', u)\n          }\n          return this\n        }),\n        this\n      )\n    })\n  var Zt = function (t, e, r) {\n      var a = e.line_id,\n        n = r.color,\n        o = r.colors\n      t.classed('mg-hover-line-color', null === n)\n        .classed('mg-hover-line' + a + '-color', null === o)\n        .attr('fill', null === o ? '' : o[a - 1])\n    },\n    Kt = function (r, t, e) {\n      ;(t.existing_band = e.selectAll('.mg-confidence-band').nodes()),\n        r.show_confidence_band &&\n          (t.confidence_area = E.area()\n            .defined(t.line.defined())\n            .x(r.scalefns.xf)\n            .y0(function (t) {\n              var e = r.show_confidence_band[0]\n              return null != t[e] ? r.scales.Y(t[e]) : r.scales.Y(t[r.y_accessor])\n            })\n            .y1(function (t) {\n              var e = r.show_confidence_band[1]\n              return null != t[e] ? r.scales.Y(t[e]) : r.scales.Y(t[r.y_accessor])\n            })\n            .curve(r.interpolate))\n    },\n    Jt = function (t, e) {\n      var r = t.scalefns,\n        a = t.scales,\n        n = t.interpolate,\n        o = t.flip_area_under_y_value,\n        i = Number.isFinite(o) ? a.Y(o) : a.Y.range()[0]\n      e.area = E.area()\n        .defined(e.line.defined())\n        .x(r.xf)\n        .y0(function () {\n          return i\n        })\n        .y1(r.yf)\n        .curve(n)\n    },\n    te = function (t, e) {\n      var r = t.y_accessor,\n        a = t.scalefns,\n        n = t.scales,\n        o = t.interpolate\n      e.flat_line = E.line()\n        .defined(function (t) {\n          return (void 0 === t._missing || !0 !== t._missing) && null !== t[r]\n        })\n        .x(a.xf)\n        .y(function () {\n          return n.Y(e.data_median)\n        })\n        .curve(o)\n    },\n    ee = function (t, e) {\n      var r = t.scalefns,\n        a = t.interpolate,\n        n = t.missing_is_zero,\n        o = t.y_accessor\n      ;(e.line = E.line()\n        .x(r.xf)\n        .y(r.yf)\n        .curve(a)),\n        n ||\n          (e.line = e.line.defined(function (t) {\n            return (void 0 === t._missing || !0 !== t._missing) && null !== t[o]\n          }))\n    },\n    re = function (t, e, r, a) {\n      var n = t.show_confidence_band,\n        o = t.transition_on_update,\n        i = t.data,\n        s = t.target\n      if (n) {\n        r.select('.mg-confidence-band-' + a).empty() &&\n          r.append('path').attr('class', 'mg-confidence-band mg-confidence-band-' + a),\n          r\n            .select('.mg-confidence-band-' + a)\n            .transition()\n            .duration(function () {\n              return o ? 1e3 : 0\n            })\n            .attr('d', e.confidence_area(i[a - 1]))\n            .attr('clip-path', 'url(#mg-plot-window-' + z(s) + ')')\n      }\n    },\n    ae = function (t, e, r, a, n) {\n      var o = t.data,\n        i = t.target,\n        s = t.colors,\n        c = r.selectAll('.mg-main-area.mg-area' + n)\n      e.display_area\n        ? c.empty()\n          ? r\n              .append('path')\n              .classed('mg-main-area', !0)\n              .classed('mg-area' + n, !0)\n              .classed('mg-area-color', null === s)\n              .classed('mg-area' + n + '-color', null === s)\n              .attr('d', e.area(o[a]))\n              .attr('fill', null === s ? '' : s[n - 1])\n              .attr('clip-path', 'url(#mg-plot-window-' + z(i) + ')')\n          : (r.node().appendChild(c.node()),\n            c\n              .transition()\n              .duration(e.update_transition_duration)\n              .attr('d', e.area(o[a]))\n              .attr('clip-path', 'url(#mg-plot-window-' + z(i) + ')'))\n        : c.empty() || c.remove()\n    },\n    ne = function (t, e) {\n      t.classed('mg-line-color', !0).classed('mg-line' + e + '-color', !0)\n    },\n    oe = function (t, e, r, a, n, o) {\n      if (a.empty()) {\n        var i = r.append('path').attr('class', 'mg-main-line mg-line' + o)\n        ;(g = i),\n          (h = n),\n          (x = o),\n          (y = t.colors) && y.constructor === Array ? (g.attr('stroke', y[h]), y.length < h + 1 && ne(g, x)) : ne(g, x),\n          (l = e),\n          (u = i),\n          (d = n),\n          (f = (c = t).animate_on_load),\n          (p = c.data),\n          (_ = c.y_accessor),\n          (m = c.target),\n          f\n            ? ((l.data_median = E.median(p[d], function (t) {\n                return t[_]\n              })),\n              u\n                .attr('d', l.flat_line(p[d]))\n                .transition()\n                .duration(1e3)\n                .attr('d', l.line(p[d]))\n                .attr('clip-path', 'url(#mg-plot-window-' + z(m) + ')'))\n            : u.attr('d', l.line(p[d])).attr('clip-path', 'url(#mg-plot-window-' + z(m) + ')')\n      } else {\n        r.node().appendChild(a.node())\n        var s = a.transition().duration(e.update_transition_duration)\n        e.display_area || !t.transition_on_update || t.missing_is_hidden\n          ? s.attr('d', e.line(t.data[n]))\n          : s.attrTween('d', je(e.line(t.data[n]), 4))\n      }\n      var c, l, u, d, f, p, _, m, g, h, x, y\n    },\n    ie = function (t, e, r, a) {\n      var n,\n        o = void 0\n      if (t.legend)\n        if (\n          (u(t.legend)\n            ? (o = t.legend[r])\n            : ((n = t.legend), '[object Function]' === Object.prototype.toString.call(n) && (o = t.legend(t.data[r]))),\n          t.legend_target)\n        )\n          t.colors && t.colors.constructor === Array\n            ? (e.legend_text =\n                \"<span style='color:\" + t.colors[r] + \"'>&mdash; \" + o + '&nbsp; </span>' + e.legend_text)\n            : (e.legend_text =\n                \"<span class='mg-line\" + a + \"-legend-color'>&mdash; \" + o + '&nbsp; </span>' + e.legend_text)\n        else {\n          var i = void 0,\n            s = void 0,\n            c = void 0\n          'left' === t.y_axis_position\n            ? ((i = t.data[r][t.data[r].length - 1]), (s = 'start'), (c = t.buffer))\n            : ((i = t.data[r][0]), (s = 'end'), (c = -t.buffer))\n          var l = e.legend_group\n            .append('svg:text')\n            .attr('x', t.scalefns.xf(i))\n            .attr('dx', c)\n            .attr('y', t.scalefns.yf(i))\n            .attr('dy', '.35em')\n            .attr('font-size', 10)\n            .attr('text-anchor', s)\n            .attr('font-weight', '300')\n            .text(o)\n          t.colors && t.colors.constructor === Array\n            ? t.colors.length < r + 1\n              ? l.classed('mg-line' + a + '-legend-color', !0)\n              : l.attr('fill', t.colors[r])\n            : l.classed('mg-line-legend-color', !0).classed('mg-line' + a + '-legend-color', !0),\n            (function (t, e) {\n              if (t && 1 != t.length) {\n                var r, a, n\n                t.sort(function (t, e) {\n                  return E.select(e).attr('y') - E.select(t).attr('y')\n                }),\n                  t.reverse()\n                for (var o = 0; o < t.length; o++) {\n                  a = E.select(t[o]).text()\n                  for (var i = 0; i < t.length; i++)\n                    if (\n                      ((n = E.select(t[i]).text()),\n                      !1 !==\n                        ((l = t[o]),\n                        (u = t[i]),\n                        void 0,\n                        (d = l.getBoundingClientRect()),\n                        (f = u.getBoundingClientRect()),\n                        (r = d.top <= f.bottom && d.top >= f.top && f.bottom - d.top)) && a !== n)\n                    ) {\n                      var s = E.select(t[o]),\n                        c = +s.attr('y')\n                      ;(c += r), s.attr('y', c)\n                    }\n                }\n              }\n              var l, u, d, f\n            })(e.legend_group.selectAll('.mg-line-legend text').nodes())\n        }\n    },\n    se = function (e, t, r, a, n, o) {\n      var i,\n        s,\n        c,\n        l = E.voronoi()\n          .x(function (t) {\n            return e.scales.X(t[e.x_accessor]).toFixed(2)\n          })\n          .y(function (t) {\n            return e.scales.Y(t[e.y_accessor]).toFixed(2)\n          })\n          .extent([\n            [e.buffer, e.buffer + (e.title ? e.title_y_position : 0)],\n            [e.width - e.buffer, e.height - e.buffer]\n          ])\n      S(t, 'mg-voronoi')\n        .selectAll('path')\n        .data(l.polygons(((s = e), (c = s.data), E.merge(c))))\n        .enter()\n        .append('path')\n        .filter(function (t) {\n          return void 0 !== t && 0 < t.length\n        })\n        .attr('d', function (t) {\n          return null == t ? null : 'M' + t.join('L') + 'Z'\n        })\n        .datum(function (t) {\n          return null == t ? null : t.data\n        })\n        .attr(\n          'class',\n          ((i = e),\n          function (t) {\n            var e = void 0\n            if (i.linked) {\n              var r = t[i.x_accessor],\n                a = MG.time_format(i.utc_time, i.linked_format)\n              return (\n                (e = 'roll_' + ('number' == typeof r ? t.line_id - 1 : a(r)) + ' mg-line' + t.line_id),\n                null === i.color && (e += ' mg-line' + t.line_id + '-color'),\n                e\n              )\n            }\n            return (e = 'mg-line' + t.line_id), null === i.color && (e += ' mg-line' + t.line_id + '-color'), e\n          })\n        )\n        .on('click', o)\n        .on('mouseover', r)\n        .on('mouseout', a)\n        .on('mousemove', n),\n        le(e, t)\n    },\n    ce = function (a, t, e, r, n, o) {\n      var i,\n        s,\n        c,\n        l,\n        u,\n        d = ((s = (i = a).x_accessor),\n        (c = i.data),\n        (l = i.x_sort),\n        (u = E.nest()\n          .key(function (t) {\n            return t[s]\n          })\n          .entries(E.merge(c))).forEach(function (t) {\n          var e = t.values[0]\n          t.key = e[s]\n        }),\n        l\n          ? u.sort(function (t, e) {\n              return new Date(t.key) - new Date(e.key)\n            })\n          : u),\n        f = d.map(function (t) {\n          var e = t.key\n          return a.scales.X(e)\n        })\n      t\n        .append('g')\n        .attr('class', 'mg-rollover-rect')\n        .selectAll('.mg-rollover-rects')\n        .data(d)\n        .enter()\n        .append('rect')\n        .attr('x', function (t, e) {\n          return 1 === f.length ? Y(a) : 0 === e ? f[e].toFixed(2) : ((f[e - 1] + f[e]) / 2).toFixed(2)\n        })\n        .attr('y', a.top)\n        .attr('width', function (t, e) {\n          return 1 === f.length\n            ? P(a)\n            : 0 === e\n            ? ((f[e + 1] - f[e]) / 2).toFixed(2)\n            : e === f.length - 1\n            ? ((f[e] - f[e - 1]) / 2).toFixed(2)\n            : ((f[e + 1] - f[e - 1]) / 2).toFixed(2)\n        })\n        .attr('class', function (t) {\n          var e = t.values,\n            r = e\n              .map(function (t) {\n                var e = t.line_id,\n                  r = ue(e)\n                return null === a.colors && (r += ' ' + de(e)), r\n              })\n              .join(' ')\n          return a.linked && 0 < e.length && (r += ' ' + fe(pe(e[0], a))), r\n        })\n        .attr('height', a.height - a.bottom - a.top - a.buffer)\n        .attr('opacity', 0)\n        .on('click', o)\n        .on('mouseover', e)\n        .on('mouseout', r)\n        .on('mousemove', n),\n        _e(a, t)\n    },\n    le = function (t, e) {\n      for (var r = t.data, a = t.custom_line_color_map, n = 0; n < r.length; n++) {\n        var o = n + 1\n        0 < a.length && void 0 !== a[n] && (o = a[n]),\n          1 !== r[n].length ||\n            e.selectAll('.mg-voronoi .mg-line' + o).empty() ||\n            (e.selectAll('.mg-voronoi .mg-line' + o).on('mouseover')(r[n][0], 0),\n            e.selectAll('.mg-voronoi .mg-line' + o).on('mouseout')(r[n][0], 0))\n      }\n    },\n    ue = function (t) {\n      return 'mg-line' + t\n    },\n    de = function (t) {\n      return 'mg-line' + t + '-color'\n    },\n    fe = function (t) {\n      return 'roll_' + t\n    },\n    pe = function (t, e) {\n      var r = e.x_accessor,\n        a = e.utc_time,\n        n = e.linked_format,\n        o = t[r],\n        i = MG.time_format(a, n)\n      return 'number' == typeof o ? o.toString().replace('.', '_') : i(o)\n    },\n    _e = function (t, e) {\n      var r = t.data,\n        a = e.selectAll('.mg-rollover-rect rect'),\n        n = a.nodes()[0][0] || a.nodes()[0]\n      0 <\n        r.filter(function (t) {\n          return 1 === t.length\n        }).length && a.on('mouseover')(n.__data__, 0)\n    },\n    me = function (t) {\n      var e = t.data\n      return 1 === e.length && 1 === e[0].length\n    },\n    ge = function (t, e) {\n      var r = t.existing_band\n      r[0] && r[0].length > e.selectAll('.mg-main-line').node().length && e.selectAll('.mg-confidence-band').remove()\n    },\n    he = function (t) {\n      var e,\n        r,\n        a,\n        n,\n        o,\n        i,\n        s,\n        c = {},\n        l = O(t.target)\n      D(l, '.mg-line-legend'),\n        (e = c),\n        (r = l),\n        t.legend && (e.legend_group = S(r, 'mg-line-legend')),\n        (c.data_median = 0),\n        (c.update_transition_duration = t.transition_on_update ? 1e3 : 0),\n        (c.display_area =\n          (t.area && !t.use_data_y_min && t.data.length <= 1 && !1 === t.aggregate_rollover) ||\n          (Array.isArray(t.area) && 0 < t.area.length)),\n        (c.legend_text = ''),\n        (o = l),\n        ee((a = t), (n = c)),\n        Jt(a, n),\n        te(a, n),\n        Kt(a, n, o),\n        (c.existing_band = l.selectAll('.mg-confidence-band').nodes()),\n        !1 !== MG.call_hook('line.before_all_series', [t]) &&\n          (function (e, t, r) {\n            ge(t, r), e.active_point_on_lines && r.selectAll('circle.mg-shown-active-point').remove()\n            for (var a = e.data.length - 1; 0 <= a; a--) {\n              var n = e.data[a]\n              MG.call_hook('line.before_each_series', [n, e])\n              var o = a + 1\n              if (\n                (0 < e.custom_line_color_map.length && (o = e.custom_line_color_map[a]),\n                (e.data[a].line_id = o),\n                e.active_point_on_lines &&\n                  r\n                    .selectAll('circle-' + o)\n                    .data(e.data[a])\n                    .enter()\n                    .filter(function (t) {\n                      return t[e.active_point_accessor]\n                    })\n                    .append('circle')\n                    .attr('class', 'mg-area' + o + '-color mg-shown-active-point')\n                    .attr('cx', e.scalefns.xf)\n                    .attr('cy', e.scalefns.yf)\n                    .attr('r', function () {\n                      return e.active_point_size\n                    }),\n                0 !== n.length)\n              ) {\n                var i = r.select('path.mg-main-line.mg-line' + o)\n                re(e, t, r, o),\n                  Array.isArray(e.area) ? e.area[o - 1] && ae(e, t, r, a, o) : ae(e, t, r, a, o),\n                  oe(e, t, r, i, a, o),\n                  ie(e, t, a, o),\n                  MG.call_hook('line.after_each_series', [n, i, e])\n              }\n            }\n          })(t, c, l),\n        (i = t.legend_target),\n        (s = c.legend_text),\n        i && E.select(i).html(s)\n    },\n    xe = function (t, e) {\n      var r,\n        a,\n        n,\n        o,\n        i,\n        s,\n        c,\n        l,\n        u,\n        d,\n        f,\n        p,\n        _ = O(t.target)\n      t.showActivePoint &&\n        0 === _.selectAll('.mg-active-datapoint-container').nodes().length &&\n        S(_, 'mg-active-datapoint-container'),\n        D((r = _), '.mg-rollover-rect'),\n        D(r, '.mg-voronoi'),\n        D(r, '.mg-active-datapoint'),\n        D(r, '.mg-line-rollover-circle'),\n        (n = _),\n        (o = (a = t).data),\n        (i = a.colors),\n        (s = n\n          .selectAll('.mg-line-rollover-circle')\n          .data(o)\n          .enter()\n          .append('circle')\n          .attr('cx', 0)\n          .attr('cy', 0)\n          .attr('r', 0)),\n        i && i.constructor === Array\n          ? s\n              .attr('class', function (t) {\n                return 'mg-line' + t.line_id\n              })\n              .attr('fill', function (t, e) {\n                return i[e]\n              })\n              .attr('stroke', function (t, e) {\n                return i[e]\n              })\n          : s.attr('class', function (t, e) {\n              var r = t.line_id\n              return ['mg-line' + r, 'mg-line' + r + '-color', 'mg-area' + r + '-color'].join(' ')\n            }),\n        s.classed('mg-line-rollover-circle', !0),\n        (function (t) {\n          for (var e = t.data, r = t.custom_line_color_map, a = 0; a < e.length; a++)\n            for (var n = 0; n < e[a].length; n++)\n              (e[a][n].index = a + 1), 0 < r.length ? (e[a][n].line_id = r[a]) : (e[a][n].line_id = a + 1)\n        })(t),\n        (f = (d = t).data),\n        (p = d.aggregate_rollover),\n        1 < f.length && !p\n          ? se(t, _, e.rolloverOn(t), e.rolloverOff(t), e.rolloverMove(t), e.rolloverClick(t))\n          : ((l = (c = t).data),\n            (u = c.aggregate_rollover),\n            1 < l.length && u\n              ? ce(t, _, e.rolloverOn(t), e.rolloverOff(t), e.rolloverMove(t), e.rolloverClick(t))\n              : (function (a, t, e, r, n, o) {\n                  var i = 1\n                  0 < a.custom_line_color_map.length && (i = a.custom_line_color_map[0])\n                  var s,\n                    c,\n                    l = t.append('g').attr('class', 'mg-rollover-rect'),\n                    u = a.data[0].map(a.scalefns.xf)\n                  l\n                    .selectAll('.mg-rollover-rects')\n                    .data(a.data[0])\n                    .enter()\n                    .append('rect')\n                    .attr('class', function (t, e) {\n                      var r = de(i) + ' ' + ue(t.line_id)\n                      return a.linked && (r += r + ' ' + fe(pe(t, a))), r\n                    })\n                    .attr('x', function (t, e) {\n                      return 1 === u.length ? Y(a) : 0 === e ? u[e].toFixed(2) : ((u[e - 1] + u[e]) / 2).toFixed(2)\n                    })\n                    .attr('y', function (t, e) {\n                      return 1 < a.data.length ? a.scalefns.yf(t) - 6 : a.top\n                    })\n                    .attr('width', function (t, e) {\n                      return 1 === u.length\n                        ? P(a)\n                        : 0 === e\n                        ? ((u[e + 1] - u[e]) / 2).toFixed(2)\n                        : e === u.length - 1\n                        ? ((u[e] - u[e - 1]) / 2).toFixed(2)\n                        : ((u[e + 1] - u[e - 1]) / 2).toFixed(2)\n                    })\n                    .attr('height', function (t, e) {\n                      return 1 < a.data.length ? 12 : a.height - a.bottom - a.top - a.buffer\n                    })\n                    .attr('opacity', 0)\n                    .on('click', o)\n                    .on('mouseover', e)\n                    .on('mouseout', r)\n                    .on('mousemove', n),\n                    me(a) && ((s = t), (c = a.data), s.select('.mg-rollover-rect rect').on('mouseover')(c[0][0], 0))\n                })(t, _, e.rolloverOn(t), e.rolloverOff(t), e.rolloverMove(t), e.rolloverClick(t)))\n    },\n    ye = function (t, e, r) {\n      var a = t.scales,\n        n = t.x_accessor,\n        o = t.y_accessor,\n        i = t.point_size\n      e.select('circle.mg-line-rollover-circle.mg-line' + r.line_id)\n        .attr('cx', a.X(r[n]).toFixed(2))\n        .attr('cy', a.Y(r[o]).toFixed(2))\n        .attr('r', i)\n        .style('opacity', 1)\n    },\n    ve = function (t, e, r) {\n      var a = t.scales,\n        n = t.x_accessor,\n        o = t.y_accessor,\n        i = t.point_size\n      e.selectAll('circle.mg-line-rollover-circle.mg-line' + r.line_id)\n        .classed('mg-line-rollover-circle', !0)\n        .attr('cx', function () {\n          return a.X(r[n]).toFixed(2)\n        })\n        .attr('cy', function () {\n          return a.Y(r[o]).toFixed(2)\n        })\n        .attr('r', i)\n        .style('opacity', 1)\n    }\n  MG.register('line', function (t) {\n    ;(this.init = function (e) {\n      if (!(this.args = e).data || 0 === e.data.length)\n        return (\n          (e.internal_error = 'No data was supplied'),\n          (t = e),\n          console.error('INTERNAL ERROR : ', t.target, ' : ', t.internal_error),\n          this\n        )\n      var t\n      ;(e.internal_error = void 0),\n        Me(e),\n        Ae(e),\n        MG.call_hook('line.before_destroy', this),\n        Ot(e),\n        new MG.scale_factory(e)\n          .namespace('x')\n          .numericalDomainFromData()\n          .numericalRange('bottom')\n      var r = (e.baselines || []).map(function (t) {\n        return t[e.y_accessor]\n      })\n      return (\n        new MG.scale_factory(e)\n          .namespace('y')\n          .zeroBottom(!0)\n          .inflateDomain(!0)\n          .numericalDomainFromData(r)\n          .numericalRange('left'),\n        e.x_axis &&\n          new MG.axis_factory(e)\n            .namespace('x')\n            .type('numerical')\n            .position(e.x_axis_position)\n            .rug(nt(e))\n            .label(st)\n            .draw(),\n        e.y_axis &&\n          new MG.axis_factory(e)\n            .namespace('y')\n            .type('numerical')\n            .position(e.y_axis_position)\n            .rug(K(e))\n            .label(et)\n            .draw(),\n        this.markers(),\n        this.mainPlot(),\n        this.rollover(),\n        this.windowListeners(),\n        e.brush && MG.add_brush_function(e),\n        MG.call_hook('line.after_init', this),\n        this\n      )\n    }),\n      (this.mainPlot = function () {\n        return he(t), this\n      }),\n      (this.markers = function () {\n        return St(t), this\n      }),\n      (this.rollover = function () {\n        return xe(t, this), MG.call_hook('line.after_rollover', t), this\n      }),\n      (this.rolloverClick = function (r) {\n        return function (t, e) {\n          r.click && r.click(t, e)\n        }\n      }),\n      (this.rolloverOn = function (n) {\n        var o = O(n.target)\n        return function (r, t) {\n          if (\n            ((function (a, n, t) {\n              if (a.aggregate_rollover && 1 < a.data.length)\n                n.selectAll('circle.mg-line-rollover-circle').style('opacity', 0),\n                  t.values.forEach(function (t, e, r) {\n                    ;(a.missing_is_hidden && r[e]._missing) || (i(t, a) && ye(a, n, t))\n                  })\n              else {\n                if ((a.missing_is_hidden && t._missing) || null === t[a.y_accessor]) return\n                i(t, a) && ve(a, n, t)\n              }\n            })(n, o, r),\n            (function (t, e, r) {\n              if (\n                t.linked &&\n                !MG.globals.link &&\n                ((MG.globals.link = !0),\n                !t.aggregate_rollover || void 0 !== e[t.y_accessor] || (e.values && 0 < e.values.length))\n              ) {\n                var a = e.values ? e.values[0] : e,\n                  n = pe(a, t)\n                E.selectAll('.' + ue(a.line_id) + '.' + fe(n)).each(function (t) {\n                  E.select(this).on('mouseover')(t, r)\n                })\n              }\n            })(n, r, t),\n            o\n              .selectAll('text')\n              .filter(function (t, e) {\n                return r === t\n              })\n              .attr('opacity', 0.3),\n            n.show_rollover_text && !((n.missing_is_hidden && r._missing) || null === r[n.y_accessor]))\n          ) {\n            var e = Xt(n, { svg: o }),\n              a = e.mouseover_row()\n            n.aggregate_rollover &&\n              a.text(\n                (n.aggregate_rollover && 1 < n.data.length\n                  ? function (t, e) {\n                      return Pe(t, e, t.x_mouseover, 'key', t.time_series)\n                    }\n                  : Se)(n, r)\n              ),\n              (n.aggregate_rollover && 1 < n.data.length ? r.values : [r]).forEach(function (t) {\n                n.aggregate_rollover && (a = e.mouseover_row()),\n                  n.legend && Zt(a.text(n.legend[t.index - 1] + '  ').bold(), t, n),\n                  Zt(a.text('—  ').elem, t, n),\n                  n.aggregate_rollover || a.text(Se(n, t)),\n                  a.text(Le(n, t, n.time_series))\n              })\n          }\n          n.mouseover && n.mouseover(r, t)\n        }\n      }),\n      (this.rolloverOff = function (c) {\n        var l = O(c.target)\n        return function (t, e) {\n          var r, a, n, o, i, s\n          !(function (t, e, a) {\n            var r = t.linked,\n              n = t.utc_time,\n              o = t.linked_format,\n              i = t.x_accessor\n            if (r && MG.globals.link) {\n              MG.globals.link = !1\n              var s = MG.time_format(n, o)\n              ;(e.values ? e.values : [e]).forEach(function (t) {\n                var e = t[i],\n                  r = 'number' == typeof e ? a : s(e)\n                E.selectAll('.roll_' + r).each(function (t) {\n                  E.select(this).on('mouseout')(t)\n                })\n              })\n            }\n          })(c, t, e),\n            c.aggregate_rollover\n              ? l\n                  .selectAll('circle.mg-line-rollover-circle')\n                  .filter(function (t) {\n                    return 1 < t.length\n                  })\n                  .style('opacity', 0)\n              : ((a = l),\n                (n = t),\n                (o = (r = c).custom_line_color_map),\n                (i = r.data),\n                (s = n.line_id),\n                a.selectAll('circle.mg-line-rollover-circle.mg-line' + s).style('opacity', function () {\n                  var t = s - 1\n                  return 0 < o.length && void 0 !== o.indexOf(s) && (t = o.indexOf(s)), 1 === i[t].length ? 1 : 0\n                })),\n            1 < c.data[0].length && Lt(l),\n            c.mouseout && c.mouseout(t, e)\n        }\n      }),\n      (this.rolloverMove = function (r) {\n        return function (t, e) {\n          r.mousemove && r.mousemove(t, e)\n        }\n      }),\n      (this.windowListeners = function () {\n        return Qt(this.args), this\n      }),\n      this.init(t)\n  })\n  function be (t, e, r) {\n    var a,\n      n,\n      o,\n      i,\n      s,\n      c = Xt(t, { svg: e }).mouseover_row()\n    if (null !== t.color_accessor && 'category' === t.color_type) {\n      var l = r[t.color_accessor]\n      c.text(l + '  ')\n        .bold()\n        .attr('fill', t.scalefns.colorf(r))\n    }\n    ;(a = t),\n      (n = c.text('●   ').elem),\n      (o = r),\n      (i = a.color_accessor),\n      (s = a.scalefns),\n      null !== i ? (n.attr('fill', s.colorf(o)), n.attr('stroke', s.colorf(o))) : n.classed('mg-points-mono', !0),\n      c.text(Se(t, r)),\n      c.text(Le(t, r, t.time_series))\n  }\n  MG.register(\n    'histogram',\n    function (r) {\n      var a = this\n      ;(this.init = function (e) {\n        Me((a.args = e)),\n          De(e),\n          Ot(e),\n          new MG.scale_factory(e)\n            .namespace('x')\n            .numericalDomainFromData()\n            .numericalRange('bottom')\n        var t = (e.baselines || []).map(function (t) {\n          return t[e.y_accessor]\n        })\n        return (\n          new MG.scale_factory(e)\n            .namespace('y')\n            .zeroBottom(!0)\n            .inflateDomain(!0)\n            .numericalDomainFromData(t)\n            .numericalRange('left'),\n          ot(e),\n          rt(e),\n          a.mainPlot(),\n          a.markers(),\n          a.rollover(),\n          a.windowListeners(),\n          a\n        )\n      }),\n        (this.mainPlot = function () {\n          var t = O(r.target)\n          return (\n            t.selectAll('.mg-histogram').remove(),\n            t\n              .append('g')\n              .attr('class', 'mg-histogram')\n              .selectAll('.mg-bar')\n              .data(r.data[0])\n              .enter()\n              .append('g')\n              .attr('class', 'mg-bar')\n              .attr('transform', function (t) {\n                return (\n                  'translate(' +\n                  r.scales.X(t[r.x_accessor]).toFixed(2) +\n                  ',' +\n                  r.scales.Y(t[r.y_accessor]).toFixed(2) +\n                  ')'\n                )\n              })\n              .append('rect')\n              .attr('x', 1)\n              .attr('width', function (t, e) {\n                return 1 === r.data[0].length\n                  ? (r.scalefns.xf(r.data[0][0]) - r.bar_margin).toFixed(0)\n                  : e !== r.data[0].length - 1\n                  ? (r.scalefns.xf(r.data[0][e + 1]) - r.scalefns.xf(t)).toFixed(0)\n                  : (r.scalefns.xf(r.data[0][1]) - r.scalefns.xf(r.data[0][0])).toFixed(0)\n              })\n              .attr('height', function (t) {\n                return 0 === t[r.y_accessor]\n                  ? 0\n                  : (r.height - r.bottom - r.buffer - r.scales.Y(t[r.y_accessor])).toFixed(2)\n              }),\n            a\n          )\n        }),\n        (this.markers = function () {\n          return St(r), a\n        }),\n        (this.rollover = function () {\n          var t = O(r.target)\n          return (\n            0 === t.selectAll('.mg-active-datapoint-container').nodes().length && S(t, 'mg-active-datapoint-container'),\n            t.selectAll('.mg-rollover-rect').remove(),\n            t.selectAll('.mg-active-datapoint').remove(),\n            t\n              .append('g')\n              .attr('class', 'mg-rollover-rect')\n              .selectAll('.mg-bar')\n              .data(r.data[0])\n              .enter()\n              .append('g')\n              .attr('class', function (t, e) {\n                return r.linked ? 'mg-rollover-rects roll_' + e : 'mg-rollover-rects'\n              })\n              .attr('transform', function (t) {\n                return 'translate(' + r.scales.X(t[r.x_accessor]) + ',0)'\n              })\n              .append('rect')\n              .attr('x', 1)\n              .attr('y', r.buffer + (r.title ? r.title_y_position : 0))\n              .attr('width', function (t, e) {\n                return 1 === r.data[0].length\n                  ? (r.scalefns.xf(r.data[0][0]) - r.bar_margin).toFixed(0)\n                  : e !== r.data[0].length - 1\n                  ? (r.scalefns.xf(r.data[0][e + 1]) - r.scalefns.xf(t)).toFixed(0)\n                  : (r.scalefns.xf(r.data[0][1]) - r.scalefns.xf(r.data[0][0])).toFixed(0)\n              })\n              .attr('height', function (t) {\n                return r.height\n              })\n              .attr('opacity', 0)\n              .on('mouseover', a.rolloverOn(r))\n              .on('mouseout', a.rolloverOff(r))\n              .on('mousemove', a.rolloverMove(r)),\n            a\n          )\n        }),\n        (this.rolloverOn = function (e) {\n          var n = O(e.target)\n          return function (r, a) {\n            if (\n              (n\n                .selectAll('text')\n                .filter(function (t, e) {\n                  return r === t\n                })\n                .attr('opacity', 0.3),\n              e.processed.xax_format || MG.time_format(e.utc_time, '%b %e, %Y'),\n              Ee(e),\n              n\n                .selectAll('.mg-bar rect')\n                .filter(function (t, e) {\n                  return e === a\n                })\n                .classed('active', !0),\n              e.linked &&\n                !MG.globals.link &&\n                ((MG.globals.link = !0),\n                E.selectAll('.mg-rollover-rects.roll_' + a + ' rect').each(function (t) {\n                  E.select(this).on('mouseover')(t, a)\n                })),\n              e.show_rollover_text)\n            ) {\n              var t = Xt(e, { svg: n }).mouseover_row()\n              t.text('▟  ').elem.classed('hist-symbol', !0), t.text(Se(e, r)), t.text(Le(e, r, e.time_series))\n            }\n            e.mouseover && (jt(n, e), e.mouseover(r, a))\n          }\n        }),\n        (this.rolloverOff = function (r) {\n          var a = O(r.target)\n          return function (t, e) {\n            r.linked &&\n              MG.globals.link &&\n              ((MG.globals.link = !1),\n              E.selectAll('.mg-rollover-rects.roll_' + e + ' rect').each(function (t) {\n                E.select(this).on('mouseout')(t, e)\n              })),\n              a.selectAll('.mg-bar rect').classed('active', !1),\n              Lt(a),\n              r.mouseout && r.mouseout(t, e)\n          }\n        }),\n        (this.rolloverMove = function (r) {\n          return function (t, e) {\n            r.mousemove && r.mousemove(t, e)\n          }\n        }),\n        (this.windowListeners = function () {\n          return Qt(a.args), a\n        }),\n        this.init(r)\n    },\n    {\n      binned: !1,\n      bins: null,\n      processed_x_accessor: 'x',\n      processed_y_accessor: 'y',\n      processed_dx_accessor: 'dx',\n      bar_margin: 1\n    }\n  )\n  var we = function (t, e) {\n    var r = e.x_accessor,\n      a = e.y_accessor\n    return t.filter(function (t) {\n      return (\n        (null === e.min_x || t[r] >= e.min_x) &&\n        (null === e.max_x || t[r] <= e.max_x) &&\n        (null === e.min_y || t[a] >= e.min_y) &&\n        (null === e.max_y || t[a] <= e.max_y)\n      )\n    })\n  }\n  MG.register(\n    'point',\n    function (a) {\n      var o = this\n      ;(this.init = function (e) {\n        if (\n          (((this.args = e).x_axis_type = s(e, 'x')),\n          (e.y_axis_type = s(e, 'y')),\n          Me(e),\n          Oe(e),\n          Ot(e),\n          'categorical' === e.x_axis_type\n            ? (MG.scale_factory(e)\n                .namespace('x')\n                .categoricalDomainFromData()\n                .categoricalRangeBands([0, e.xgroup_height], null === e.xgroup_accessor),\n              e.xgroup_accessor\n                ? new MG.scale_factory(e)\n                    .namespace('xgroup')\n                    .categoricalDomainFromData()\n                    .categoricalRangeBands('bottom')\n                : ((e.scales.XGROUP = function () {\n                    return Y(e)\n                  }),\n                  (e.scalefns.xgroupf = function () {\n                    return Y(e)\n                  })),\n              (e.scalefns.xoutf = function (t) {\n                return e.scalefns.xf(t) + e.scalefns.xgroupf(t)\n              }))\n            : (MG.scale_factory(e)\n                .namespace('x')\n                .inflateDomain(!0)\n                .zeroBottom('categorical' === e.y_axis_type)\n                .numericalDomainFromData(\n                  (e.baselines || []).map(function (t) {\n                    return t[e.x_accessor]\n                  })\n                )\n                .numericalRange('bottom'),\n              (e.scalefns.xoutf = e.scalefns.xf)),\n          'categorical' === e.y_axis_type)\n        )\n          MG.scale_factory(e)\n            .namespace('y')\n            .zeroBottom(!0)\n            .categoricalDomainFromData()\n            .categoricalRangeBands([0, e.ygroup_height], !0),\n            e.ygroup_accessor\n              ? new MG.scale_factory(e)\n                  .namespace('ygroup')\n                  .categoricalDomainFromData()\n                  .categoricalRangeBands('left')\n              : ((e.scales.YGROUP = function () {\n                  return b(e)\n                }),\n                (e.scalefns.ygroupf = function () {\n                  return b(e)\n                })),\n            (e.scalefns.youtf = function (t) {\n              return e.scalefns.yf(t) + e.scalefns.ygroupf(t)\n            })\n        else {\n          var t = (e.baselines || []).map(function (t) {\n            return t[e.y_accessor]\n          })\n          MG.scale_factory(e)\n            .namespace('y')\n            .inflateDomain(!0)\n            .zeroBottom('categorical' === e.x_axis_type)\n            .numericalDomainFromData(t)\n            .numericalRange('left'),\n            (e.scalefns.youtf = function (t) {\n              return e.scalefns.yf(t)\n            })\n        }\n        if (null !== e.color_accessor) {\n          var r = MG.scale_factory(e).namespace('color')\n          'number' === e.color_type\n            ? r\n                .numericalDomainFromData(B(e))\n                .numericalRange(I(e))\n                .clamp(!0)\n            : e.color_domain\n            ? r.categoricalDomain(e.color_domain).categoricalRange(e.color_range)\n            : r.categoricalDomainFromData().categoricalColorRange()\n        }\n        return (\n          e.size_accessor &&\n            new MG.scale_factory(e)\n              .namespace('size')\n              .numericalDomainFromData()\n              .numericalRange(it(e))\n              .clamp(!0),\n          new MG.axis_factory(e)\n            .namespace('x')\n            .type(e.x_axis_type)\n            .zeroLine('categorical' === e.y_axis_type)\n            .position(e.x_axis_position)\n            .rug(nt(e))\n            .label(st)\n            .draw(),\n          new MG.axis_factory(e)\n            .namespace('y')\n            .type(e.y_axis_type)\n            .zeroLine('categorical' === e.x_axis_type)\n            .position(e.y_axis_position)\n            .rug(K(e))\n            .label(et)\n            .draw(),\n          this.mainPlot(),\n          this.markers(),\n          this.rollover(),\n          this.windowListeners(),\n          e.brush && MG.add_brush_function(e),\n          this\n        )\n      }),\n        (this.markers = function () {\n          return St(a), a.least_squares && ze(a), this\n        }),\n        (this.mainPlot = function () {\n          var t = O(a.target),\n            e = we(a.data[0], a)\n          t.selectAll('.mg-points').remove()\n          var r = t\n            .append('g')\n            .classed('mg-points', !0)\n            .selectAll('circle')\n            .data(e)\n            .enter()\n            .append('circle')\n            .attr('class', function (t, e) {\n              return 'path-' + e\n            })\n            .attr('cx', a.scalefns.xoutf)\n            .attr('cy', function (t) {\n              return a.scalefns.youtf(t)\n            })\n          return (\n            null !== a.color_accessor\n              ? (r.attr('fill', a.scalefns.colorf), r.attr('stroke', a.scalefns.colorf))\n              : r.classed('mg-points-mono', !0),\n            null !== a.size_accessor ? r.attr('r', a.scalefns.sizef) : r.attr('r', a.point_size),\n            this\n          )\n        }),\n        (this.rollover = function () {\n          var t = O(a.target)\n          0 === t.selectAll('.mg-active-datapoint-container').nodes().length && S(t, 'mg-active-datapoint-container'),\n            t.selectAll('.mg-voronoi').remove()\n          var e = E.voronoi()\n            .x(a.scalefns.xoutf)\n            .y(a.scalefns.youtf)\n            .extent([\n              [a.buffer, a.buffer + (a.title ? a.title_y_position : 0)],\n              [a.width - a.buffer, a.height - a.buffer]\n            ])\n          return (\n            t\n              .append('g')\n              .attr('class', 'mg-voronoi')\n              .selectAll('path')\n              .data(e.polygons(we(a.data[0], a)))\n              .enter()\n              .append('path')\n              .attr('d', function (t) {\n                return null == t ? null : 'M' + t.join(',') + 'Z'\n              })\n              .attr('class', function (t, e) {\n                return 'path-' + e\n              })\n              .style('fill-opacity', 0)\n              .on('mouseover', this.rolloverOn(a))\n              .on('mouseout', this.rolloverOff(a))\n              .on('mousemove', this.rolloverMove(a)),\n            1 === a.data[0].length && be(a, t, a.data[0][0]),\n            this\n          )\n        }),\n        (this.rolloverOn = function (a) {\n          var n = O(a.target)\n          return function (t, e) {\n            n.selectAll('.mg-points circle').classed('selected', !1)\n            var r = n.selectAll('.mg-points circle.path-' + e).classed('selected', !0)\n            a.size_accessor\n              ? r.attr('r', function (t) {\n                  return a.scalefns.sizef(t) + a.active_point_size_increase\n                })\n              : r.attr('r', a.point_size + a.active_point_size_increase),\n              a.linked &&\n                !MG.globals.link &&\n                ((MG.globals.link = !0),\n                E.selectAll('.mg-voronoi .path-' + e).each(function () {\n                  E.select(o).on('mouseover')(t, e)\n                })),\n              a.show_rollover_text && be(a, n, t.data),\n              a.mouseover && a.mouseover(t, e)\n          }\n        }),\n        (this.rolloverOff = function (a) {\n          var n = O(a.target)\n          return function (t, e) {\n            a.linked &&\n              MG.globals.link &&\n              ((MG.globals.link = !1),\n              E.selectAll('.mg-voronoi .path-' + e).each(function () {\n                E.select(o).on('mouseout')(t, e)\n              }))\n            var r = n\n              .selectAll('.mg-points circle')\n              .classed('unselected', !1)\n              .classed('selected', !1)\n            a.size_accessor ? r.attr('r', a.scalefns.sizef) : r.attr('r', a.point_size),\n              1 < a.data[0].length && Lt(n),\n              a.mouseout && a.mouseout(t, e)\n          }\n        }),\n        (this.rolloverMove = function (r) {\n          return function (t, e) {\n            r.mousemove && r.mousemove(t, e)\n          }\n        }),\n        (this.update = function (t) {\n          return this\n        }),\n        (this.windowListeners = function () {\n          return Qt(this.args), this\n        }),\n        this.init(a)\n    },\n    {\n      y_padding_percentage: 0.05,\n      y_outer_padding_percentage: 0.2,\n      ygroup_padding_percentage: 0,\n      ygroup_outer_padding_percentage: 0,\n      x_padding_percentage: 0.05,\n      x_outer_padding_percentage: 0.2,\n      xgroup_padding_percentage: 0,\n      xgroup_outer_padding_percentage: 0,\n      y_categorical_show_guides: !0,\n      x_categorical_show_guides: !0,\n      buffer: 16,\n      ls: !1,\n      lowess: !1,\n      point_size: 2.5,\n      label_accessor: null,\n      size_accessor: null,\n      color_accessor: null,\n      size_range: null,\n      color_range: null,\n      size_domain: null,\n      color_domain: null,\n      active_point_size_increase: 1,\n      color_type: 'number'\n    }\n  )\n  MG.register(\n    'bar',\n    function (M) {\n      var G = this\n      ;(this.args = M),\n        (this.init = function (e) {\n          if (\n            (((G.args = e).x_axis_type = s(e, 'x')),\n            (e.y_axis_type = s(e, 'y')),\n            'categorical' == e.x_axis_type\n              ? (e.orientation = 'vertical')\n              : 'categorical' == e.y_axis_type\n              ? (e.orientation = 'horizontal')\n              : 'categorical' != e.x_axis_type && 'categorical' != e.y_axis_type && (e.orientation = 'vertical'),\n            Me(e),\n            Oe(e),\n            Ot(e),\n            'categorical' === e.x_axis_type\n              ? (MG.scale_factory(e)\n                  .namespace('x')\n                  .categoricalDomainFromData()\n                  .categoricalRangeBands([0, e.xgroup_height], null === e.xgroup_accessor),\n                e.xgroup_accessor\n                  ? new MG.scale_factory(e)\n                      .namespace('xgroup')\n                      .categoricalDomainFromData()\n                      .categoricalRangeBands('bottom')\n                  : ((e.scales.XGROUP = function (t) {\n                      return Y(e)\n                    }),\n                    (e.scalefns.xgroupf = function (t) {\n                      return Y(e)\n                    })),\n                (e.scalefns.xoutf = function (t) {\n                  return e.scalefns.xf(t) + e.scalefns.xgroupf(t)\n                }))\n              : (MG.scale_factory(e)\n                  .namespace('x')\n                  .inflateDomain(!0)\n                  .zeroBottom('categorical' === e.y_axis_type)\n                  .numericalDomainFromData(\n                    (e.baselines || []).map(function (t) {\n                      return t[e.x_accessor]\n                    })\n                  )\n                  .numericalRange('bottom'),\n                (e.scalefns.xoutf = e.scalefns.xf)),\n            'categorical' === e.y_axis_type)\n          )\n            MG.scale_factory(e)\n              .namespace('y')\n              .zeroBottom(!0)\n              .categoricalDomainFromData()\n              .categoricalRangeBands([0, e.ygroup_height], !0),\n              e.ygroup_accessor\n                ? new MG.scale_factory(e)\n                    .namespace('ygroup')\n                    .categoricalDomainFromData()\n                    .categoricalRangeBands('left')\n                : ((e.scales.YGROUP = function () {\n                    return b(e)\n                  }),\n                  (e.scalefns.ygroupf = function (t) {\n                    return b(e)\n                  })),\n              (e.scalefns.youtf = function (t) {\n                return e.scalefns.yf(t) + e.scalefns.ygroupf(t)\n              })\n          else {\n            var t = (e.baselines || []).map(function (t) {\n              return t[e.y_accessor]\n            })\n            MG.scale_factory(e)\n              .namespace('y')\n              .inflateDomain(!0)\n              .zeroBottom('categorical' === e.x_axis_type)\n              .numericalDomainFromData(t)\n              .numericalRange('left'),\n              (e.scalefns.youtf = function (t) {\n                return e.scalefns.yf(t)\n              })\n          }\n          return (\n            null !== e.ygroup_accessor &&\n              ((e.ycolor_accessor = e.y_accessor),\n              MG.scale_factory(e)\n                .namespace('ycolor')\n                .scaleName('color')\n                .categoricalDomainFromData()\n                .categoricalColorRange()),\n            null !== e.xgroup_accessor &&\n              ((e.xcolor_accessor = e.x_accessor),\n              MG.scale_factory(e)\n                .namespace('xcolor')\n                .scaleName('color')\n                .categoricalDomainFromData()\n                .categoricalColorRange()),\n            new MG.axis_factory(e)\n              .namespace('x')\n              .type(e.x_axis_type)\n              .zeroLine('categorical' === e.y_axis_type)\n              .position(e.x_axis_position)\n              .draw(),\n            new MG.axis_factory(e)\n              .namespace('y')\n              .type(e.y_axis_type)\n              .zeroLine('categorical' === e.x_axis_type)\n              .position(e.y_axis_position)\n              .draw(),\n            G.mainPlot(),\n            G.markers(),\n            G.rollover(),\n            G.windowListeners(),\n            G\n          )\n        }),\n        (this.mainPlot = function () {\n          var t = O(M.target),\n            e = M.data[0],\n            r = t.select('g.mg-barplot'),\n            a = r.empty(),\n            n = void 0\n          ;(a && M.animate_on_load) || M.transition_on_update,\n            M.transition_duration,\n            a && (r = t.append('g').classed('mg-barplot', !0)),\n            (n = r\n              .selectAll('.mg-bar')\n              .data(e)\n              .enter()\n              .append('rect')\n              .classed('mg-bar', !0)\n              .classed('default-bar', !M.scales.hasOwnProperty('COLOR')))\n          var o = void 0,\n            i = void 0,\n            s = void 0,\n            c = void 0,\n            l = void 0,\n            u = void 0,\n            d = void 0,\n            f = void 0,\n            p = void 0,\n            _ = void 0,\n            m = void 0,\n            g = void 0,\n            h = void 0,\n            x = void 0,\n            y = void 0,\n            v = void 0\n          if (\n            ('vertical' == M.orientation &&\n              ((o = 'height'),\n              (i = 'width'),\n              (s = M.y_axis_type),\n              (c = M.x_axis_type),\n              (l = 'y'),\n              (u = 'x'),\n              (d = 'categorical' == s ? M.scalefns.youtf : M.scalefns.yf),\n              (f = 'categorical' == c ? M.scalefns.xoutf : M.scalefns.xf),\n              (p = M.scales.Y),\n              (_ = M.scales.X),\n              (m = M.y_accessor),\n              (g = M.x_accessor),\n              (h = function (t) {\n                var e = void 0\n                return (e = d(t)), t[m] < 0 && (e = p(0)), e\n              }),\n              (x = function (t) {\n                return Math.abs(d(t) - p(0))\n              }),\n              (y = function (t) {\n                return Math.abs(p(t[M.reference_accessor]) - p(0))\n              }),\n              (v = function (t) {\n                return p(t[M.reference_accessor])\n              })),\n            'horizontal' == M.orientation &&\n              ((o = 'width'),\n              (i = 'height'),\n              (s = M.x_axis_type),\n              (c = M.y_axis_type),\n              (l = 'x'),\n              (u = 'y'),\n              (d = 'categorical' == s ? M.scalefns.xoutf : M.scalefns.xf),\n              (f = 'categorical' == c ? M.scalefns.youtf : M.scalefns.yf),\n              (p = M.scales.X),\n              (_ = M.scales.Y),\n              (m = M.x_accessor),\n              (g = M.y_accessor),\n              (h = function (t) {\n                return p(0)\n              }),\n              (x = function (t) {\n                return Math.abs(d(t) - p(0))\n              }),\n              (y = function (t) {\n                return Math.abs(p(t[M.reference_accessor]) - p(0))\n              }),\n              (v = function (t) {\n                return p(0)\n              })),\n            n.attr(l, h),\n            n.attr(u, function (t) {\n              var e = void 0\n              return 'categorical' == c ? (e = f(t)) : ((e = _(0)), t[g] < 0 && (e = f(t))), (e -= M.bar_thickness / 2)\n            }),\n            M.scales.COLOR && n.attr('fill', M.scalefns.colorf),\n            n.attr(o, x).attr(i, function (t) {\n              return M.bar_thickness\n            }),\n            null !== M.reference_accessor)\n          ) {\n            var b = e.filter(function (t) {\n              return t.hasOwnProperty(M.reference_accessor)\n            })\n            r.selectAll('.mg-categorical-reference')\n              .data(b)\n              .enter()\n              .append('rect')\n              .attr(l, v)\n              .attr(u, function (t) {\n                return f(t) - M.reference_thickness / 2\n              })\n              .attr(o, y)\n              .attr(i, M.reference_thickness)\n          }\n          if (null !== M.comparison_accessor) {\n            var w = null\n            w = null === M.comparison_thickness ? M.bar_thickness / 2 : M.comparison_thickness\n            var k = e.filter(function (t) {\n              return t.hasOwnProperty(M.comparison_accessor)\n            })\n            r.selectAll('.mg-categorical-comparison')\n              .data(k)\n              .enter()\n              .append('line')\n              .attr(l + '1', function (t) {\n                return p(t[M.comparison_accessor])\n              })\n              .attr(l + '2', function (t) {\n                return p(t[M.comparison_accessor])\n              })\n              .attr(u + '1', function (t) {\n                return f(t) - w / 2\n              })\n              .attr(u + '2', function (t) {\n                return f(t) + w / 2\n              })\n              .attr('stroke', 'black')\n              .attr('stroke-width', M.comparison_width)\n          }\n          return (\n            (M.legend || (null !== M.color_accessor && M.ygroup_accessor !== M.color_accessor)) &&\n              (M.legend_target\n                ? (function (t) {\n                    var e = t.legend_target,\n                      r = t.orientation,\n                      a = t.scales\n                    if (e) {\n                      var n = E.select(e)\n                        .append('div')\n                        .classed('mg-bar-target-legend', !0)\n                      ;('horizontal' == r ? a.Y.domain() : a.X.domain()).forEach(function (t) {\n                        var e = n.append('span').classed('mg-bar-target-element', !0)\n                        e\n                          .append('span')\n                          .classed('mg-bar-target-legend-shape', !0)\n                          .style('color', a.COLOR(t))\n                          .text('◼ '),\n                          e\n                            .append('span')\n                            .classed('mg-bar-target-legend-text', !0)\n                            .text(t)\n                      })\n                    }\n                  })(M)\n                : (function (t, r) {\n                    var e = void 0\n                    e = 'horizontal' == r.orientation ? r.scales.Y.domain() : r.scales.X.domain()\n                    var a = 0,\n                      n = t\n                        .append('g')\n                        .classed('mg-bar-legend', !0)\n                        .append('text')\n                    n.selectAll('*').remove(),\n                      n\n                        .attr('width', r.right)\n                        .attr('height', 100)\n                        .attr('text-anchor', 'start'),\n                      e.forEach(function (t) {\n                        var e = n\n                          .append('tspan')\n                          .attr('x', P(r))\n                          .attr('y', r.height / 2)\n                          .attr('dy', 1.1 * a + 'em')\n                        e\n                          .append('tspan')\n                          .text('■ ')\n                          .attr('fill', r.scales.COLOR(t))\n                          .attr('font-size', 20),\n                          e\n                            .append('tspan')\n                            .text(t)\n                            .attr('font-weight', 300)\n                            .attr('font-size', 10),\n                          a++\n                      })\n                  })(t, M)),\n            G\n          )\n        }),\n        (this.markers = function () {\n          return St(M), G\n        }),\n        (this.rollover = function () {\n          var t = O(M.target)\n          0 === t.selectAll('.mg-active-datapoint-container').nodes().length && S(t, 'mg-active-datapoint-container'),\n            t.selectAll('.mg-rollover-rect').remove(),\n            t.selectAll('.mg-active-datapoint').remove()\n          var e = void 0,\n            r = void 0,\n            a = void 0,\n            n = void 0,\n            o = void 0,\n            i = void 0,\n            s = void 0,\n            c = void 0,\n            l = void 0,\n            u = void 0,\n            d = void 0,\n            f = void 0\n          'vertical' == M.orientation &&\n            ((e = 'height'),\n            (r = 'width'),\n            (a = M.y_axis_type),\n            (n = M.x_axis_type),\n            (o = 'y'),\n            (i = 'x'),\n            'categorical' == a ? M.scalefns.youtf : M.scalefns.yf,\n            (s = 'categorical' == n ? M.scalefns.xoutf : M.scalefns.xf),\n            (c = M.scales.Y),\n            (l = M.scales.X),\n            M.y_accessor,\n            (u = M.x_accessor),\n            (d = function (t) {\n              return b(M)\n            }),\n            (f = function (t) {\n              return M.height - M.top - M.bottom - 2 * M.buffer\n            })),\n            'horizontal' == M.orientation &&\n              ((e = 'width'),\n              (r = 'height'),\n              (a = M.x_axis_type),\n              (n = M.y_axis_type),\n              (o = 'x'),\n              (i = 'y'),\n              'categorical' == a ? M.scalefns.xoutf : M.scalefns.xf,\n              (s = 'categorical' == n ? M.scalefns.youtf : M.scalefns.yf),\n              (c = M.scales.X),\n              (l = M.scales.Y),\n              M.x_accessor,\n              (u = M.y_accessor),\n              (d = function (t) {\n                return c(0)\n              }),\n              (f = function (t) {\n                return M.width - M.left - M.right - 2 * M.buffer\n              }))\n          var p = void 0,\n            _ = void 0\n          'right' === M.rollover_align\n            ? ((p = M.width - M.right), (_ = 'end'))\n            : 'left' === M.rollover_align\n            ? ((p = M.left), (_ = 'start'))\n            : ((p = (M.width - M.left - M.right) / 2 + M.left), (_ = 'middle')),\n            t\n              .append('text')\n              .attr('class', 'mg-active-datapoint')\n              .attr('xml:space', 'preserve')\n              .attr('x', p)\n              .attr('y', 0.75 * M.top)\n              .attr('dy', '.35em')\n              .attr('text-anchor', _)\n          var m = t\n            .append('g')\n            .attr('class', 'mg-rollover-rect')\n            .selectAll('.mg-bar-rollover')\n            .data(M.data[0])\n            .enter()\n            .append('rect')\n            .attr('class', 'mg-bar-rollover')\n          return (\n            m\n              .attr('opacity', 0)\n              .attr(o, d)\n              .attr(i, function (t) {\n                var e = void 0\n                return (\n                  'categorical' == n ? (e = s(t)) : ((e = l(0)), t[u] < 0 && (e = s(t))), (e -= M.bar_thickness / 2)\n                )\n              }),\n            m.attr(e, f),\n            m.attr(r, function (t) {\n              return M.bar_thickness\n            }),\n            m\n              .on('mouseover', G.rolloverOn(M))\n              .on('mouseout', G.rolloverOff(M))\n              .on('mousemove', G.rolloverMove(M)),\n            G\n          )\n        }),\n        (this.rolloverOn = function (o) {\n          var i = O(o.target)\n          return (\n            G.is_vertical ? o.x_accessor : o.y_accessor,\n            G.is_vertical ? o.y_accessor : o.x_accessor,\n            G.is_vertical ? o.yax_units : o.xax_units,\n            function (t, r) {\n              MG.time_format(o.utc_time, '%b %e, %Y'), Ee(o)\n              var e = i\n                .selectAll('g.mg-barplot .mg-bar')\n                .filter(function (t, e) {\n                  return e === r\n                })\n                .classed('active', !0)\n              if (\n                (o.scales.hasOwnProperty('COLOR')\n                  ? e.attr('fill', E.rgb(o.scalefns.colorf(t)).darker())\n                  : e.classed('default-active', !0),\n                o.show_rollover_text)\n              ) {\n                var a = Xt(o, { svg: i }),\n                  n = a.mouseover_row()\n                o.ygroup_accessor && n.text(t[o.ygroup_accessor] + '   ').bold(),\n                  n.text(Se(o, t)),\n                  n.text(o.y_accessor + ': ' + t[o.y_accessor]),\n                  (o.predictor_accessor || o.baseline_accessor) &&\n                    ((n = a.mouseover_row()),\n                    o.predictor_accessor && n.text(Pe(o, t, null, o.predictor_accessor, !1)),\n                    o.baseline_accessor && n.text(Pe(o, t, null, o.baseline_accessor, !1)))\n              }\n              o.mouseover && o.mouseover(t, r)\n            }\n          )\n        }),\n        (this.rolloverOff = function (a) {\n          var n = O(a.target)\n          return function (t, e) {\n            var r = n.selectAll('g.mg-barplot .mg-bar.active').classed('active', !1)\n            a.scales.hasOwnProperty('COLOR') ? r.attr('fill', a.scalefns.colorf(t)) : r.classed('default-active', !1),\n              n.select('.mg-active-datapoint').text(''),\n              Lt(n),\n              a.mouseout && a.mouseout(t, e)\n          }\n        }),\n        (this.rolloverMove = function (r) {\n          return function (t, e) {\n            r.mousemove && r.mousemove(t, e)\n          }\n        }),\n        (this.windowListeners = function () {\n          return Qt(G.args), G\n        }),\n        this.init(M)\n    },\n    {\n      y_padding_percentage: 0.05,\n      y_outer_padding_percentage: 0.2,\n      ygroup_padding_percentage: 0,\n      ygroup_outer_padding_percentage: 0,\n      x_padding_percentage: 0.05,\n      x_outer_padding_percentage: 0.2,\n      xgroup_padding_percentage: 0,\n      xgroup_outer_padding_percentage: 0,\n      buffer: 16,\n      y_accessor: 'factor',\n      x_accessor: 'value',\n      reference_accessor: null,\n      comparison_accessor: null,\n      secondary_label_accessor: null,\n      color_accessor: null,\n      color_type: 'category',\n      color_domain: null,\n      reference_thickness: 1,\n      comparison_width: 3,\n      comparison_thickness: null,\n      legend: !1,\n      legend_target: null,\n      mouseover_align: 'right',\n      baseline_accessor: null,\n      predictor_accessor: null,\n      predictor_proportion: 5,\n      show_bar_zero: !0,\n      binned: !0,\n      truncate_x_labels: !0,\n      truncate_y_labels: !0\n    }\n  ),\n    (MG.data_table = function (t) {\n      return (\n        (this.args = t),\n        (this.args.standard_col = { width: 150, font_size: 12, font_weight: 'normal' }),\n        (this.args.columns = []),\n        (this.formatting_options = [\n          ['color', 'color'],\n          ['font-weight', 'font_weight'],\n          ['font-style', 'font_style'],\n          ['font-size', 'font_size']\n        ]),\n        (this._strip_punctuation = function (t) {\n          return t.replace(/[^a-zA-Z0-9 _]+/g, '').replace(/ +?/g, '')\n        }),\n        (this._format_element = function (a, n, o) {\n          this.formatting_options.forEach(function (t) {\n            var e = t[0],\n              r = t[1]\n            o[r] && a.style(e, 'string' == typeof o[r] || 'number' == typeof o[r] ? o[r] : o[r](n))\n          })\n        }),\n        (this._add_column = function (t, e) {\n          var r = this.args.standard_col,\n            a = p(MG.clone(t), MG.clone(r))\n          ;(a.type = e), this.args.columns.push(a)\n        }),\n        (this.target = function () {\n          var t = arguments[0]\n          return (this.args.target = t), this\n        }),\n        (this.title = function () {\n          return this._add_column(arguments[0], 'title'), this\n        }),\n        (this.text = function () {\n          return this._add_column(arguments[0], 'text'), this\n        }),\n        (this.bullet = function () {\n          return this\n        }),\n        (this.sparkline = function () {\n          return this\n        }),\n        (this.number = function () {\n          return this._add_column(arguments[0], 'number'), this\n        }),\n        (this.display = function () {\n          var t = this.args\n          j(t)\n          var e,\n            r,\n            a,\n            n,\n            o,\n            i,\n            s,\n            c,\n            l,\n            u,\n            d,\n            f,\n            p = t.target,\n            _ = E.select(p)\n              .append('table')\n              .classed('mg-data-table', !0),\n            m = _.append('colgroup'),\n            g = _.append('thead'),\n            h = _.append('tbody')\n          for (a = g.append('tr'), f = 0; f < t.columns.length; f++) {\n            var x = t.columns[f]\n            ;(i = x.type),\n              (c = void 0 === (c = x.label) ? '' : c),\n              (n = a\n                .append('th')\n                .style('width', x.width)\n                .style('text-align', 'title' === i ? 'left' : 'right')\n                .text(c)),\n              t.show_tooltips &&\n                x.description &&\n                k() &&\n                (n\n                  .append('i')\n                  .classed('fa', !0)\n                  .classed('fa-question-circle', !0)\n                  .classed('fa-inverse', !0),\n                $(n.node()).popover({\n                  html: !0,\n                  animation: !1,\n                  content: x.description,\n                  trigger: 'hover',\n                  placement: 'top',\n                  container: $(n.node())\n                }))\n          }\n          for (f = 0; f < t.columns.length; f++)\n            (d = m.append('col')), 'number' === t.columns[f].type && d.attr('align', 'char').attr('char', '.')\n          for (var y = 0; y < t.data.length; y++) {\n            a = h.append('tr')\n            for (var v = 0; v < t.columns.length; v++) {\n              if (((o = (e = t.columns[v]).accessor), (s = l = t.data[y][o]), 'number' === (i = e.type))) {\n                if (\n                  (e.hasOwnProperty('round') && !e.hasOwnProperty('format') && (l = E.format('0,.' + e.round + 'f')(l)),\n                  e.hasOwnProperty('value_formatter') && (l = e.value_formatter(l)),\n                  e.hasOwnProperty('format'))\n                ) {\n                  e.round && (l = Math.round(l, e.round))\n                  var b,\n                    w = e.format\n                  'percentage' === w && (b = E.format('.0%')),\n                    'count' === w && (b = E.format(',.0f')),\n                    'temperature' === w &&\n                      (b = function (t) {\n                        return t + '°'\n                      }),\n                    (l = b(l))\n                }\n                e.hasOwnProperty('currency') && (l = e.currency + l)\n              }\n              ;(u = a\n                .append('td')\n                .classed('table-' + i, !0)\n                .classed('table-' + i + '-' + this._strip_punctuation(o), !0)\n                .attr('data-value', s)\n                .style('width', e.width)\n                .style('text-align', 'title' === i || 'text' === i ? 'left' : 'right')),\n                this._format_element(u, s, e),\n                'title' === i\n                  ? ((r = u.append('div').text(l)),\n                    this._format_element(r, l, e),\n                    t.columns[v].hasOwnProperty('secondary_accessor') &&\n                      u\n                        .append('div')\n                        .text(t.data[y][t.columns[v].secondary_accessor])\n                        .classed('secondary-title', !0))\n                  : u.text(l)\n            }\n          }\n          return this\n        }),\n        this\n      )\n    })\n  function ke (t, e) {\n    var r, a, n\n    function o (t) {\n      return 1e3 === t ? 3 : 1e6 === t ? 7 : Math.log(t) / Math.LN10\n    }\n    'x' === e\n      ? ((r = t.x_accessor), (a = t.scales.X.ticks(t.xax_count)), (n = t.processed.max_x))\n      : 'y' === e && ((r = t.y_accessor), (a = t.scales.Y.ticks(t.yax_count)), (n = t.processed.max_y)),\n      (('x' === e && 'log' === t.x_scale_type) || ('y' === e && 'log' === t.y_scale_type)) &&\n        (a = a.filter(function (t) {\n          return Math.abs(o(t)) % 1 < 1e-6 || Math.abs(o(t)) % 1 > 1 - 1e-6\n        }))\n    var i = a.length,\n      s = !0\n    t.data.forEach(function (t, e) {\n      t.forEach(function (t, e) {\n        if (t[r] % 1 != 0) return (s = !1)\n      })\n    }),\n      s &&\n        n < i &&\n        'count' === t.format &&\n        (a = a.filter(function (t) {\n          return t % 1 == 0\n        })),\n      'x' === e ? (t.processed.x_ticks = a) : 'y' === e && (t.processed.y_ticks = a)\n  }\n  function Me (r) {\n    if (\n      ((r.data = MG.clone(r.data)),\n      (r.single_object = !1),\n      (r.array_of_objects = !1),\n      (r.array_of_arrays = !1),\n      (r.nested_array_of_arrays = !1),\n      (r.nested_array_of_objects = !1),\n      a(r.data)\n        ? ((r.nested_array_of_objects = r.data.map(function (t) {\n            return e(t)\n          })),\n          (r.nested_array_of_arrays = r.data.map(function (t) {\n            return a(t)\n          })))\n        : ((r.array_of_objects = n(r.data)), (r.array_of_arrays = a(r.data))),\n      'line' === r.chart_type\n        ? (r.array_of_objects || r.array_of_arrays) && (r.data = [r.data])\n        : y(r.data[0]) || (r.data = [r.data]),\n      Ge(r, 'x_accessor'),\n      Ge(r, 'y_accessor'),\n      void 0 !== r.color && (r.colors = r.color),\n      null !== r.colors && 'string' == typeof r.colors && (r.colors = [r.colors]),\n      'line' === r.chart_type && !0 === r.x_sort)\n    )\n      for (var t = 0; t < r.data.length; t++)\n        r.data[t].sort(function (t, e) {\n          return t[r.x_accessor] - e[r.x_accessor]\n        })\n    return this\n  }\n  function Ge (e, r) {\n    y(e[r]) &&\n      ((e.data = e.data.map(function (t) {\n        return e[r].map(function (e) {\n          return t\n            .map(function (t) {\n              if (void 0 !== (t = MG.clone(t))[e]) return (t['multiline_' + r] = t[e]), t\n            })\n            .filter(function (t) {\n              return void 0 !== t\n            })\n        })\n      })[0]),\n      (e[r] = 'multiline_' + r))\n  }\n  function Ae (r) {\n    var t,\n      e =\n        0 <\n        E.sum(\n          r.data.map(function (t) {\n            return 0 < t.length && x(t[0][r.x_accessor])\n          })\n        )\n    if ((r.missing_is_zero || r.missing_is_hidden) && 'line' === r.chart_type && e)\n      for (var a = 0; a < r.data.length; a++)\n        if (!(r.data[a].length <= 1)) {\n          var n = r.data[a][0],\n            o = r.data[a][r.data[a].length - 1],\n            i = [],\n            s = MG.clone(n[r.x_accessor]).setDate(n[r.x_accessor].getDate() + 1),\n            c = r.min_x ? r.min_x : s,\n            l = r.max_x ? r.max_x : o[r.x_accessor]\n          if (\n            ((t = lt((l - c) / 1e3)),\n            -1 !== ['four-days', 'many-days', 'many-months', 'years', 'default'].indexOf(t) &&\n              null === r.missing_is_hidden_accessor)\n          )\n            for (var u = new Date(c); u <= l; u.setDate(u.getDate() + 1)) {\n              var d = {}\n              u.setHours(0, 0, 0, 0), Date.parse(u) === Date.parse(new Date(s)) && i.push(MG.clone(r.data[a][0]))\n              var f = null\n              r.data[a].forEach(function (t, e) {\n                if (Date.parse(t[r.x_accessor]) === Date.parse(new Date(u))) return (f = t), !1\n              }),\n                f\n                  ? ((f[r.missing_is_hidden_accessor] || null === f[r.y_accessor]) && (f._missing = !0), i.push(f))\n                  : ((d[r.x_accessor] = new Date(u)), (d[r.y_accessor] = 0), (d._missing = !0), i.push(d))\n            }\n          else\n            for (var p = 0; p < r.data[a].length; p += 1) {\n              var _ = MG.clone(r.data[a][p])\n              ;(_._missing = r.data[a][p][r.missing_is_hidden_accessor]), i.push(_)\n            }\n          r.data[a] = i\n        }\n    return this\n  }\n  function De (e) {\n    var t,\n      r = e.data[0]\n    if (!1 === e.binned) {\n      if ('object' === c(r[0]))\n        t = r.map(function (t) {\n          return t[e.x_accessor]\n        })\n      else {\n        if ('number' != typeof r[0])\n          return void console.log('TypeError: expected an array of numbers, found ' + c(r[0]))\n        t = r\n      }\n      var a = E.histogram()\n      e.bins && a.thresholds(e.bins)\n      var n = a(t)\n      e.processed_data = n.map(function (t) {\n        return { x: t.x0, y: t.length }\n      })\n    } else {\n      var o, i\n      e.processed_data = r.map(function (t) {\n        return { x: t[e.x_accessor], y: t[e.y_accessor] }\n      })\n      for (var s = 0; s < e.processed_data.length; s++)\n        (o = e.processed_data[s]),\n          s === e.processed_data.length - 1\n            ? (o.dx = e.processed_data[s - 1].dx)\n            : ((i = e.processed_data[s + 1]), (o.dx = i.x - o.x))\n    }\n    return (\n      e.processed || (e.processed = {}),\n      (e.processed.original_data = e.data),\n      (e.processed.original_x_accessor = e.x_accessor),\n      (e.processed.original_y_accessor = e.y_accessor),\n      (e.data = [e.processed_data]),\n      (e.x_accessor = e.processed_x_accessor),\n      (e.y_accessor = e.processed_y_accessor),\n      this\n    )\n  }\n  function Oe (e) {\n    var t = e.data[0],\n      r = t.map(function (t) {\n        return t[e.x_accessor]\n      }),\n      a = t.map(function (t) {\n        return t[e.y_accessor]\n      })\n    return e.least_squares && (e.ls_line = Fe(r, a)), this\n  }\n  function ze (e) {\n    var t = O(e.target),\n      r = e.data[0],\n      a = E.min(r, function (t) {\n        return t[e.x_accessor]\n      }),\n      n = E.max(r, function (t) {\n        return t[e.x_accessor]\n      })\n    E.select(e.target)\n      .selectAll('.mg-least-squares-line')\n      .remove(),\n      t\n        .append('svg:line')\n        .attr('x1', e.scales.X(a))\n        .attr('x2', e.scales.X(n))\n        .attr('y1', e.scales.Y(e.ls_line.fit(a)))\n        .attr('y2', e.scales.Y(e.ls_line.fit(n)))\n        .attr('class', 'mg-least-squares-line')\n  }\n  function Fe (t, e) {\n    var r, a, n\n    t.length\n    ;(r = x(t[0])\n      ? t.map(function (t) {\n          return t.getTime()\n        })\n      : t),\n      (a = x(e[0])\n        ? e.map(function (t) {\n            return t.getTime()\n          })\n        : e)\n    for (var o = E.mean(r), i = E.mean(a), s = 0, c = 0, l = 0; l < r.length; l++)\n      (s += ((n = r[l]) - o) * (a[l] - i)), (c += (n - o) * (n - o))\n    var u = s / c,\n      d = i - u * o\n    return {\n      x0: d,\n      beta: u,\n      fit: function (t) {\n        return d + t * u\n      }\n    }\n  }\n  function Ce (t, e) {\n    return 0 <= t && t <= 1 ? Math.pow(1 - Math.pow(t, e), e) : 0\n  }\n  function Te (t) {\n    var e,\n      r,\n      a,\n      n,\n      o,\n      i,\n      s,\n      c = ((a = t),\n      (n = E.sum(\n        a.map(function (t) {\n          return t.w\n        })\n      )),\n      {\n        xbar:\n          E.sum(\n            a.map(function (t) {\n              return t.w * t.x\n            })\n          ) / n,\n        ybar:\n          E.sum(\n            a.map(function (t) {\n              return t.w * t.y\n            })\n          ) / n\n      }),\n      l = ((o = t),\n      (i = r = c.xbar),\n      (s = e = c.ybar),\n      E.sum(\n        o.map(function (t) {\n          return Math.pow(t.w, 2) * (t.x - i) * (t.y - s)\n        })\n      ) /\n        E.sum(\n          o.map(function (t) {\n            return Math.pow(t.w, 2) * Math.pow(t.x - i, 2)\n          })\n        ))\n    return { beta: l, xbar: r, ybar: e, x0: e - l * r }\n  }\n  function Re (t, e, r, a, n) {\n    var o = Math.floor(t.length * r),\n      i = t.slice()\n    i.sort(function (t, e) {\n      return t < e ? -1 : e < t ? 1 : 0\n    })\n    for (\n      var s,\n        c,\n        l,\n        u,\n        d,\n        f = E.quantile(i, 0.98),\n        p = E.quantile(i, 0.02),\n        _ = E.zip(t, e, n).sort(),\n        m = Math.abs(f - p) / a,\n        g = p,\n        h = f,\n        x = E.range(g, h, m),\n        y = [],\n        v = 0;\n      v < x.length;\n      v += 1\n    ) {\n      ;(c = x[v]),\n        (s = _.map(function (t) {\n          return [Math.abs(t[0] - c), t[0], t[1], t[2]]\n        })\n          .sort()\n          .slice(0, o)),\n        (d = E.max(s)[0])\n      var b = Te(\n        (s = s.map(function (t) {\n          return { w: ((e = t[0] / d), Ce(e, 3) * t[3]), x: t[1], y: t[2] }\n          var e\n        }))\n      )\n      ;(u = b.x0), (l = b.beta), y.push(u + l * c)\n    }\n    return { x: x, y: y }\n  }\n  function Ee (r) {\n    return 'count' === r.format\n      ? function (t) {\n          var e\n          return (\n            (e = t % 1 != 0 ? E.format(',.' + r.decimals + 'f') : E.format(',.0f')),\n            r.yax_units_append ? e(t) + r.yax_units : r.yax_units + e(t)\n          )\n        }\n      : function (t) {\n          var e = (r.decimals ? '.' + r.decimals : '') + '%'\n          return E.format(e)(t)\n        }\n  }\n  MG.register(\n    'missing-data',\n    function (t) {\n      var R = this\n      ;(this.init = function (t) {\n        yt((R.args = t)), vt(t)\n        var e = E.select(t.target)\n        Gt(e, t)\n        var r,\n          a,\n          n,\n          o,\n          i,\n          s,\n          c,\n          l,\n          u,\n          d,\n          f,\n          p,\n          _,\n          m,\n          g,\n          h,\n          x,\n          y,\n          v,\n          b,\n          w,\n          k,\n          M,\n          G,\n          A,\n          D,\n          O,\n          z,\n          F,\n          C = e.selectAll('svg')\n        if (\n          (bt(C, t),\n          kt((C = wt(C, t)), t),\n          Mt(C, t),\n          (r = t.target),\n          E.select(r)\n            .selectAll('svg *')\n            .remove(),\n          C.classed('mg-missing', !0),\n          (a = t.legend_target) && E.select(a).html(''),\n          j(t),\n          t.show_missing_background)\n        ) {\n          !(function (t) {\n            for (var e = [], r = 1; r <= 50; r++) e.push({ x: r, y: Math.random() - 0.03 * r })\n            t.data = e\n          })(t),\n            ((G = t).scales.X = E.scaleLinear()\n              .domain([0, G.data.length])\n              .range([Y(G), P(G)])),\n            (G.scalefns.yf = function (t) {\n              var e = t.y\n              return G.scales.Y(e)\n            }),\n            ((M = t).scales.Y = E.scaleLinear()\n              .domain([-2, 2])\n              .range([M.height - M.bottom - 2 * M.buffer, M.top])),\n            (M.scalefns.xf = function (t) {\n              var e = t.x\n              return M.scales.X(e)\n            })\n          var T = S(C, 'mg-missing-pane')\n          ;(h = T),\n            (y = (x = t).title),\n            (v = x.buffer),\n            (b = x.title_y_position),\n            (w = x.width),\n            (k = x.height),\n            h\n              .append('svg:rect')\n              .classed('mg-missing-background', !0)\n              .attr('x', v)\n              .attr('y', v + 2 * (y ? b : 0))\n              .attr('width', w - 2 * v)\n              .attr('height', k - 2 * v - 2 * (y ? b : 0))\n              .attr('rx', 15)\n              .attr('ry', 15),\n            (d = T),\n            (p = (f = t).scalefns),\n            (_ = f.interpolate),\n            (m = f.data),\n            (g = E.line()\n              .x(p.xf)\n              .y(p.yf)\n              .curve(_)),\n            d\n              .append('path')\n              .attr('class', 'mg-main-line mg-line1-color')\n              .attr('d', g(m)),\n            (n = T),\n            (i = (o = t).scalefns),\n            (s = o.scales),\n            (c = o.interpolate),\n            (l = o.data),\n            (u = E.area()\n              .x(i.xf)\n              .y0(s.Y.range()[0])\n              .y1(i.yf)\n              .curve(c)),\n            n\n              .append('path')\n              .attr('class', 'mg-main-area mg-area1-color')\n              .attr('d', u(l))\n        }\n        return (\n          (A = C),\n          (O = (D = t).missing_text),\n          (z = D.width),\n          (F = D.height),\n          A.selectAll('.mg-missing-text')\n            .data([O])\n            .enter()\n            .append('text')\n            .attr('class', 'mg-missing-text')\n            .attr('x', z / 2)\n            .attr('y', F / 2)\n            .attr('dy', '.50em')\n            .attr('text-anchor', 'middle')\n            .text(O),\n          R.windowListeners(),\n          R\n        )\n      }),\n        (this.windowListeners = function () {\n          return Qt(R.args), R\n        }),\n        this.init(t)\n    },\n    {\n      top: 40,\n      bottom: 30,\n      right: 10,\n      left: 0,\n      buffer: 8,\n      legend_target: '',\n      width: 350,\n      height: 220,\n      missing_text: 'Data currently missing or unavailable',\n      scalefns: {},\n      scales: {},\n      show_tooltips: !0,\n      show_missing_background: !0\n    }\n  ),\n    (MG.raw_data_transformation = Me),\n    (MG.process_line = Ae),\n    (MG.process_histogram = De),\n    (MG.process_categorical_variables = function (t) {\n      return (\n        'vertical' === t.bar_orientation ? t.x_accessor : t.y_accessor,\n        'vertical' === t.bar_orientation ? t.y_accessor : t.x_accessor,\n        this\n      )\n    }),\n    (MG.process_point = Oe),\n    (MG.add_ls = ze),\n    (MG.add_lowess = function (e) {\n      var t = O(e.target),\n        r = e.lowess_line,\n        a = E.svg\n          .line()\n          .x(function (t) {\n            return e.scales.X(t.x)\n          })\n          .y(function (t) {\n            return e.scales.Y(t.y)\n          })\n          .interpolate(e.interpolate)\n      t.append('path')\n        .attr('d', a(r))\n        .attr('class', 'mg-lowess-line')\n    }),\n    (MG.lowess_robust = function (t, e, r, a) {\n      var n,\n        o,\n        i = []\n      for (E.mean(e), o = 0; o < t.length; o += 1) i.push(1)\n      var s = (n = Re(t, e, r, a, i)).x,\n        c = n.y\n      for (o = 0; o < 100; o += 1) {\n        i = E.zip(c, e).map(function (t) {\n          return Math.abs(t[1] - t[0])\n        })\n        var l = E.quantile(i.sort(), 0.5)\n        ;(s = (n = Re(\n          t,\n          e,\n          r,\n          a,\n          (i = i.map(function (t) {\n            return Ce(t / (6 * l), 2)\n          }))\n        )).x),\n          (c = n.y)\n      }\n      return E.zip(s, c).map(function (t) {\n        var e = {}\n        return (e.x = t[0]), (e.y = t[1]), e\n      })\n    }),\n    (MG.lowess = function (t, e, r, a) {\n      for (var n = [], o = 0; o < t.length; o += 1) n.push(1)\n      Re(t, e, r, a, n)\n    }),\n    (MG.least_squares = Fe)\n  var Ye = function (t, e, r, a) {\n      return 'string' == typeof t ? MG.time_format(a, t)(e[r]) : 'function' == typeof t ? t(e) : e[r]\n    },\n    $e = function (t, e, r) {\n      return 'string' == typeof t ? E.format('s')(e[r]) : 'function' == typeof t ? t(e) : e[r]\n    }\n  function Pe (t, e, r, a, n) {\n    var o,\n      i = (function (t) {\n        if (t.rollover_time_format) return MG.time_format(t.utc_time, t.rollover_time_format)\n        switch (t.processed.x_time_frame) {\n          case 'millis':\n            return MG.time_format(t.utc_time, '%b %e, %Y  %H:%M:%S.%L')\n          case 'seconds':\n            return MG.time_format(t.utc_time, '%b %e, %Y  %H:%M:%S')\n          case 'less-than-a-day':\n          case 'four-days':\n            return MG.time_format(t.utc_time, '%b %e, %Y  %I:%M%p')\n        }\n        return MG.time_format(t.utc_time, '%b %e, %Y')\n      })(t)\n    return (\n      (o =\n        'string' == typeof e[a]\n          ? function (t) {\n              return t\n            }\n          : Ee(t)),\n      null !== r\n        ? n\n          ? Ye(r, e, a, t.utc)\n          : $e(r, e, a)\n        : n\n        ? i(new Date(+e[a])) + '  '\n        : (t.time_series ? '' : a + ': ') + o(e[a]) + '   '\n    )\n  }\n  function Se (t, e) {\n    return Pe(t, e, t.x_mouseover, t.x_accessor, t.time_series)\n  }\n  function Le (t, e) {\n    return Pe(t, e, t.y_mouseover, t.y_accessor, !1)\n  }\n  function je (c, l) {\n    return function () {\n      for (\n        var a = this,\n          n = a.cloneNode(),\n          o = a.getTotalLength() || 0,\n          i = (n.setAttribute('d', c), n).getTotalLength() || 0,\n          t = [0],\n          e = 0,\n          r = l / Math.max(o, i);\n        (e += r) < 1;\n\n      )\n        t.push(e)\n      t.push(1)\n      var s = t.map(function (t) {\n        var e = a.getPointAtLength(t * o),\n          r = n.getPointAtLength(t * i)\n        return E.interpolate([e.x, e.y], [r.x, r.y])\n      })\n      return function (e) {\n        return e < 1\n          ? 'M' +\n              s\n                .map(function (t) {\n                  return t(e)\n                })\n                .join('L')\n          : c\n      }\n    }\n  }\n  function Xe (t) {\n    console.error('ERROR : ', t.target, ' : ', t.error),\n      E.select(t.target)\n        .select('.mg-chart-title')\n        .append('tspan')\n        .attr('class', 'fa fa-x fa-exclamation-circle mg-warning')\n        .attr('dx', '0.3em')\n        .text('')\n  }\n  return (\n    (MG.format_rollover_number = Ee),\n    (MG.path_tween = je),\n    (MG.render_markup = function (t) {\n      switch ('undefined' == typeof window ? 'undefined' : c(window)) {\n        case 'undefined':\n          return (function (t) {\n            var e,\n              r = MG.virtual_window,\n              a = E.select(r.document),\n              n = r.document.createElement('div'),\n              o = global.d3,\n              i = global.window,\n              s = global.document\n            ;(global.d3 = a), (global.window = r), (global.document = r.document)\n            try {\n              t(n)\n            } catch (t) {\n              e = t\n            }\n            if (((global.d3 = o), (global.window = i), (global.document = s), e)) throw e\n            return a\n              .select(function () {\n                return n\n              })\n              .html()\n          })(t)\n        default:\n          return (e = t), (r = document.createElement('div')), e(r), E.select(r).html()\n      }\n      var e, r\n    }),\n    (MG.init_virtual_window = function (t, e) {\n      if (!MG.virtual_window || e) {\n        var r = t.jsdom({ html: '', features: { QuerySelector: !0 } })\n        MG.virtual_window = r.defaultView\n      }\n    }),\n    (MG.error = Xe),\n    MG\n  )\n})\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\"), __webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\"), __webpack_require__(/*! ./../../../../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./src/public/js/vendor/metricsgraphics/metricsgraphics.min.js?");

/***/ }),

/***/ "./src/public/js/vendor/simplecolorpicker/jquery.simplecolorpicker.js":
/*!****************************************************************************!*\
  !*** ./src/public/js/vendor/simplecolorpicker/jquery.simplecolorpicker.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(jQuery) {/*\n * Very simple jQuery Color Picker\n * https://github.com/tkrotoff/jquery-simplecolorpicker\n *\n * Copyright (C) 2012-2013 Tanguy Krotoff <tkrotoff@gmail.com>\n *\n * Licensed under the MIT license\n */\n\n;(function ($) {\n  'use strict'\n\n  /**\n   * Constructor.\n   */\n  var SimpleColorPicker = function (select, options) {\n    this.init('simplecolorpicker', select, options)\n  }\n\n  /**\n   * SimpleColorPicker class.\n   */\n  SimpleColorPicker.prototype = {\n    constructor: SimpleColorPicker,\n\n    init: function (type, select, options) {\n      var self = this\n\n      self.type = type\n\n      self.$select = $(select)\n      self.$select.hide()\n\n      self.options = $.extend({}, $.fn.simplecolorpicker.defaults, options)\n\n      self.$colorList = null\n\n      if (self.options.picker === true) {\n        var selectText = self.$select.find('> option:selected').text()\n        self.$icon = $(\n          '<span class=\"simplecolorpicker icon\"' +\n            ' title=\"' +\n            selectText +\n            '\"' +\n            ' style=\"background-color: ' +\n            self.$select.val() +\n            ';\"' +\n            ' role=\"button\" tabindex=\"0\">' +\n            '</span>'\n        ).insertAfter(self.$select)\n        self.$icon.on('click.' + self.type, $.proxy(self.showPicker, self))\n\n        self.$picker = $('<span class=\"simplecolorpicker picker ' + self.options.theme + '\"></span>').appendTo(\n          document.body\n        )\n        self.$colorList = self.$picker\n\n        // Hide picker when clicking outside\n        $(document).on('mousedown.' + self.type, $.proxy(self.hidePicker, self))\n        self.$picker.on('mousedown.' + self.type, $.proxy(self.mousedown, self))\n      } else {\n        self.$inline = $('<span class=\"simplecolorpicker inline ' + self.options.theme + '\"></span>').insertAfter(\n          self.$select\n        )\n        self.$colorList = self.$inline\n      }\n\n      // Build the list of colors\n      // <span class=\"color selected\" title=\"Green\" style=\"background-color: #7bd148;\" role=\"button\"></span>\n      self.$select.find('> option').each(function () {\n        var $option = $(this)\n        var color = $option.val()\n\n        var isSelected = $option.is(':selected')\n        var isDisabled = $option.is(':disabled')\n\n        var selected = ''\n        if (isSelected === true) {\n          selected = ' data-selected'\n        }\n\n        var disabled = ''\n        if (isDisabled === true) {\n          disabled = ' data-disabled'\n        }\n\n        var title = ''\n        if (isDisabled === false) {\n          title = ' title=\"' + $option.text() + '\"'\n        }\n\n        var role = ''\n        if (isDisabled === false) {\n          role = ' role=\"button\" tabindex=\"0\"'\n        }\n\n        var $colorSpan = $(\n          '<span class=\"color\"' +\n            title +\n            ' style=\"background-color: ' +\n            color +\n            ';\"' +\n            ' data-color=\"' +\n            color +\n            '\"' +\n            selected +\n            disabled +\n            role +\n            '>' +\n            '</span>'\n        )\n\n        self.$colorList.append($colorSpan)\n        $colorSpan.on('click.' + self.type, $.proxy(self.colorSpanClicked, self))\n\n        var $next = $option.next()\n        if ($next.is('optgroup') === true) {\n          // Vertical break, like hr\n          self.$colorList.append('<span class=\"vr\"></span>')\n        }\n      })\n    },\n\n    /**\n     * Changes the selected color.\n     *\n     * @param color the hexadecimal color to select, ex: '#fbd75b'\n     */\n    selectColor: function (color) {\n      var self = this\n\n      var $colorSpan = self.$colorList.find('> span.color').filter(function () {\n        return (\n          $(this)\n            .data('color')\n            .toLowerCase() === color.toLowerCase()\n        )\n      })\n\n      if ($colorSpan.length > 0) {\n        self.selectColorSpan($colorSpan)\n      } else {\n        console.error(\"The given color '\" + color + \"' could not be found\")\n      }\n    },\n\n    showPicker: function () {\n      var pos = this.$icon.offset()\n      this.$picker.css({\n        // Remove some pixels to align the picker icon with the icons inside the dropdown\n        left: pos.left - 6,\n        top: pos.top + this.$icon.outerHeight()\n      })\n\n      this.$picker.show(this.options.pickerDelay)\n    },\n\n    hidePicker: function () {\n      this.$picker.hide(this.options.pickerDelay)\n    },\n\n    /**\n     * Selects the given span inside $colorList.\n     *\n     * The given span becomes the selected one.\n     * It also changes the HTML select value, this will emit the 'change' event.\n     */\n    selectColorSpan: function ($colorSpan) {\n      var color = $colorSpan.data('color')\n      var title = $colorSpan.prop('title')\n\n      // Mark this span as the selected one\n      $colorSpan.siblings().removeAttr('data-selected')\n      $colorSpan.attr('data-selected', '')\n\n      if (this.options.picker === true) {\n        this.$icon.css('background-color', color)\n        this.$icon.prop('title', title)\n        this.hidePicker()\n      }\n\n      // Change HTML select value\n      this.$select.val(color)\n    },\n\n    /**\n     * The user clicked on a color inside $colorList.\n     */\n    colorSpanClicked: function (e) {\n      // When a color is clicked, make it the new selected one (unless disabled)\n      if ($(e.target).is('[data-disabled]') === false) {\n        this.selectColorSpan($(e.target))\n        this.$select.trigger('change')\n      }\n    },\n\n    /**\n     * Prevents the mousedown event from \"eating\" the click event.\n     */\n    mousedown: function (e) {\n      e.stopPropagation()\n      e.preventDefault()\n    },\n\n    destroy: function () {\n      if (this.options.picker === true) {\n        this.$icon.off('.' + this.type)\n        this.$icon.remove()\n        $(document).off('.' + this.type)\n      }\n\n      this.$colorList.off('.' + this.type)\n      this.$colorList.remove()\n\n      this.$select.removeData(this.type)\n      this.$select.show()\n    }\n  }\n\n  /**\n   * Plugin definition.\n   * How to use: $('#id').simplecolorpicker()\n   */\n  $.fn.simplecolorpicker = function (option) {\n    var args = $.makeArray(arguments)\n    args.shift()\n\n    // For HTML element passed to the plugin\n    return this.each(function () {\n      var $this = $(this),\n        data = $this.data('simplecolorpicker'),\n        options = typeof option === 'object' && option\n      if (data === undefined) {\n        $this.data('simplecolorpicker', (data = new SimpleColorPicker(this, options)))\n      }\n      if (typeof option === 'string') {\n        data[option].apply(data, args)\n      }\n    })\n  }\n\n  /**\n   * Default options.\n   */\n  $.fn.simplecolorpicker.defaults = {\n    // No theme by default\n    theme: '',\n\n    // Show the picker or make it inline\n    picker: false,\n\n    // Animation delay in milliseconds\n    pickerDelay: 0\n  }\n})(jQuery)\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./src/public/js/vendor/jquery/jquery.js\")))\n\n//# sourceURL=webpack:///./src/public/js/vendor/simplecolorpicker/jquery.simplecolorpicker.js?");

/***/ })

}]);